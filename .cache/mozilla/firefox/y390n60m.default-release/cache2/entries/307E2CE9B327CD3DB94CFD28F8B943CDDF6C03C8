{
  "components/accordion.html": {
    "href": "components/accordion.html",
    "title": "Angular Accordion Component – Fully-featured collapsible panels - Infragistics",
    "keywords": "Angular Accordion Component Overview What is Angular Accordion? The Angular Accordion is a GUI component for building vertical expandable panels with clickable headers and associated content sections, displayed in a single container. The accordion is commonly used to reduce the need of scrolling across multiple sections of content on a single page. It offers keyboard navigation and API to control the underlying panels' expansion state. Users are enabled to interact and navigate among a list of items, such as thumbnails or labels. Each one of those items can be toggled (expanded or collapsed) in order to reveal the containing information. Depending on the configuration, there can be a single or multiple expanded items at a time. Angular Accordion Example The following is a basic Angular Accordion example of a FAQ section. It operates as an accordion, with individually working sections. You can toggle each text block with a single click, while expanding multiple panels at the same time. This way you can read information more easily, without having to go back and forth between an automatically expanding and collapsing panel, which conceals the previously opened section every time. In it, you can see how to define an igx-accrodion and its expansion panels. The sample also demonstrates the two types of expansion behavior. The switch button sets the singleBranchExpand property to toggle between single and multiple branches to be expanded at a time. Getting Started with Ignite UI for Angular Accordion To get started with the Ignite UI for Angular Accordion component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxAccordionModule in your app.module.ts file. // app.module.ts ... import { IgxAccordionModule } from 'igniteui-angular'; // import { IgxAccordionModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxAccordionModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxAccordionComponent as a standalone dependency, or use the IGX_ACCORDION_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts ... import { IGX_ACCORDION_DIRECTIVES } from 'igniteui-angular'; // import { IGX_ACCORDION_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-accordion> <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 1</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Panel 1 </igx-expansion-panel-body> </igx-expansion-panel> </igx-accordion> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_ACCORDION_DIRECTIVES] /* or imports: [IgxAccordionComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Accordion module or directives imported, you can start with a basic configuration of the igx-accordion and its panels. Using the Angular Accordion Component Each section in the IgxAccordionComponent is defined using an expansion panel. Panels provide disabled, collapsed and animationSettings properties, which give you the ability to configure the states of the panel as per your requirement. Declaring an accordion The accordion wraps all igx-expansion-panels declared inside it. <igx-accordion #accordion [singleBranchExpand]=\"true\"> <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 1</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Panel 1 </igx-expansion-panel-body> </igx-expansion-panel> <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 2</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Panel 2 </igx-expansion-panel-body> </igx-expansion-panel> </igx-accordion> Using the panels accessor you can get a reference to the collection containing all expansion panels children of the igx-accordion. @ViewChild('accordion', { static: true }) public accordion!: IgxAccordionComponent; this.accordion.panels; As demonstrated above, the singleBranchExpand property gives you the ability to set whether single or multiple panels can be expanded at a time. Angular Accordion Animations Angular Accordion supports animations for both expanding and collapsing actions of the panels. Animation behavior can be customized. Normally, animations can be set for each expansion panel individually. However, it could also be applied to all panels at once on IgxAccordionComponent level. This gives users the ability to disable animations for all sections at once via the animations property of the IgxAccordionComponent. With regards to animation, you have two options. First, you could set the animationSettings property on the accordion component: import { useAnimation } from '@angular/animations'; import { slideInLeft, slideOutRight } from 'igniteui-angular'; // import { slideInLeft, slideOutRight } from '@infragistics/igniteui-angular'; for licensed package @Component({ ... }) export class AccordionComponent { public animationSettingsCustom = { closeAnimation: useAnimation(slideOutRight, { params: { duration: '100ms', toPosition: 'translateX(25px)' } }), openAnimation: useAnimation(slideInLeft, { params: { duration: '500ms', fromPosition: 'translateX(-15px)', startOpacity: 0.1 } }) }; } As you can see, we are using slideInLeft and slideOutRight animations from our inbuilt suite of animations to make the component content appear from the left side and disappear to the right when collapsing the content. We further customize the animations by overriding some of the animations' parameters. The following snippet demonstrates passing the animation settings to the component: <igx-accordion #accordion [animationSettings]=\"animationSettingsCustom\"> ... </igx-accordion> Note If you would like to turn off the animation for the IgxAccordionComponent the animationSettings could be set to null. Alternatively, you have the ability to set every single expansion panel`s animationSettings input. <igx-accordion #accordion [singleBranchExpand]=\"true\"> <igx-expansion-panel [animationSettings]=\"slideLeftRightSettings\"> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 1</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Panel 1 </igx-expansion-panel-body> </igx-expansion-panel> <igx-expansion-panel [animationSettings]=\"slideTopBottomSettings\"> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 2</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Panel 2 </igx-expansion-panel-body> </igx-expansion-panel> </igx-accordion> Using the collapseAll and expandAll methods you can respectively collapse and expand all IgxExpansionPanels of the IgxAccordion programmatically. Note If singleBranchExpand property is set to true calling expandAll method would expand only the last panel. Angular Accordion Templating Example With the Angular Accordion component, you can customize the header and content panel`s appearance. The sample below demonstrates how elaborate filtering options can be implemented using the built-in templating functionality of the IgxExpansionPanel. Nested Angular Accordions Scenario In the following Angular accordion example, we are going to create a complex FAQ section in order to illustrate how you can go about this common application scenario. In the sample nested IgxAccordionComponent is achieved by adding an accordion inside the body of an expansion panel. <igx-accordion #accordion> <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Panel 1</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> <igx-accordion #childAccordion> <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title>Title Nested Panel 1</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Content Nested Panel 1 </igx-expansion-panel-body> </igx-expansion-panel> ... </igx-accordion> </igx-expansion-panel-body> </igx-expansion-panel> ... </igx-accordion> You can see the result below. Keyboard Navigation Keyboard navigation in the Ignite UI for Angular Accordion provides a rich variety of keyboard interactions to the end-user. This functionality is enabled by default and allows end-users to easily navigate through the panels. The IgxAccordionComponent navigation is compliant with W3C accessibility standards and convenient to use. Key Combinations Tab - moves the focus to the first(if the focus is before accordion)/next panel Shift + Tab - moves the focus to the last(if the focus is after accordion)/previous panel Arrow Down - moves the focus to the panel below Arrow Up - moves the focus to the panel above Alt + Arrow Down - expands the focused panel in the accordion Alt + Arrow Up - collapses the focused panel in the accordion Shift + Alt + Arrow Down - expands all enabled panels(if singleBranchExpand is set to true expands the last enabled panel) Shift + Alt + Arrow Up - collapses all enabled panels Home - navigates to the FIRST enabled panel in the accordion End - navigates to the LAST enabled panel in the accordion Angular Accordion Styling The accordion serves only as a container for the underlying panels. Styles can be applied directly through the panel's theme, as described in the styling section of the IgxExpansionPanel topic. By design, there is a margin set to the expanded panels, in case that they are positioned within an igx-accordion. In order to modify it there is a property exposed inside the igx-expansion-panel theme. In order to take advantage of the functions exposed by the theming engine, we have to import the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the expansion-panel-theme and accepts an $expanded-margin parameter. $custom-panel-theme: expansion-panel-theme( $expanded-margin: 0px ); Using CSS Variables The last step is to include the component's theme. :host { @include css-vars($custom-panel-theme); } Using Theme Overrides In order to style components in Internet Explorer 11, we have to use a different approach, since CSS variables are not supported there. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme from leaking into other components, make sure to wrap the ::ng-deep in a :host selector: :host { ::ng-deep { @include expansion-panel($custom-panel-theme); } } API Reference IgxAccordion API IgxExpansionPanel API IgxExpansionPanelHeader API IgxExpansionPanelBody API IgxExpansionPanel Styles Additional Resources Our community is active and always welcoming new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/action-strip.html": {
    "href": "components/action-strip.html",
    "title": "Angular Action Strip Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Action Strip Directive Overview The Ignite UI for Angular Action Strip component provides an overlay area containing one or more actions allowing additional UI and functionality to be shown on top of a specific target container upon user interaction e.g. hover. The container should be positioned relatively as the Action Strip attempts to overlay it and is itself positioned absolutely. Despite overlapped by an Action Strip, the main interactions and user access to the target container remain available. Angular Action Strip Example Getting Started with Ignite UI for Angular Action Strip To get started with the Ignite UI for Angular Action Strip component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxActionStripModule in your app.module.ts file. // app.module.ts ... import { IgxActionStripModule } from 'igniteui-angular'; // import { IgxActionStripModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxActionStripModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxActionStripComponent as a standalone dependency, or use the IGX_ACTION_STRIP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts ... import { IGX_ACTION_STRIP_DIRECTIVES, IgxButtonDirective, IgxIconComponent } from 'igniteui-angular'; // import { IGX_ACTION_STRIP_DIRECTIVES, IgxButtonDirective, IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <div style=\"width:100px; height:100px;\"> <igx-action-strip> <button igxButton (click)=\"makeTextBold()\"> <igx-icon>format_bold</igx-icon> </button> </igx-action-strip> <div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_ACTION_STRIP_DIRECTIVES, IgxButtonDirective, IgxIconComponent] /* or imports: [IgxActionStripComponent, IgxButtonDirective, IgxIconComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Action Strip module or directives imported, you can start with a basic configuration of the igx-action-strip component. Using the Angular Action Strip Component To initialize and position the Action Strip correctly, it needs to be inside a relatively positioned container: <div style=\"position:relative; width:100px; height:100px;\"> <igx-action-strip> <button igxButton (click)=\"makeTextBold()\"> <igx-icon>format_bold</igx-icon> </button> </igx-action-strip> <div> By default, the Action Strip will be visible, but this can be configured via the hidden @Input property. Menu look and feel For scenarios where more than three action items will be shown, it is best to use IgxActionStripMenuItem directive. Any item within the Action Strip marked with the *igxActionStripMenuItem structural directive will be shown in a dropdown, revealed upon toggling the more button i.e. the three dots representing the last action. <div style=\"position:relative; width:100px; height:100px;\"> <igx-action-strip> <button *igxActionStripMenuItem igxButton (click)=\"alignTextLeft()\"> <igx-icon>format_align_left</igx-icon> </button> <button *igxActionStripMenuItem igxButton (click)=\"alignTextCenter()\"> <igx-icon>format_align_center</igx-icon> </button> <button *igxActionStripMenuItem igxButton (click)=\"alignTextRight()\"> <igx-icon>format_align_right</igx-icon> </button> </igx-action-strip> </div> Reusing the Action Strip The same Action Strip instance can be used in multiple places in the document as long as the actions need not be visible simultaneously for them. The Action Strip can change its parent container, which is possible by changing the context. The best way to do so is via the show API method and passing the context as an argument. The context should be an instance of a component and should have an accessible element property of the ElementRef type. Note The show API method uses Angular Renderer2 to append the Action Strip to that element. Usage in Grids The Action Strip provides additional functionality and UI for the IgxGrid. This can be utilized via grid action components and we are providing two default ones: IgxGridEditingActionsComponent - includes functionality and UI related to grid editing. It allows you to quickly toggle edit mode for cells or rows, depending on the value of the rowEditable option of the grid and whether deleting rows is allowed. IgxGridPinningActionsComponent - includes functionality and UI related to grid row pinning. It allows you to quickly pin rows and navigate between pinned rows and their disabled counterparts. <igx-grid [data]=\"data\" [rowEditable]=\"true\" [primaryKey]=\"'ID'\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-grid> Note These components inherit IgxGridActionsBaseDirective and when creating a custom grid action component, it should also inherit IgxGridActionsBaseDirective. Note When IgxActionStripComponent is a child component of the grid, hovering a row will automatically show the UI. Note More information about how to use ActionStrip in the grid component could be found here. Styling To customize the Action Strip, you first need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Next, we have to create a new theme that extends the action-strip-theme and pass the parameters which we'd like to change: $custom-strip: action-strip-theme( $background: rgba(150, 133, 143, 0.4), $actions-background: rgba(109, 121, 147, 0.6), $icon-color: null, $delete-action: null, $actions-border-radius: 0 ); The last step is to include the newly created component theme in our application. When $legacy-support is set to false(default), include the component css variables like this: @include css-vars($custom-strip); When $legacy-support is set to true, include the component theme like this: @include action-strip($custom-strip); Known Issues and Limitations Using the Action Strip component on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API and Style References For more detailed information regarding the Action Strip API, refer to the following links: IgxActionStripComponent API The following built-in CSS styles helped us achieve this Action Strip layout: IgxActionStripComponent Styles Additional components and/or directives that can be used within the Action Strip: IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent IgxDividerDirective Theming Dependencies IgxButton Theme IgxRipple Theme IgxDropDown Theme IgxIcon Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/angular-reactive-form-validation.html": {
    "href": "components/angular-reactive-form-validation.html",
    "title": "Angular reactive form validation – Ignite UI for Angular",
    "keywords": "Angular reactive form validation What are reactive forms in Angular? Reactive forms in Angular provide a direct access to the underlying form object model, offering an immutable and explicit approach to handling form inputs. As the values of those inputs change in time, the state of the form is managed by reactive forms, relying on fixed or inflexible methods. Which means that, each time a change is triggered to the data model, the so-called observable operators return a new data model, instead of updating the already existing one again and again. And that keeps the state of a form clean. Angular reactive forms are considered extremely scalable, reusable, and robust due to their: Immutability Reactive forms in Angular provide an immutable or fixed data structure. Once the state of the underlying model is altered, you get a new “version” of this particular model which is updated. It has new values but remains aligned with all the (UI) controls in any moment. Better testability Testing is pretty straightforward with reactive forms and requires less setup. When it comes to large applications this is very beneficial. Here, you get a synchronous access to streams of input and the possibility to test the form and data models without having to render UI. Predictability Reactive forms are built around observable streams which track every unique change in the form and allow you to access input values synchronously (thanks to the well-structured data flow). Which, in turn, makes reactive forms highly predictable. Consistent & structured data flow The data flow in Angular reactive forms is well-structured because the form logic is led by the component class. This enables you to add validator functions directly to the FormControl instance in the component class. Whenever a change occurs, Angular calls these functions. What is angular form validation? Angular form validation is an integral technical process that verifies if any input provided by a user into a web-form is correct and complete. You can manage validation in a template-driven approach or with Angular reactive forms. Based on what is entered, the form will either allow users to proceed or will display a specific error message to help the user know where they went wrong with their data input. Depending on which validator failed, the on-screen error message gives feedback, indicating what is wrong and what exactly needs to be filled in or re-entered as data. In general, apps use forms to allow users to perform data-entry tasks like signing up, logging in, updating online profiles, submitting sensitive information, and more. Angular runs form validation every time the value of a form input is changed and to confirm if data inputs filled in a web-form by a user are accurate and complete. To do that properly, Angular calls a list of validators which are run on every change that occurs. Validation of user-input from the UI can be done either with template-driven forms or with Angular reactive forms. Both of these forms are built on the following base classes: FormControl FormGroup FormArray ControlValueAccessor Angular reactive form validation Reactive forms deliver a model-driven approach to managing form inputs, the values of which change with respect to time. Because reactive forms are built on a component class, Angular reactive form validation happens by adding validator functions directly to the form control model in the component class. When the value is valid, validators return null. If the value is invalid, validators generate a set of errors, and you can display a specific error message on the screen. There are built-in validators such as required, minlength, maxlength etc. However, you can also create your own validators. A simple custom reactive form validator can look like this: import { Directive, OnInit } from '@angular/core'; import { Validator, NG_VALIDATORS, AbstractControl, ValidationErrors } from '@angular/forms'; @Directive({ selector: '[dateValueValidator]', providers: [{ provide: NG_VALIDATORS, useExisting: DateValueValidatorDirective, multi: true }] }) export class DateValueValidatorDirective implements Validator { public validate(control: AbstractControl): ValidationErrors | null { if (!this.isDate(control.value)) { return { value: true }; } return null; } private isDate(value: unknown): value is Date { return value instanceof Date && !isNaN(value.getTime()); } } Also a validator can be asynchronous: import { Directive, OnInit } from '@angular/core'; import { AsyncValidator, NG_ASYNC_VALIDATORS, AbstractControl, ValidationErrors } from '@angular/forms'; import { Observable, of } from 'rxjs'; @Directive({ selector: '[dateValueAsyncValidator]', providers: [{ provide: NG_ASYNC_VALIDATORS, useExisting: DateValueAsyncValidatorDirective, multi: true }] }) export class DateValueAsyncValidatorDirective implements AsyncValidator { public validate(control: AbstractControl): Observable<ValidationErrors | null> { if (!this.isDate(control.value)) { return of({ value: true }); } return of(null); } private isDate(value: unknown): value is Date { return value instanceof Date && !isNaN(value.getTime()); } } Angular Reactive form validation example Let’s see how you can set up reactive form validation in practice with this Angular form validation example. It is a quick demo of a pretty standard booking form for a movie. It shows what happens if one or several of the form inputs are incomplete and you can see how the specific error message is visualized. For the purposes of our example of Angular reactive form validation, the fields which are required include: movie, full name, email, and genre. Unless you get all of them completed, you won’t be able to proceed with your booking and the book button will remain disabled. So, if you enter values for movie title, full name, phone, and email, they will be highlighted in green. But if you forget to select favorite genre, this field will be highlighted in red, indicating incomplete value inputs. Once the values are all set right, the field will be highlighted in green, indicating correct value inputs. The book button will be activated and the form can be successfully submitted afterwards. Angular form group validation Form groups are basically a group of multiple related FormControlls that enable you to access the state of the encapsulated controls. Angular from group validation helps you track the value of group controls or a form as well as to track validation of the state of the form control. FormGroup is used with FormControl. Why would you need Angular form custom validation? With custom validators you can address different functionality and ensure the values in a form meet certain criteria, which sometimes isn’t possible to do when using built-in validators only. If you want to validate a phone number or a specific password pattern, it’s best to create custom validator and rely on Angular form custom validation. With reactive forms, generating such is just as easy as writing a new function. And for model-driven forms (such is the reactive form in Angular) we create custom validation functions and send them to the FormControl constructor. Below you can see how to write and implement a custom form validator in your reactive form. import { FormGroup, FormControl, Validators, ValidatorFn, ValidationErrors } from '@angular/forms'; import { Component, OnInit } from '@angular/core'; @Component({/* ... */}) export class MyComponent implements OnInit { public form: FormGroup; public ngOnInit(): void { this.form = new FormGroup({ datePicker: new FormControl('', [Validators.required, this.dateValidator(new Date())]) }); } private dateValidator(val: Date): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { if (this.isDate(control.value) || this.valGreaterThanDate(control.value, val)) { return { value: true }; } return null; } } private valGreaterThanDate(value: Date, date: Date): boolean { const value1 = new Date(value).setHours(0, 0, 0, 0); const value2 = new Date(date).setHours(0, 0, 0, 0); return value.getTime() > date.getTime(); } private isDate(value: unknown): value is Date { return value instanceof Date && !isNaN(value.getTime()); } } Additional Resources Related topics: Combo Select Input Group Date Picker Time Picker Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/autocomplete.html": {
    "href": "components/autocomplete.html",
    "title": "Angular Autocomplete Component – Ignite UI for Angular",
    "keywords": "Angular Autocomplete Directive Overview Angular Autocomplete is a search box directive that enables users to easily find, filter and select an item from a list of suggestions while they type. Feature-rich, it supports seamless data binding, filtering, grouping, UI customization options, and other built-in functionalities so developers can create intuitive autocomplete search experience. The igxAutocomplete directive provides a way to enhance a text input by showing an igxDropDown with suggested options, provided by the developer. The suggestions will show once you start typing in the text input or use the Arrow Up/Arrow Down keys. Angular Autocomplete Example The Angular Autocomplete example below generates a dropdown suggestion list as users start typing the name of a town in the input textbox. Getting Started with Ignite UI for Angular Autocomplete To get started with the Ignite UI for Angular for Angular Components and Autocomplete directive in particular, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxAutocompleteModule and IgxDropDownModule in our app.module. If igxAutocomplete is applied on an igxInput, the igxInputGroupModule is also required: // app.module.ts ... import { IgxAutocompleteModule, IgxDropDownModule, IgxInputGroupModule } from 'igniteui-angular'; // import { IgxAutocompleteModule, IgxDropDownModule, IgxInputGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [ ..., IgxAutocompleteModule, IgxDropDownModule, IgxInputGroupModule, .... ], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxAutocompleteDirective as a standalone directive. // home.component.ts ... import { IgxAutocompleteDirective, IGX_INPUT_GROUP_DIRECTIVES, IGX_DROP_DOWN_DIRECTIVES } from 'igniteui-angular'; // import { IgxAutocompleteDirective, IGX_INPUT_GROUP_DIRECTIVES, IGX_DROP_DOWN_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-input-group> <input igxInput name=\"towns\" type=\"text\" [igxAutocomplete]=\"townsPanel\" /> <label igxLabel for=\"towns\">Towns</label> </igx-input-group> <igx-drop-down #townsPanel> <igx-drop-down-item *ngFor=\"let town of towns\"> {{town}} </igx-drop-down-item> </igx-drop-down> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxAutocompleteDirective, IGX_INPUT_GROUP_DIRECTIVES, IGX_DROP_DOWN_DIRECTIVES] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Action Strip module or directive imported, you can start with a basic configuration of the igxAutocomplete component. Using the Angular Autocomplete In order to apply the autocomplete functionality to an input, add the igxAutocomplete directive, referencing the dropdown: <igx-input-group> <input igxInput name=\"towns\" type=\"text\" [igxAutocomplete]=\"townsPanel\" /> <label igxLabel for=\"towns\">Towns</label> </igx-input-group> <igx-drop-down #townsPanel> <igx-drop-down-item *ngFor=\"let town of towns\"> {{town}} </igx-drop-down-item> </igx-drop-down> Add the list that will be shown in the dropdown. If you want the list to be filtered while typing, use the PipeTransform interface. import { Component, Pipe, PipeTransform } from '@angular/core'; @Component({ selector: 'app-autocomplete-sample', styleUrls: ['autocomplete.sample.css'], templateUrl: `autocomplete.sample.html` }) export class AutocompleteSampleComponent { constructor() { this.towns = [ 'New York', 'Washington, D.C.', 'London', 'Berlin', 'Sofia', 'Rome', 'Kiev', 'Copenhagen', 'Paris', 'Barcelona', 'Vienna', 'Athens', 'Dublin', 'Yerevan', 'Oslo', 'Helsinki', 'Stockholm', 'Prague', 'Istanbul', 'El Paso', 'Florence', 'Moscow' ]; } } @Pipe({ name: 'startsWith' }) export class AutocompletePipeStartsWith implements PipeTransform { public transform(collection: any[], term = '') { return collection.filter((item) => item.toString().toLowerCase().startsWith(term.toString().toLowerCase())); } } Note The igxAutocomplete uses the igxDropDown as a provider for the available options, which means that all capabilities of the dropdown component can be used in the autocomplete. Disable Angular Autocomplete You can disable the Angular autocomplete by using the IgxAutocompleteDisabled input: <igx-input-group> <input igxInput name=\"towns\" type=\"text\" [igxAutocomplete]='townsPanel' [igxAutocompleteDisabled]=\"disabled\"/> <label igxLabel for=\"towns\">Towns</label> </igx-input-group> Autocomplete Settings The igx-autocomplete dropdown positioning, scrolling strategy, and outlet can be configured using the IgxAutocompleteSettings. In the following Angular Autocomplete example we will position the dropdown above the input and disable the opening and closing animations. We're using the ConnectedPositioningStrategy for this: <igx-input-group class=\"autocomplete\"> <label igxLabel for=\"cinema\">Cinema</label> <input igxInput name=\"cinema\" type=\"text\" [igxAutocomplete]=\"townsPanel\" [igxAutocompleteSettings]=\"settings\"/> </igx-input-group> <igx-drop-down #townsPanel maxHeight=\"300px\"> <igx-drop-down-item-group *ngFor=\"let town of towns\" [label]=\"town.name\"> <igx-drop-down-item *ngFor=\"let cinema of town.cinemas\" [value]=\"cinema\"> {{cinema}} </igx-drop-down-item> </igx-drop-down-item-group> </igx-drop-down> export class AutocompleteComponent { public settings = { positionStrategy: new ConnectedPositioningStrategy({ closeAnimation: null, openAnimation: null, verticalDirection: VerticalAlignment.Top, verticalStartPoint: VerticalAlignment.Top }) }; public towns = [ { name: 'New York', cinemas: [ 'Regal Cinemas', 'Village East Cinema', 'Roxy Cinema', 'The Paris Theatre' ]}, { name: 'Los Angeles', cinemas: [ 'Arc Light', 'Pacific Cinerama Dome', 'New Beverly Cinema', 'Downtown Independent' ]}, { name: 'Seattle', cinemas: [ 'Central Cinema', 'Grand Illusion Cinema', 'Ark Lodge Cinemas', 'Skyway Outdoor Cinema' ]} ]; } Note The default positioning strategy is AutoPositionStrategy and the dropdown is opened according to the available space. If everything went right, you should see this in your browser: Keyboard Navigation ⬆ / ⬇ or typing in the input will open the dropdown, if it's closed. ⬇ - will move to the next dropdown item. ⬆ - will move to the previous dropdown item. ENTER will confirm the already selected item and will close the dropdown. ESC will close the dropdown. Note When the Angular autocomplete opens, then the first item on the list is automatically selected. The same is valid when the list is filtered. You can also see how our WYSIWYG App Builder™ streamlines the entire design-to-code story by 80% using real Angular components. Compatibility support Applying the igxAutocomplete directive will decorate the element with the following ARIA attributes: role=\"combobox\" - role of the element, where the directive is applied. aria-autocomplete=\"list\" - indicates that input completion suggestions are provided in the form of list aria-haspopup=\"listbox\" attribute to indicate that igxAutocomplete can pop-up a container to suggest values. aria-expanded=\"true\"/\"false\" - value depending on the collapsed state of the dropdown. aria-owns=\"dropDownID\" - id of the dropdown used for displaying suggestions. aria-activedescendant=\"listItemId\" - value is set to the id of the current active list element. The drop-down component, used as provider for suggestions, will expose the following ARIA attributes: role=\"listbox\" - applied on the igx-drop-down component container role=\"group\" - applied on the igx-drop-down-item-group component container role=\"option\" - applied on the igx-drop-down-item component container aria-disabled=\"true\"/\"false\" applied on igx-drop-down-item, igx-drop-down-item-group component containers when they are disabled. Styling Every component has its own theme. To get the igxAutocomplete styled, you have style its containing components. In our case, we need to use both the input-group-theme and the drop-down-theme. Take a look at the igxInputGroup and the igxDropdown styling sections to get a better understanding of how to style those two components. API Reference IgxAutocompleteDirective IgxDropDownComponent IgxInputGroupComponent Theming Dependencies IgxDropDown Theme IgxInputGroup Theme Additional Resources IgxDropDown IgxInputGroup Template Driven Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/avatar.html": {
    "href": "components/avatar.html",
    "title": "Angular Avatar Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Avatar Component Overview Angular Avatar component helps adding initials, images, or material icons to your application. Angular Avatar Example Getting Started with Ignite UI for Angular Avatar To get started with the Ignite UI for Angular Avatar component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxAvatarModule in your app.module.ts file. // app.module.ts ... import { IgxAvatarModule } from 'igniteui-angular'; // import { IgxAvatarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxAvatarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxAvatarComponent as a standalone dependency. // home.component.ts ... import { IgxAvatarComponent } from 'igniteui-angular'; // import { IgxAvatarComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-avatar shape=\"circle\"></igx-avatar>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxAvatarComponent] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Avatar module or component imported, you can start with a basic configuration of the igx-avatar component. Using the Angular Avatar Component The Ignite UI for Angular Avatar component comes in three shapes (square, rounded, and circle) and three size options (small, medium, and large). It can be used for displaying initials, images or icons. Avatar Shape We can change the avatar shape through the shape attribute setting its value to square, rounded or circle. By default, the shape of the avatar is square. <igx-avatar shape=\"circle\"></igx-avatar> Avatar displaying initials To get a simple avatar with initials (i.e. JS for 'Jack Sock'), add the following code inside the component template: <igx-avatar initials=\"JS\" shape=\"circle\"></igx-avatar> Let's enhance our avatar by making it circular and bigger in size. <igx-avatar size=\"medium\" initials=\"JS\" shape=\"circle\"></igx-avatar> We can also change the background through the background property or set a color on the initials through the color property. // avatar.component.scss igx-avatar { background: #e41c77; color: #000000; } Warning The roundShape property of the igx-avatar component have been deprecated. The shape attribute should be used instead. If all went well, you should see something like the following in the browser: Avatar displaying image To get an avatar that displays an image, all you have to do is set the image source via the src property. <igx-avatar src=\"https://randomuser.me/api/portraits/men/1.jpg\" shape=\"rounded\" size=\"large\"> </igx-avatar> If all went well, you should see something like the following in the browser: Avatar displaying icon Analogically, the avatar can display an icon via the icon property. Currently all icons from the material icon set are supported. <igx-avatar icon=\"person\" shape=\"rounded\" size=\"small\"> </igx-avatar> You should see something like this: Styling To get started with styling the avatar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the avatar-theme and accepts the $background, $color, and the $border-radius parameters. Given the following markup: <div class=\"initials-avatar\"> <igx-avatar>BA</igx-avatar> </div> We need to create a theme: $custom-avatar-theme: avatar-theme( $background: #72da67, $color: #000000, $border-radius: 16px ); Using CSS variables The last step is to pass the custom avatar theme: .initials-avatar { @include css-vars($custom-avatar-theme); } Using mixins In order to style components for Internet Explorer 11 and older browsers, we have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. On the other side, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom avatar theme to the `igx-avatar` mixin .initials-avatar { @include avatar($custom-avatar-theme); } } } If all went well, you should see something like the following in the browser: Custom sizing You can either use the --size variable, targeting the igx-avatar directly: igx-avatar { --size: 200px; } Or you can use the universal --igx-avatar-size variable to target all instances: <div class=\"my-app\"> <igx-avatar></igx-avatar> </div> .my-app { --igx-avatar-size: 200px; } You can also use one of the predefined sizes, assigning it to the --ig-size variable, if theres no size attribute applied. The available values for --ig-size are --ig-size-small, --ig-size-medium, and --ig-size-large: igx-avatar { --ig-size: var(--ig-size-small); } Learn more about it in the Size article. API References IgxAvatarComponent Theming Dependencies IgxAvatar Theme IgxIcon Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/badge.html": {
    "href": "components/badge.html",
    "title": "Angular Badge Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Badge Component Overview Angular Badge is a component used in conjunction with avatars, navigation menus, or other components in an application when a visual notification is needed. Badges are usually designed as icons with a predefined style to communicate information, success, warnings, or errors. Angular Badge Example Getting Started with Ignite UI for Angular Badge To get started with the Ignite UI for Angular Badge component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxBadgeModule in your app.module.ts file. // app.module.ts ... import { IgxBadgeModule } from 'igniteui-angular'; // import { IgxBadgeModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxBadgeModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxBadgeComponent as a standalone dependency. // home.component.ts ... import { IgxBadgeComponent } from 'igniteui-angular'; // import { IgxBadgeComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-badge icon=\"check\" type=\"success\" shape=\"square\"></igx-badge>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxBadgeComponent] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Badge module or component imported, you can start with a basic configuration of the igx-badge component. Using the Angular Badge Component Let's see how the demo sample is done. It's a simple success badge on an avatar. To build that, we need to import the IgxAvatarModule, along with the IgxBadgeModule: // app.module.ts ... import { IgxBadgeModule, IgxAvatarModule } from 'igniteui-angular'; // import { IgxBadgeModule, IgxAvatarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxBadgeModule, IgxAvatarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxBadgeComponent and IgxAvatarComponent as standalone dependencies. Next, we will add those components to our template: <div class=\"wrapper\"> <igx-avatar icon=\"person\" shape=\"circle\" size=\"small\"></igx-avatar> <igx-badge icon=\"check\" type=\"success\"></igx-badge> </div> Using the wrapper, we will position the badge absolutely, covering a little bit of the avatar: .wrapper { position: relative; margin-top: 15px; } igx-badge { position: absolute; bottom: 0; left: 28px; } Badge Shape We can change the badge shape through the shape attribute setting its value to square. By default, the shape of the badge is rounded. <igx-badge icon=\"check\" type=\"success\" shape=\"square\"></igx-badge> If everything's done right, you should see the demo sample shown above in your browser. Badge Icon In addition to material icons, the igx-badge component also supports usage of Material Icons Extended and any other custom icon set. To add an icon from the material icons extended set inside your badge component, first you have to register it: export class BadgeIconComponent implements OnInit { constructor (protected _iconService: IgxIconService) {} public ngOnInit() { this._iconService.addSvgIconFromText(heartMonitor.name, heartMonitor.value, 'imx-icons'); } } Then, just specify the icon name and family as follows: <igx-badge icon=\"heart-monitor\" iconSet=\"imx-icons\"></igx-badge> Badge in List Let's extend the previous sample and create a list with contacts, similar to those in chat clients. In addition to the contact name, we want to display an avatar and the current state of the contact (online, offline or away). To achieve this, we're using the igx-badge and igx-avatar components. For a container, igx-list is used. To continue, include all needed modules and import them in the app.module.ts file. // app.module.ts ... import { IgxListModule, IgxAvatarModule, IgxBadgeModule } from 'igniteui-angular'; // import { IgxListModule, IgxAvatarModule, IgxBadgeModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxListModule, IgxAvatarModule, IgxBadgeModule], }) export class AppModule {} Note The igx-badge has icon and type inputs to configure the badge look. You can set the icon by providing its name from the official material icons set. The badge type can be set to either default, info, success, warning, or error. Depending on the type, a specific background color is applied. In our sample, icon and type are bound to model properties named icon and type. Next, we're adding the contacts in our template: <!-- contacts.component.html --> <igx-list> <igx-list-item isHeader=\"true\"> Team Members (4) </igx-list-item> <igx-list-item *ngFor=\"let member of members\"> <div class=\"wrapper\"> <div> <igx-avatar icon=\"person\" shape=\"circle\" size=\"small\"></igx-avatar> <igx-badge [icon]=\"member.icon\" [type]=\"member.type\" class=\"badge-style\"></igx-badge> </div> <div class=\"contact-container\"> <span class=\"contact-name\">{{ member.name }}</span> </div> </div> </igx-list-item> </igx-list> We're going to create our members in the typescript file like this: // contacts.component.ts ... public members: Member[] = [ new Member('Terrance Orta', 'online'), new Member('Donna Price', 'online'), new Member('Lisa Landers', 'away'), new Member('Dorothy H. Spencer', 'offline'), ]; ... class Member { public name: string; public status: string; public type: string; public icon: string; constructor(name: string, status: string) { this.name = name; this.status = status; switch (status) { case 'online': this.type = 'success'; this.icon = 'check'; break; case 'away': this.type = 'warning'; this.icon = 'schedule'; break; case 'offline': this.type = 'error'; this.icon = 'remove'; break; } } } Position the badge in its parent container: /* contacts.component.css */ .wrapper { display: flex; flex-direction: row; } .contact-name { font-weight: 600; } .contact-container { margin-left: 20px; } .badge-style { position: absolute; bottom: 2.5px; left: 40px; } If the sample is configured properly, a list of members should be displayed and every member has an avatar and a badge, showing its current state. Styling To get started with styling the badges, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the badge-theme and accepts some parameters that style the badge's items. $custom-badge-theme: badge-theme( $border-color: white, $border-width: 1px, $icon-color: white, $text-color: black, $shadow: 3px 2px 5px 0px rgba(0,0,0,0.4) ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include badge($custom-badge-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include badge($custom-badge-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-badge-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-badge-theme); } Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxAvatarComponent IgxBadgeComponent IgxBadgeComponent Styles IgxListComponent IgxListItemComponent IgxBadgeType Theming Dependencies IgxIcon Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/banner.html": {
    "href": "components/banner.html",
    "title": "Angular Banner Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Banner Component Overview Angular Banner Component provides a way to easily display a prominent message to your application's users in a way that is less transient than a snackbar and less obtrusive than a dialog. The Banner can also be configured to display custom action buttons and an icon. Angular Banner Example Getting Started with Ignite UI for Angular Banner To get started with the Ignite UI for Angular Banner component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxBannerModule in your app.module.ts file. // app.module.ts ... import { IgxBannerModule } from 'igniteui-angular'; // import { IgxBannerModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxBannerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxBannerComponent as a standalone dependency, or use the IGX_BANNER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts ... import { IGX_BANNER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_BANNER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-banner> You are currently offline. </igx-banner> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_BANNER_DIRECTIVES] /* or imports: [IgxBannerComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Banner module or directives imported, you can start with a basic configuration of the igx-banner component. Using the Angular Banner Component Show Banner In order to display the banner component, use its open() method and call it on a button click. The banner appears relative to where the element was inserted in the page template, moving all other content. It typically shows some non-intrusive content that requires minimal user interaction to be dismissed. <!--banner.component.html--> <igx-icon (click)=\"connectionBanner.open()\">refresh</igx-icon> ... <igx-banner #connectionBanner> You are currently offline. </igx-banner> Note The IgxBannerModule includes a default banner button Dismiss, which closes the banner. Examples The IgxBannerComponent allows templating of its content while still sticking as closely as possible to the material design banner guidelines. Changing the banner message Configuring the message displayed in the banner is easy - just change the content you are passing to the igx-banner tag. The text will show up in the specified banner area and the banner will use its default template when displaying it. Below, we will change the content of our sample banner to be a bit more descriptive: <!--banner.component.html--> <igx-banner #connectionBanner> You have lost connection to the internet. This app is offline. </igx-banner> Adding an icon An igx-icon can be displayed in the banner by passing it to the banner's content. The icon will always be positioned at the beginning of the banner message. Note If several igx-icon elements are inserted as direct descendants of the banner, the banner will try to position all of them at the beginning. It is strongly advised to pass only one igx-icon directly to the banner. To pass an igx-icon to you banner, simply insert it in the banner's content: <!--banner.component.html--> <igx-banner #connectionBanner> <igx-icon>signal_wifi_off</igx-icon> You have lost connection to the internet. This app is offline. </igx-banner> If you want to use an igx-icon in your banner message, wrap it in a span tag: <!--banner.component.html--> <igx-banner #connectionBanner> You have lost connection to the internet. This app is offline. <span> <igx-icon>signal_wifi_off</igx-icon> </span> </igx-banner> Changing the banner button The IgxBannerModule exposes a directive for templating the banner buttons - IgxBannerActionsDirective. This directive allows you to override the default banner button (Dismiss) and add user-defined custom actions. <!--banner.component.html--> <igx-banner #connectionBanner> <igx-icon>signal_wifi_off</igx-icon> You have lost connection to the internet. This app is offline. <igx-banner-actions> <button igxButton igxRipple (click)=\"connectionBanner.toggle()\">Toggle Banner</button> </igx-banner-actions> </igx-banner> Applying custom animations The banner component comes with the animationSettings property that allows applying custom opening and closing animations. Developers can choose between self-defined animations, and those from our Animation suite. The default ones, used by the banner, are growVerIn for entering and growVerOut for exiting. Let's change the animations that our banner uses, so that it slides in and out: <!--banner.component.html--> <igx-banner #connectionBanner [animationSettings]=\"animationSettings\"> ... </igx-banner> // banner.component.ts import { IgxBannerComponent, slideInLeft, slideOutRight } from 'igniteui-angular' // import { IgxBannerComponent, slideInLeft, slideOutRight } from '@infragistics/igniteui-angular'; for licensed package ... export class MyBannerComponent { ... public animationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight } ... } Binding to events The banner component emits events when changing its state - opening and opened are called when the banner is shown (before and after, resp.), while closing and closed are emitted when the banner is closed. The ing events (opening, closing) are cancelable - they use the ICancelEventArgs interface and the emitted object has a cancel property. If the cancel property is set to true, the corresponding end action and event will not be triggered - e.g. if we cancel opening, the banner's open method will not finish and the banner will not be shown. To cancel an event, bind it to the emitted object and set its cancel property to true. <!--banner.component.html--> <igx-banner #connectionBanner (opening)=\"handleOpen($event)\"> ... </igx-banner> // banner.component.ts ... export class MyBannerComponent { ... public handleOpen(event) { event.cancel = true; } } Note If the changes above are applied, the banner will never open, as the opening event is always cancelled. Advanced Example Let's create a banner with two custom buttons - one for dismissing the notification and one for turning on the connection. We can pass custom action handlers using the igx-banner-actions selector: <!--banner.component.html--> <igx-banner class=\"offline-banner\" #connectionBanner [animationSettings]=\"animationSettings\"> <igx-icon>signal_wifi_off</igx-icon> You have lost connection to the internet. This app is offline. <igx-banner-actions> <button igxButton igxRipple (click)=\"connectionBanner.close()\">Continue Offline</button> <button igxButton igxRipple (click)=\"wifiState = true\">Turn On Wifi</button> </igx-banner-actions> </igx-banner> Note According to Google's Material Design guidelines, a banner should have a maximum of 2 buttons present. The IgxBannerComponent does not explicitly limit the number of elements under the igx-banner-actions tag, but it is strongly recommended to use up to 2 if you want to adhere to the material design guidelines. The dismiss option ('Continue Offline') doesn't need any further logic, so it can just call the close() method. The confirm action ('Turn On Wifi'), however, requires some additional logic, so we have to define it in the component. Then, we will create onNetworkStateChange Observable and subscribe to it. The last step is to call the refreshBanner() method on each change, which will toggle the banner depending on the wifiState. The banner will also have a WiFi icon in the navbar. As the subscription fires on any change of the wifiState, the icon will not only toggle the banner, but change according to the state of the connection: <!--banner.component.html--> <igx-navbar title=\"Gallery\"> <igx-icon (click)=\"wifiState = !wifiState\"> {{ wifiState ? 'signal_wifi_4_bar' : 'signal_wifi_off' }} </igx-icon> </igx-navbar> Finally, we will add a toast, displaying a message about the WiFi state. The results of the templated banner can be seen in the demo below: Styling First, in order to use the functions exposed by the theme engine, we need to import the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the banner-theme and accepts the $banner-message-color, $banner-background and the $banner-illustration-color parameters. $custom-banner-theme: banner-theme( $banner-message-color: #151515, $banner-background: #dedede, $banner-illustration-color: #666666 ); Using CSS variables The last step is to pass the custom banner theme: @include css-vars($custom-banner-theme); Using mixins In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom banner theme to the `igx-banner` mixin @include banner($custom-banner-theme); } } Using color palettes Instead of hardcoding the color values, like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. The igx-palette function generates a color palette based on the primary and secondary colors that are passed: $white-color: #dedede; $black-color: #151515; $light-banner-palette: palette($primary: $white-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-banner-theme: banner-theme( $banner-message-color: color($light-banner-palette, \"secondary\", 400), $banner-background: color($light-banner-palette, \"primary\", 400), $banner-illustration-color: color($light-banner-palette, \"secondary\", 100) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to the Palettes topic for detailed guidance on how to use them. Using schemas You can build a robust and flexible structure that benefits from schemas. Extend one of the two predefined schemas, that are provided for every component, in this case - light-banner schema: // Extending the banner schema $light-toast-schema: extend($_light-toast, ( banner-message-color: ( color: (\"secondary\", 400) ), banner-background: ( color: (\"primary\", 400) ), banner-illustration-color: ( color: (\"secondary\", 100) ) ) ); // Defining banner with the global light schema $custom-banner-theme: banner-theme( $palette: $light-banner-palette, $schema: $light-toast-schema ); Don't forget to include the themes in the same way as it was demonstrated above. API Reference IgxBannerComponent IgxBannerActionsDirective IgxBannerComponent Styles Additional components and/or directives with relative APIs that were used: IgxCardComponent IgxIconComponent IgxNavbarComponent IgxToastComponent Theming Dependencies IgxIcon Theme IgxButton Theme IgxRipple Theme IgxExpansionPanel Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/bullet-graph.html": {
    "href": "components/bullet-graph.html",
    "title": "Angular Bullet Graph | Data Visualization Tools | Infragistics",
    "keywords": "Angular Bullet Graph Overview The Angular bullet graph component allows for a linear and concise view of measures compared against a scale. The Ignite UI for Angular bullet graph component provides you with the ability to create attractive data presentations, replacing meters and gauges that are used on dashboards with simple yet straightforward and clear bar charts. A bullet graph is one of the most effective and efficient ways to present progress towards goals, good/better/best ranges, or compare multiple measurements in as little horizontal or vertical space as possible. Angular Bullet Graph Example The following sample demonstrates how setting multiple properties on the same IgxBulletGraphComponent can transform it to completely different bullet graph. The bullet graph supports one scale, one set of tick marks and one set of labels. The bullet graph component also has built-in support for animated transitions. This animation is easily customizable by setting the transitionDuration property. The features of the bullet graph include configurable orientation and direction, configurable visual elements such as the needle, and more. Dependencies When installing the gauge package, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-gauges Component Modules The IgxBulletGraphComponent requires the following modules: // app.module.ts import { IgxBulletGraphModule } from 'igniteui-angular-gauges'; @NgModule({ imports: [ // ... IgxBulletGraphModule // ... ] }) export class AppModule {} Usage The following code walks through creating a bullet graph component, and configuring a performance bar, comparative measure marker, and three comparative ranges on the scale. <igx-bullet-graph height=\"100\" width=\"300\" minimumValue=\"5\" maximumValue=\"55\" value=\"35\" targetValue=\"43\"> <igx-linear-graph-range startValue=\"0\" endValue=\"15\" brush=\"#828181\"> </igx-linear-graph-range> <igx-linear-graph-range startValue=\"15\" endValue=\"30\" brush=\"#AAAAAA\"> </igx-linear-graph-range> <igx-linear-graph-range startValue=\"30\" endValue=\"55\" brush=\"#D0D0D0\"> </igx-linear-graph-range> </igx-bullet-graph> Comparative Measures The bullet graph can show two measures: performance value and target value. Performance value is the primary measure displayed by the component and it is visualized as a bar that stretches along the length of the whole graph. The target value is a measure which the performance value compares against. It is displayed as a small block that runs perpendicular to the orientation of the performance bar. <igx-bullet-graph value=50 valueBrush=\"DodgerBlue\" valueStrokeThickness=1 valueInnerExtent=0.5 valueOuterExtent=0.65 targetValue=80 targetValueBreadth=10 targetValueBrush=\"LimeGreen\" targetValueOutline=\"LimeGreen\" targetValueStrokeThickness=1 targetValueInnerExtent=0.3 targetValueOuterExtent=0.85 height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100> </igx-bullet-graph> Comparative Ranges The ranges are visual elements that highlight a specified range of values on a scale. Their purpose is to visually communicate the qualitative state of the performance bar measure, illustrating at the same time the degree to which it resides within that state. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 value=80 interval=10 maximumValue=100 targetValue=90 rangeBrushes =\"#C62828, #F96232, #FF9800\" rangeOutlines=\"#C62828, #F96232, #FF9800\"> <igx-linear-graph-range startValue=0 endValue=40 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.95 outerEndExtent=0.95> </igx-linear-graph-range> <igx-linear-graph-range startValue=40 endValue=70 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.95 outerEndExtent=0.95> </igx-linear-graph-range> <igx-linear-graph-range startValue=70 endValue=100 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.95 outerEndExtent=0.95> </igx-linear-graph-range> </igx-bullet-graph> Tick Marks The tick marks serve as a visual division of the scale into intervals in order to increase the readability of the bullet graph. Major tick marks – The major tick marks are used as primary delimiters on the scale. The frequency they appear at, their extents and style can be controlled by setting their corresponding properties. Minor tick marks – The minor tick marks represent helper tick marks, which might be used to additionally improve the readability of the scale and can be customized in a way similar to the major ones. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 value=70 maximumValue=100 targetValue=90 interval=10 tickBrush=\"DodgerBlue\" ticksPreTerminal=0 ticksPostInitial=0 tickStrokeThickness=2 tickStartExtent=0.2 tickEndExtent=0.075 minorTickCount=4 minorTickBrush=\"DarkViolet\" minorTickEndExtent=0.1 minorTickStartExtent=0.2 minorTickStrokeThickness=1> </igx-bullet-graph> Labels The labels indicate the measures on the scale. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 value=70 interval=10 maximumValue=100 targetValue=90 labelInterval=10 labelExtent=0.025 labelsPreTerminal=0 labelsPostInitial=0 fontBrush=\"DodgerBlue\" font=\"11px Verdana\"> </igx-bullet-graph> Backing The backing element represents background and border of the bullet graph component. It is always the first element rendered and all the rest of elements such as labels, and tick marks are overlaid on top of it. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 value=70 interval=10 maximumValue=100 targetValue=90 backingBrush=\"#bddcfc\" backingOutline=\"DodgerBlue\" backingStrokeThickness=4 backingInnerExtent=0 backingOuterExtent=1> </igx-bullet-graph> Scale The scale is visual element that highlights the full range of values in the gauge. You can customize appearance and shape of the scale. The scale can also be inverted (using isScaleInverted property) and all labels will be rendered from right-to-left instead of left-to-right. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 value=70 interval=10 maximumValue=100 targetValue=90 isScaleInverted=false scaleBackgroundBrush=\"DodgerBlue\" scaleBackgroundOutline=\"DarkViolet\" scaleBackgroundThickness=2 scaleStartExtent=0.05 scaleEndExtent=0.95> </igx-bullet-graph> Summary For your convenience, all above code snippets are combined into one code block below that you can easily copy to your project and see the bullet graph with all features and visuals enabled. <igx-bullet-graph height=\"80px\" width=\"400px\" minimumValue=0 maximumValue=100 isScaleInverted=false scaleBackgroundBrush=\"Gray\" scaleBackgroundOutline=\"Gray\" scaleBackgroundThickness=2 scaleStartExtent=0.05 scaleEndExtent=0.95 value=50 valueBrush=\"Black\" valueStrokeThickness=1 valueInnerExtent=0.5 valueOuterExtent=0.65 targetValue=80 targetValueBreadth=7.5 targetValueBrush=\"Black\" targetValueOutline=\"Black\" targetValueStrokeThickness=1 targetValueInnerExtent=0.3 targetValueOuterExtent=0.85 labelInterval=10 labelExtent=0.025 labelsPreTerminal=0 labelsPostInitial=0 fontBrush=\"Black\" font=\"11px Verdana\" backingBrush=\"#cecece\" backingOutline=\"#cecece\" backingStrokeThickness=4 backingInnerExtent=0 backingOuterExtent=1 interval=10 tickBrush=\"Black\" ticksPreTerminal=0 ticksPostInitial=0 tickStrokeThickness=2 tickStartExtent=0.2 tickEndExtent=0.075 minorTickCount=4 minorTickBrush=\"Black\" minorTickEndExtent=0.1 minorTickStartExtent=0.2 minorTickStrokeThickness=1 rangeBrushes =\"#C62828, #F96232, #FF9800\" rangeOutlines=\"#C62828, #F96232, #FF9800\"> <igx-linear-graph-range startValue=20 endValue=40 innerStartExtent=0.25 innerEndExtent=0.25 outerStartExtent=0.9 outerEndExtent=0.9> </igx-linear-graph-range> <igx-linear-graph-range startValue=40 endValue=60 innerStartExtent=0.25 innerEndExtent=0.25 outerStartExtent=0.9 outerEndExtent=0.9> </igx-linear-graph-range> <igx-linear-graph-range startValue=60 endValue=90 innerStartExtent=0.25 innerEndExtent=0.25 outerStartExtent=0.9 outerEndExtent=0.9> </igx-linear-graph-range> </igx-bullet-graph> API References The following is a list of API members mentioned in the above sections: IgxBulletGraphComponent IgxLinearGraphRangeComponent Additional Resources You can find more information about other types of gauges in these topics: Linear Gauge Radial Gauge View page on GitHub"
  },
  "components/button.html": {
    "href": "components/button.html",
    "title": "Angular Button Component – Ignite UI for Angular",
    "keywords": "Angular Button Overview Angular Button directive is used for creating and adding actionable buttons to a web page/application. There are different Angular Button types that are easy to customize and include several built-in features. By default, Angular Material uses native <button> and <a> elements to deliver an accessible experience. The Ignite UI for Angular Button directive is intended to turn any button, span, div, or anchor element into a fully functional button. You can use the following Angular Button types - Flat Button, Contained Button, Outlined Button, and Floating Action Button. With customizable colors, options to create themes and change the Angular Button Style and enabling users to choose the button size and more. Angular Button Example We have created the Angular Button example below to show you how different button types can appear and look like when they are styled with a border or when a transparent background is applied. Getting Started with Ignite UI for Angular Button To get started with the Ignite UI for Angular Button directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxButtonModule in your app.module.ts file. // app.module.ts import { IgxButtonModule } from 'igniteui-angular'; // import { IgxButtonModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxButtonModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxButtonDirective as a standalone dependency. // home.component.ts ... import { IgxButtonDirective } from 'igniteui-angular'; // import { IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<button igxButton=\"flat\">Flat</button>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxButtonDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Button module or directive imported, you can start using the igxButton directive on elements. Angular Button Types Flat Button Use the igxButton directive to add a simple flat button in your component template. Note that if you do not choose a type, by default it will be set to flat. <button igxButton=\"flat\">Flat</button> Contained Button All you have to do to create a contained button is to change the value of the igxButton property: <button igxButton=\"contained\">Contained</button> Outlined Button Analogically, we can switch to outlined type: <button igxButton=\"outlined\">Outlined</button> Icon Button As of version 17.1.0 the IgniteUI for Angular exposes a new igxIconButton directive intended to turn icons into fully functional buttons. You can read more about the Icon Button here. <button igxIconButton=\"flat\"> <igx-icon fontSet=\"material\">favorite</igx-icon> </button> Floating Action Button We can create a floating action button and use an icon to display: <button igxButton=\"fab\"> <igx-icon fontSet=\"material\">edit</igx-icon> </button> To create an extended FAB, you can add any element prior to the igx-icon: <button class=\"btn\" igxButton=\"fab\"> <span>like</span> <igx-icon fontSet=\"material\">favorite</igx-icon> </button> Note To get the extended FAB text styled properly, use <span> or <div> tags. Examples Angular Disable Button The disabled property can be used to make a button unclickable: <button igxButton=\"contained\" [disabled]=\"'true'\">Disabled</button> Ripple The igxRipple directive adds a ripple effect to your buttons or other specified elements. You can easily change the default ripple color, position and duration, using its properties: <button igxButton=\"contained\" igxRipple=\"white\" [igxRippleCentered]=\"true\" [igxRippleDuration]=\"2000\"> Ripple </button> Span We can also use the igxButton directive to turn elements like span and div into Ignite UI for Angular styled buttons. The default colors can be customized via the igxButtonColor and the igxButtonBackground properties: <span igxButton=\"contained\" igxButtonColor=\"white\" igxButtonBackground=\"#72da67\" igxRipple=\"white\"> Span </span> Size (Display Density) We can allow the user to choose the size of the igxButton by using the --ig-size custom CSS property. To do this, first we have to import the IgxButtonGroupModule, and then use the igxButtonGroup component to display size values. This way whenever one gets selected, we will update the --ig-size CSS property. // app.module.ts ... import { IgxButtonGroupModule } from 'igniteui-angular'; // import { IgxButtonGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxButtonGroupModule ... ] }) <!--buttons-density.component.html--> <igx-buttongroup [values]=\"sizes\" (selected)=\"selectSize($event)\"></igx-buttongroup> ... <button igxButton=\"flat\">Flat</button> // buttons-density.component.ts public size = \"large\"; public sizes; public ngOnInit() { this.sizes = [ { label: 'large', selected: this.size === 'large', togglable: true }, { label: 'medium', selected: this.size === 'medium', togglable: true }, { label: 'small', selected: this.size === 'small', togglable: true } ]; } public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } If all went well, you should see something like the following in the browser: Angular Button Styling To get started with styling the button, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the button-theme and accepts the $foreground and the $background parameters with their respective hover and focus parameters. Given the following markup: <div class=\"my-contained-btn\"> <button igxButton=\"contained\">Contained button</button> </div> We need to create a theme: $custom-button-theme: button-theme( $foreground: #fdfdfd, $hover-foreground: #fdfdfd, $focus-foreground: #fdfdfd, $background: #345779, $hover-background: #2e4d6b, $focus-background: #2e4d6b, $disabled-foreground: #2e4d6b ); Take a look at the button-theme section for a complete list of available parameters for styling any type of button. Using CSS variables The last step is to pass the custom button theme in our application: .my-contained-btn { @include css-vars($custom-button-theme); } Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { .my-contained-btn { @include button($custom-button-theme); } } } Demo Custom sizing You can change the button height either by using the --size variable, targeting the button directly: button { --size: 50px; } Or you can use the universal --igx-button-size variable to target all instances: <div class=\"my-app\"> <button igxButton=\"raised\"></button> </div> .my-app { --igx-button-size: 50px; } You can also use one of the predefined sizes, assigning it to the --ig-size variable. The available values for --ig-size are --ig-size-small, --ig-size-medium, and --ig-size-large: button { --ig-size: var(--ig-size-large); } Learn more about it in the Size article. API References IgxButtonDirective IgxButton Styles IgxRippleDirective IgxIconButtonDirective IgxButtonGroupComponent Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/button-group.html": {
    "href": "components/button-group.html",
    "title": "Angular Button Group Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Button Group Component Overview Angular Button Group component is used to organize buttons into styled button groups with horizontal/vertical alignment, single/multiple selection and toggling. Angular Button Group Example Getting Started with Ignite UI for Angular Button Group To get started with the Ignite UI for Angular Button Group component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxButtonGroupModule in your app.module.ts file. // app.module.ts ... import { IgxButtonGroupModule } from 'igniteui-angular'; // import { IgxButtonGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxButtonGroupModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxButtonGroupComponent as a standalone dependency, or use the IGX_BUTTON_GROUP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts ... import { IGX_BUTTON_GROUP_DIRECTIVES, IgxIconComponent } from 'igniteui-angular'; // import { IGX_BUTTON_GROUP_DIRECTIVES, IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-buttongroup> <button igxButton> <igx-icon>format_align_left</igx-icon> </button> <button igxButton> <igx-icon>format_align_center</igx-icon> </button> <button igxButton> <igx-icon>format_align_right</igx-icon> </button> <button igxButton [selected]=\"true\"> <igx-icon>format_align_justify</igx-icon> </button> </igx-buttongroup> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_BUTTON_GROUP_DIRECTIVES, IgxIconComponent] /* or imports: [IgxButtonGroupComponent, IgxButtonDirective, IgxIconComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Button Group module or directives imported, you can start with a basic configuration of the igx-buttongroup and its buttons. Using for Angular Button Group Component Add Button Group Use the igx-buttongroup selector to wrap your buttons and display them into a button group. If you want a button to be selected by default, use the selected property: <!-- sample.component.html --> <igx-buttongroup> <button igxButton> <igx-icon>format_align_left</igx-icon> </button> <button igxButton> <igx-icon>format_align_center</igx-icon> </button> <button igxButton> <igx-icon>format_align_right</igx-icon> </button> <button igxButton [selected]=\"true\"> <igx-icon>format_align_justify</igx-icon> </button> </igx-buttongroup> Examples Alignment Use the alignment input property to set the orientation of the buttons in the button group. //sample.component.ts import { ButtonGroupAlignment } from 'igniteui-angular'; // import { ButtonGroupAlignment } from '@infragistics/igniteui-angular'; for licensed package ... public alignment = ButtonGroupAlignment.vertical; ... <!-- sample.component.html --> <igx-buttongroup [alignment]=\"alignment\"> <button igxButton>Sofia</button> <button igxButton>London</button> <button igxButton [selected]=\"true\">New York</button> <button igxButton>Tokyo</button> </igx-buttongroup> Selection In order to configure the igx-buttongroup selection, you could use its selectionMode property. This property accepts the following three modes: single - default selection mode of the button group. A single button can be selected/deselected by the user. singleRequired - mimics a radio group behavior. Only one button can be selected and once initial selection is made, deselection is not possible through user interaction. multi - multiple buttons in the group can be selected and deselected. The sample below demonstrates the exposed igx-buttongroup selection modes: Size (Display Density) The --ig-size CSS custom property can be used to control the size of the button group. /* sample.component.scss */ igx-buttongroup { --ig-size: var(--ig-size-small); } <!-- sample.component.html --> <igx-buttongroup></igx-buttongroup> Custom toggle buttons Use the values input property to set an array of customized buttons in the button group. // sample.component.ts interface IButton { ripple?: string; label?: string; disabled?: boolean; togglable?: boolean; selected?: boolean; color?: string; icon?: string; } class ToggleButton { private ripple: string; private label: string; private disabled: boolean; private togglable: boolean; private selected: boolean; private color: string; private icon: string; constructor(obj?: IButton) { this.ripple = obj.ripple || 'gray'; this.label = obj.label; this.selected = obj.selected || false; this.togglable = obj.togglable || true; this.disabled = obj.disabled || false; this.color = obj.color; this.icon = obj.icon; } } ... public bordersButtons: ToggleButton[]; public ngOnInit() { this.bordersButtons = [ new ToggleButton({ icon: 'border_top', selected: true }), new ToggleButton({ icon: 'border_right', selected: false }), new ToggleButton({ icon: 'border_bottom', selected: false }), new ToggleButton({ icon: 'border_left', selected: false }) ]; } ... <!-- sample.component.html --> <igx-buttongroup [selectionMode]=\"'multi'\" [values]=\"bordersButtons\"></igx-buttongroup> Styling To get started with styling the button group, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the button-group-theme and accepts some of the parameters that style the button group's items in their different states. $custom-button-group: button-group-theme( $item-text-color: #fdfdfd, $item-background: #2f4d6a, $item-hover-text-color: #fdfdfd, $item-hover-background: #1f3347, $item-selected-text-color: #fdfdfd, $item-selected-background: #1f3347, $item-selected-hover-background: #1f3347, $disabled-text-color: gray, $disabled-background-color: lightgray ); As seen, the button-group-theme exposes some useful parameters for basic styling of its items. If you want to drill deeper and change some button specific parameters, you can create a new theme that extends the button-theme and scope it under the respective button group class. Using CSS variables The last step is to include the component's theme. @include css-vars($custom-button-group); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include button-group($custom-button-group); } } Demo API References IgxButtonGroupComponent IgxButtonGroup Styles IgxButtonDirective IgxButton Styles Theming Dependencies IgxIcon Theme IgxButton Theme IgxRipple Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/calendar.html": {
    "href": "components/calendar.html",
    "title": "Angular Calendar Component – Ignite UI for Angular",
    "keywords": "Angular Calendar Component Overview Angular Calendar is a UI component used for displaying dates and days in an app. Supporting different features, it enables users to easily manage calendar functionalities, drag and create events in a calendar, navigate to a preferred date in it, and show events in an Angular calendar month view, week view, or day view in a single click. The Ignite UI for Angular Calendar component, developed as a native Angular component, provides an easy and intuitive ways to display date information, enable dates or apply Angular calendar disable dates mode. Users can choose from three different selection modes - single selection, multi selection or range selection. Angular Calendar Example We created the following Angular Calendar example using the Ignite UI for Angular Calendar package. It quickly shows how a basic calendar looks and feels like, how users can choose and highlight a single date, and how to move back and forth to a specific date. Getting Started with Ignite UI for Angular Calendar To get started with the Ignite UI for Angular Calendar component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxCalendarModule in your app.module.ts file. Note The IgxCalendarComponent also depends on the BrowserAnimationsModule and the HammerModule for touch interactions, so they need to be added to the AppModule as well: // app.module.ts ... import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxCalendarModule } from 'igniteui-angular'; // import { IgxCalendarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., BrowserAnimationsModule, HammerModule, IgxCalendarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxCalendarComponent as a standalone dependency, or use the IGX_CALENDAR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IGX_CALENDAR_DIRECTIVES } from 'igniteui-angular'; // import { IGX_CALENDAR_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-calendar></igx-calendar>', styleUrls: ['home.component.scss'], standalone: true, imports: [BrowserAnimationsModule, HammerModule, IGX_CALENDAR_DIRECTIVES] /* or imports: [BrowserAnimationsModule, HammerModule, IgxCalendarComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Calendar module or directives imported, you can start using the igx-calendar component. Note The IgxCalendarComponent uses the Intl Web API for localization and formatting of dates. Consider using appropriate polyfills if your target platform does not support them. Using the Angular Calendar Angular Single Selection Calendar Instantiating the IgxCalendarComponent is as easy as placing its selector element in the template. This will display the current month in the single selection calendar mode. <!-- app.component.html --> <!-- Single selection mode --> <igx-calendar></igx-calendar> Angular Calendar Multiselect We can easily change the default mode using the selection property: <!-- app.component.html --> <!-- Multi selection mode --> <igx-calendar selection=\"multi\" [showWeekNumbers]=\"true\"></igx-calendar> Angular Calendar Range Picker Following the same approach, we can switch to range selection mode: <!-- app.component.html --> <!-- Range selection mode --> <igx-calendar selection=\"range\"></igx-calendar> Note Notice that the calendar header is not rendered when the selection is either multi or range. Localization and Formatting Due to their very nature, localization and formatting are essential to any calendar. In the IgxCalendarComponent those are controlled and customized through the following properties - locale, formatOptions, formatViews, weekStart. Let's go ahead and try those along with other customizations from the IgxCalendarComponent API. First thing we need to set is the weekStart, which controls the starting day of the week. It defaults to 0, which corresponds to Sunday, so we will set a value of 1 for Monday. In the markup below we are also binding the formatOptions and formatViews properties to customize the display formatting. Finally, we are binding the locale property to a value, based on the user's location choice: <!-- app.component.html --> <igx-select #select [(ngModel)]=\"locale\"> <igx-select-item *ngFor=\"let locale of locales\" [value]=\"locale\"> {{ locale }} </igx-select-item> </igx-select> <igx-calendar #calendar [weekStart]=\"1\" [locale]=\"locale\" [formatOptions]=\"formatOptions\" [formatViews]=\"formatViews\"> </igx-calendar> All property values should be set in the AppCоmponent file: // app.component.ts @ViewChild('calendar', { read: IgxCalendarComponent }) public calendar: IgxCalendarComponent; public formatOptions: any; public formatViews: any; public locales = ['EN', 'DE', 'FR', 'AR', 'ZH']; public locale = 'EN'; public ngOnInit() { this.formatOptions = { day: '2-digit', month: 'long', weekday: 'long', year: 'numeric' }; this.formatViews = { day: true, month: true, year: true }; } If everything went well, we should now have a calendar with customized dates display, that also changes the locale representation, based on the user location. Let's have a look at it: How to Disable Dates In Angular Calendar This section demonstrates the usage of disabledDates functionality. For this purpose, different single dates or ranges can be added to an array and then passed to the disabledDates descriptor. The DateRangeType is used to specify a range that is going to be disabled. Let's create a sample that is disabling the dates between the 3rd and the 8th of the current month: export class CalendarSample6Component { @ViewChild('calendar') public calendar: IgxCalendarComponent; public today = new Date(Date.now()); public range = [ new Date(this.today.getFullYear(), this.today.getMonth(), 3), new Date(this.today.getFullYear(), this.today.getMonth(), 8) ]; public ngOnInit() { this.calendar.disabledDates = [{ type: DateRangeType.Between, dateRange: this.range }]; } } These configurions should have the following result: Special dates The specialDates feature is using almost the same configuration principles as the disabledDates. The ability to select and focus specialDates is what differs them from the disabled ones. Let's add some specialDates to our igxCalendar. In order to do this, we have to create a DateRangeDescriptor item of type DateRangeType.Specific and pass an array of dates as a dateRange: export class CalendarSample7Component { @ViewChild('calendar', { static: true }) public calendar: IgxCalendarComponent; @ViewChild('alert', { static: true }) public dialog: IgxDialogComponent; public range = []; public selectPTOdays(dates: Date[]) { this.range = dates; } public submitPTOdays(eventArgs) { this.calendar.specialDates = [{ type: DateRangeType.Specific, dateRange: this.range }]; this.range.forEach((item) => { this.calendar.selectDate(item); }); ... } } <igx-calendar #calendar weekStart=\"1\" selection=\"multi\" (selected)=\"selectPTOdays($event)\"> </igx-calendar> <igx-dialog #alert title=\"Request Time Off\" leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\"> </igx-dialog> <button igxButton=\"contained\" (click)=\"submitPTOdays($event)\">Submit Request</button> The following demo illustrates a calendar with a vacation request option: Week numbers You can now use showWeekNumbers input to show the week numbers for both Calendar and DatePicker components. <!-- app.component.html --> <igx-calendar selection=\"multi\" [showWeekNumbers]=\"true\"></igx-calendar> The following demo illustrates a calendar with enabled week numbers: Calendar Events Let's explore the events emitted by the calendar: selected - emitted when selecting date(s) in the calendar. viewDateChanged - emitted every time when the presented month/year is changed - for example after navigating to the next or previous month. activeViewChanged - emitted after the active view is changed - for example after the user has clicked on the month or year section in the header. <!-- app.component.html --> <igx-calendar #calendar (selected)=\"onSelection($event)\" (viewDateChanged)=\"viewDateChanged($event)\" (activeViewChanged)=\"activeViewChanged($event)\"> </igx-calendar> The selected event is suitable to build input validation logic. Use the code from below to alert the user if selection exceeds 5 days, and then reset the selection: // app.component.ts ... public onSelection(dates: Date[]) { if (dates.length > 5) { this.calendar.selectedDates = []; // alert the user } } public viewDateChanged(event: IViewDateChangeEventArgs) { // use event.previousValue to get previous month/year that was presented. // use event.currentValue to get current month/year that is presented. } public activeViewChanged(event: CalendarView) { // use CalendarView[event] to get the current active view (DEFAULT, YEAR or DECADE) } Use the demo below to play around (change selection, navigate through months and years) and see the events logged real time: Angular Calendar Views There are separate views provided by the IgxCalendarModule that can be used independently: Angular Calendar Days View - igx-days-view Angular Calendar Month View - igx-months-view Angular Calendar Year View - igx-years-view Keyboard navigation If you traverse the page using Tab key you should keep in mind that based on W3 accessability recommendations the igxCalendarComponent now introduces the following tab stops: Previous month button Month selection button Year selection button Next month button Selected date, Current date, First focusable (not disabled) date in the days view In an Angular Calendar that contains more than one selected dates, only the first date will be introduced as a tab stop. For example, when an Angular Calendar multiselect is enabled and you have selected the dates: 13/10/2020, 17/10/2020 and 21/10/2020 only 13/10/2020 will be accessible during tab navigation; in an Angular Calendar Range Picker, only the first date of the selected range will be part of the page tab sequence. Note Behavioral change, from v10.2.0 - Tab key navigation in the days view is no longer available. In order to navigate between the dates in the date view you should use the arrow keys. When the igxCalendar component is focused, use: PageUp key to move to the previous month, PageDown key to move to the next month, Shift + PageUp keys to move to the previous year, Shift + PageDown keys to move to the next year, Home key to focus the first day of the current month or first month in view End key to focus the last day of the current month or last month in view When the prev or the next month buttons (in the subheader) are focused, use: Space or Enter key to scroll into view the next or previous month. When the months button (in the subheader) is focused, use: Space or Enter key to open the months view. When the year button (in the subheader) is focused, use: Space or Enter key to open the decade view. When a day inside the current month is focused: Use Arrow keys to navigate through the days. Note: The disabled dates will be skipped. Focus will be persisted on the current month that is in the view, while navigation from/to the last day/first day of the month. THe kb navigation would be continuous, which means that it will go through all months while navigating with the arrows. Use Enter key to select the currently focused day. When a month inside the months view is focused, use: Arrow keys to navigate through the months. Home key to focus the first month inside the months view. End key to focus the last month inside the months view. Enter key to select the currently focused month and close the view. When an year inside the decade view is focused, use: Arrow up and Arrow down keys to navigate through the years, Enter key to select the currently focused year and close the view. Note Following version 8.2.0, keyboard navigation will not focus days that are outside of current month, but will rather change the month in view. Multi View Calendar Multiview calendar supports all three types of selection. Use the monthsViewNumber input to set the number of displayed months, which will be shown horizontally in a flex container. There is no limit on the max value set. While using a multi view calendar, you may want to hide the days that do not belong to the current month. You are able to do it with the hideOutsideDays property. Keyboard navigation moves to next/previous months when those are in view. Styling To get started with styling the calendar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the calendar-theme and accepts some of the default theme's parameters. $custom-calendar-theme: calendar-theme( $header-background: #345779, $content-background: #fdfdfd, $header-text-color: #ffffff, $date-current-text-color: #2dabe8, $picker-arrow-color: #2dabe8, $date-selected-text-color: #fdfdfd, $date-current-bg-color: #fdfdfd, $picker-arrow-hover-color: #345779, $year-current-text-color: #2dabe8, $year-hover-text-color: #2dabe8, $month-current-text-color: #2dabe8, $month-hover-text-color: #2dabe8, $picker-text-color: #2dabe8, $picker-text-hover-color: #345779 ); Using CSS variables The last step is to pass the custom calendar theme: @include css-vars($custom-calendar-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include calendar($custom-calendar-theme); } } API References IgxCalendarComponent IgxCalendarComponent Styles DateRangeType DateRangeDescriptor Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/card.html": {
    "href": "components/card.html",
    "title": "Angular Card Component – Ignite UI for Angular",
    "keywords": "Angular Card Component Overview Angular Card represents a flexible container that has different elements like title text, descriptions, image styles, call to action buttons, links and others. In order to represent a given scenario/content in the best possible way, it offers various display options, headers, footers, as well as background colors, animations, and more. This lightweight Angular Card component is used for creating all sorts of cards, some of them can be – business cards, material flipping cards, stacked cards. Angular Card Example Below you can see a basic sample of a well-crafted Ignite UI for Angular Card with main card sections like image, title, subtitle, primary card content, container for a button. Getting Started with Ignite UI for Angular Card To get started with the Ignite UI for Angular Card component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxCardModule inside your app.module.ts file. // app.module.ts ... import { IgxCardModule } from 'igniteui-angular'; // import { IgxCardModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxCardModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxCardComponent as a standalone dependency, or use the IGX_CARD_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_CARD_DIRECTIVES } from 'igniteui-angular'; // import { IGX_CARD_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-card> <igx-card-media height=\"196px\"> <img [src]=\"https://images.unsplash.com/photo-1518235506717-e1ed3306a89b?ixlib=rb-1.2.1&auto=format&fit=crop&w=640&q=50\"> </igx-card-media> <igx-card-header> <h3 igxCardHeaderTitle>New York</h3> <h5 igxCardHeaderSubtitle>City in New York</h5> </igx-card-header> <igx-card-content> <p>New York City comprises 5 boroughs sitting where the Hudson River meets the Atlantic Ocean. At its core is Manhattan, a densely populated borough that’s among the world’s major commercial, financial and cultural centers.</p> </igx-card-content> <igx-card-actions> <button igxButton igxRipple>Read More</button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>favorite</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>share</igx-icon> </button> </igx-card-actions> </igx-card> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_CARD_DIRECTIVES] /* or imports: [IgxCardComponent, IgxCardHeaderComponent, IgxCardMediaDirective, IgxCardContentDirective, IgxCardActionsComponent, IgxCardFooterDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardThumbnailDirective, IgxButtonDirective, IgxRippleDirective] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Card module or directives imported, you can start using the igx-card component. Using the Angular Card Component Then to represent the demo card template we can add the following code. <!--card.component.html>--> <igx-card> <igx-card-media height=\"196px\"> <img [src]=\"https://images.unsplash.com/photo-1518235506717-e1ed3306a89b?ixlib=rb-1.2.1&auto=format&fit=crop&w=640&q=50\"> </igx-card-media> <igx-card-header> <h3 igxCardHeaderTitle>New York</h3> <h5 igxCardHeaderSubtitle>City in New York</h5> </igx-card-header> <igx-card-content> <p>New York City comprises 5 boroughs sitting where the Hudson River meets the Atlantic Ocean. At its core is Manhattan, a densely populated borough that’s among the world’s major commercial, financial and cultural centers.</p> </igx-card-content> <igx-card-actions> <button igxButton igxRipple>Read More</button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>favorite</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>share</igx-icon> </button> </igx-card-actions> </igx-card> You will notice a few things above. First when we want to tag an elements as a header title, like the h3 heading, we place it between the igx-card-header tags and attach the igxCardHeaderTitle directive to the element. Conversely, if we wanted to make another heading element a subtitle we would attach the igxCardHeaderSubtitle to it. Any image or video we want to show in the Angular Card, we wrap inside the igx-card-media tags. The igx-card-media allows us to size the content placed inside via the width and height attributes. In the example above we provided just height, which would leave the width to auto, thus allowing the image to stretch across the entire card surface, while maintaining the set height. You can place anything inside the igx-card-content tags. Usually text goes there. Finally, the igx-card-actions is where you'd place any actionable items, like buttons. If you use the igxButton directive on an element, it will automatically be placed correctly according to the material design spec inside the area. Media, Thumbs, and Avatars If you want to show an image or icon in the card header next to the title and subtitle, you can do it by using the igxCardThumbnail directive. Taking the card above as an example, we can edit the contents of the igx-card-header and add a igxCardThumbnail container to hold an icon: <igx-card-header> <div igxCardThumbnail> <igx-icon>place</igx-icon> </div> <h3 igxCardHeaderTitle>Title</h3> <h5 igxCardHeaderSubtitle>Subtitle</h5> </igx-card-header> The above example will show the icon alongside the title and subtitle in the card header. We also automatically detect the presence of igx-avatar or igx-card-media placed in the card header. They will appear as if they were card thumbnails. So you can do: <igx-card-header> <igx-avatar> <igx-icon>place</igx-icon> </igx-avatar> <h3 igxCardHeaderTitle>Title</h3> <h5 igxCardHeaderSubtitle>Subtitle</h5> </igx-card-header> or, even this: <igx-card-header> <igx-card-media width=\"40px\" height=\"40px\"> <img src=\"https://images.unsplash.com/photo-1518235506717-e1ed3306a89b?ixlib=rb-1.2.1&auto=format&fit=crop&w=80&q=50\"> </igx-card-media> <h3 igxCardHeaderTitle>Title</h3> <h5 igxCardHeaderSubtitle>Subtitle</h5> </igx-card-header> Outlined cards The card has a type attribute you can set to either default (set automatically if omitted), or outlined. The outlined type removes any shadows from the card, replacing them with a thin border to separate the card from the background. Angular Card Horizontal Layout By default all sections of the card (header, content, media, actions) are layed out vertically. This is nice when we have a lot of vertical space. Say we wanted to lay out all the sections in the card horizontally. We can use the horizontal attribute of the card to set its layout. Here's an example of an outlined horizonal card: <igx-card type=\"outlined\" [horizontal]=\"horizontal\"> <div class=\"h-sample-column\"> <igx-card-header> <h5 igxCardHeaderTitle>{{card.title}}</h5> <h5 igxCardHeaderSubtitle>{{card.subtitle}}</h5> <igx-card-media width=\"64px\" height=\"64px\"> <img [src]=\"card.imageUrl\"> </igx-card-media> </igx-card-header> <igx-card-content> <p>{{card.content}}</p> </igx-card-content> </div> <igx-divider [vertical]=\"horizontal\"></igx-divider> <igx-card-actions layout=\"justify\"> <button *ngFor=\"let icon of card.icons;\" igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>{{icon}}</igx-icon> </button> </igx-card-actions> </igx-card> We are using the .h-sample-column class to bundle the igx-card-header and igx-card-content together, keeping them aligned vertically, while other sections in the card align horizontally. The styles that .h-sample-column class applies are: .h-sample-column { display: flex; flex-direction: column; align-items: flex-start; flex: 1 1 0%; igx-card-header { padding-bottom: 0; } } Notice how the buttons in the igx-card-actions have now switched to a vertical layout. The igx-card-actions has an inverse layout relationship with its parent. So whenever the card's horizontal attribute is set to true the actions vertical property will be set to true and vice versa. You can set the vertical attribute of he actions area explicitly, thus overriding this default behavior. <igx-card-actions layout=\"justify\" [vertical]=\"false\"> <button *ngFor=\"let icon of card.icons;\" igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\"> <igx-icon>{{icon}}</igx-icon> </button> </igx-card-actions> If everything went well, our card should look like this: Alternative layouts You can get even more creative with the layout of the igx-card. Below is an example showing how you can create a semi-horizontal card, where we have every section of the card layed out vertically, while the igx-card-media appears alongside the vertical sections of the card. <igx-card [horizontal]=\"horizontal\"> <div igxLayout igxLayoutDir=\"column\" igxFlex igxFlexGrow=\"1\"> <igx-card-header> <igx-avatar [src]=\"card.avatarUrl\"></igx-avatar> <h5 igxCardHeaderTitle>{{card.title}}</h5> <h5 igxCardHeaderSubtitle>{{card.subtitle}}</h5> </igx-card-header> <igx-card-content> <p>{{card.content}}</p> </igx-card-content> <igx-card-actions [vertical]=\"false\"> <button *ngFor=\"let button of card.buttons;\" igxButton=\"flat\" igxRipple> {{button}} </button> </igx-card-actions> </div> <igx-card-media width=\"96px\"> <img [src]=\"card.imageUrl\"> </igx-card-media> </igx-card> Angular Card Actions The Angular Card actions area allows additional configuration to what we have already mentioned. You can reverse order of the flat buttons and the button icons using the reverse attribute. <igx-card-actions [reverse]=\"true\"> <button igxButton>Button</button> <button igxIconButton=\"flat\"> <igx-icon>star</igx-icon> </button> </igx-card-actions> Now the icon buttons will appear before the flat-style text buttons. You can also justify the buttons so that they are layed out across the entire axis, not at the opposite ends. To do that, use the layout attribute an set its value to justify, like below: <igx-card-actions layout=\"justify\"> <button igxButton>Button</button> <button igxIconButton=\"flat\"> <igx-icon>star</igx-icon> </button> </igx-card-actions> Styling To get started with styling the card, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the card-theme and accepts some parameters that style the card's items: $colorful-card: card-theme( $background: #011627, $header-text-color: #FEFEFE, $subtitle-text-color: #ECAA53, $content-text-color: #FEFEFE ); As seen, the card-theme exposes some useful parameters for basic styling of its items. Including themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include card($colorful-card); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include card($colorful-card); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($colorful-card); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($colorful-card); } Angular Card Demo Summary In this article we covered a lot of ground with the card component. First, we created a very simple card with text content only. Then added some images to make the card a bit more appealing. We used some additional Ignite UI for Angular components inside our card, avatar, buttons and icons, to enrich the experience and add some functionality. And finally, we changed the card's theme by setting some exposed theme colors, creating custom palettes and extending schemas. The card component is capable of displaying more different layouts worth exploring in the Card Demo in the beginning of this article. API and Style References For more detailed information regarding the card's API, refer to the following links: IgxCardComponent API The following built-in CSS styles helped us achieve this card layout: IgxCardComponent Styles Additional components and/or directives that were used: IgxAvatarComponent IgxIconComponent IgxButtonDirective IgxDividerDirective Styles: IgxAvatarComponent Styles IgxIconComponent Styles IgxButtonDirective Styles Theming Dependencies IgxButton Theme IgxAvatar Theme IgxIconTheme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/carousel.html": {
    "href": "components/carousel.html",
    "title": "Angular Carousel Component – Ignite UI for Angular",
    "keywords": "Angular Carousel Component Overview Ignite UI for Angular Carousel is a responsive, lightweight component that provides the most flexible way to create slideshow-like web experience for users who navigate back and forth through a collection of images with text slides, links, and other html elements. The Angular Carousel component allows you to use animations, slide transitions, and customization so you can easily tweak the interface and build Angular custom carousel. Angular Carousel Example The Angular Carousel demo you see below shows slides containing only images. We’ve enabled navigation buttons allowing users to easily move from one slide to another – going back and forth. Getting Started with Ignite UI for Angular Carousel To get started with the Ignite UI for Angular Carousel component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxCarouselModule in our app.module.ts file: Note This component requires HammerModule to be imported in the root module of the application in order for touch interactions to work as expected. // app.module.ts import { HammerModule } from '@angular/platform-browser'; import { IgxCarouselModule } from 'igniteui-angular'; // import { IgxCarouselModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., HammerModule, IgxCarouselModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxCarouselComponent as a standalone dependency, or use the IGX_CAROUSEL_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { IGX_CAROUSEL_DIRECTIVES } from 'igniteui-angular'; // import { IGX_CAROUSEL_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-carousel> <igx-slide *ngFor=\"let slide of slides\"> <div class=\"image-container\"> <img [src]=\"slide.src\" /> </div> </igx-slide> </igx-carousel> `, styleUrls: ['home.component.scss'], standalone: true, imports: [HammerModule, IGX_CAROUSEL_DIRECTIVES] /* or imports: [HammerModule, IgxCarouselComponent, IgxSlideComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Carousel module or directives imported, you can start using the igx-carousel component. Using the Angular Carousel Component The Ignite UI for Angular Carousel component can be used as a full-screen element or situated inside another component. Also, the slides may feature any valid html content inside, including other Angular components. In this section we will go through the setup of the above defined demo. Adding slides with *ngFor If we have slides with the same type of content, the easiest approach is to use *ngFor to add them in the template. Since our slides are going to contain only images, we are going to create an array of objects in the ts file and use it to populate the igx-carousel with slides: @Component({...}) export class HomeComponent { public slides = [ { src: '/assets/images/carousel/ignite-ui-angular-indigo-design.png' }, { src: '/assets/images/carousel/slider-image-chart.png' }, { src: '/assets/images/carousel/ignite-ui-angular-charts.png' } ]; } <div class=\"carousel-container\"> <igx-carousel #carousel> <igx-slide *ngFor=\"let slide of slides\"> <div class=\"image-container\"> <img [src]=\"slide.src\" /> </div> </igx-slide> </igx-carousel> </div> Angular Carousel Custom Examples Configuring IgxCarousel By default, the Carousel in Angular has its loop input property set to true ( looping occurs when the first slide comes after the last by navigating using the Next action, or when the last slide comes after the first by using the Previous action ). The looping behavior can be disabled by setting the value of the loop input to false. To keep track of each slide index, the carousel has indicators that are positioned at the bottom of the carousel by default. In order to change this behavior, we have to use the indicatorsOrientation property and assign it to top. Indicators can be disabled by adding an empty template. The carousel template may look like this: <div class=\"carousel-container\"> <igx-carousel #carousel [loop]=\"false\"> ... <!-- Adding an empty template to disable carousel's indicators --> <ng-template igxCarouselIndicator></ng-template> </igx-carousel> </div> Custom indicators To add Angular custom carousel indicators we will have to use the IgxCarouselIndicatorDirective, like this: ... <ng-template igxCarouselIndicator let-slide> <div [ngClass]=\"{'selected': slide.current === current}\"></div> </ng-template> ... Custom nav buttons To achieve this we will use the IgxCarouselPrevButtonDirective and IgxCarouselNextButtonDirective directives: ... <ng-template igxCarouselNextButton let-disabled> <button igxButton=\"fab\" igxRipple=\"white\" [disabled]=\"disabled\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </ng-template> <ng-template igxCarouselPrevButton let-disabled> <button igxButton=\"fab\" igxRipple=\"white\" [disabled]=\"disabled\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> </ng-template> ... Slide containing other components This carousel is going to contain slides with forms and images: ... <div class=\"carousel-container\"> <igx-carousel> <igx-slide> <div class=\"slide-content-wrapper\"> <img src=\"assets/images/svg/carousel/SignUp.svg\"> <form #form class=\"signInForm\"> <igx-input-group> <igx-prefix> <igx-icon>person</igx-icon> </igx-prefix> <label style=\"display: flex;\" igxLabel for=\"username\">Username</label> <input igxInput id=\"username\" type=\"text\" /> </igx-input-group> <igx-input-group> <igx-prefix> <igx-icon>lock</igx-icon> </igx-prefix> <label style=\"display: flex;\" igxLabel for=\"password\">Password</label> <input igxInput id=\"password\" type=\"password\" /> </igx-input-group> </form> <div class=\"btn\"> <button igxButton=\"contained\" type=\"submit\" (click)=\"form.reset()\">Sign In</button> </div> </div> </igx-slide> <igx-slide> <div class=\"slide-content-wrapper\"> <img src=\"assets/images/svg/carousel/Route.svg\"> <form #form2 class=\"searchForm\"> <igx-input-group> <igx-prefix> <igx-icon>search</igx-icon> </igx-prefix> <label style=\"display: flex;\" igxLabel for=\"username\">Search</label> <input igxInput id=\"search\" type=\"text\" /> </igx-input-group> </form> <div class=\"btn\"> <button igxButton=\"contained\" type=\"submit\" (click)=\"form2.reset()\">Search</button> </div> </div> </igx-slide> </igx-carousel> </div> ... Demo Angular Carousel Animations Animated slide transitions provide the end-users a nice experience when interacting with the carousel. The carousel is configured to use the slide animation by default but it also supports fade as an alternative animation. The animations are configured through the animationType input, like this: <igx-carousel animationType=\"fade\"> ... </igx-carousel> Setting none to the animationType input disables carousel's animations. Demo The demo below demonstrates the different types of animations, which the carousel supports. Navigation Transition and navigation are the most important carousel features. The navigation in the carousel can be handled by the user through navigation buttons, keyboard navigation and pan interaction on mobile devices. Pan gestures By default, the carousel can be used on any touch-enabled device. This is optional and can be changed by setting the gesturesSupport property to false. The carousel animations are fully supported on touch devices, which makes the carousel consistent with any platform and great when used in progressive web applications (PWA). Keyboard navigation To navigate to the next/previous slide, you have to use, respectfully: Arrow Right key for the next slide Arrow Left key for the previous slide To navigate to the end/start slide you have to use, respectfully: End key for the end slide Home key for the start slide Automatic transitioning The IgxCarousel can be easily configured to change the slides automatically, without any user interaction. This way you can create your own slideshow by only setting a transition interval to the interval property, which determines the amount of time in milliseconds between slides transition. Note The automatic slide transitioning is not entirely user-independent by default. Positioning the mouse pointer over a slide will interrupt the current slide transition until the mouse pointer leaves the slide area. This can be prevented by setting pause property to false. Advanced Example Let's create a fully automated carousel with looping enabled. Each slide will be synced with a list item in a list. Clicking on a list item will trigger a slide change. To achieve this goal, we have to do the following configurations to the carousel: disable gesturesSupport disable the navigation buttons disable the carousel indicators disable the pause on user interaction with the slide add transition interval Our carousel will look like this in the template: ... <div class=\"carousel-wrapper\"> <igx-carousel [navigation]=\"false\" [pause]=\"false\" animationType=\"fade\" [interval]=\"2000\" [gesturesSupport]=\"false\"> <div class=\"slides-wrapper\"> <igx-slide *ngFor=\"let item of slides\"> <!-- Slides content goes here --> </igx-slide> </div> <!-- Adding an empty template to disable carousel's indicators --> <ng-template igxCarouselIndicator></ng-template> </igx-carousel> </div> ... We are ready with the carousel configuration. Now we need only to add a list component and sync the both components: adding IgxList: ... <div class=\"list-wrapper\"> <igx-list> <!-- Adding disabled classes when the list item index does not match the current slide index--> <igx-list-item *ngFor=\"let item of slides; let i=index\" [ngClass]=\"{'disabled': i !== currentIndex }\" > <!-- List item content goes here --> </igx-list-item> </igx-list> </div> ... syncing the components by hooking up on carousel's slideChanged and list's itemClicked events: Note As of v15.1.0 onSlideChanged was renamed to slideChanged. Using ng update will automatically migrate your code prior to use the new event name. public ngOnInit() { this.list.itemClicked.subscribe((args: IListItemClickEventArgs) => { this.currentIndex = args.item.index; this.carousel.select(this.carousel.get(this.currentIndex)); }); this.carousel.slideChanged.subscribe((args: ISlideEventArgs) => { this.currentIndex = args.slide.index; }); } These configurions will have the following result: Accessibility WAI-ARIA Roles, States, and Properties The Carousel base element role is region - section containing content that is relevant to specific purpose and users will likely want to be able to navigate easily. Carousel indicators are with role tab - grouping label providing a mechanism for selecting the tab content that is to be rendered to the user The element that serves as the container for the set of tabs (carousel indicators) role is set to tablist. Each slide element is set with role tabpanel. The element that serves as the container for the set of igx-slides is set with aria-live=\"polite\". Both options are off: if the carousel is automatically rotating. polite: if the carousel is NOT automatically rotating. ARIA support Carousel component Attributes: aria-roledescription set to 'carousel'. aria-selected- set to true or false based on the active slide. aria-controls - set a slide index whose content is controlled by the current element. aria-live - used to set the priority with which screen reader should treat updates to live regions - the possible settings are: off and polite. The default setting is polite. When the interval option set, the aria-live attribute would be set to off. aria-label slide based. aria-label (buttons) aria-label - for previous slide. aria-label - for next slide. Slide component Roles: attr.role=\"tabpanel\" - container for the resources associated with a tab, where each tab is contained in a tablist. Attributes: id - follows the pattern \"panel-${this.index}\" aria-labelledby follows the pattern \"tab-${this.index}-${this.total}\" aria-selected set active slide. Indicates the current selected state of a particular slide element. API References IgxCarouselComponent IgxCarouselComponent Styles IgxSlideComponent IgxListComponent IgxListItemComponent Theming Dependencies IgxIcon Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/charts/chart-api.html": {
    "href": "components/charts/chart-api.html",
    "title": "Angular Chart API | Data Visualization Tools | Infragistics",
    "keywords": "Angular Chart API The Ignite UI for Angular charts provide simple and easy to use APIs to plot your data in IgxCategoryChartComponent, IgxFinancialChartComponent, IgxDataChartComponent, IgxDoughnutChartComponent, IgxPieChartComponent, and IgxSparklineComponent UI elements. Angular Category Chart API Members The Angular IgxCategoryChartComponent has the following API members: Chart Properties Axis Properties Series Properties - chartType - excludedProperties - includedProperties - isHorizontalZoomEnabled - isVerticalZoomEnabled - crosshairsDisplayMode - transitionInMode - highlightingBehavior - highlightingMode - trendLineType - xAxisInterval - xAxisLabelLocation - xAxisGap - xAxisOverlap - xAxisTitle - yAxisInterval - yAxisLabelLocation - yAxisTitle - yAxisMinimumValue - yAxisMaximumValue - brushes - outlines - markerBrushes - markerOutlines - markerTypes - toolTipType Angular Financial Chart API Members The Angular IgxFinancialChartComponent has the following API members: Chart Properties Axis Properties Series Properties - chartType - excludedProperties - includedProperties - isHorizontalZoomEnabled - isVerticalZoomEnabled - toolTipType - crosshairsDisplayMode - highlightingBehavior - highlightingMode - trendLineType - xAxisInterval - xAxisLabelLocation - xAxisTitle - yAxisInterval - yAxisLabelLocation - yAxisTitle - yAxisMinimumValue - yAxisMaximumValue - yAxisMode - xAxisMode - brushes - outlines - markerBrushes - markerOutlines - markerTypes - indicatorTypes - volumeType - zoomSliderType Angular Data Chart API Members The Angular IgxDataChartComponent has the following API members: Chart Properties Axis Classes - chartTitle - subtitle - isHorizontalZoomEnabled - isVerticalZoomEnabled - brushes - outlines - markerBrushes - markerOutlines - PlotAreaMargin - IgxAxisComponent is base class for all axis types - IgxCategoryXAxisComponent used with Category, Stacked, and Financial Series - IgxCategoryYAxisComponent used with Category, Stacked Series - IgxCategoryAngleAxisComponent used with Radial Series - IgxNumericXAxisComponent used with Scatter and Stacked Bar Series - IgxNumericYAxisComponent used with Category, Stacked, and Financial Series - IgxNumericAngleAxisComponent used with Polar Series - IgxNumericRadiusAxisComponent used with Polar and Radial Series - IgxTimeXAxisComponent used with Category and Financial Series The Angular IgxDataChartComponent can use the following type of series that inherit from IgxSeriesComponent: Category Series Stacked Series - IgxAreaSeriesComponent - IgxBarSeriesComponent - IgxColumnSeriesComponent - IgxLineSeriesComponent - IgxPointSeriesComponent - IgxSplineSeriesComponent - IgxSplineAreaSeriesComponent - IgxStepLineSeriesComponent - IgxStepAreaSeriesComponent - IgxRangeAreaSeriesComponent - IgxRangeColumnSeriesComponent - IgxWaterfallSeriesComponent - IgxStackedAreaSeriesComponent - IgxStackedBarSeriesComponent - IgxStackedColumnSeriesComponent - IgxStackedLineSeriesComponent - IgxStackedSplineSeriesComponent - IgxStacked100AreaSeriesComponent - IgxStacked100BarSeriesComponent - IgxStacked100ColumnSeriesComponent - IgxStacked100LineSeriesComponent - IgxStacked100SplineSeriesComponent Scatter Series Financial Series - IgxBubbleSeriesComponent - IgxHighDensityScatterSeriesComponent - IgxScatterSeriesComponent - IgxScatterLineSeriesComponent - IgxScatterSplineSeriesComponent - IgxScatterAreaSeriesComponent - IgxScatterContourSeriesComponent - IgxScatterPolylineSeriesComponent - IgxScatterPolygonSeriesComponent - IgxFinancialPriceSeriesComponent - IgxBollingerBandsOverlayComponent - IgxForceIndexIndicatorComponent - IgxMedianPriceIndicatorComponent - IgxMassIndexIndicatorComponent - IgxRelativeStrengthIndexIndicatorComponent - IgxStandardDeviationIndicatorComponent - IgxTypicalPriceIndicatorComponent - IgxWeightedCloseIndicatorComponent Radial Series Polar Series - IgxRadialLineSeriesComponent - IgxRadialAreaSeriesComponent - IgxRadialPieSeriesComponent - IgxRadialColumnSeriesComponent - IgxPolarScatterSeriesComponent - IgxPolarLineSeriesComponent - IgxPolarAreaSeriesComponent - IgxPolarSplineSeriesComponent - IgxPolarSplineAreaSeriesComponent Angular Data Legend API Members The Angular IgxDataLegendComponent has the following API members: includedColumns excludedColumns includedSeries excludedSeries valueFormatAbbreviation valueFormatMode valueFormatCulture valueFormatMinFractions valueFormatMaxFractions valueTextColor titleTextColor labelTextColor unitsTextColor summaryType headerTextColor badgeShape Angular Donut Chart API Members The Angular IgxDoughnutChartComponent has the following API members: allowSliceExplosion allowSliceSelection innerExtent SliceClick Angular Pie Chart API Members The Angular IgxPieChartComponent has the following API members: legendItemBadgeTemplate legendItemTemplate legendLabelMemberPath othersCategoryThreshold othersCategoryType selectionMode Angular Sparkline Chart API Members The Angular IgxSparklineComponent has the following API members: displayNormalRangeInFront displayType lowMarkerBrush lowMarkerSize lowMarkerVisibility normalRangeFill unknownValuePlotting Additional Resources You can find more information about charts in these topics: Chart Overview Chart Features View page on GitHub"
  },
  "components/charts/chart-features.html": {
    "href": "components/charts/chart-features.html",
    "title": "Angular Chart Features | Data Visualization | Infragistics",
    "keywords": "Angular Chart Features The Ignite UI for Angular Charts allow you to display many different features to portray the full data story to be told with your chart. Each of these features are fully customizable, and can be styled to suit your design needs - allowing you full control. Interactions such as highlighting and annotations allow you to call out important data details allowing for a deeper data analysis within your chart. The Angular Charts offer the following chart features: Axis Modify or customize all aspects of both the X-Axis and Y-Axis using the different axis properties. You can display gridlines, customize the style of tickmarks, change axis titles, and even modify axis locations and crossing values. You can learn more about customizations of the Angular chart's Axis Gridlines, Axis Layouts, and Axis Options topic. Annotations These additional layers are on top of the chart which are mouse / touch dependent. Used individually or combined, they provide powerful interactions that help to highlight certain values within the chart. You can learn more about this feature in the Chart Annotations topic. Animations Animate your chart as it loads a new data source by enabling animations. These are customizable by setting different types of animations and the speed at which those animations take place. You can learn more about this feature in the Chart Animations topic. Highlighting Bring focus to visuals such as lines, columns, or markers by highlighting them as the mouse hovers over the data items. This features is enabled on all chart types. You can learn more about this feature in the Chart Highlighting topic. Markers Identify data points quickly, even if the value falls between major gridlines with the use of markers on the chart series. These are fully customizable in style, color, and shape. You can learn more about this feature in the Chart Markers topic. Navigation You can navigate the chart by zooming and panning with the mouse, keyboard, and touch interactions. You can learn more about this feature in the Chart Navigation topic. Overlays Overlays allows you to annotate important values and thresholds by plotting horizontal or vertical lines in charts. You can learn more about this feature in the Chart Overlays topic. Performance Angular charts are optimized for high performance of rendering millions of data points and updating them every few milliseconds. However, there are several chart features that affect performance of the charts and they should be considered when optimizing performance in your application. You can learn more about this feature in the Chart Performance topic. Tooltips Display all information relevant to the particular series type via Tooltips. There are different tooltips that can be enabled, such as Item-level and Category-level tooltips. You can learn more about this feature in the Chart Tooltips topic. Trendlines Use trendlines to identify a trend or find patterns in your data. There are many different trendlines supported by the Angular chart, such as CubicFit and LinearFit. You can learn more about this feature in the Chart Trendlines topic. API References IgxCategoryChartComponent IgxDataChartComponent IgxFinancialChartComponent View page on GitHub"
  },
  "components/charts/chart-overview.html": {
    "href": "components/charts/chart-overview.html",
    "title": "Angular Charts & Graphs Library | Ignite UI for Angular",
    "keywords": "Angular Charts & Graphs Overview Ignite UI for Angular Charts & Graphs is an extensive library of data visualizations that enable stunning, interactive charts and dashboards for your web and mobile apps. Built for speed and beauty, designed to work on every modern browser, and with complete touch and interactivity, you can quickly and easily build responsive visuals into your next app on any device. The Ignite UI for Angular Charts support over 65 types of series and combinations that let you visualize any type of data, including Category Series, Financial Series, Polar Series, Radial Series, Range Series, Scatter Series, Shape Series, and Geospatial Series. No matter the type of comparison you are doing, or what type of data story you are trying to tell, you can represent your data in any of these ways: Change Over Time Comparison Correlation Distribution Geospatial Overview + Detail Part to Whole Ranking Power your most demanding visualizations with Infragistics Angular charting! Angular Chart and Graph Types The Angular product has over 65 different chart and graph types for any scenario – from a single chart display to an interactive dashboard. You can create Angular charts like Pie, Bar, Area, Line, Point, Stacked, Donut, Scatter, Gauge, Polar, Treemap, Stock, Financial, Geospatial Maps and more for your mobile or web apps. The benefit of our Angular chart vs. others is full support for features like: Responsive Web Design built in Interactive Panning and Zooming with Mouse, Keyboard and Touch Full Control of Chart Animation Chart Drill-Down Events Real-Time Streaming Support High-Volume (Millions of Data Points) Support Trends Lines and other Data Analysis features Built with a modular design of axis, markers, series, legend, and annotation layers, the Angular chart makes it easy to design a render any type of data story. Build a simple chart with a single data series, or build more complex data stories with multiple series of data, with multiple axis in composite views. Category and Financial Chart vs. Data Chart The Angular Category and Financial Chart is what we refer to as our domain specific charts. It's a wrapper around Angular Data Chart that assumes your domain is a category, or financial price series. Choosing these specific domain charts allows to simplify the API and draw a lot of interfaces about the data to automatically configure the chart scenario, all without needing to explicitly define attributes such as axes, series, and annotations. In contrast, the data chart is very explicit and every critical part of the chart needs to be defined. Domain charts are using a data chart at its core; so the same performance optimizations apply to both. The difference lies in whether they are trying to make things very easy to specify for the developer, or to be as flexible as possible. Angular Data Chart is more verbose, unlocking all of our charting capabilities you need, allowing you to mix and match of any number of series, axes or annotation for example. For the category and financial charts, there might be a situation that cannot be easily done that the data chart is more suited for, such as a series with a scatter series with a numeric x axis. It can be difficult to know which chart to pick at first. It's crucial to understand the type of series and how many additional features you want to present. For a more light-weight basic category or financial series, we recommend using one of the domain charts. For more advances scenarios we recommend using Angular Data Chart, such as presenting something other than what is covered by the category chart's chartType property such as a stacked or scatter series, or numeric or time-based data. It's worth noting that the Angular Financial Chart covers only column, OHLC bar, candlestick, and line series types. We make Angular Category and Financial Chart easier to use, the good news you can always switch to data chart in the future. Angular Bar Chart The Angular Bar Chart, or Bar Graph is among the most common category chart types used to quickly compare frequency, count, total, or average of data in different categories with data encoded by horizontal bars of equal width and differing lengths. They are ideal for showing variations in the value of an item over time, data distribution, sorted data ranking (high to low, worst to best). Data is represented using a collection of rectangles that extend from the left to right of the chart towards the values of data points. Learn more about our bar chart Angular Pie Chart The Angular Pie Chart, or Pie Graph, is a very common part-to-whole chart type. Part-to-whole charts show how categories (parts) of a data set add up to a total (whole) value. Categories are shown in proportion to other categories based on their value percentage to the total value being analyzed. A pie chart renders data values as sections in a circular, or pie-shaped graph. Each section, or pie slice, has an arc length proportional to its underlying data value. The total values represented by the pie slices represent a whole value, like 100 or 100%. Pie charts are perfect for small data sets and are easy to read at a quick glance. Learn more about our pie chart Angular Line Chart The Angular Line Chart, or Line Graph is a type of category line graph shows the continuous data values represented by points connected by straight line segments of one or more quantities over a period time for showing trends and performing comparative analysis. The Y-Axis (labels on left side) show a numeric value, while the X-Axis (bottom labels) are showing a time-series or comparison category. You can include one or more data sets to compare, which would render as multiple lines in the chart. Learn more about our line chart Angular Donut Chart The Angular Donut Chart or Donut Graph, is a variant of a Pie Chart, proportionally illustrating the occurrences of a variable in a circle to represents parts of a whole. The donut chart has a circular opening at the center of the pie chart, where a title or category explanation can be displayed. Donut charts can support multiple concentric rings, with built-in support for visualizing hierarchical data. Learn more about our Donut chart Angular Area Chart The Angular Area Chart is rendered using a collection of points connected by straight line segments with the area below the line filled in. Values are represented on the y-axis (labels on the left side) and categories are displayed on the x-axis (bottom labels). Area Charts emphasize the amount of change over a period of time or compare multiple items as well as the relationship of parts of a whole by displaying the total of the plotted values. Learn more about our area chart Angular Sparkline Chart The Angular Sparkline Chart, or Sparkline Graph is a type of category graph intended for rendering within a small-scale layout such as within a grid cell, or anywhere a word-sized visualization is needed to tell a data story. Like other Angular chart types, the Sparkline Chart has several visual elements and corresponding features that can be configured and customized such as the chart type, markers, ranges, trendlines, unknown value plotting, and tooltips. Sparkline charts can render as a Line Chart, Area Chart, Column Chart or Win / Loss Chart. The difference between the full-sized chart equivalent to the Spark-chart, is the Y-Axis (left side labels) and X-Axis (bottom labels) are not visible. Learn more about our sparkline chart. Angular Bubble Chart The Angular Bubble Chart, or Bubble Graph, is used to show data comprising of three numeric values. Two of the values are plotted as an intersecting point using a Cartesian (X, Y) coordinate system, and the third value is rendered as the diameter size of the point. This gives the Bubble Chart its name - a visualization of varying sized bubbles along the X and Y coordinates of the plot. The Angular Bubble Chart is used to show relationships of data correlations with the data value differences rendered by size. You can also use a fourth data dimension, typically color, to further differentiate the values in your Bubble chart. Learn more about our bubble chart. Angular Financial / Stock Chart The Angular Financial or Stock Chart, is a composite visualization that renders stock data and financial data in a time-series chart that includes interactive visual elements in a toolbar like day / week / month filters, chart type selection, volume type selection, indicators selection and trends lines selection. Designed for customization, the Angular Stock Chart can be customized in any way to give an easier visualization and interpretation of your data. The financial chart renders the date-time data along the X-Axis (bottom labels) and shows fields like Open, High, Low and Close volumes. The type of chart to render the Time-Series data can be Bar, Candle, Column, or Line. Learn more about our stock chart. Angular Column Chart The Angular Column Chart, or Column Graph is among the most common category chart types used to quickly compare frequency, count, total, or average of data in different categories with data encoded by vertical bars of equal width and differing lengths. They are ideal for showing variations in the value of an item over time, data distribution, sorted data ranking (high to low, worst to best). Data is represented using a collection of rectangles that extend from the top to bottom of the chart towards the values of data points. Learn more about our column chart. Angular Composite Chart The Angular Composite Chart, also called a Combo Chart, is visualization that combines different types of chart types in the same plot area. It is very useful when presenting two data series that have a very different scale and might be expressed in different units. The most common example is dollars on one axis and percentage on the other axis. Learn more about our composite chart. Angular Polar Chart The Angular Polar Area Chart or Polar Graph belongs to a group of polar charts and has a shape of a filled polygon which vertices or corners are located at the polar (angle/radius) coordinates of data points. The Polar Area Chart uses the same concepts of data plotting as the Scatter Chart but wraps data points around a circle rather than stretching them horizontally. Like with other series types, multiple Polar Area Charts can be plotted in the same data chart and they can be overlaid on each other to show differences and similarities between data sets. Learn more about our polar chart. Angular Scatter Chart The Angular Scatter Chart, or Scatter Graph, is used to show the relationship between two values using a Cartesian (X, Y) coordinate system to plot data. Each data point is rendered as the intersecting point of the data value on the X and Y Axis. Scatter charts draw attention to uneven intervals or clusters of data. They can highlight the deviation of collected data from predicted results and they are often used to plot scientific and statistical data. The Angular Scatter chart organizes and plots data chronologically (even if the data is not in chronological order before binding) on X-Axis and Y-Axis. Learn more about our scatter chart. Angular Shape Chart The Angular Shape Charts is a group of chart that take array of shapes (array or arrays of X/Y points) and render them as collection of polygons or polylines in Cartesian (x, y) coordinate system. They are often used highlight regions in scientific data or they can be used to plot diagrams, blueprints, or even floor plan of buildings. Learn more about our shape chart. Angular Spline Chart The Angular Spline Chart, or Spline Graph is a type of category line graph shows the continuous data values represented by points connected by smooth line segments of one or more quantities over a period time for showing trends and performing comparative analysis. The Y-Axis (labels on left side) show a numeric value, while the X-Axis (bottom labels) are showing a time-series or comparison category. You can include one or more data sets to compare, which would render as multiple lines in the chart. The Angular Spline chart is identical to the Angular Spline chart, the only different being the line chart is points connected by straight lines, and the spline chart points are connected by smooth curves. Learn more about our spline chart. Angular Step Chart The Angular Step Chart, or Step Graph, is a category charts that renders a collection of data points connected by continuous vertical and horizontal lines forming a step-like progression. Values are represented on the Y-Axis (left labels) and categories are displayed on the X-Axis (bottom labels). The Angular Step Line chart emphasizes the amount of change over a period of time or compares multiple items. The Angular Step Line chart is identical to the Angular Step Area Chart in all aspects except that the area below the step lines is not filled in. Learn more about our step chart Angular Treemap The Ignite UI for Angular Treemap displays hierarchical (tree-structured) data as a set of nested nodes. Each branch of the tree is given a treemap node, which is then tiled with smaller nodes representing sub-branches. Each node's rectangle has an area proportional to a specified dimension on the data. Often the nodes are colored to show a separate dimension of the data. Learn more about our treemaps. Angular Charts Key Features Show how your data changes over time with our built-in Time Axis. We’ll dynamically change time scales and label formats, as you interact with your chart. We’ve included a complete Financial Chart with all of the features you’ve come to expect in your financial charts, like Yahoo Finance or Google Finance. Dynamic Charts Visualize your data by creating new Composite Chart and overlapping multiple series in single chart. In the Chart, you can display and overlap multiple chart columns to create stacked columns. Custom Tooltips Visualize your data by creating new composite views and overlapping multiple series in single chart. In the Chart, you can create Custom Tooltips with images, data binding, and even combine tooltips of multiple series into single tooltip. High-Performance, Real-Time Charting Display thousands of data points with milliseconds-level updates in real time with live, streaming data. You will experience no lag, no screen-flicker, and no visual delays, even as you interact with the chart on a touch-device. For a demo, refer to the Chart with High-Frequency topic. High-Volume Data Handling Optimize Chart Performance to render millions of data points while the chart keeps providing smooth performance when end-users tries zooming in/out or navigating chart content. For a demo, refer to the Chart with High-Volume topic. Modular Design The Angular chart is designed for modularity. Only features that are needed are part of your deployment, so you get the smallest possible footprint in your rendered pages. Smart Data Binding Let us choose the chart type. Our smart Data Adapter automatically chooses the best chart type for the data. All you do is set the data source and we do the rest. Trendlines Angular Charts support all Trendlines you’ll ever need, including linear (x), quadratic (x2), cubic (x3), quartic (x4), quintic (x5), logarithmic (log x), exponential (ex), and power law (axk + o(xk)) trend lines. Interactive Panning and Zooming Use single or multi-touch, keyboard, zoom bar, mouse wheel, drag-select for any rectangular region with the mouse to zoom in for close-up look at data points, scroll data history, or pan data regions. Markers, Tooltips, and Templates Use one of 10 Marker Types or create your own Marker Template to highlight data or use simple Tooltips or multi-axis and multi-series chart with Custom Tooltips to give more context and meaning to your data. But Wait, There’s More! If you are considering any other Angular Charts on the market, here are a few things to think about: We include over 65 Angular chart types and combination charts, with the simplest configuration on the market with our smart data adapter. Our charts are optimized on all platforms including Angular, Blazor, jQuery / JavaScript, React, UNO, UWP, WPF, Windows Forms, WebComponents, WinUI, and Xamarin. They support the same API and same features on every platform. Our stock chart and financial charting gives you everything you need for a Yahoo Finance or Google Finance-like experience – all with a single line of code. We test against everyone elses performance. Everyone says they are fast and can handle lots of data, but we can prove it. See for yourself how we handle high-volume data and real-time data streaming. We are here 24x5. Infragistics has global support that is always online. For North America, Asia Pacific, Middle East, and Europe, we are on the clock when you are! We have many more UI controls in Angular besides the Charts. We offer a complete Angular solution to build your applications! Ignite UI for Angular is built on Angular for the Angular developer, with zero 3rd party dependencies. We are 100% optimized for Angular. We offer the world’s first, and only, end-to-end comprehensive design to code platform for UX Designers, Visual Designers, and Developers that will generate pixel-perfect Angular controls from Sketch designs. With Indigo.Design, everything you craft in Sketch from our Indigo Design System matches to our Ignite UI for Angular controls. API References All types of chart types mentioned in this topic are implemented in these API components: IgxCategoryChartComponent IgxDataChartComponent IgxFinancialChartComponent IgxTreemapComponent View page on GitHub"
  },
  "components/charts/features/chart-animations.html": {
    "href": "components/charts/features/chart-animations.html",
    "title": "Angular Chart Animations | Data Visualization | Infragistics",
    "keywords": "Angular Chart Animations Animations allows you to ease-in the series as it loads a new data source. The available animation differs depending on the type of series involved. For example, the column series animates by rising from the x-axis, a line series animates by drawing from the origin of y-axis. Animations are disabled in the Ignite UI for Angular Charts, but they can be enabled by setting the isTransitionInEnabled property to true. From there, you can set the transitionInDuration property to determine how long your animation should take to complete and the transitionInMode to determine the type of animation that takes place. Angular Chart Animation Example The following example depicts a Line Chart with an animation set to the default transitionInMode - \"Auto.\" The drop-down and slider at the top in this example will allow you to modify the transitionInMode and transitionInDuration, respectively, so that you can see what the different supported animations look like at different speeds. Additional Resources You can find more information about related chart features in these topics: Chart Annotations Chart Highlighting Chart Tooltips API References The following is a list of API members mentioned in the above sections: IgxCategoryChartComponent isTransitionInEnabled transitionInDuration transitionInMode View page on GitHub"
  },
  "components/charts/features/chart-annotations.html": {
    "href": "components/charts/features/chart-annotations.html",
    "title": "Angular Chart Annotations | Data Visualization | Infragistics",
    "keywords": "Angular Chart Annotations The Angular chart's hover interactions and annotations are implemented through hover interaction layers, which are series that are added to the series collection. These layers are dependent on the cursor position. Each of these annotation layers provides a different hover interaction that may be used individually or combined with others to provide powerful hover interactions. Angular Annotations Example The following example demonstrates the annotation layers that are available on the Angular chart. Click on the checkboxes to turn each layer on and off. Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. Angular Crosshair Layer The IgxCrosshairLayerComponent renders as crossing lines intersecting at the actual value of every series that they are configured to target with each series rendering a separate set of lines. Crosshair types include: Horizontal Vertical Both The chart's crosshairs can also be configured to snap to data points by setting the crosshairsSnapToData property to true, otherwise the crosshairs will be interpolated between data points. Annotations can also be enabled to display the crosshair's value along the axis. You can configure the crosshair layer so that the layer will only display on one specific series, as by default they will target all series in the chart control. To achieve this, set the targetSeries property. By default, the color of the crosshair lines is a lighter color than the series that it is interacting with. However, this default setting can be overridden so that you can select a color that will be used for the crosshair lines. This is done by setting the brush property of the Crosshair Layer. The following example shows how to configure the crosshair layer but targeting a single series, setting the type to vertical and styling the brush color. Angular Final Value Layer The IgxFinalValueLayerComponent of the IgxDataChartComponent control provides a quick view along the axis of the ending value displayed in a series. You can configure this annotation to target a specific series if you want to have multiple final value layers present with different configurations. This can be done be setting the targetSeries property. You can also customize this annotation by setting the following properties: axisAnnotationBackground: This property is used to choose the brush for the annotation's background color. The default is to use the series brush. axisAnnotationTextColor: This property is used to choose the brush for the annotation's text color. axisAnnotationOutline: This property is used to choose the brush for the annotation's outline color. The following example demonstrates how to style the final value layer annotation by setting the properties listed above. <igx-category-chart [dataSource]=\"data\" finalValueAnnotationsVisible=\"true\"> </igx-category-chart> Angular Callout Layer The IgxCalloutLayerComponent displays annotations from existing or new data on the chart control. The annotations appear next to the given data values in the data source. Use the callout annotations to display additional information, such as notes or specific details about data points, that you would like to point out to your users. You can configure the callouts to target a specific series if you want to have multiple callout layers present with different configurations. This can be done by setting the targetSeries property. You can also customize this annotation by setting the following properties: calloutLeaderBrush: This property is used to choose the brush for the leader lines for the callouts for the layer. calloutOutline: This property is used to choose the brush for the annotation's outline color. calloutBackground: This property is used to choose the brush for the annotation's background color. The default is to use the series brush. calloutTextColor: This property is used to choose the brush for the annotation's text color. calloutStrokeThickness: This property is used to choose the thickness for the callout backing. calloutCornerRadius: This property is used to curve the corners of the callouts. allowedPositions: This property is used to choose which positions that the callout layer is allowed to use. eg. top, bottom The following example demonstrates how to style the callout layer annotations by setting the properties listed above: <igx-category-chart [dataSource]=\"data\" calloutsVisible=\"true\" [calloutsDataSource]=\"calloutData\" calloutsXMemberPath=\"index\" calloutsYMemberPath=\"value\" calloutsLabelMemberPath=\"info\"> </igx-category-chart> API References The following is a list of API members mentioned in the above sections: crosshairsSnapToData IgxCategoryChartComponent View page on GitHub"
  },
  "components/charts/features/chart-axis-gridlines.html": {
    "href": "components/charts/features/chart-axis-gridlines.html",
    "title": "Angular Axis Gridlines | Data Visualization | Infragistics",
    "keywords": "Angular Axis Gridlines All Ignite UI for Angular charts include built-in capability to modify appearance of axis lines as well as frequency of major/minor gridlines and tickmarks that are rendered on the X-Axis and Y-Axis. [!Note] the following examples can be applied to IgxCategoryChartComponent as well as IgxFinancialChartComponent controls. Axis major gridlines are long lines that extend horizontally along the Y-Axis or vertically along the X-Axis from locations of axis labels, and they render through the plot area of the chart. Axis minor gridlines are lines that render between axis major gridlines. Axis tickmarks are displayed along all horizontal and vertical axes at each label at all major line positions of the Angular chart. Angular Axis Gridlines Example This example shows how configure the axis gridline to display major and minor gridlines at specified intervals: Angular Axis Gridlines Properties Setting the axis interval property specifies how often major gridlines and axis labels are rendered on an axis. Similarly, the axis minor interval property specifies how frequent minor gridlines are rendered on an axis. In order to display minor gridlines that correspond to minor interval, you need to set xAxisMinorStroke and xAxisMinorStrokeThickness properties on the axis. This is because minor gridlines do not have a default color or thickness and they will not be displayed without first assigning them. You can customize how the gridlines are displayed in your Angular chart by setting the following properties: Axis Visuals Type Property Names Description Major Stroke Color string xAxisMajorStroke yAxisMajorStroke These properties set the color of axis major gridlines. Minor Stroke Color string xAxisMinorStroke yAxisMinorStroke These properties set the color of axis minor gridlines. Major Stroke Thickness number xAxisMajorStrokeThickness yAxisMajorStrokeThickness These properties set the thickness in pixels of the axis major gridlines. Minor Stroke Thickness number xAxisMinorStrokeThickness yAxisMinorStrokeThickness These properties set the thickness in pixels of the axis minor gridlines. Major Interval number xAxisInterval yAxisInterval These properties set interval between axis major gridlines and labels. Minor Interval number xAxisMinorInterval yAxisMinorInterval These properties set interval between axis minor gridlines, if used. Axis Line Stroke Color string xAxisStroke yAxisStroke These properties set the color of an axis line. Axis Stroke Thickness number xAxisStrokeThickness yAxisStrokeThickness These properties set the thickness in pixels of an axis line. Regarding the Major and Minor Interval in the table above, it is important to note that the major interval for axis labels will also be set by this value, displaying one label at the point on the axis associated with the interval. The minor interval gridlines are always rendered between the major gridlines, and as such, the minor interval properties should always be set to something much smaller (usually 2-5 times smaller) than the value of the major Interval properties. On category axes, the intervals are represented as an index between first item and last category item. Generally, this value should equal to 10-20% of total numbers of category items for the major Interval so that all axis labels fit on axis so that they are not clipped by other axis labels. For minor intervals, this is represented as a fraction of the major interval properties. This value generally should equal between 0.25 and 0.5. On numeric axes, the interval values are represented as a double between axis minimum value and axis maximum value. By default, numeric axes will automatically calculate and find a nice and round interval based on axis minimum values and maximum value. On date time axes, this value is represented as time span between axis minimum value and axis maximum value. The following example demonstrates how to customize the gridlines by setting the properties above: The axes of the IgxDataChartComponent also have the ability to place a dash array on the major and minor gridlines by utilizing the majorStrokeDashArray and minorStrokeDashArray properties, respectively. The actual axis line can be dashed as well by setting the strokeDashArray property of the corresponding axis. These properties take an array of numbers that will describe the length of the dashes for the corresponding grid lines. The following example demonstrates a IgxDataChartComponent with the above dash array properties set: Angular Axis Tickmarks Example Axis tick marks are enabled by setting the xAxisTickLength and yAxisTickLength properties to a value greater than 0. These properties specifies the length of the line segments forming the tick marks. Tick marks are always extend from the axis line and point to the direction of the labels. Labels are offset by the value of the length of tickmarks to avoid overlapping. For example, with the yAxisTickLength property is set to 5, axis labels will be shifted left by that amount. The following example demonstrates how to customize the tickmarks by setting the properties above: Angular Axis Tickmarks Properties You can customize how the axis tickmarks are displayed in our Angular chats by setting the following properties: Axis Visuals Type Property Names Description Tick Stroke Color string xAxisTickStroke yAxisTickStroke These properties set the color of the tickmarks. Tick Stroke Thickness number xAxisTickStrokeThickness yAxisTickStrokeThickness These properties set the thickness of the axis tick marks. Tick Stroke Length number xAxisTickLength yAxisTickLength These properties set the length of the axis tick marks. Additional Resources You can find more information about related chart features in these topics: Axis Layout Axis Options API References The following is a list of API members mentioned in the above sections: IgxDataChartComponent IgxCategoryChartComponent or IgxFinancialChartComponent Axes ➔ IgxNumericXAxisComponent ➔ interval xAxisInterval (Major Interval) Axes ➔ IgxNumericYAxisComponent ➔ interval yAxisInterval (Major Interval) Axes ➔ IgxNumericXAxisComponent ➔ minorInterval xAxisMinorInterval Axes ➔ IgxNumericYAxisComponent ➔ minorInterval yAxisMinorInterval Axes ➔ IgxNumericXAxisComponent ➔ majorStroke xAxisMajorStroke Axes ➔ IgxNumericYAxisComponent ➔ majorStroke yAxisMajorStroke Axes ➔ IgxNumericXAxisComponent ➔ majorStrokeThickness xAxisMajorStrokeThickness Axes ➔ IgxNumericYAxisComponent ➔ majorStrokeThickness yAxisMajorStrokeThickness Axes ➔ IgxNumericXAxisComponent ➔ minorStrokeThickness xAxisMinorStrokeThickness Axes ➔ IgxNumericYAxisComponent ➔ minorStrokeThickness yAxisMinorStrokeThickness Axes ➔ IgxNumericXAxisComponent ➔ strokeThickness xAxisStrokeThickness Axes ➔ IgxNumericYAxisComponent ➔ strokeThickness yAxisStrokeThickness Axes ➔ IgxNumericXAxisComponent ➔ stroke xAxisStroke (Axis Line Color) Axes ➔ IgxNumericYAxisComponent ➔ stroke yAxisStroke (Axis Line Color) Axes ➔ IgxNumericXAxisComponent ➔ tickLength xAxisTickLength Axes ➔ IgxNumericYAxisComponent ➔ tickLength yAxisTickLength Axes ➔ IgxNumericXAxisComponent ➔ tickStroke xAxisTickStroke Axes ➔ IgxNumericYAxisComponent ➔ tickStroke yAxisTickStroke Axes ➔ IgxNumericXAxisComponent ➔ strip xAxisStrip (Space between Major Gridlines) Axes ➔ IgxNumericYAxisComponent ➔ strip yAxisStrip (Space between Major Gridlines) View page on GitHub"
  },
  "components/charts/features/chart-axis-layouts.html": {
    "href": "components/charts/features/chart-axis-layouts.html",
    "title": "Angular Axis Layouts | Data Visualization | Infragistics",
    "keywords": "Angular Axis Layouts All Ignite UI for Angular charts include options to configure many axis layout options such as location as well as having the ability to share axis between series or have multiple axes in the same chart. These features are demonstrated in the examples given below. [!Note] the following examples can be applied to IgxCategoryChartComponent as well as IgxFinancialChartComponent controls. Axis Locations Example For all axes, you can specify axis location in relationship to chart plot area. The xAxisLabelLocation property of the Angular charts, allows you to position x-axis line and its labels on above or below plot area. Similarly, you can use the yAxisLabelLocation property to position y-axis on left side or right side of plot area. The following example depicts the amount of renewable electricity produced since 2009, represented by a Line Chart. There is a drop-down that lets you configure the yAxisLabelLocation so that you can visualize what the axes look like when the labels are placed on the left or right side on the inside or outside of the chart's plot area. Axis Advanced Scenarios For more advanced axis layout scenarios, you can use Angular Data Chart to share axis, add multiple y-axis and/or x-axis in the same plot area, or even cross axes at specific values. The following examples show how to use these features of the IgxDataChartComponent. Axis Sharing Example You can share and add multiple axes in the same plot area of the Angular IgxDataChartComponent. It a common scenario to use share IgxTimeXAxisComponent and add multiple IgxNumericYAxisComponent to plot many data sources that have wide range of values (e.g. stock prices and stock trade volumes). The following example depicts a stock price and trade volume chart with a Stock Chart and a Column Chart plotted. In this case, the Y-Axis on the left is used by the Column Chart and the Y-Axis on the right is used by the Stock Chart, while the X-Axis is shared between the two. Axis Crossing Example In addition to placing axes outside plot area, the Angular IgxDataChartComponent also provides options to position axes inside of plot area and make them cross at specific values. For example, you can create trigonometric chart by setting crossingAxis and crossingValue properties on both x-axis and y-axis to render axis lines and axis labels such that they are crossing at (0, 0) origin point. The following example shows a Sin and Cos wave represented by a Scatter Spline Chart with the X and Y axes crossing each other at the (0, 0) origin point. Additional Resources You can find more information about related chart features in these topics: Axis Gridlines Axis Options API References The following is a list of API members mentioned in the above sections: d in the above sections: IgxDataChartComponent IgxCategoryChartComponent Axes ➔ IgxNumericYAxisComponent ➔ crossingAxis None Axes ➔ IgxNumericYAxisComponent ➔ crossingValue None Axes ➔ IgxNumericXAxisComponent ➔ isInverted xAxisInverted Axes ➔ IgxNumericYAxisComponent ➔ isInverted yAxisInverted Axes ➔ IgxNumericYAxisComponent ➔ LabelLocation yAxisLabelLocation Axes ➔ IgxNumericXAxisComponent ➔ LabelLocation xAxisLabelLocation Axes ➔ IgxNumericYAxisComponent ➔ LabelHorizontalAlignment yAxisLabelHorizontalAlignment Axes ➔ IgxNumericXAxisComponent ➔ LabelVerticalAlignment xAxisLabelVerticalAlignment Axes ➔ IgxNumericYAxisComponent ➔ LabelVisibility yAxisLabelVisibility Axes ➔ IgxNumericXAxisComponent ➔ LabelVisibility xAxisLabelVisibility View page on GitHub"
  },
  "components/charts/features/chart-axis-options.html": {
    "href": "components/charts/features/chart-axis-options.html",
    "title": "Angular Axis Options | Data Visualization | Infragistics",
    "keywords": "Angular Axis Options In all Ignite UI for Angular charts, the axes provide properties for visual configurations such as titles, labels, and ranges. These features are demonstrated in the examples provided below. Axis Titles Example The axis titles feature of the Angular charts, allows you to add contextual information to the your chart. You can customize the look and feel of the axis titles in many different ways such as applying different font styles, colors, margins, and alignments. Axis Labels Example The Angular Charts allows you full control over configuring, formatting, and styling the font of the labels displayed on an axis in your chart. You can change the rotation angle, margin, horizontal and vertical alignment, color, padding, and visibility of axis labels. The following example shows how to use these features of axes. Axis Labels Management The axes of the chart have the ability to perform an enhanced calculation regarding the amount of space available to the labels of the owning axis. This enhanced calculation allows the axis to optimize the amount of space given to it in order to display more labels for the given axis. This enhanced calculation is something that you need to opt-in to, which you can do by setting the useEnhancedIntervalManagement property to true. Then, if you prefer to display as many labels as can fit in the dimensions of the axis without manually setting the interval property of the axis, you can set the enhancedIntervalPreferMoreCategoryLabels property on the axis to true. The chart also has the ability to consider auto-rotation of the labels if they will not fit in the allotted space as well as the ability to apply an automatic margin to the plot area to ensure the labels can fit. This is something that can be opted into initially by first setting the autoMarginAndAngleUpdateMode property on the chart to either SizeChanging or SizeChangingAndZoom. This will tell the chart when to re-evaluate the auto margin and angle applied to the labels, if desired. After setting the autoMarginAndAngleUpdateMode, you can set the shouldAutoExpandMarginForInitialLabels property to true to opt into the automatic margin or set the shouldConsiderAutoRotationForInitialLabels property to true for the auto-rotation. You can also further customize the automatic margin that is applied by setting the autoExpandMarginExtraPadding and autoExpandMarginMaximumValue to provide extra space or a maximum possible margin, respectively. Custom label formats such as IgxNumberFormatSpecifier and IgxDateTimeFormatSpecifier can be added to each axis via the XAxisLabelFormatSpecifier and YAxisLabelFormatSpecifier collections. Commonly used for applying Intl.NumberFormat and Intl.DateTimeFormat language sensitive number, date and time formatting. In order for a custom format to be applied to the labels, the yAxisLabelFormat or xAxisLabelFormat need to be set to {0} on the IgxCategoryChartComponent. The following example formats the yAxis with a IgxNumberFormatSpecifier to reprerent $USD prices for top box office movies in the United States. Axis Range Example In the Angular charts, you can define a range minimum and range maximum value of a numeric or time axis. The range minimum is the lowest value of the axis and the range maximum is the highest value of the axis. These are set by setting the yAxisMinimumValue and yAxisMaximumValue options. By default, charts will calculate the minimum and maximum values for the numeric and time axis range based on the lowest and highest corresponding value points in your data, but this automatic calculation may not be appropriate for your set of data points in all cases. For example, if your data has a minimum value of 850, you may want to set the yAxisMinimumValue to 800 so that there will be a space value of 50 between the axis minimum and the lowest value of data points. The same idea can be applied to the axis minimum value and the highest value of data points using the yAxisMaximumValue property. Axis Modes & Scale In the IgxFinancialChartComponent and IgxCategoryChartComponent controls, you can choose if your data is plotted on logarithmic scale along the y-axis when the yAxisIsLogarithmic property is set to true or on linear scale when this property is set to false (default value). With the yAxisLogarithmBase property, you can change base of logarithmic scale from default value of 10 to other integer value. The IgxFinancialChartComponent and control allows you to choose how your data is represented along the y-axis using yAxisMode property that provides Numeric and PercentChange modes. The Numeric mode will plot data with the exact values while the PercentChange mode will display the data as percentage change relative to the first data point provided. The default value is Numeric mode. In addition to yAxisMode property, the IgxFinancialChartComponent control has xAxisMode property that provides Time and Ordinal modes for the x-axis. The Time mode will render space along the x-axis for gaps in data (e.g. no stock trading on weekends or holidays). The Ordinal mode will collapse date areas where data does not exist. The default value is Ordinal mode. Axis Gap Example The xAxisGap property of the Angular charts, determines the amount of space between columns or bars of plotted series. This property accepts a numeric value between 0.0 and 1.0. The value represents a relative width of the gap out of the available number of pixels between the series. Setting this property to 0 would mean there is no gap rendered between the series, and setting it 1 would render the maximum available gap. The xAxisMaximumGap property of the Angular charts, determines the maximum gap value to allow. This default is set to 1.0 but can be changed depending on what you set xAxisGap to. The xAxisMinimumGapSize property of the Angular charts, determines the minimum amount of pixels to use for the gap between the categories, if possible. The following example shows the average maximum temperature in Celsius in New York City's Central Park represented by a Column Chart with an xAxisGap initially set to 1, and so there will be a full category's width between the columns. There is a slider that allows you to configure the gap in this example so that you can see what the different values do. Axis Overlap Example The xAxisOverlap property of the Angular charts, allows setting the overlap of the rendered columns or bars of plotted series. This property accepts a numeric value between -1.0 and 1.0. The value represents a relative overlap out of the available number of pixels dedicated to each series. Setting this property to a negative value (down to -1.0) results in the categories being pushed away from each other, producing a gap between themselves. Conversely, setting this property to a positive value (up to 1.0) results in the categories overlapping each other. A value of 1 directs the chart to render the categories on top of each other. The following example shows a comparison of the highest grossing worldwide film franchises compared by the total world box office revenue of the franchise and the highest grossing movie in the series, represented by a Column Chart with an xAxisOverlap initially set to 1, and so the columns will completely overlap each other. There is a slider that allows you to configure the overlap in this example so that you can see what the different values do. Additional Resources You can find more information about related chart features in these topics: Axis Gridlines Axis Layout API References The following is a list of API members mentioned in the above sections: IgxDataChartComponent IgxFinancialChartComponent IgxCategoryChartComponent Axes ➔ IgxNumericYAxisComponent ➔ maximumValue yAxisMaximumValue yAxisMaximumValue Axes ➔ IgxNumericYAxisComponent ➔ minimumValue yAxisMinimumValue yAxisMinimumValue Axes ➔ IgxNumericYAxisComponent ➔ isLogarithmic yAxisIsLogarithmic yAxisIsLogarithmic Axes ➔ IgxNumericYAxisComponent ➔ logarithmBase yAxisLogarithmBase yAxisLogarithmBase Axes ➔ IgxCategoryXAxisComponent ➔ gap None xAxisGap Axes ➔ IgxCategoryXAxisComponent ➔ overlap None xAxisOverlap Axes ➔ IgxTimeXAxisComponent xAxisMode None Axes ➔ IgxPercentChangeYAxisComponent yAxisMode None Axes ➔ IgxNumericYAxisComponent ➔ labelSettings.angle yAxisLabelAngle yAxisLabelAngle Axes ➔ IgxNumericXAxisComponent ➔ labelSettings.angle xAxisLabelAngle xAxisLabelAngle Axes ➔ IgxNumericYAxisComponent ➔ labelSettings.textColor YAxisLabelForeground YAxisLabelForeground Axes ➔ IgxNumericXAxisComponent ➔ labelSettings.textColor XAxisLabelForeground XAxisLabelForeground Axes ➔ IgxNumericYAxisComponent ➔ labelSettings.visibility yAxisLabelVisibility yAxisLabelVisibility Axes ➔ IgxNumericXAxisComponent ➔ labelSettings.visibility xAxisLabelVisibility xAxisLabelVisibility View page on GitHub"
  },
  "components/charts/features/chart-axis-types.html": {
    "href": "components/charts/features/chart-axis-types.html",
    "title": "Angular Axis Types | Data Visualization | Infragistics",
    "keywords": "Angular Axis Types The Ignite UI for Angular Category Chart uses only one IgxCategoryXAxisComponent and one IgxNumericYAxisComponent type. Similarly, Ignite UI for Angular Financial Chart uses only one IgxTimeXAxisComponent and one IgxNumericYAxisComponent types. However, the Ignite UI for Angular Data Chart provides support for multiple axis types that you can position on any side of the chart by setting axis location or even inside of the chart by using axis crossing properties. This topic goes over each one, which axes and series are compatible with each other, and some specific properties to the unique axes. Cartesian Axes The IgxDataChartComponent with Cartesian Axes, allows you to plot data in horizontal (X-axis) and vertical (X-axis) direction with 3 types of X-Axis (IgxCategoryXAxisComponent, IgxNumericXAxisComponent, and IgxTimeXAxisComponent) and 2 types of Y-Axis (IgxCategoryYAxisComponent and IgxNumericYAxisComponent). Category X-Axis The IgxCategoryXAxisComponent treats its data as a sequence of categorical data items. It can display almost any type of data including strings and numbers. If you are plotting numbers on this axis, it is important to keep in mind that this axis is a discrete axis and not continuous. This means that each categorical data item will be placed equidistant from the one before it. The items will also be plotted in the order that they appear in the axis' data source. The IgxCategoryXAxisComponent requires you to provide a DataSource and a label in order to plot data with it. It is generally used with the IgxNumericYAxisComponent to plot the following type of series: Category Series Stacked Series Financial Series - IgxAreaSeriesComponent - IgxColumnSeriesComponent - IgxLineSeriesComponent - IgxPointSeriesComponent - IgxSplineSeriesComponent - IgxSplineAreaSeriesComponent - IgxStepLineSeriesComponent - IgxStepAreaSeriesComponent - IgxRangeAreaSeriesComponent - IgxRangeColumnSeriesComponent - IgxWaterfallSeriesComponent - IgxStackedAreaSeriesComponent - IgxStackedColumnSeriesComponent - IgxStackedLineSeriesComponent - IgxStackedSplineSeriesComponent - IgxStacked100AreaSeriesComponent - IgxStacked100ColumnSeriesComponent - IgxStacked100LineSeriesComponent - IgxStacked100SplineSeriesComponent - IgxFinancialPriceSeriesComponent - IgxBollingerBandsOverlayComponent - IgxForceIndexIndicatorComponent - IgxMedianPriceIndicatorComponent - IgxMassIndexIndicatorComponent - IgxRelativeStrengthIndexIndicatorComponent - IgxStandardDeviationIndicatorComponent - IgxTypicalPriceIndicatorComponent The following example demonstrates usage of the IgxCategoryXAxisComponent type: Category Y-Axis The IgxCategoryYAxisComponent works very similarly to the IgxCategoryXAxisComponent described above, but it is placed vertically rather than horizontally. Also, this axis requires you to provide a DataSource and a label in order to plot data with it. The IgxCategoryYAxisComponent is generally used with the IgxNumericXAxisComponent to plot the following type of series: IgxBarSeriesComponent IgxStackedBarSeriesComponent IgxStacked100BarSeriesComponent The following example demonstrates usage of the IgxCategoryYAxisComponent type: Numeric X-Axis The IgxNumericXAxisComponent treats its data as continuously varying numerical data items. Labels on this axis are placed horizontally along the X-Axis. The location of the IgxNumericXAxisComponent labels depends on the XMemberPath property of the various Scatter Series that it supports if combined with a IgxNumericYAxisComponent. Alternatively, if combined with the IgxCategoryXAxisComponent, these labels will be placed corresponding to the ValueMemberPath of the IgxBarSeriesComponent, IgxStackedBarSeriesComponent, and IgxStacked100BarSeriesComponent. The IgxNumericXAxisComponent is compatible with the following type of series: IgxBarSeriesComponent IgxBubbleSeriesComponent IgxHighDensityScatterSeriesComponent IgxScatterSeriesComponent IgxScatterLineSeriesComponent IgxScatterSplineSeriesComponent IgxScatterAreaSeriesComponent IgxScatterContourSeriesComponent IgxScatterPolylineSeriesComponent IgxScatterPolygonSeriesComponent IgxStackedBarSeriesComponent IgxStacked100BarSeriesComponent The following example demonstrates usage of the IgxNumericXAxisComponent: Numeric Y-Axis The IgxNumericYAxisComponent treats its data as continuously varying numerical data items. Labels on this axis are placed vertically along the Y-Axis. The location of the IgxNumericYAxisComponent labels depends on the YMemberPath property of the various ScatterSeries that is supports if combined with a IgxNumericXAxisComponent. Alternatively, if combined with the IgxCategoryYAxisComponent, these labels will be placed corresponding to the ValueMemberPath of the category or stacked series mentioned in the table above. If you are using one of the financial series, they will be placed corresponding to the Open/High/Low/Close paths and the series type that you are using. The IgxNumericYAxisComponent is compatible with the following type of series: Category Series Stacked Series Financial Series Scatter Series - IgxAreaSeriesComponent - IgxColumnSeriesComponent - IgxLineSeriesComponent - IgxPointSeriesComponent - IgxSplineSeriesComponent - IgxSplineAreaSeriesComponent - IgxStepLineSeriesComponent - IgxStepAreaSeriesComponent - IgxRangeAreaSeriesComponent - IgxRangeColumnSeriesComponent - IgxWaterfallSeriesComponent - IgxStackedAreaSeriesComponent - IgxStackedColumnSeriesComponent - IgxStackedLineSeriesComponent - IgxStackedSplineSeriesComponent - IgxStacked100AreaSeriesComponent - IgxStacked100ColumnSeriesComponent - IgxStacked100LineSeriesComponent - IgxStacked100SplineSeriesComponent - IgxFinancialPriceSeriesComponent - IgxBollingerBandsOverlayComponent - IgxForceIndexIndicatorComponent - IgxMedianPriceIndicatorComponent - IgxMassIndexIndicatorComponent - IgxRelativeStrengthIndexIndicatorComponent - IgxStandardDeviationIndicatorComponent - IgxTypicalPriceIndicatorComponent - IgxBubbleSeriesComponent - IgxHighDensityScatterSeriesComponent - IgxScatterSeriesComponent - IgxScatterLineSeriesComponent - IgxScatterSplineSeriesComponent - IgxScatterAreaSeriesComponent - IgxScatterContourSeriesComponent - IgxScatterPolylineSeriesComponent - IgxScatterPolygonSeriesComponent The following example demonstrates usage of the IgxNumericYAxisComponent: Time X Axis The IgxTimeXAxisComponent treats its data as a sequence of data items, sorted by date. Labels on this axis type are dates and can be formatted and arranged according to date intervals. The date range of this axis is determined by the date values in a data column that is mapped using its DateTimeMemberPath. This, along with a DataSource is required to plot data with this axis type. The IgxTimeXAxisComponent is the X-Axis type in the IgxFinancialChartComponent component. Breaks in Time X Axis The IgxTimeXAxisComponent has the option to exclude intervals of data by using breaks. As a result, the labels and plotted data will not appear at the excluded interval. For example, working/non-working days, holidays, and/or weekends. An instance of IgxTimeAxisBreakComponent can be added to the Breaks collection of the axis and configured by using a unique start, end and interval. Formating in Time X Axis The IgxTimeXAxisComponent has the labelFormats property, which represents a collection of IgxTimeAxisLabelFormatComponent objects. Each IgxTimeAxisLabelFormatComponent added to the collection is responsible for assigning a unique format and range. This can be especially useful for drilling down data from years to milliseconds and adjusting the labels depending on the range of time shown by the chart. The format property of the IgxTimeAxisLabelFormatComponent specifies what format to use for a particular visible range. The range property of the IgxTimeAxisLabelFormatComponent specifies the visible range at which the axis label formats will switch to a different format. For example, if you have two IgxTimeAxisLabelFormatComponent elements with a range set to 10 days and another set to 5 hours, then as soon as the visible range of the axis becomes less than 10 days, it will switch to 5-hour format. Intervals in Time X Axis The IgxTimeXAxisComponent replaces the conventional interval property of the category and numeric axes with an intervals collection of type IgxTimeAxisIntervalComponent. Each IgxTimeAxisIntervalComponent added to the collection is responsible for assigning a unique interval, range and intervalType. This can be especially useful for drilling down data from years to milliseconds to provide unique spacing between labels depending on the range of time shown by the chart. A description of these properties is below: interval: This specifies the interval to use. This is tied to the intervalType property. For example, if the intervalType is set to Days, then the numeric value specified in interval will be in days. range: This specifies the visible range at which the axis interval will switch to a different interval. For example, if you have two TimeAxisInterval with a range set to 10 days and another set to 5 hours, as soon as the visible range in the axis becomes less than 10 days it will switch to the interval whose range is 5 hours. intervalType: This specifies the unit of time for the interval property. Polar Axes The IgxDataChartComponent with Polar Axes, allows you to plot data outwards (radius axis) from center of the chart and around (angle axis) of center of the chart. Category Angle Axis The IgxCategoryAngleAxisComponent treats its data as a sequence of category data items. The labels on this axis are placed along the edge of a circle according to their position in that sequence. This type of axis can display almost any type of data including strings and numbers. The IgxCategoryAngleAxisComponent is generally used with the IgxNumericRadiusAxisComponent to plot Radial Series. The following example demonstrates usage of the IgxCategoryAngleAxisComponent type: Numeric Angle Axis The IgxNumericAngleAxisComponent treats its data as continuously varying numerical data items. The labels on this axis area placed along a radius line starting from the center of the circular plot. The location of the labels on the IgxNumericAngleAxisComponent varies according to the value in the data column mapped using the RadiusMemberPath property of the Polar Series object or the ValueMemberPath property of the Radial Series object. The The IgxNumericAngleAxisComponent can be used with either the IgxCategoryAngleAxisComponent to plot Radial Series or with the IgxNumericRadiusAxisComponent to plot Polar Series respectively. The following example demonstrates usage of the IgxNumericAngleAxisComponent type: Numeric Radius Axis The IgxNumericRadiusAxisComponent treats the data as continuously varying numerical data items. The labels on this axis are placed around the circular plot. The location of the labels varies according to the value in a data column mapped using the AngleMemberPath property of the corresponding polar series. The IgxNumericRadiusAxisComponent can be used with the IgxNumericRadiusAxisComponent to plot Polar Series. The following example demonstrates usage of the IgxNumericRadiusAxisComponent type: Additional Resources You can find more information about related chart features in these topics: Axis Gridlines Axis Layouts Axis Options View page on GitHub"
  },
  "components/charts/features/chart-data-aggregations.html": {
    "href": "components/charts/features/chart-data-aggregations.html",
    "title": "Angular Data Aggregations | Data Visualization | Infragistics",
    "keywords": "Angular Data Aggregations In the Ignite UI for Angular IgxCategoryChartComponent control Data Aggregations feature allows you to group data in the chart by unique values on the XAxis and then sort those groups. You may then apply summaries which will be reflected by the range of the YAxis and will be displayed in the tooltip when hovering the series. Angular Data Aggregations Example The following example depicts a Column Chart that groups by the Country member of the XAxis and can be changed to other properties within each data item such as Product, MonthName, and Year to aggregate the sales data. Also a summary and sort option is available to get a desirable order for the grouped property. Note, the abbreviated functions found within the dropdowns for initialSummaries and groupSorts have be applied as shown to get a correct result based on the property you assign. eg. Sum(sales) as Sales | Sales Desc <igx-category-chart [dataSource]=\"salesData\" initialGroups=\"country\" initialSummaries=\"Sum(sales) as Sales\" groupSorts=\"Sales Desc\"> </igx-category-chart> API References The following is a list of API members mentioned in the above sections: initialSortDescriptions initialSorts sortDescriptions initialGroups initialGroupDescriptions groupDescriptions initialSummaries initialSummaryDescriptions summaryDescriptions initialGroupSortDescriptions groupSorts groupSortDescriptions [!Note] Chart Aggregation will not work when using includedProperties | excludedProperties. These properties on the chart are meant for non-aggregated data. Once you attempt to aggregate data these properties should no longer be used. The reason it does not work is because aggregation replaces the collection that is passed to the chart for render. The include/exclude properties are designed to filter in/out properties of that data and those properties no longer exist in the new aggregated collection. View page on GitHub"
  },
  "components/charts/features/chart-data-legend.html": {
    "href": "components/charts/features/chart-data-legend.html",
    "title": "Angular Chart Data Legend | Data Visualization Tools | Infragistics",
    "keywords": "Angular Data Legend In Ignite UI for Angular, the IgxDataLegendComponent is highly-customizable version of the IgxLegendComponent, that shows values of series and provides many configuration properties for filtering series rows and values columns, styling and formatting values. This legend updates when moving the mouse inside of the plot area of the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent. Also, it has a persistent state that remembers the last hovered point when the user's mouse pointer exits the plot area. It displays this content using a set of three type of rows (header, series, summary) and four types of columns (title, label, value, unit). Angular Data Legend Rows The rows of the IgxDataLegendComponent include the header row, series row(s), and the summary row. The header row displays the axis label of the point that is hovered, and can be changed using the headerText property. Header Row The header row displays the current label of x-axis when hovering mouse over category series and financial series. You can use headerFormatDate and headerFormatTime properties to format date and time in the IgxDataLegendComponent if the x-axis shows dates. For other types of series, the IgxDataLegendComponent does not render the header row. Series Row The series row represents each series plotted in the chart. These rows will display the legend badge, series title, actual/abbreviated value of the the series, and abbreviation symbol or unit of measurement, if specified. You can filter series rows by setting includedSeries or excludedSeries properties to a collection of series' indexes (1, 2, 3) or series' titles (Tesla, Microsoft). Summary Row Finally, there is a summary row that displays the total of all series values. The default summary title can be changed using the summaryTitleText property of the legend. Also, you can use the summaryType property to customize whether you display the Total, Min, Max, or Average of series values in the summary row. Angular Data Legend Columns The columns of the IgxDataLegendComponent include the series title, label, value of data column, and optional unit associated with the value. Some series in the chart can have multiple columns for label, value, and units. For example, financial price series has High, Low, Open, and Close data columns which can be filtered in the IgxDataLegendComponent using the includedColumns or excludedColumns properties. Setting values on the includedColumns and excludedColumns properties, depends on type of series and how many data columns they support. For example, you can set includedColumns property to a collection of Open and Close strings and the legend will show only open and close values for stock prices when the chart is plotting financial series. The following table lists all column names that can be use to filter columns in data legend. Type of Series Column Names Category Series Value Radial Series Value Polar Series Radius, Angle Bubble Series X, Y, Radius Scatter Series X, Y Range Series High, Low Financial Series High, Low, Open, Close, Change, TypicalPrice, Volume Where the TypicalPrice and percentage Change of OHLC prices are automatically calculated by financial series so you do not need to include them in your data sources. Title Column The title column displays legend badges and series titles, which come from the title property of the different IgxSeriesComponent plotted in the chart. Label Column The label column displays short name on the left side of value column, e.g. \"O\" for Open stock price. You can toggle visibility of this column using the labelDisplayMode property. Value Column The value column displays values of series as abbreviated text which can be formatted using the valueFormatAbbreviation property to apply the same abbreviation for all numbers by setting this property to Shared. Alternatively, a user can select other abbreviations such as Independent, Kilo, Million, etc. Precision of abbreviated values is controlled using the valueFormatMinFractions and valueFormatMaxFractions for minimum and maximum digits, respectively. Unit Column The unit column displays an abbreviation symbol on the right side of value column. The unit symbol depends on the valueFormatAbbreviation property, e.g. \"M\" for the Million abbreviation. Customizing Columns You can customize text displayed in the Label and Unit columns using properties that end with MemberAsLegendLabel and MemberAsLegendUnit on each series. The following table shows some possible customizations of the Label and Unit columns. Type of Series Series Properties Category Series ValueMemberAsLegendLabel=\"$\" ValueMemberAsLegendUnit=\"M\" Radial Series ValueMemberAsLegendLabel=\"Distance:\" ValueMemberAsLegendUnit=\"KM\" Polar Series RadiusMemberAsLegendLabel=\"Radius:\" RadiusMemberAsLegendUnit=\"KM\" AngleMemberAsLegendLabel=\"Angle:\" AngleMemberAsLegendUnit=\"°\" Range Series HighMemberAsLegendLabel=\"H:\" HighMemberAsLegendUnit=\"K\" LowMemberAsLegendLabel=\"L:\" LowMemberAsLegendUnit=\"K\" Financial Series OpenMemberAsLegendLabel=\"O:\" OpenMemberAsLegendUnit=\"K\" HighMemberAsLegendLabel=\"H:\" HighMemberAsLegendUnit=\"K\" LowMemberAsLegendLabel=\"L:\" LowMemberAsLegendUnit=\"K\" CloseMemberAsLegendLabel=\"C:\" CloseMemberAsLegendUnit=\"K\" Also, you can use the UnitText property on the IgxDataLegendComponent to change text displayed in all Unit columns. Angular Data Legend Styling The IgxDataLegendComponent provides properties for styling each type of column. Each of these properties begins with Title, Label, Value, or Units. You can style the text's color, font, and margin. For example, if you wanted to set the text color of all columns, you would set the titleTextColor, labelTextColor, valueTextColor, and unitsTextColor properties. The following example demonstrates a utilization of the styling properties mentioned above: Angular Data Legend Value Formatting The IgxDataLegendComponent provides automatic abbreviation of large numbers using its valueFormatAbbreviation property. This adds a multiplier in the units column such as kilo, million, billion, etc. You can customize the number of fractional digits that are displayed by setting the valueFormatMinFractions and valueFormatMaxFractions. This will allow you to determine the minimum and maximum number of digits that appear after the decimal point, respectively. The following example demonstrates how to use those properties: Angular Data Legend Value Mode You have the ability to change the default decimal display of values within the IgxDataLegendComponent to a currency by changing the valueFormatMode property. Also, you can change the culture of the displayed currency symbol by setting the valueFormatCulture property a culture tag. For example, the following example data legend with the valueFormatCulture set to \"en-GB\" to display British Pounds (£) symbol: The IgxDataLegendComponent has several events that fire when rendering their corresponding row, even during mouse interactions where the values are updating. These events are listed below with a description of what they are designed to be used for: StyleSeriesRow: This event fires once for each series row, which allows conditional styling of the values of the series. StyleSeriesColumn: This event fires once for each series column, which allows conditional styling of the different columns for the series in the chart. StyleSummaryRow: This event fires once when rendering the summary row. StyleSummaryColumn: This event fires once when rendering the summary column. API References excludedColumns excludedSeries headerFormatDate headerFormatTime headerText includedColumns includedSeries labelDisplayMode labelTextColor StyleHeaderRow: StyleSeriesColumn: StyleSeriesRow StyleSeriesRow: StyleSummaryColumn: StyleSummaryRow: summaryTitleText summaryType titleTextColor UnitText unitsTextColor valueFormatAbbreviation valueFormatCulture valueFormatMaxFractions valueFormatMaxFractions valueFormatMinFractions valueFormatMode valueTextColor View page on GitHub"
  },
  "components/charts/features/chart-data-tooltip.html": {
    "href": "components/charts/features/chart-data-tooltip.html",
    "title": "Angular Chart Data Tooltip | Data Visualization Tools | Infragistics",
    "keywords": "Angular Chart Data Tooltip In Ignite UI for Angular, the DataToolTip displays values and titles of series as well as legend badges of series in a tooltip. In addition, it provides many configuration properties of the IgxDataLegendComponent for filtering series rows and values columns, styling, and formatting values. This tooltip type updates while moving the mouse inside of the plot area of the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent components. Angular Data Tooltip Properties All properties of IgxDataToolTipLayerComponent are prefixed with DataToolTip and exposed on API of IgxCategoryChartComponent and IgxFinancialChartComponent components. However, you will need to create an instance of IgxDataToolTipLayerComponent and add it to series collection of IgxDataChartComponent component if you want to use it with Radial Charts, Polar Charts, Scatter Charts. Angular Data Tooltip Elements The DataToolTip displays content using a set of three types of rows and four types of columns. Angular Data Tooltip Rows The rows of the DataToolTip include the header row, series row(s), and the summary row. The header row displays the axis label of the point that is hovered, and can be changed using the dataToolTipHeaderText property. The series row can actually be a set of rows corresponding to each series plotted in the chart. These rows will display the legend badge, series title, actual/abbreviated value of the the series, and abbreviation symbol and unit, if specified. Finally, there is a summary row that displays the total of all series values. The default summary title can be changed using the dataToolTipSummaryTitleText property of the legend. Also, you can use the dataToolTipSummaryType property to customize whether you display the Total, Min, Max, or Average of series values in the summary row. The following example demonstrates the data tooltip with a summary applied: Angular Data Tooltip Columns The columns of the IgxDataToolTipLayerComponent include the title, label, value, and units columns. Each series in the chart can have multiple columns for label, value, and units depending on the dataToolTipIncludedColumns or dataToolTipExcludedColumns collections of the chart. The title column displays legend badges and series titles, which come from the chartTitle property of the different IgxSeriesComponent plotted in the chart. The label column displays the name or abbreviation of the different property paths in the dataToolTipIncludedColumns or dataToolTipExcludedColumns collections of the tooltip. The value column displays series values as abbreviated text which can be formatted using the dataToolTipValueFormatAbbreviation property to apply the same abbreviation for all numbers by setting this property to Auto or Shared. Alternatively, a user can select other abbreviations such as Independent, Kilo, Million, etc. Precision of abbreviated values is controlled using the dataToolTipValueFormatMinFractions and dataToolTipValueFormatMaxFractions for minimum and maximum digits, respectively. The units column displays an abbreviation symbol and/or unit text, which can be set either on the DataToolTip by setting the dataToolTipUnitsText for all columns or using the following properties on each series in the chart: Category Series (e.g. ColumnSeries) ValueMemberAsLegendUnit=\"K\" Financial Price Series: OpenMemberAsLegendUnit=\"K\" LowMemberAsLegendUnit=\"K\" HighMemberAsLegendUnit=\"K\" CloseMemberAsLegendUnit=\"K\" Range Series: LowMemberAsLegendUnit=\"K\" HighMemberAsLegendUnit=\"K\" Radial Series: ValueMemberAsLegendUnit=\"km\" Polar Series: RadiusMemberAsLegendUnit=\"km\" AngleMemberAsLegendUnit=\"degrees\" For the above-listed properties, there are corresponding properties ending with MemberAsLegendLabel to determine the text in the label columns mentioned previously. The columns included in the dataToolTipIncludedColumns and dataToolTipExcludedColumns collections generally correspond to the value paths of your underlying data items, but the financial series has the option to include some special ones in addition to the High, Low, Open, and Close paths that are required for the financial series to plot correctly. You have the ability to show TypicalPrice, Change, and Volume options within the tooltip. The following example demonstrates a data tooltip with the added columns of Open, High, Low, Close, and Change: Angular Data Tooltip Grouping & Positioning for Category Chart & Financial Chart You can set dataToolTipGroupingMode property to either Grouped or Individual to group content for multiple series into single tooltip or separate content for each series in multiple tooltips. In the Grouped mode, you can customize where the tooltip is shown by setting the dataToolTipGroupedPositionModeX and dataToolTipGroupedPositionModeY properties. This essentially allows you to customize the horizontal and vertical alignments of the tooltip and whether you want it to track to the closest series points to the mouse position or pin the tooltip to edge of plot area. The following example demonstrates a data tooltip positioned to the top-right of the chart: Angular Data Tooltip Value Formatting The DataToolTip provides automatic abbreviation of large numbers using its dataToolTipValueFormatAbbreviation property. This adds a multiplier in the units column such as kilo, million, billion, etc. You can customize the number of fractional digits that are displayed by setting the dataToolTipValueFormatMinFractions and dataToolTipValueFormatMaxFractions. This will allow you to determine the minimum and maximum number of digits that appear after the decimal point, respectively. The following example demonstrates a DataToolTip with the minimum and maximum fractions set: Angular Data Tooltip Value Mode You can change the default decimal display of values within the DataToolTip to be currency by changing the dataToolTipValueFormatMode property of the layer. The DataToolTip also exposes the ability to modify the culture of the displayed currency symbol by using its dataToolTipValueFormatCulture property and setting it to its corresponding culture tag. For example, the following sample demonstrates a chart with the dataToolTipValueFormatCulture set to \"en-GB\": API References dataToolTipExcludedColumns dataToolTipGroupedPositionModeX dataToolTipGroupedPositionModeY dataToolTipGroupingMode dataToolTipHeaderText dataToolTipIncludedColumns dataToolTipLabelTextColor IgxDataToolTipLayerComponent dataToolTipSummaryTitleText dataToolTipSummaryType dataToolTipTitleTextColor dataToolTipUnitsTextColor dataToolTipUnitsText dataToolTipValueFormatAbbreviation dataToolTipValueFormatCulture dataToolTipValueFormatMaxFractions dataToolTipValueFormatMaxFractions dataToolTipValueFormatMinFractions dataToolTipValueFormatMode dataToolTipValueTextColor MemberAsLegendLabel View page on GitHub"
  },
  "components/charts/features/chart-highlight-filter.html": {
    "href": "components/charts/features/chart-highlight-filter.html",
    "title": "Angular Chart Highlight Filter | Data Visualization | Infragistics",
    "keywords": "Angular Chart Highlight Filter The Ignite UI for Angular Chart components support a data highlighting overlay that can enhance the visualization of the series plotted in those charts by allowing you to view a subset of the data plotted. When enabled, this will highlight a subset of data while showing the total set with a reduced opacity in the case of column and area series types, and a dashed line in the case of line series types. This can help you to visualize things like target values versus actual values with your data set. This feature is demonstrated in the following example: Note that data highlighting feature is supported by the IgxDataChartComponent and IgxCategoryChartComponent, but it is configured in different ways in those controls due to the nature of how those controls work. One thing remains constant with this feature though, in that you need to set the highlightedValuesDisplayMode property to Overlay if you want to see the highlight. The following will explain the different configurations for the highlight filter feature. Using Highlight Filter with DataChart In the IgxDataChartComponent, much of the highlight filter API happens on the series themselves, mainly by setting the HighlightedItemsSource property to a collection representing a subset of the data you want to highlight. The count of the items in the HighlightedItemsSource needs to match the count of the data bound to the ItemsSource of the series that you are looking to highlight, and in the case of category series, it will use the ValueMemberPath that you have defined as the highlight path by default. The sample at the top of this page uses the HighlightedItemsSource in the IgxDataChartComponent to show the overlay. In the case that the schema does not match between the HighlightedItemsSource and the ItemsSource of the series, you can configure this using the HighlightedValueMemberPath property on the series. Additionally, if you would like to use the ItemsSource of the series itself as the highlight source and have a path on your data item that represents the subset, you can do this. This is done by simply setting the HighlightedValueMemberPath property to that path and not providing a HighlightedItemsSource. The reduced opacity of the column and area series types is configurable by setting the highlightedValuesFadeOpacity property on the series. You can also set the highlightedValuesDisplayMode property to Hidden if you do not wish to see the overlay at all. The part of the series shown by the highlight filter will be represented in the legend and tooltip layers of the chart separately. You can configure the title that this is given in the tooltip and legend by setting the highlightedTitleSuffix. This will append the value that you provide to the end of the chartTitle of the series. The following example demonstrates the usage of the data highlighting overlay feature within the IgxDataChartComponent control using the HighlightedValueMemberPath: Using Highlight Filter in CategoryChart The IgxCategoryChartComponent highlight filter happens on the chart by setting the initialHighlightFilter property. Since the IgxCategoryChartComponent takes all of the properties on your underlying data item into account by default, you will need to define the initialGroups on the chart as well so that the data can be grouped and aggregated in a way that you can have a subset of the data to filter on. You can set the initialGroups to a value path in your underlying data item to group by a path that has duplicate values. Similar to the IgxDataChartComponent, the highlightedValuesDisplayMode property is also exposed on the IgxCategoryChartComponent. In the case that you do not want to see the overlay, you can set this property to Hidden. The following example demonstrates the usage of the data highlighting overlay feature within the IgxCategoryChartComponent control: Additional Resources You can find more information about related chart features in these topics: Chart Highlighting Chart Data Tooltip Chart Data Aggregations API References The following is a list of API members mentioned in the above sections: IgxCategoryChartComponent Properties IgxDataChartComponent Properties CategoryChart.HighlightedItemsSource Series.HighlightedItemsSource highlightedTitleSuffix highlightedTitleSuffix CategoryChart.HighlightedValueMemberPath Series.HighlightedValueMemberPath highlightedValuesDisplayMode highlightedValuesDisplayMode highlightedValuesFadeOpacity highlightedValuesFadeOpacity highlightedValuesDisplayMode highlightedValuesDisplayMode initialHighlightFilter initialGroups View page on GitHub"
  },
  "components/charts/features/chart-highlighting.html": {
    "href": "components/charts/features/chart-highlighting.html",
    "title": "Angular Chart Highlighting | Data Visualization | Infragistics",
    "keywords": "Angular Chart Highlighting Example The following example demonstrates the different highlighting options that are available on the Angular chart. Angular Chart Highlighting Modes & Behaviors All Angular Charts support a variety of highlighting options. highlightingMode can be set to brighten or fade when the mouse is hovering over a series/data item rendered in the plot area. highlightingBehavior can be set to directly over or the nearest data item to trigger the highlighting effect. Highlighting modes and behaviors is supported by the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent controls and they have the same API for using the highlighting feature. The following example demonstrates the highlightingMode Angular chart. The following example demonstrates the highlightingBehavior Angular chart. Angular Chart Legend Highlighting All Angular Charts support legend highlighting. legendHighlightingMode can enabled so that when mouse is hovering over a legend marker item then the rendered series will highlight in the plot area. Legend highlighting is supported by the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent controls and they have the same API for using the highlighting feature. The following example demonstrates the legend series highlighting Angular chart. Highlight Layers The Ignite UI for Angular IgxCategoryChartComponent can enable three types of highlighting when hovering over data items. Series Highlighting will highlight the single data point represented by a marker or column when the pointer is positioned over it. This is enabled by setting the isSeriesHighlightingEnabled property to true. Item Highlighting highlights items in a series either by drawing a banded shape at their position or by rendering a marker at their position. This is enabled by setting the isItemHighlightingEnabled property to true. Category Highlighting targets all category axes in the chart. They draw a shape that illuminates the area of the axis closest to the pointer position. This is enabled by setting the isCategoryHighlightingEnabled property to true. The following example demonstrates the different highlighting layers that are available on the Angular chart. Additional Resources You can find more information about related chart features in these topics: Chart Animations Chart Annotations Chart Tooltips API References The following is a list of API members mentioned in the above sections: highlightingMode highlightingBehavior LegendHighlightingBehavior isCategoryHighlightingEnabled isItemHighlightingEnabled isSeriesHighlightingEnabled IgxCategoryChartComponent IgxDataChartComponent IgxFinancialChartComponent View page on GitHub"
  },
  "components/charts/features/chart-legends.html": {
    "href": "components/charts/features/chart-legends.html",
    "title": "Angular Chart Legends | Data Visualization Tools | Infragistics",
    "keywords": "Angular Chart Legends Angular Legend Types Angular Legend Layouts Angular Legend Customization View page on GitHub"
  },
  "components/charts/features/chart-markers.html": {
    "href": "components/charts/features/chart-markers.html",
    "title": "Angular Chart Markers | Data Visualization | Infragistics",
    "keywords": "Angular Chart Markers In Ignite UI for Angular, markers are visual elements that display the values of data points in the chart's plot area. Markers help your end-users immediately identify a data point's value even if the value falls between major or minor grid lines. Angular Chart Marker Example In the following example, the Line Chart is comparing the generation of renewable electricity for the countries Europe, China, and USA over the years of 2009 to 2019 with markers enabled by setting the MarkerType property to Circle enum value. The colors of the markers are also managed by setting the markerBrushes and markerOutlines properties in the sample below. The markers and chartType is configurable in this sample by using the drop-downs as well. Angular Chart Marker Templates In addition to marker properties, you can implement your own marker by setting a function to the MarkerTemplate property of a series rendered in the IgxCategoryChartComponent control as it is demonstrated in example below. Additional Resources You can find more information about related chart features in these topics: Chart Annotations Chart Highlighting API References The following is a list of API members mentioned in the above sections: markerBrushes markerOutlines MarkerType IgxCategoryChartComponent View page on GitHub"
  },
  "components/charts/features/chart-navigation.html": {
    "href": "components/charts/features/chart-navigation.html",
    "title": "Angular Data Chart | Data Visualization Tools | Navigation | Infragistics",
    "keywords": "Angular Chart Navigation The Ignite UI for Angular charts allows for interactive panning and zooming via the mouse, keyboard and touch. Angular Chart Navigation Example The following example shows all of the available panning and zooming options that are available. You can interact with the example by using the buttons, or select your desired options using the dropdowns or checkboxes. Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. Chart Navigation with User Interactions Zooming is on by default on the chart. In order to disable navigation in the UI, you need to set either the isHorizontalZoomEnabled and/or the isVerticalZoomEnabled properties of the chart to false, depending on the direction that you wish to disable zooming. It is also possible to zoom or pan simply by clicking the mouse or using touch. The defaultInteraction property of the data chart determines what happens on mouse click or touch events. This property defaults to DragZoom and when set to this with zooming enabled, clicking and dragging will place a preview rectangle over the plot area that will become the zoomed area of the chart. This defaultInteraction property can also be set to either DragPan to allow panning or None to prevent these operations. Chart Navigation with Touch, Mouse and Keyboard Navigation in the Angular data chart can happen with either touch, the mouse or the keyboard. The following operations can be invoked using touch, mouse or keyboard operations by default: Panning: Using 🡐 🡒 🡑 🡓 arrow keys on the keyboard or holding the Shift key, clicking and dragging with the mouse or pressing and moving your finger via touch. Zoom In: Using the Page Up key on the keyboard, rolling the mouse wheel up, or pinching to zoom in via touch. Zoom Out: Using the Page Down key on the keyboard, rolling the mouse wheel down, or pinching to zoom out via touch. Fit to Chart Plot Area: Using the Home key on the keyboard. There is no mouse or touch operation for this. Area Zoom: Click and drag the mouse within the plot area with the defaultInteraction property set to its default - DragZoom. The zoom and pan operations can also be enabled by using modifier keys by setting the dragModifier and panModifier properties, respectively. These properties can be set to the following modifier keys, and when pressed, the corresponding operation will be executed: Modifier Value Corresponding Key Shift Shift Control Ctrl Windows Win Apple Apple None no keys Chart Navigation with Scrollbars The chart can be scrolled by enabling the verticalViewScrollbarMode and horizontalViewScrollbarMode properties. These can be configured to the following options Persistent - The scrollbars always stay visible, as long as the chart is zoomed in, and fade away when fully zoomed out. Fading - The scrollbars disappear after use and reappear when the mouse is near their location. FadeToLine - The scrollbars are reduced to a thinner line when zooming is not in use. None - Default, no scrollbars are shown. The following example demonstrates enabling scrollbars. Chart Navigation through Code [!Note] Code navigation of the chart can only be used for the IgxDataChartComponent control. The Angular data chart provides several navigation properties that are updated each time a zoom or pan operation happens in the chart. You can also set each of these properties to zoom or pan the data chart programmatically. The following is a list of these properties: windowPositionHorizontal: A numeric value describing the X portion of the content view rectangle displayed by the data chart. windowPositionVertical: A numeric value describing the Y portion of the content view rectangle displayed by the data chart. windowRect: A Rect object representing a rectangle that represents the portion of the chart that is currently in view. For example, a windowRect of \"0, 0, 1, 1\" would be the entirety of the data chart. windowScaleHorizontal: A numeric value describing the width portion of the content view rectangle displayed by the data chart. windowScaleVertical: A numeric value describing the height portion of the content view rectangle displayed by the data chart. Additional Resources You can find more information about related chart features in these topics: Chart Tooltips Chart Trendlines API References The following is a list of API members mentioned in the above sections: defaultInteraction dragModifier isHorizontalZoomEnabled isVerticalZoomEnabled panModifier IgxCategoryChartComponent IgxDataChartComponent IgxFinancialChartComponent View page on GitHub"
  },
  "components/charts/features/chart-overlays.html": {
    "href": "components/charts/features/chart-overlays.html",
    "title": "Angular Chart Overlays | Data Visualization Tools | Value Overlay | Infragistics",
    "keywords": "Angular Chart Overlays The Angular IgxDataChartComponent allows for placement of horizontal or vertical lines at a single numeric value that you define through usage of the IgxValueOverlayComponent. This can help you to visualize data such as the mean or median of a particular series. Angular Value Overlay Example The following example depicts a Column Chart with a few horizontal value overlays plotted. Angular Value Overlay Properties Unlike other series types that use a ItemsSource for data binding, the value overlay uses a ValueMemberPath property to bind a single numeric value. In addition, the value overlay requires you to define a single axis to use. If you use an X-axis, the value overlay will be a vertical line, and if you use a Y-axis, it will be a horizontal line. When using a numeric X or Y axis, the ValueMemberPath property should reflect the actual numeric value on the axis where you want the value overlay to be drawn. When using a category X or Y axis, the ValueMemberPath should reflect the index of the category at which you want the value overlay to appear. When using the value overlay with a numeric angle axis, it will appear as a line from the center of the chart and when using a numeric radius axis, it will appear as a circle. IgxValueOverlayComponent appearance properties are inherited from IgxSeriesComponent and so brush and thickness for example are available and work the same way they do with other types of series. It is also possible to show an axis annotation on a IgxValueOverlayComponent to show the value of the overlay on the owning axis. In order to show this, you can set the isAxisAnnotationEnabled property to true. Angular Value Layer The Angular charting components also expose the ability to use value lines to call out different focal points of your data, such as minimum, maximum, and average values. Applying the IgxValueLayerComponent in the IgxCategoryChartComponent and IgxFinancialChartComponent components is done by setting the valueLines property on the chart. This property takes a collection of the ValueLayerValueMode enumeration. You can mix and match multiple value layers in the same chart by adding multiple ValueLayerValueMode enumerations to the valueLines collection of the chart. In the IgxDataChartComponent, this is done by adding a IgxValueLayerComponent to the IgxSeriesComponent collection of the chart and then setting the ValueMode property to one of the ValueLayerValueMode enumerations. Each of these enumerations and what they mean is listed below: Auto: The default value mode of the ValueLayerValueMode enumeration. Average: Applies potentially multiple value lines to call out the average value of each series plotted in the chart. GlobalAverage: Applies a single value line to call out the average of all of the series values in the chart. GlobalMaximum: Applies a single value line to call out the absolute maximum value of all of the series values in the chart. GlobalMinimum: Applies a single value line to call out the absolute minimum value of all of the series values in the chart. Maximum: Applies potentially multiple value lines to call out the maximum value of each series plotted in the chart. Minimum: Applies potentially multiple value lines to call out the minimum value of each series plotted in the chart. If you want to prevent any particular series from being taken into account when using the IgxValueLayerComponent element, you can set the targetSeries property on the layer. This will force the layer to target the series that you define. You can have as many IgxValueLayerComponent elements within a single IgxDataChartComponent as you want. The following sample demonstrates usage of the different valueLines in the IgxCategoryChartComponent: Angular Financial Overlays You can also plot built-in financial overlays and indicators in Angular Stock Chart. Additional Resources You can find more information about related chart types in these topics: Chart Annotations Column Chart Line Chart Stock Chart API References The following is a list of API members mentioned in the above sections: IgxDataChartComponent ItemsSource IgxValueOverlayComponent axis brush IsAxisAnnotationsEnabled IgxSeriesComponent thickness IgxValueLayerComponent ValueLayerValueMode valueLines View page on GitHub"
  },
  "components/charts/features/chart-performance.html": {
    "href": "components/charts/features/chart-performance.html",
    "title": "Angular Chart Performance | Data Visualization | Infragistics",
    "keywords": "Angular Chart Performance Angular charts are optimized for high performance of rendering millions of data points and updating them every few milliseconds. However, there are several chart features that affect performance of the chart and they should be considered when optimizing performance in your application. This topic will guide you to make Angular charts work as fast as possible in your application. Angular Chart Performance Examples The following examples demonstrates two high performance scenarios of Angular charts. Angular Chart with High-Frequency In High-Frequency scenario, the Angular Charts can render data items that are updating in real time or at specified milliseconds intervals. You will experience no lag, no screen-flicker, and no visual delays, even as you interact with the chart on a touch-device. The following sample demonstrates the IgxCategoryChartComponent in High-Frequency scenario. Angular Chart with High-Volume In High-Volume scenario, the Angular Charts can render 1 million of data points while the chart keeps providing smooth performance when end-users tries zooming in/out or navigating chart content. The following sample demonstrates the IgxCategoryChartComponent in High-Volume scenario. General Performance Guidelines This section lists guidelines and chart features that add to the overhead and processing updates in the Angular charts. Data Size If you need to plot data sources with large number of data points (e.g. 10,000+), we recommend using Angular IgxDataChartComponent with one of the following type of series which where designed for specially for that purpose. Scatter HD Chart instead of Category Point Chart or Scatter Marker Chart Scatter Polyline Chart instead of Category Line Chart or Scatter Line Chart Scatter Polygon Chart instead of Category Area Chart or Column Chart Data Structure Although Angular charts support rendering of multiple data sources by binding array of arrays of data points to ItemsSource property. It is much faster for charts if multiple data sources are flatten into single data source where each data item contains multiple data columns rather just one data column. For example: this.CategoryChart.dataSource = FlattenDataSource.create(); this.FinancialChart.dataSource = FlattenDataSource.create(); export class FlattenDataSource { public static create(): any[] { const data: any[] = []; data.push({ \"Year\": \"1996\", \"USA\": 148, \"CHN\": 110 }); data.push({ \"Year\": \"2000\", \"USA\": 142, \"CHN\": 115 }); return data; } } // instead of this data structure: export class MultiDataSources { public static create(): any[] { const dataSource1: any[] = []; dataSource1.push({ \"Year\": \"1996\", \"Value\": 148 }); dataSource1.push({ \"Year\": \"2000\", \"Value\": 142 }); const dataSource2: any[] = []; dataSource2.push({ \"Year\": \"1996\", \"Value\": 110 }); dataSource2.push({ \"Year\": \"2000\", \"Value\": 115 }); const multipleSources: any[] = [dataSource1, dataSource2]; return multipleSources; } } Data Filtering Angular IgxCategoryChartComponent and the IgxFinancialChartComponent controls have built-in data adapter that analyzes your data and generates chart series for you. However, it works faster if you use includedProperties and excludedProperties to filter only those data columns that you actually want to render. For example, this.Chart.includedProperties = [ \"Year\", \"USA\", \"RUS\" ]; this.Chart.excludedProperties = [ \"CHN\", \"FRN\", \"GER\" ]; Chart Performance Guidelines Chart Types Simpler chart types such as Line Chart have faster performance than using Spline Chart because of the complex interpolation of spline lines between data points. Therefore, you should use chartType property of Angular IgxCategoryChartComponent or the IgxFinancialChartComponent control to select type of chart that renders faster. Alternatively, you can change a type of series to a faster series in Angular IgxDataChartComponent control. The following table lists chart types in order from the fastest performance to slower performance in each group of charts: Chart Group Chart Type Pie Charts - Pie Chart - Donut Chart - Radial Pie Chart Line Charts - Category Line Chart - Category Spline Chart - Step Line Chart - Radial Line Chart - Polar Line Chart - Scatter Line Chart - Scatter Polyline Chart (*) - Scatter Contour Chart - Stacked Line Chart - Stacked 100% Line Chart Area Charts - Category Area Chart - Step Area Chart - Range Area Chart - Radial Area Chart - Polar Area Chart - Scatter Polygon Chart (*) - Scatter Area Chart - Stacked Area Chart - Stacked 100% Area Chart Column Charts - Column Chart - Bar Chart - Waterfall Chart - Range Column Chart - Radial Column Chart - Stacked Column Chart - Stacked Bar Chart - Stacked 100% Column Chart - Stacked 100% Bar Chart Spline Charts - Category Spline Chart - Polar Spline Chart - Scatter Spline Chart - Stacked Spline Chart - Stacked 100% Spline Chart Point Charts - Category Point Chart - Scatter HD Chart - Scatter Marker Chart - Scatter Bubble Chart - Polar Marker Chart Financial Charts - Stock Chart in Line Mode - Stock Chart in Column Mode - Stock Chart in Bar Mode - Stock Chart in Candle Mode - Stock Chart with Overlays - Stock Chart with Zoom Pane - Stock Chart with Volume Pane - Stock Chart with Indicator Pane Scatter Charts - Scatter HD Chart - Scatter Marker Chart - Scatter Line Chart - Scatter Bubble Chart - Scatter Spline Chart - Scatter Area Chart - Scatter Contour Chart - Scatter Polyline Chart (*) - Scatter Polygon Chart (*) Radial Charts - Radial Line Chart - Radial Area Chart - Radial Pie Chart - Radial Column Chart Polar Charts - Polar Marker Chart - Polar Line Chart - Polar Area Chart - Polar Spline Chart - Polar Spline Area Chart Stacked Charts - Stacked Line Chart - Stacked Area Chart - Stacked Column Chart - Stacked Bar Chart - Stacked Spline Chart - Stacked 100% Line Chart - Stacked 100% Area Chart - Stacked 100% Column Chart - Stacked 100% Bar Chart - Stacked 100% Spline Chart * Note that the Scatter Polygon Chart and Scatter Polyline Chart have better performance than rest of charts if you have a lot of data sources bound to the chart. For more info, see Series Collection section. Otherwise, other chart types are faster. Chart Animations Enabling Chart Animations will slightly delay final rendering series in the Angular charts while they play transition-in animations. Chart Annotations Enabling Chart Annotations such as the Callout Annotations, Crosshairs Annotations, or Final Value Annotations, will slightly decrease performance of the Angular chart. Chart Highlighting Enabling the Chart Highlighting will slightly decrease performance of the Angular chart. Chart Legend Adding a legend to the Angular charts might decrease performance if titles of series or data items mapped to legend are changing often at runtime. Chart Markers In Angular charts, Markers are especially expensive when it comes to chart performance because they add to the layout complexity of the chart, and perform data binding to obtain certain information. Also, markers decrease performance when there are a lot of data points or if there are many data sources bound. Therefore, if markers are not needed, they should be removed from the chart. This code snippet shows how to remove markers from the Angular charts. // on CategoryChart or FinancialChart this.Chart.markerTypes.clear(); this.Chart.markerTypes.add(MarkerType.None); // on LineSeries of DataChart this.LineSeries.markerType = MarkerType.None; Chart Resolution Setting the resolution property to a higher value will improve performance, but it will lower the graphical fidelity of lines of plotted series. As such, it can be increased up until the fidelity is unacceptable. This code snippet shows how to decrease resolution in the Angular charts. // on CategoryChart or FinancialChart: this.Chart.Resolution = 10; // on LineSeries of DataChart: this.LineSeries.Resolution = 10; Chart Overlays Enabling Chart Overlays will slightly decrease performance of the Angular chart. Chart Trendlines Enabling Chart Trendlines will slightly decrease performance of the Angular chart. Axis Types Usage of x-axis with DateTime support is not recommended if spaces between data points, based on the amount of time span between them, are not important. Instead, ordinal/category axis should be used because it is more efficient in the way it coalesces data. Also, ordinal/category axis doesn’t perform any sorting on the data like the time-based x-axis does. [!Note] The IgxCategoryChartComponent already uses ordinal/category axis so there is no need to change its properties. This code snippet shows how to ordinal/category x-axis in the IgxFinancialChartComponent and IgxDataChartComponent controls. <igx-financial-chart xAxisMode=\"Ordinal\"></igx-financial-chart> <igx-data-chart> <igx-category-x-axis label=\"Time\"></igx-category-x-axis> </igx-data-chart> Axis Intervals By default, Angular charts will automatically calculate yAxisInterval based on range of your data. Therefore, you should avoid setting axis interval especially to a small value to prevent rendering of too many of axis gridlines and axis labels. Also, you might want to consider increasing yAxisInterval property to a larger value than the automatically calculated axis interval if you do not need many axis gridlines or axis labels. [!Note] We do not recommend setting axis minor interval as it will decrease chart performance. This code snippet shows how to set axis major interval in the Angular charts. <igx-category-chart xAxisInterval=\"5\" yAxisInterval=\"50\"></igx-category-chart> <igx-financial-chart xAxisInterval=\"5\" yAxisInterval=\"50\"></igx-financial-chart> <igx-data-chart> <igx-category-x-axis name=\"xAxis\" interval=\"5\"></igx-category-x-axis> <igx-numeric-y-axis name=\"yAxis\" interval=\"50\"></igx-numeric-y-axis> </igx-data-chart> Axis Scale Setting the yAxisIsLogarithmic property to false is recommended for higher performance, as fewer operations are needed than calculating axis range and values of axis labels in logarithmic scale. Axis Labels Visibility In the same way as Markers, axis labels are also expensive because they use templates and bindings, and may have their data context changed often. If labels are not used, they should be hidden or their interval should be increased to decrease number of axis labels. This code snippet shows how to hide axis labels in the Angular charts. <igx-category-chart xAxisLabelVisibility=\"Collapsed\" yAxisLabelVisibility=\"Collapsed\"> </igx-category-chart> <igx-financial-chart xAxisLabelVisibility=\"Collapsed\" yAxisLabelVisibility=\"Collapsed\"> </igx-financial-chart> <igx-data-chart> <igx-category-x-axis name=\"xAxis\" labelVisibility=\"Collapsed\"></igx-category-x-axis> <igx-numeric-y-axis name=\"yAxis\" labelVisibility=\"Collapsed\"></igx-numeric-y-axis> </igx-data-chart> Axis Labels Abbreviation Although, the Angular charts support abbreviation of large numbers (e.g. 10,000+) displayed in axis labels when yAxisAbbreviateLargeNumbers is set to true. We recommend, instead pre-processing large values in your data items by dividing them a common factor and then setting yAxisTitle to a string that represents factor used used to abbreviate your data values. This code snippet shows how to set axis title in the Angular charts. <igx-category-chart yAxisTitle=\"In millions of Dollars\"></igx-category-chart> <igx-financial-chart yAxisTitle=\"In millions of Dollars\"></igx-financial-chart> <igx-data-chart> <igx-numeric-y-axis title=\"In millions of Dollars\"></igx-numeric-y-axis> </igx-data-chart> Axis Labels Extent At runtime, the Angular charts adjust extent of labels on y-axis based on a label with longest value. This might decrease chart performance if range of data changes and labels need to be updated often. Therefore, it is recommended to set label extent at design time in order to improve chart performance. The following code snippet shows how to set a fixed extent for labels on y-axis in the Angular charts. <igx-category-chart xAxisLabelExtent=\"50\" yAxisLabelExtent=\"50\"></igx-category-chart> <igx-financial-chart xAxisLabelExtent=\"50\" yAxisLabelExtent=\"50\"></igx-financial-chart> <igx-data-chart> <igx-category-x-axis name=\"xAxis\" labelExtent=\"50\"></igx-category-x-axis> <igx-numeric-y-axis name=\"yAxis\" labelExtent=\"50\"></igx-numeric-y-axis> </igx-data-chart> Axis Other Visuals Enabling additional axis visuals (e.g. axis titles) or changing their default values might decrease performance in the Angular charts. For example, changing these properties on the IgxCategoryChartComponent or IgxFinancialChartComponent control: Axis Visual X-Axis Properties Y-Axis Properties All Axis Visual xAxisInterval xAxisMinorInterval yAxisInterval yAxisMinorInterval Axis Tickmarks xAxisTickStroke xAxisTickStrokeThickness xAxisTickLength yAxisTickStroke yAxisTickStrokeThickness yAxisTickLength Axis Major Gridlines xAxisMajorStroke xAxisMajorStrokeThickness yAxisMajorStroke yAxisMajorStrokeThickness Axis Minor Gridlines xAxisMinorStroke xAxisMinorStrokeThickness yAxisMinorStroke yAxisMinorStrokeThickness Axis Main Line xAxisStroke xAxisStrokeThickness yAxisStroke yAxisStrokeThickness Axis Titles xAxisTitle xAxisTitleAngle yAxisTitle yAxisTitleAngle Axis Strips xAxisStrip yAxisStrip Or changing properties of an IgxAxisComponent in the IgxDataChartComponent control: Axis Visual Axis Properties All Axis Visuals Interval, MinorInterval Axis Tickmarks TickStroke , TickStrokeThickness, TickLength Axis Major Gridlines MajorStroke, MajorStrokeThickness Axis Minor Gridlines MinorStroke, MinorStrokeThickness Axis Main Line Stroke, StrokeThickness Axis Titles chartTitle, TitleAngle Axis Strips Strip Performance in Financial Chart In addition to above performance guidelines, the Angular IgxFinancialChartComponent control has the following unique features that affect performance. Y-Axis Mode Setting the yAxisMode option to Numeric is recommended for higher performance, as fewer operations are needed than using PercentChange mode. Chart Panes Setting a lot of panes using indicatorTypes and overlayTypes options, might decrease performance and it is recommended to use a few financial indicators and one financial overlay. Zoom Slider Setting the zoomSliderType option to None will improve chart performance and enable more vertical space for other indicators and the volume pane. Volume Type Setting the volumeType property can have the following impact on chart performance: None - is the least expensive since it does not display the volume pane. Line - is more expensive volume type to render and it is recommended when rendering a lot of data points or when plotting a lot of data sources. Area - is more expensive to render than the Line volume type. IgxColumn - is more expensive to render than the Area volume type and it is recommended when rendering volume data of 1-3 stocks. Performance in Data Chart In addition to the general performance guidelines, the Angular IgxDataChartComponent control has the following unique features that affect performance. Axes Collection Adding too many axis to the Axes collection of the IgxDataChartComponent control will decrease chart performance and we recommend Sharing Axes between series. Series Collection Also, adding a lot of series to the IgxSeriesComponent collection of the Angular IgxDataChartComponent control will add overhead to rendering because each series has its own rendering canvas. This is especially important if you have more than 10 series in the Data Chart. We recommend combining multiple data sources into flatten data source (see Data Structure section) and then using conditional styling feature of the following series: Slower Performance Scenario Faster Scenario with Conditional Styling 10+ of IgxLineSeriesComponent Single IgxScatterLineSeriesComponent 20+ of IgxLineSeriesComponent Single IgxScatterPolylineSeriesComponent 10+ of IgxScatterLineSeriesComponent Single IgxScatterPolylineSeriesComponent 10+ of IgxPointSeriesComponent Single IgxScatterSeriesComponent 20+ of IgxPointSeriesComponent Single IgxHighDensityScatterSeriesComponent 20+ of IgxScatterSeriesComponent Single IgxHighDensityScatterSeriesComponent 10+ of IgxAreaSeriesComponent Single IgxScatterPolygonSeriesComponent 10+ of IgxColumnSeriesComponent Single IgxScatterPolygonSeriesComponent Additional Resources You can find more information about related chart types in these topics: Area Chart Bar Chart Bubble Chart Column Chart Donut Chart Pie Chart Point Chart Polar Chart Radial Chart Shape Chart Spline Chart Scatter Chart Stacked Chart Step Chart Stock Chart Chart Animations Chart Annotations Chart Highlighting Chart Markers Chart Overlays Chart Trendlines API References The following table lists API members mentioned in above sections: resolution indicatorTypes overlayTypes volumeType zoomSliderType xAxisMode yAxisMode xAxisInterval yAxisInterval xAxisMinorInterval yAxisMinorInterval xAxisLabelVisibility yAxisLabelVisibility yAxisIsLogarithmic View page on GitHub"
  },
  "components/charts/features/chart-synchronization.html": {
    "href": "components/charts/features/chart-synchronization.html",
    "title": "Angular Data Chart | Data Visualization Tools | Synchronization | Infragistics",
    "keywords": "Angular Chart Synchronization The Ignite UI for Angular data chart allows for synchronization with respect to the coordination of zooming, panning, and crosshair events between multiple charts. This can help you to visualize the same areas of multiple charts, assuming your data sources are similar or the same with respect to the axes. Angular Chart Synchronization Example This sample shows synchronization of two Angular data charts: Chart Synchronization Properties There are four options of chart synchronization, in that you can synchronize horizontally only, vertically only, both, or you can choose not to synchronize at all, which is the default. If you want to synchronize a set of charts, you can assign them the same name to the SyncChannel property and then specify whether or not to synchronize the charts horizontally and/or vertically by setting the SynchronizeHorizontally and SynchronizeVertically properties to the corresponding boolean value. Note that in order to synchronize either vertically and/or horizontally, you will need to set the isHorizontalZoomEnabled and/or isVerticalZoomEnabled property to true, respectively. A synchronized chart that is dependent on another chart will still zoom regardless of this property setting. API References The following is a list of API members mentioned in the above sections: isHorizontalZoomEnabled isVerticalZoomEnabled SyncChannel SynchronizeHorizontally SynchronizeVertically IgxDataChartComponent View page on GitHub"
  },
  "components/charts/features/chart-titiles.html": {
    "href": "components/charts/features/chart-titiles.html",
    "title": "Angular Chart Titles | Data Visualization Tools | Infragistics",
    "keywords": "Angular Chart Titles View page on GitHub"
  },
  "components/charts/features/chart-tooltips.html": {
    "href": "components/charts/features/chart-tooltips.html",
    "title": "Angular Chart Tooltips | Data Visualization | Infragistics",
    "keywords": "Angular Chart Tooltips In Angular charts, tooltips provide details about bound data and they are rendered in popups when the end-user hovers over data points. Tooltips are supported by the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent controls. Angular Chart Tooltip Types Angular Chart provide three types of tooltips that you can with tooltips enabled by setting the toolTipType property. The following example shows the Column Chart with a combo-box that you can use to change type of tooltips. The toolTipType property is configurable and can be set to one of the following options: Property Value Description Default Tooltip Display a tooltip for a single item when the pointer is positioned over it. Data Tooltip Display the data tooltips for all series in the chart. Item Tooltip Display a tooltip for each data item in the category that the pointer is positioned over. Category Tooltip Display a grouped tooltip for all data points in the category that the pointer is positioned over. Angular Chart Tooltip Template If none of built-in types of tooltips are matching your requirements, you can create your own tooltips to display and style series title, data values, and axis values. The following sections demonstrate how to do this in different types of Angular charts. Custom Tooltips in Category Chart This example shows how to create custom tooltips for all series in Angular IgxCategoryChartComponent control. Note that you can also apply the same logic to custom tooltips in Angular IgxFinancialChartComponent control. Custom Tooltips in Data Chart This example shows how to create custom tooltips for each series in Angular Data Chart control. Additional Resources You can find more information about related chart features in these topics: Chart Annotations Chart Markers API References The IgxCategoryChartComponent and IgxFinancialChartComponent components share the following API properties: toolTipType In the IgxDataChartComponent component, you can use the following API components and properties: IgxDataToolTipLayerComponent IgxItemToolTipLayerComponent IgxCategoryToolTipLayerComponent ShowDefaultToolTip View page on GitHub"
  },
  "components/charts/features/chart-trendlines.html": {
    "href": "components/charts/features/chart-trendlines.html",
    "title": "Angular Chart Trendlines | Data Visualization | Infragistics",
    "keywords": "Angular Chart Trendlines In Ignite UI for Angular charts, trendlines help in identifying a trend or finding patterns in data. Trendlines are always rendered in front of data points bound to the chart and are supported by the IgxCategoryChartComponent, IgxFinancialChartComponent, and IgxDataChartComponent (except for stacked series, shape series, and range series). Trendlines are off by default, but you can enable them by setting the trendLineType property. Also, you can modify multiple appearance properties of trendlines such as its brush, period, and thickness. The trendlines also have the ability to have a dash array applied to them once enabled. This is done by setting the TrendLineDashArray property to an array of numbers. The numeric array describes the length of the dashes of the trendline. Angular Chart Trendlines Example The following sample depicts a IgxFinancialChartComponent showing the stock trend of Microsoft between 2013 and 2017 with a QuinticFit trendline initially applied. There is a drop-down that will allow you to change the type of trendline that is applied, and all possible trendline types are listed within that drop-down. Angular Chart Trendlines Dash Array Example The following sample depicts a IgxDataChartComponent showing a IgxFinancialPriceSeriesComponent with a QuarticFit dashed trendline applied via the trendLineDashArray property: Additional Resources You can find more information about related chart features in these topics: Chart Annotations Chart Highlighting API References The IgxCategoryChartComponent and IgxFinancialChartComponent components share the following API properties: trendLineBrushes trendLinePeriod trendLineThickness trendLineType In the IgxDataChartComponent component, most types of series have the following API properties: trendLineBrush trendLineDashArray trendLinePeriod trendLineThickness trendLineType View page on GitHub"
  },
  "components/charts/types/area-chart.html": {
    "href": "components/charts/types/area-chart.html",
    "title": "Angular Area Chart | Data Visualization | Infragistics",
    "keywords": "Angular Area Chart The Ignite UI for Angular Area Chart renders as a collection of points connected by straight line segments with the area below the line filled in. Values are represented on the y-axis (labels on the left side) and categories are displayed on the x-axis (bottom labels). This chart emphasize the amount of change over a period of time or compare multiple items as well as the relationship of parts of a whole by displaying the total of the plotted values. Therefore, they are often chronological, showing a change of quantity e.g. accumulation of a commodity over time. Angular Area Chart Example You can create Angular Category Area Chart in the IgxCategoryChartComponent control by binding your data to ItemsSource property and setting chartType property to Area enum, as shown in the example below. Area Chart Recommendations Area Chart Use Cases There are several common use cases for choosing an Area Chart: Have a large, high-volume data set that fits well with the chart interactions like Panning, Zooming, and Drill-down. Need to compare the trends of your data over time. Want to show the difference between 2 or more data series. Want to show cumulative part-to-whole comparisons of distinct categories. Need to show data trends for one or more categories for comparative analysis. Need to visualize details time-series data. Area Chart Best Practices Always start the Y-Axis (left or right axis) at 0 so data comparison is accurate. Order time-series data from left to right. Use transparent colors to ensure that data that is plotted behind another series is not blocked. When Not to Use Area Charts You have many (more than 7 or 10) series of data. Your goal is to ensure the chart is readable. Time-series data has similar values (data over the same period). This makes overlapped shaded areas impossible to differentiate. Area Chart Data Structure The data source must be an array or a list of data items (for single series). The data source must be an array of arrays or a list of lists (for multiple series). The data source should contain two or more data items in order to render a line between them. All data items must contain at least one data column (string or date time). All data items must contain at least one numeric data column. Angular Area Chart with Single Series Angular Area Chart is often used to show the change of value over time such as the amount of renewable electricity produced. You can create this type of chart in IgxCategoryChartComponent control by binding your data and setting chartType property to Area value, as shown in the example below. Angular Area Chart with Multiple Series Similarly to how you can show multiple Line Chart and Spline Chart, you may also combine multiple Area Charts in the same control. This is accomplished by binding multiple data source to ItemsSource property of the IgxCategoryChartComponent control. Angular Area Chart Styling Area charts often have semi-transparent fill for their areas, thicker lines and slightly larger markers than usual. Below is an example showing how you can style the Area Chart from earlier accordingly. Advanced Types of Area Charts The following sections explain more advanced types of Angular Area Charts that can be created using the IgxDataChartComponent control instead of IgxCategoryChartComponent control with simplified API. Angular Step Area Chart The Angular Step Area Chart belongs to a group of category charts and it is rendered using a collection of points connected by continuous vertical and horizontal lines with the area below lines filled in. Values are represented on the y-axis and categories are displayed on the x-axis. The step area chart emphasizes the amount of change over a period of time or compares multiple items. You can create this type of chart in IgxCategoryChartComponent control by binding your data and setting chartType property to StepArea value, as shown in the example below. Advanced Types of Area Charts The following sections explain more advanced types of Angular Area Charts that can be created using the IgxDataChartComponent control instead of IgxCategoryChartComponent control with simplified API. Angular Range Area Chart The Angular Range Area Chart allows you show the area as a range between two values over time. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxRangeAreaSeriesComponent, as shown in the example below. Angular Stacked Area Chart The Angular Stacked Area Chars is rendered using a collection of points connected by line segments, with the area below the line filled in and stacked on top of each other. Stacked Area Charts follow all the same requirements as Area Charts, with the only difference being that visually, the shaded areas are stacked on top of each other. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxStackedAreaSeriesComponent, as shown in the example below. Angular Stacked 100% Area Chart The Angular Stacked 100% Area Chart allows you represent your data as part of a whole being changed over time e.g. a country's energy consumption related to the sources from which it is produced. In such cases representing all stacked elements equally may be a better idea. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxStacked100AreaSeriesComponent, as shown in the example below. Angular Stacked Spline Area Chart The Angular Stacked Spline Area Chart is rendered using a collection of points connected by curved spline segments, with the area below the curved spline fill in and stacked on top of each other. Stacked Spline Area Chart follows all of the same requirements as area charts, with the only difference being that the visually shaded areas are stacked on top of each other. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxStackedSplineAreaSeriesComponent, as shown in the example below. Angular Stacked 100% Spline Area Chart The Angular Stacked 100% Spline Area Chart is identical to the Stacked Spline Area Chart in all aspects except for the treatment of the values on the y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Spline Area Chart presents the data in terms of a percent of the sum of all values in a particular data point. Sometimes the chart represents part of a whole being changed over time. For example, a country's energy consumption related to the sources from which it is produced. In such cases, representing all stacked elements equally may be a better idea. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxStacked100SplineAreaSeriesComponent, as shown in the example below. Angular Radial Area Chart The Angular Radial Area Chart belongs to a group of Radial Chart and has a shape of a filled polygon that is bound by a collection of straight lines connecting data points. This chart type uses the same concept of data plotting as the Area Chart, but wraps the data points around a circular axis rather than stretching them horizontally. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxRadialAreaSeriesComponent, as shown in the example below. Angular Polar Area Chart The Angular Polar Area Chart belongs to a group of Polar Chart and have a shape of a filled polygon, where vertices or corners are located at the polar (angle/radius) coordinates of data points and are connected by a straight line and then filling the area represented by the connected points. The Polar Area Chart uses the same concepts of data plotting as the Scatter Marker Chart, but instead wraps the points around a circle and fills in the area that is drawn, rather than stretching the points and area filled along a horizontal line. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxPolarAreaSeriesComponent, as shown in the example below. Angular Polar Spline Area Chart The Angular Polar Spline Area Chart belongs to a group of Polar Chart and have a shape of a filled polygon, where vertices or corners are located at the polar (angle/radius) coordinates of data points and are connected by a curved spline and then filling the area represented by the connected points. The Polar Spline Area Chart uses the same concepts of data plotting as the Scatter Marker Chart, but instead wraps the points around a circle and fills in the area that is drawn, rather than stretching the points and area filled along a horizontal line. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxPolarSplineAreaSeriesComponent, as shown in the example below. Additional Resources You can find more information about related chart types in these topics: Bar Chart Column Chart Polar Chart Radial Chart Spline Chart Stacked Chart API References The following table lists API members mentioned in above sections: Chart Type Control Name API Members Area IgxCategoryChartComponent chartType = Area Step Area IgxCategoryChartComponent chartType = StepArea Range Area IgxDataChartComponent IgxRangeAreaSeriesComponent Radial Area IgxDataChartComponent IgxRadialAreaSeriesComponent Polar Area IgxDataChartComponent IgxPolarAreaSeriesComponent Polar Spline Area IgxDataChartComponent IgxPolarSplineAreaSeriesComponent Stacked Area IgxDataChartComponent IgxStackedAreaSeriesComponent Stacked Spline Area IgxDataChartComponent IgxStackedSplineAreaSeriesComponent Stacked 100% Area IgxDataChartComponent IgxStacked100AreaSeriesComponent Stacked 100% Spline Area IgxDataChartComponent IgxStacked100SplineAreaSeriesComponent View page on GitHub"
  },
  "components/charts/types/bar-chart.html": {
    "href": "components/charts/types/bar-chart.html",
    "title": "Angular Bar Chart and Graph | Ignite UI for Angular",
    "keywords": "Angular Bar Chart The Ignite UI for Angular Bar Chart, Bar Graph, or Horizontal Bar Chart, is among the most common category chart types used to quickly compare frequency, count, total, or average of data in different categories with data encoded by horizontal bars with equal heights but different lengths. This chart is ideal for showing variations in the value of an item over time. Data is represented using a collection of rectangles that extend from the left to right of the chart towards the values of data points. Bar Chart is very similar to Column Chart except that Bar Chart renders with 90 degrees clockwise rotation and therefore it has horizontal orientation (left to right) while Column Chart has vertical orientation (up and down) Angular Bar Chart Example You can create Angular Bar Chart in the IgxDataChartComponent control by binding your data sources to multiple IgxBarSeriesComponent, as shown in the example below: Bar Chart Recommendations Are Angular Bar Charts right for your project? Angular Bar Chart includes several variants based on your data or how you want to tell the correct story with your data. These include: Grouped Bar Chart Stacked Bar Chart Polar Bar Chart Stacked 100 Bar Chart Bar Chart Use Cases There are several common use cases for choosing a Bar Chart: You need to show trends over time or a numeric value change in a category of data. You need to compare data values of 1 or more data series. You want to show a part-to-whole comparison. You want to show top or bottom percentage of categories. Analyzing multiple data points grouped in sub-categories (Stacked Bar). These use cases are commonly used for the following scenarios: Sales Management. Inventory Management. Stock Charts. Any String Value Comparing a Numeric Value or Time-Series Value. Bar Chart Best Practices: Start you numeric Axis at 0. Use a single color for the bars. Be sure the space separating each bar is 1/2 the width of the bar itself. Be sure ranking or comparing ordered categories (items) are sorted in increasing or decreasing order. Right-align category values on the Y-Axis (left side labels of chart) for readability. When Not to Use Bar Chart You have too much data so the Y-Axis can't fit in the space or is not legible. You need a detailed Time-Series analysis - consider a Line Chart with a Time-Series for this type of data. Bar Chart Data Structure: The data source must be an array or a list of data items. The data source must contain at least one data item. The list must contain at least one data column (string or date time). The list must contain at least one numeric data column. Angular Bar Chart with Single Series Bar Chart belongs to a group of Category Series and it is rendered using a collection of rectangles that extend from the left to right of the chart towards the values of data points. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxBarSeriesComponent, as shown in the example below: Angular Bar Chart with Multiple Series The Bar Chart is able to render multiple bars per category for comparison purposes. In this example, the Bar Chart is comparing box office revenue amongst popular movie franchises. You can create this type of chart in the IgxDataChartComponent control by binding your data to multiple IgxBarSeriesComponent, as shown in the example below: Angular Bar Chart Styling The Bar Chart can be styled, and allows for the ability to use annotation values for each bar, for example, to demonstrate percent comparisons. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxBarSeriesComponent and adding a IgxCalloutLayerComponent, as shown in the example below: Angular Stacked Bar Chart A Stacked Bar Chart, or Stacked Bar Graph, is a type of category chart that is used to compare the composition of different categories of data by displaying different sized fragments in the horizontal bars of the chart. The length of each bar, or stack of fragments, is proportionate to its overall value. The Stacked Bar Chart differs from the Bar Chart in that the data points representing your data are stacked next to each other horizontally to visually group your data. Each stack can contain both positive and negative values. All positive values are grouped on the positive side of the X-Axis, and all negative values are grouped on the negative side of the X-Axis. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedBarSeriesComponent, as shown in the example below: Angular Stacked 100% Bar Chart The Angular Stacked 100% Bar Chart is identical to the Angular Stacked Bar Chart in all aspects except in their treatment of the values on X-Axis (bottom labels of the chart). Instead of presenting a direct representation of the data, the stacked 100 bar chart presents the data in terms of percent of the sum of all values in a data point. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100BarSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Column Chart Line Chart Spline Chart Stacked Chart API References The following table lists API members mentioned in the above sections: IgxDataChartComponent ItemsSource IgxBarSeriesComponent IgxCalloutLayerComponent IgxStackedBarSeriesComponent IgxStacked100BarSeriesComponent IgxStackedBarSeriesComponent View page on GitHub"
  },
  "components/charts/types/bubble-chart.html": {
    "href": "components/charts/types/bubble-chart.html",
    "title": "Angular Bubble Chart | Data Visualization | Infragistics",
    "keywords": "Angular Bubble Chart The Ignite UI for Angular Bubble Chart is a type of Scatter Chart that show markers with variable scaling to represent the relationship among items in several distinct series of data or to plot data items using x and y coordinates. These coordinates of the data point are determined by two numeric data columns. The Bubble Chart draws attention to uneven intervals or clusters of data. This chart is often used to plot scientific data, and can highlight the deviation of collected data from predicted results. The Bubble Chart has many of the characteristics of the Scatter Marker Chart but with the option to have various radius scale sizes. Angular Bubble Chart Example You can create Ignite UI for Angular Bubble Chart in IgxDataChartComponent control using the IgxBubbleSeriesComponent and two numeric axes, as shown in the example below. Angular Bubble Chart with Single Series You can bind your data to ItemsSource property of IgxBubbleSeriesComponent and map data columns using its xMemberPath, yMemberPath, radiusMemberPath properties, as shown in the example below: Angular Bubble Chart with Multiple Series In Angular Bubble Chart, binding multiple data sources works by setting each new data source to ItemsSource property of a additional IgxBubbleSeriesComponent, as shown in the example below: Angular Bubble Chart Styling In Angular Bubble Chart, you can customize shape of bubble markers using markerType property, their size with radiusScale property, and their appearance using markerBrush, markerOutline, markerThickness properties. In addition, you can also color bubble markers based on a data column using fillMemberPath and fillScale properties. In this example, usage of above properties is demonstrated. Additional Resources Scatter Chart Shape Chart API References The following table lists API members mentioned in the above sections: IgxDataChartComponent IgxBubbleSeriesComponent IgxScatterSeriesComponent ItemsSource fillMemberPath fillScale markerType markerBrush markerOutline markerThickness radiusScale radiusMemberPath xMemberPath yMemberPath View page on GitHub"
  },
  "components/charts/types/column-chart.html": {
    "href": "components/charts/types/column-chart.html",
    "title": "Angular Column Chart | Data Visualization | Infragistics",
    "keywords": "Angular Column Chart The Ignite UI for Angular Column Char, Column Graph, or Vertical Bar Chart is among the most common category chart types used to quickly compare frequency, count, total, or average of data in different categories with data encoded by columns with equal widths but different heights. These columns extend from the bottom to top of the chart towards the values of data points. This chart emphasizes the amount of change over a period of time or compares multiple items. Column Chart is very similar to Bar Chart except that Column Chart renders in vertical orientation (up and down) while Bar Chart has horizontal orientation (left to right) or 90 degrees clockwise rotation. Angular Column Chart Example You can create Angular Column Chart in the IgxCategoryChartComponent control by binding your data and setting chartType to Column enum, as shown in the example below: Column Charts Recommendations Column Charts Use Cases There are several uses cases for Column Charts. When you: Need to compare data values of related categories. Need to compare data over a time period. Need to display negative values as well as positive values in the same data set. Have a large, high-volume data set that fits well with the chart interactions like Panning, Zooming, and Drill-down. Column Charts Best Practices: Always start the Y-Axis (left or right axis) at 0 so data comparison is accurate. Order time-series data from left to right. When Not to Use Column Charts You have many (more than 10 or 12) series of data. Your goal is to ensure the chart is readable. Column Charts Data Structure: The data model must contain at least one numeric property. The data model may contain an options string or date-time property for labels. The data source should contain at least one data item. Angular Column Chart with Single Series Column Chart belongs to a group of Category Series and it is rendered using a collection of rectangles that extend from the bottom to top of the chart towards the values of data points. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Column value, as shown in the example below: Angular Column Chart with Multiple Series The Column Chart is able to render multiple columns per category for comparison purposes. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Column value, as shown in the example below: Angular Column Chart Styling The Angular Column Chart has many options for styling and modification of the visual appearance. You can create this type of chart in the IgxCategoryChartComponent control by binding your data, as shown in the example below: Advanced Types of Column Charts The following sections explain more advanced types of Angular Column Charts that can be created using the IgxDataChartComponent control instead of IgxCategoryChartComponent control with simplified API. Angular Waterfall Chart The Waterfall Chart belongs to a group of category charts and it is rendered using a collection of vertical columns that show the difference between consecutive data points. The columns are color coded for distinguishing between positive and negative changes in value. The Waterfall Chart is similar in appearance to the Range Column Chart, but it requires only one numeric data column rather than two columns for each data point. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxWaterfallSeriesComponent, as shown in the example below: Angular Stacked Column Chart The Stacked Column Chart is similar to the Category Column Chart in all aspects, except the series are represented on top of one another rather than to the side. The Stacked Column Chart is used to show comparing results between series. Each stacked fragment in the collection represents one visual element in each stack. Each stack can contain both positive and negative values. All positive values are grouped on the positive side of the Y-Axis, and all negative values are grouped on the negative side of the Y-Axis. The Stacked Column Chart uses the same concepts of data plotting as the Stacked Bar Chart but data points are stacked along vertical line (Y-Axis) rather than along horizontal line (X-Axis). You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedBarSeriesComponent, as shown in the example below: Angular Stacked 100% Column Chart The Stacked 100% Column Chart is identical to the Stacked Column Chart in all aspects except in their treatment of the values on Y-Axis. Instead of presenting a direct representation of the data, the Stacked 100 Column Chart presents the data in terms of percent of the sum of all values in a data point. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100BarSeriesComponent, as shown in the example below: Angular Range Column Chart The Angular Range Column Chart belongs to a group of range charts and is rendered using vertical rectangles that can appear in the middle of the plot area of the chart, rather than stretching from the bottom like the traditional Category Column Chart. This type of series emphasizes the amount of change between low values and high values in the same data point over a period of time or compares multiple items. Range values are represented on the Y-Axis and categories are displayed on the X-Axis. The Range Column Chart is identical to the Range Area Chart(area-chart.md#angular-range-area-chart) in all aspects except that the ranges are represented as a set of vertical columns rather than a filled area. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxRangeColumnSeriesComponent, as shown in the example below: Angular Radial Column Chart The Radial Column Chart belongs to a group of Radial Chart, and is visualized by using a collection of rectangles that extend from the center of the chart toward the locations of data points. This utilizes the same concepts of data plotting as the Category Column Chart, but wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxRadialColumnSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Bar Chart Composite Chart Radial Chart Stacked Chart API References The following table lists API members mentioned in the above sections: Chart Type Control Name API Members Column IgxCategoryChartComponent chartType = Column Radial Column IgxDataChartComponent IgxRadialColumnSeriesComponent Range Column IgxDataChartComponent IgxRangeColumnSeriesComponent Stacked Column IgxDataChartComponent IgxStackedColumnSeriesComponent Stacked 100% Column IgxDataChartComponent IgxStacked100ColumnSeriesComponent Waterfall IgxDataChartComponent IgxWaterfallSeriesComponent View page on GitHub"
  },
  "components/charts/types/composite-chart.html": {
    "href": "components/charts/types/composite-chart.html",
    "title": "Angular Composite Chart | Combo Chart| Data Visualization | Infragistics",
    "keywords": "Angular Composite / Combo Chart The Ignite UI for Angular Composite Chart, also called a Combo Chart, is visualization that combines different types of chart types in the same plot area. It is very useful when presenting two data series that have a very different scale and might be expressed in different units. The most common example is dollars on one axis and percentage on the other axis. Angular Composite / Combo Example The following example demonstrates how to create Composite Chart using IgxColumnSeriesComponent and IgxLineSeriesComponent in the IgxDataChartComponent control. Additional Resources Bar Chart Column Chart Line Chart Stacked Chart API References IgxCategoryXAxisComponent IgxColumnSeriesComponent IgxLineSeriesComponent IgxNumericYAxisComponent IgxDataChartComponent View page on GitHub"
  },
  "components/charts/types/donut-chart.html": {
    "href": "components/charts/types/donut-chart.html",
    "title": "Angular Donut Chart | Data Visualization | Infragistics",
    "keywords": "Angular Donut Chart The Ignite UI for Angular Donut Chart is similar to the Pie Chart, proportionally illustrating the occurrences of a variable. The donut chart can display multiple variables in concentric rings, and provides built-in support for visualizing hierarchical data. The rings are capable of being bound to a different data item, or they can share a common data source. Angular Donut Chart Example You can create Donut Chart using the IgxDoughnutChartComponent control by binding your data as shown in the example below. Angular Donut Chart Recommendations Are Angular Donut Charts right for your project? Donut Charts are appropriate for small data sets and are easy to read at a glance. Donut charts are just one type of part-to-whole visualization. Others include: Pie Stacked Area Stacked 100% Area (Stacked Percentage Area) Stacked Bar Stacked 100% Bar (Stacked Percentage Bar) Treemap Waterfall The Angular Donut Chart includes interactive features that give the viewer tools to analyze data, like: Legends Slice Explosion Slice Selection Chart Animations Best Practices for Donut Charts Using multiple data sets to display your data in a ring display. Placing the information such as values or labels, within the hole of the donut for quick explanation of data. Comparing slices or segments as percentage values in proportion to a total value or whole. Showing how a group of categories is broken into smaller segments. Ensuring data segments add up to 100%. Ensuring the color palette is distinguishable for segments/slices of the parts. When not to use a Donut Chart Comparing change over time —use a Bar, Line or Area chart. Requiring precise data comparison —use a Bar, Line or Area chart. You have more than 6 or 8 segments (high data volume) — consider a Bar, Line or Area chart if it works for your data story. It would be easier for the viewer to perceive the value difference in a Bar chart. You have negative data, as this can not be represented in a donut chart. Angular Donut Chart - Slice Selection The Angular Donut Chart has the ability to select slices on click. Optionally, you may apply a single custom visual style to the selected slices. The SliceClick event is raised when the user clicks on a slice. Enabling slice selection allows you to modify the slice's selection upon click. The following sample demonstrates how to enable slice selection and set the selected slice color to gray. Angular Donut Chart - Multiple Rings It is possible to have a multiple ring display in the Angular Donut Chart, with each of the rings capable of being bound to a different data item, or they can share a common data source. This can be helpful if you need to display your data as tiers that have an underlying common category, such as the season to month data display below: Additional Resources You can find more information about related chart types in these topics: Pie Chart Polar Chart Radial Chart API References The following table lists API members mentioned in the above sections: IgxDoughnutChartComponent allowSliceExplosion allowSliceSelection innerExtent SliceClick View page on GitHub"
  },
  "components/charts/types/line-chart.html": {
    "href": "components/charts/types/line-chart.html",
    "title": "Angular Line Chart and Graph | Ignite UI for Angular",
    "keywords": "Angular Line Chart The Ignite UI for Angular Line Chart or Line Graph is a type of category charts that show the continuous data values represented by points connected by straight line segments of one or more quantities over a period of time. It’s often used to show trends and perform comparative analysis. The Y-Axis (labels on left side) show a numeric value, while the X-Axis (bottom labels) show a time-series or comparison category. You can include one or more data sets to compare, which would render as multiple lines in the chart. Angular Line Chart Example You can create the Angular Line Chart in the IgxCategoryChartComponent control by binding your data to ItemsSource property and setting chartType property to Line enum, as shown in the example below. Line Chart Recommendations Are Angular Line Charts right for your project? Different than an area chart, the line chart does not fill the area between the X-Axis (bottom axis) and the line. The Angular line chart is identical to the Angular spline chart in all aspects except that the line connecting data points does not have spline interpolation and smoothing for improved presentation of data. A Line Chart includes several variants based on your data or how you want to tell the correct story with your data. These include: Layered Line Chart Stacked Line Chart Stepped Line Chart Polar Line Chart Stacked 100 Line Chart Line Chart Use Cases There are several common use cases for choosing a Line Chart: Have a large, high-volume data set that fits well with the chart interactions like Panning, Zooming and Drill-down. Need to compare the trends over time. Want to show the difference between 2 or more data series. Want to show cumulative part-to-whole comparisons of distinct categories. Need to show data trends for one or more categories for comparative analysis. Need to visualize detailed time-series data. Line Chart Best Practices: Always start the Y-Axis (left or right axis) at 0 so data comparison is accurate. Order time-series data from left to right. Use visual attributes like solid lines to show a series of data. When Not to Use Line Chart You have many (more than 7 or 10) series of data. Your goal is to ensure the chart is readable. Time-series data has similar values (data over the same period), it makes overlapped lines impossible to differentiate. Line Chart Data Structure: The data source must be an array or a list of data items (for single series). The data source must be an array of arrays or a list of lists (for multiple series). The data source must contain at least one data item. All data items must contain at least one data column (string or date time). All data items must contain at least one numeric data column. Angular Line Chart with Single Series The Angular Line Chart is often used to show the change of value over time such as the amount of renewable electricity produced since 2009 over a ten-year period, as we have shown in the example below. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Line, as shown in the example below: Angular Line Chart with Multiple Series Since the Angular Line Chart allows you to combine multiple series and compare or see how they change over time, let’s see how easy it is to achieve this. All we need to do is bind to a data source containing the data for China and the USA, and the line chart will automatically update to fit the additional data. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Line, as shown in the example below: Angular Line Chart with Live Data The Angular Line chart is capable of handling high volumes of data, ranging into millions of data points, and updating them every few milliseconds as demonstrated in the following demo. In this example, we are streaming live data into the Angular Line Chart at an interval of your choosing. You can set the data points from 5,000 to 1 million and update the chart to optimize the scale based on the device you are rendering the chart on. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Line, as shown in the example below: Angular Styling Line Chart Once our chart is set up, we may want to make some further styling customizations such as change the line colors, change the legend font family, and/or increase the size of the axis labels to make it easier to read. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Line, as shown in the example below: You can also create a dashed line within the IgxLineSeriesComponent by using the IgxDataChartComponent and setting the dashArray property on the series. This property takes an array of numbers that will describe the length of the resulting dashes in the line. The following example demonstrates usage of the dashArray in a IgxLineSeriesComponent in IgxDataChartComponent: Advanced Types of Line Charts The following sections explain more advanced types of Angular Line Charts that can be created using the IgxDataChartComponent control instead of IgxCategoryChartComponent control with simplified API. Angular Stacked Line Chart The Stacked Line Chart is often used to show the change of value over time such as the amount of renewable electricity produced for several years between regions. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedLineSeriesComponent, as shown in the example below: Angular Stacked 100% Line Chart The Stacked 100% Line Chart is identical to the Stacked Line Chart in all aspects except in their treatment of the values on y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Line Chart presents the data in terms of percent of the sum of all values in a data point. The example below shows a study made for online shopping traffic by departments via tablet, phone and personal computers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100LineSeriesComponent, as shown in the example below: Angular Radial Line Chart The Radial Line Chart belongs to a group of radial charts and has a shape of an unfilled polygon that is bound by a collection of straight lines connecting data points. This chart type uses the same concept of data plotting as the Line Chart, but wraps the data points around a circular axis rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxRadialLineSeriesComponent, as shown in the example below: Angular Polar Line Chart The Polar Line Chart belongs to a group of polar charts and is rendered using a collection of straight lines connecting data points in polar (angle/radius) coordinate system. Polar Line Charts use the same concepts of data plotting as the Scatter Line Chart with the difference that the visualization wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarLineSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Column Chart Polar Chart Radial Chart Spline Chart Stacked Chart API References The following table lists API members mentioned in the above sections: Chart Type Control Name API Members Line IgxCategoryChartComponent chartType = Line Polar Line IgxDataChartComponent IgxPolarLineSeriesComponent Radial Line IgxDataChartComponent IgxRadialLineSeriesComponent Stacked Line IgxDataChartComponent IgxStackedLineSeriesComponent Stacked 100% Line IgxDataChartComponent IgxStacked100LineSeriesComponent View page on GitHub"
  },
  "components/charts/types/pie-chart.html": {
    "href": "components/charts/types/pie-chart.html",
    "title": "Angular Pie Charts and Graphs | Ignite UI for Angular",
    "keywords": "Angular Pie Chart The Ignite UI for Angular Pie Chart, or Pie Graph, is a part-to-whole chart that shows how categories (parts) of a data set add up to a total (whole) value. Categories are rendered as sections in a circular, or pie-shaped graph. Each section, or pie slice, has an arc length proportional to its underlying data value. Categories are shown in proportion to other categories based on their value percentage to the total value being analyzed, as parts of 100 or 100%. Angular Pie Chart Example You can create the Angular Pie Chart in the IgxPieChartComponent by binding your data items with a string and a numeric data value. These data values will add up to a value of 100% of visualization. In this case, the example shows the overall breakdown of budget spend by department. Angular Pie Chart Recommendations Pie Charts are appropriate for small data sets and are easy to read at a glance. Pie charts are just one type of part-to-whole visualization. Others include: Pie Doughnut (Ring) Funnel Stacked Area Stacked 100% Area (Stacked Percentage Area) Stacked Bar Stacked 100% Bar (Stacked Percentage Bar) Treemap Waterfall The Angular Pie Chart includes interactive features that give the viewer tools to analyze data, like: Legends Slice Explosion Slice Selection Chart Animations Best Practices for a Pie Chart: Comparing slices or segments as percentage values in proportion to a total value or whole. Showing how a group of categories is broken into smaller segments. Presenting small, non-hierarchical data sets (less than 6 to 8 segments of data). Ensuring data segments add up to 100%. Arranging the order of data from largest (highest) to smallest (least). Using standard presentation techniques such as starting in the 12 o'clock position and continuing clockwise. Ensuring the color palette is distinguishable for segments/slices of the parts. Considering data labels in segments vs. legends for ease of reading. Choosing an alternative chart to Pie such as Bar or Ring based on ease of comprehension. Avoiding positioning multiple pie charts next to each other for comparative analysis. Do Not Use Pie Chart When: Comparing change over time —use a Bar, Line or Area chart. Requiring precise data comparison —use a Bar, Line or Area chart. You have more than 6 or 8 segments (high data volume) — consider a Bar, Line or Area chart if it works for your data story. It would be easier for the viewer to perceive the value difference in a Bar chart. Angular Pie Chart Legend Legends are used to show information about each point, to know about its contribution towards the total sum. You can collapse the point using legend click. In order to display a legend next to the pie chart an ItemLegend needs to be created and assigned to the IgxLegendComponent property. The legendLabelMemberPath can then be used to specify which property on your data model it will use to display inside the legend for each pie slice. Additionally you can use the legendItemTemplate and legendItemBadgeTemplate properties and the various font properties on ItemLegend to further customize the look of the legend items. Angular Pie Chart Others Category Sometimes, the underlying data for the pie chart will contain many items with small values. In this case, the Others category will permit automatic aggregation of several data values into a single slice In the sample below, the othersCategoryThreshold is set to 2, and othersCategoryType is set to Number. Therefore, items with value less than or equal to 2 will be assigned to the \"Others\" category. If you set othersCategoryType to Percent, then othersCategoryThreshold will be interpreted as a percentage rather than as a value, i.e. items whose values are less than 2% of the sum of all item values would be assigned to the Others category. You can use whichever othersCategoryType is most appropriate for your application. Angular Pie Chart Explosion The pie chart supports explosion of individual pie slices as well as a SliceClick event that allows you to modify selection states and implement custom logic Angular Pie Chart Selection The pie chart supports slice selection by mouse click as the default behavior. You can determine the selected slices by using the selectedItems property. The selected slices are then highlighted. There is a property called selectionMode which is how you set what mode you want the pie chart to use. The default value is Single. In order to disable selection, set the property to Manual. The pie chart supports three different selection modes. Single - When the mode is set to single, only one slice can be selected at a time. When you select a new slice the previously selected slice will be deselected and the new one will become selected. Multiple - When the mode is set to Multiple, many slices can be selected at once. If you click on a slice, it will become selected and clicking on a different slice will also select that slice leaving the previous slice selected. Manual - When the mode is set to Manual, selection is disabled. The pie chart has 4 events associated with selection: SelectedItemChanging SelectedItemChanged SelectedItemsChanging SelectedItemsChanged The events that end in “Changing” are cancelable events which means you can stop the selection of a slice by setting the event argument property Cancel to true. When set to true the associated property will not update and the slice will not become selected. This is useful for scenarios where you want to keep users from being able to select certain slices based on the data inside it. For scenarios where you click on the Others slice, the pie chart will return an object called IgxPieSliceOthersContext. This object contains a list of the data items contained within the Others slice. Angular Pie Chart Animation You can animate the pie chart smoothly by setting the radiusFactor property, which will scale the chart's radius. Also set the startAngle property to angle the chart such that it keep increasing the chart angle while rotating. In the code below, the radiusFactor is increasing the chart by 0.25% of the size, and startAngle is rotating the chart by 1 degree. When radiusFactor and startAngle reached to its maximum limit the animation is stopped by reset the animation flag and clear the interval. Angular Pie Chart Styling Once our pie chart is created, we may want to make some further styling customizations such as a change of the colors for the slices of the chart, as demonstrated below: Angular Radial Pie Chart The Radial Pie Chart belongs to a group of Radial Charts and uses belongs to a group of radial charts and uses pie slices that extend from the center of chart towards locations of data points. This chart type takes concepts of categorizing multiple series of data points and wraps them around a circular axis rather than stretching data points along a horizontal line. Additional Resources Donut Chart Polar Chart Radial Chart API References The following table lists API members mentioned in the above sections: legendItemBadgeTemplate legendItemTemplate legendLabelMemberPath othersCategoryThreshold othersCategoryType selectionMode Chart Type Control Name API Members Pie Chart IgxPieChartComponent PieChart Radial Pie Chart IgxDataChartComponent IgxRadialPieSeriesComponent View page on GitHub"
  },
  "components/charts/types/point-chart.html": {
    "href": "components/charts/types/point-chart.html",
    "title": "Angular Point Chart | Data Visualization | Infragistics",
    "keywords": "Angular Point Chart The Ignite UI for Angular Point Chart renders a collection of points. Values are represented on the y-axis (labels on the left side) and categories are displayed on the x-axis (bottom labels). These charts emphasize the amount of change over a period of time or compare multiple items as well as the relationship of parts of a whole by displaying the total of the plotted values. Angular Point Chart Example You can create the Angular Point Chart in the IgxCategoryChartComponent control by binding your data to ItemsSource property and setting chartType property to Point enum, as shown in the example below. Angular Point Chart with Single Series In the following example, the Angular Point Chart plots a single data source by automatically selecting numeric data column for y-axis and non-numeric data column for x-axis. Angular Point Chart with Multiple Series Since the Angular Point Chart allows you to combine multiple series and compare or see how they change over time, let’s see how easy it is to achieve this. All we need to do is bind to a data source containing the data for China and the USA, and the point chart will automatically update to fit the additional data. Angular Point Chart Styling Once the Angular Point Chart is set up, we may want to make some further styling customizations such as change the markers and its outlines, brushes and thickness. Advanced Types of Point Charts You can create more advanced types of Angular Point Charts using the IgxDataChartComponent control instead of IgxCategoryChartComponent control by following these topics: Scatter Bubble Chart Scatter Marker Chart Scatter HD Chart Polar Marker Chart Additional Resources You can find more information about related chart features in these topics: Chart Performance Chart Markers API References The following table lists API members mentioned in the above sections: IgxCategoryChartComponent IgxDataChartComponent chartType markerTypes markerOutlines markerBrushes markerThickness View page on GitHub"
  },
  "components/charts/types/polar-chart.html": {
    "href": "components/charts/types/polar-chart.html",
    "title": "Angular Polar Chart | Data Visualization | Infragistics",
    "keywords": "Angular Polar Chart The Ignite UI for Angular Polar Chart uses the polar coordinate system (angle, radius) instead of the Cartesian coordinate system (x, y) to plot data in chart. In other words, Polar Chart takes concepts of Scatter Series and wrap them around a circle rather than stretching data points horizontally. It is often used to plot scientific data (e.g. wind direction and speed, direction, and strength of magnetic field, location of objects in solar system), and can highlight the deviation of collected data from predicted results. Angular Polar Area Chart The Polar Area Chart renders using a collection of polygons connecting data points and it uses the same concepts of data plotting as the Category Area Chart with the difference that the visualization wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarAreaSeriesComponent, as shown in the example below: Angular Polar Spline Area Chart The Polar Spline Area Chart renders also as a collection of polygons but they have curved splines connecting data points instead of straight lines like Polar Area Chart does. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarAreaSeriesComponent, as shown in the example below: Angular Polar Marker Chart The Polar Marker Chart renders using a collection of markers representing data points in polar (angle/radius) coordinate system. This chart uses the same concepts of data plotting as the Scatter Marker Chart with the difference that the visualization wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarScatterSeriesComponent, as shown in the example below: Angular Polar Line Chart The Polar Line Chart renders using a collection of straight lines connecting data points in polar (angle/radius) coordinate system. This chart uses the same concepts of data plotting as the Scatter Line Chart with the difference that the visualization wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarLineSeriesComponent, as shown in the example below: Angular Polar Spline Chart The Polar Spline Chart renders using a collection of curved splines connecting data points in polar (angle/radius) coordinate system. This Chart uses the same concepts of data plotting as the Scatter Spline Chart with the difference that the visualization wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarSplineSeriesComponent, as shown in the example below: Angular Polar Chart Styling Once our polar chart is created, we may want to make some further styling customizations such as a change of the line colors, marker types, or outline colors of those markers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxPolarAreaSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Donut Chart Line Chart Pie Chart Radial Chart Scatter Chart Spline Chart API References The following table lists API members mentioned in the above sections: IgxDataChartComponent IgxPolarAreaSeriesComponent IgxPolarLineSeriesComponent IgxPolarSplineSeriesComponent IgxPolarSplineAreaSeriesComponent IgxPolarScatterSeriesComponent ItemsSource angleMemberPath radiusMemberPath IgxNumericAngleAxisComponent IgxNumericRadiusAxisComponent View page on GitHub"
  },
  "components/charts/types/radial-chart.html": {
    "href": "components/charts/types/radial-chart.html",
    "title": "Angular Radial Chart | Data Visualization | Infragistics",
    "keywords": "Angular Radial Chart The Ignite UI for Angular Radial Chart takes data and render it as collection of data points wrapped around a circle (rather than stretching along a horizontal line). Radial Chart is also mapping a list of categories from the minimum to the maximum of the extent of the chart, and support the category grouping mechanisms. Angular Radial Area Chart The Angular Radial Area Chart has a shape of a filled polygon that is bound by a collection of straight lines connecting data points. This chart type uses the same concept of data plotting as the Area Chart, but wraps the data points around a circular axis rather than stretching them horizontally. You can create this type of chart in IgxDataChartComponent control by binding your data to IgxRadialAreaSeriesComponent, as shown in the example below. Angular Radial Column Chart The Radial Column Chart is visualized by using a collection of rectangles that extend from the center of the chart toward the locations of data points. This utilizes the same concepts of data plotting as the Column Chart, but wraps data points around a circle rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxRadialColumnSeriesComponent, as shown in the example below: Angular Radial Line Chart The Angular Radial Line Chart has renders as a collection of straight lines connecting data points. This chart type uses the same concept of data plotting as the Line Chart, but wraps the data points around a circular axis rather than stretching them horizontally. You can create this type of chart in the IgxDataChartComponent control by binding your data to IgxRadialLineSeriesComponent, as shown in the example below: Angular Radial Pie Chart The Radial Pie Chart uses pie slices that extend from the center of chart towards locations of data points. This chart type takes concepts of categorizing multiple series of data points and wraps them around a circular axis rather than stretching data points along a horizontal line. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxRadialPieSeriesComponent, as shown in the example below: Angular Radial Chart Styling Once our radial chart is created, we may want to make some further styling customizations such as a change of the line colors, marker types, or outline colors of those markers. This example demonstrates how to customize styling in IgxDataChartComponent control. Additional Resources You can find more information about related chart types in these topics: Area Chart Column Chart Donut Chart Line Chart Pie Chart API References The following table lists API members mentioned in the above sections: IgxDataChartComponent IgxRadialAreaSeriesComponent IgxRadialColumnSeriesComponent IgxRadialLineSeriesComponent IgxRadialPieSeriesComponent ItemsSource AngleAxisName ValueAxisName valueMemberPath IgxCategoryAngleAxisComponent IgxNumericRadiusAxisComponent View page on GitHub"
  },
  "components/charts/types/scatter-chart.html": {
    "href": "components/charts/types/scatter-chart.html",
    "title": "Angular Scatter Chart | Data Visualization | Infragistics",
    "keywords": "Angular Scatter Charts The Ignite UI for Angular Scatter Chart belongs to a group of charts that show the relationship among items in distinct series of data or to plot data items using numeric x and y coordinates. These charts draw attention to uneven intervals or clusters of data. They are often used to plot scientific data, and can highlight the deviation of collected data from predicted results. Also, you can use them to organize data chronologically (even if the data is not in chronological order). Angular Scatter Marker Chart Angular Scatter Marker Chart renders as a collection of markers, each having a pair of numeric X/Y values that determines its location in the Cartesian coordinate system. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterSeriesComponent, as shown in the example below: Angular Scatter Line Chart Angular Scatter Line Chart renders as a collection of markers connected by a straight lines, each having a pair of numeric X/Y values that determines its location in the Cartesian coordinate system. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterLineSeriesComponent, as shown in the example below: Angular Scatter Spline Chart Angular Scatter Spline Chart renders as a collection of markers connected by a curved spline, each having a pair of numeric X/Y values that determines its location in the Cartesian coordinate system. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterSplineSeriesComponent, as shown in the example below: Angular Scatter High Density Chart Use the Angular Scatter High Density (HD) Chart to bind and show scatter data ranging from thousands to millions of data points with very little loading time. Due to this chart type being designed for such a large amount of points, it is visualized as tiny dots as opposed to full sized markers, and displays areas with the most data using a higher color density representing a cluster of data points. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxHighDensityScatterSeriesComponent, as shown in the example below: Angular Scatter Area Chart Angular Scatter Area Chart draws a colored surface based on a triangulation of X and Y data with a numeric data value assigned to each point. This chart is useful for rendering heat maps, magnetic field strength or Wi-Fi strength in an office. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterAreaSeriesComponent, as shown in the example below: Angular Scatter Contour Chart Angular Scatter Contour Chart draws colored contour lines based on a triangulation of X and Y data with a numeric data value assigned to each point. This chart is useful for rendering heat maps, magnetic field strength or Wi-Fi strength in an office. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterContourSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Bubble Chart Line Chart Spline Chart Shape Chart API References The following table lists API members mentioned in the above sections: Chart Type Control Name API Members Scatter Marker IgxDataChartComponent IgxScatterSeriesComponent Scatter Line IgxDataChartComponent IgxScatterLineSeriesComponent Scatter Spline IgxDataChartComponent IgxScatterSplineSeriesComponent High Density Scatter IgxDataChartComponent IgxHighDensityScatterSeriesComponent Scatter Area IgxDataChartComponent IgxScatterAreaSeriesComponent Scatter Contour IgxDataChartComponent IgxScatterContourSeriesComponent View page on GitHub"
  },
  "components/charts/types/shape-chart.html": {
    "href": "components/charts/types/shape-chart.html",
    "title": "Angular Shape Chart | Data Visualization | Infragistics",
    "keywords": "Angular Shape Charts The Ignite UI for Angular Shape Charts are a group of charts that take array of shapes (array or arrays of X/Y points) and render them as collection of polygons or polylines in Cartesian (x, y) coordinate system. They are often used highlight regions in scientific data or they can be used to plot diagrams, blueprints, or even floor plan of buildings. Angular Scatter Polygon Chart The Angular Scatter Polygon Chart renders an array or array of arrays of polygons in the Cartesian (x, y) coordinate system using IgxScatterPolygonSeriesComponent in the IgxDataChartComponent control. This chart can be used to filled shapes of plot diagrams, blueprints, or even the floor plan of buildings. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterPolygonSeriesComponent, as shown in the example below: Angular Scatter Polyline Chart The Angular Scatter Polyline Chart renders an array or array of arrays of polylines in the Cartesian (x, y) coordinate system using IgxScatterPolylineSeriesComponent in the IgxDataChartComponent control. This chart can be used to outlines of plot diagrams, blueprints, or even the floor plan of buildings. Also, it can visualizes complex relationships between a large amount of elements. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxScatterPolylineSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Line Chart Scatter Chart API References The following table lists API members mentioned in the above sections: IgxDataChartComponent IgxScatterPolygonSeriesComponent IgxScatterPolylineSeriesComponent ItemsSource shapeMemberPath IgxNumericXAxisComponent IgxNumericYAxisComponent YAxisName XAxisName View page on GitHub"
  },
  "components/charts/types/sparkline-chart.html": {
    "href": "components/charts/types/sparkline-chart.html",
    "title": "Angular Sparkline | Data Visualization Tools | Infragistics",
    "keywords": "Angular Sparkline The Ignite UI for Angular Sparkline is a lightweight charting control. It is intended for rendering within a small-scale layout such as within a grid cell but can also be rendered alone. The Sparkline has several visual elements and corresponding features that can be configured and customized such as the chart type, markers, ranges, trendlines, unknown value plotting, and tooltips. Angular Sparkline Example The following example shows all the different types of Sparkline available. The type is defined by setting the displayType property. If the displayType property is not specified, then by default, the Line type is displayed. Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. Sparkline Recommendations Is the Sparkline chart right for your project? The primary benefit of the Sparkline control compared to other charting controls is that it can render in a limited space such as a grid cell with all its visual elements shown. The Angular Sparkline has the ability to mark the data points with elliptical icons to indicate the highest, lowest, first, last, and negative values. The markers can be customized with a desired shape, color, or image. Sparkline Use Cases You have a compact space to display a chart in. You want to show trends in a series of values, such as weekly revenue. Sparkline Best Practices Always start the Y-Axis (left or right axis) at 0 so data comparison is accurate. Order time-series data from left to right. Use visual attributes like solid lines to show a series of data. When Not to Use Sparkline You need to analyze the data in detail. You need to display every label of the data points. It only allows showing high and low values on the Y-Axis, and first and last values on the X-Axis. Sparkline Data Structure It requires one-dimensional data. The data set must contain at least two numeric fields. The text in the data source fields can be used to display the first and last label on the X-Axis. Sparkline Types The Angular Sparkline supports the following types of sparklines by setting the displayType property accordingly: Line: Displays the line chart type of Sparkline with numeric data, connecting the data points with line segments. At least two data points must be supplied to visualize the data in Sparkline. Area: Displays the Area chart type of Sparkline with numeric data. This is like line type with additional steps of closing the area after each line is drawn. At least two data points must be supplied to visualize the data in Sparkline. Column: Displays the Column chart type of Sparkline with numeric data. Some may refer to it as vertical bars. This type can render a single data point, but it would require specifying the minimum value range property (minimum) in Sparkline so the supplied single data point can be visible, otherwise the value will be treated as the minimum value and will not be visible. WinLoss: This type is similar in its visual appearance to Column chart type, in which the value of each column is equal to either the positive maximum (for positive values) or the negative minimum (for negative value) of the data set. The idea is to indicate a win or loss scenario. For the Win/Loss chart to display properly, the data set must have both positive and negative values. If the WinLoss sparkline is bound to the same data as the other types such as the Line type, which can be bound to a collection of numeric values, then the Angular Sparkline will select two values from the collection - the highest and the lowest - and will render the sparkline based upon those values. Markers The Angular Sparkline allows you to show markers as circular-colored icons on your series to indicate the individual data points based on X/Y coordinates. Markers can be set on sparklines of display types of Line, Area, and Column. The WinLoss type of sparkline does not currently accept markers. By default, markers are not displayed, but they can be enabled by setting the corresponding marker visibility property. Markers in the sparkline can be placed in any combination of the following locations: All: Display markers for all data points in the sparkline. Low: Display markers on the data point of the lowest value. If there are multiple points at the lowest value, it will show on each point with that value. High: Display markers on the data point of the highest value. If there are multiple points at the highest value, it will show on each point with that value. First: Display a marker on the first data point in the sparkline. Last: Display a marker on the last data point in the sparkline. Negative: Display markers on the negative data points plotted in the sparkline. All of the markers mentioned above can be customized using the related marker type's property in aspects of color, visibility, and size. For example, the Low markers above will have properties lowMarkerBrush, lowMarkerVisibility, and lowMarkerSize. Normal Range The normal range feature of the Angular Sparkline is a horizontal stripe representing some pre-defined meaningful range when the data is being visualized. The normal range can be set as a shaded area outlined with the desired color. The normal range can be wider than the maximum data point or beyond, and it can also be as thin as the sparkline's Line display type, to serve as a threshold indicator, for instance. The width of the normal range is determined by the following three properties, which serve as the minimum settings required for displaying the normal range: normalRangeVisibility: Whether the normal range is visible. normalRangeMaximum: The bottom border of the range. normalRangeMinimum: The top border of the range. By default, the normal range is not displayed. When enabled, the normal range shows up with a light gray color appearance, which can also be configured using the normalRangeFill property. You can also configure whether to show the normal range in front of or behind the plotted series in your Angular Sparkline by setting the displayNormalRangeInFront property. Trendlines The Angular Sparkline has support for a range of trendlines that display as another layer on top of the actual sparkline layer. To display a sparkline, you can use the trendLineType property. The trendlines are calculated according to the algorithm specified by the trendLineType property using the values of the data the the chart is bound to. Trendlines can only be displayed one at a time and by default, the trendline is not displayed. The sample below shows all the available trendlines via the dropdown: Unknown Value Interpolation The Angular Sparkline can detect unknown values and render the space for unknown values through a specified interpolation algorithm. If your data contains null values and you do not use this feature, meaning no interpolation is specified, the unknown value will not be plotted. To plot the unknown values, you can set the unknownValuePlotting property of the Angular Sparkline. The sample below shows the differences between the values of the unknownValuePlotting property, allowing you to toggle it on or off using a checkbox: Sparkline in Data Grid You can embed the Angular Sparkline in a template column of data grid or other UI controls that support templates. The following code example shows how to do this: Additional Resources You can find more information about related chart types in these topics: Area Chart Column Chart Line Chart API References The following is a list of API members mentioned in the above sections: displayNormalRangeInFront displayType lowMarkerBrush lowMarkerSize lowMarkerVisibility normalRangeFill unknownValuePlotting IgxSparklineComponent View page on GitHub"
  },
  "components/charts/types/spline-chart.html": {
    "href": "components/charts/types/spline-chart.html",
    "title": "Angular Spline Chart | Data Visualization | Infragistics",
    "keywords": "Angular Spline Chart The Ignite UI for Angular Spline Chart belongs to a group of Category Charts that render as a collection of points connected by smooth curves of spline. Values are represented on the y-axis and categories are displayed on the x-axis. Spline Chart emphasizes the amount of change over a period of time or compares multiple items as well as the relationship of parts to a whole by displaying the total of the plotted values. Spline Chart is identical to Line Chart in all aspects except that line connecting data points has spline interpolation and smoothing for improved presentation of data. Angular Spline Chart Example The following example shows how to create Angular Spline Chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Spline enum. Angular Spline Chart with Single Series The Spline Chart is often used to show the change of value over time such as the amount of renewable electricity produced since 2009 over a ten-year period for Europe, as shown in the example below. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Spline, as shown in the example below: Angular Spline Chart with Multiple Series Since the Spline Chart allows you to combine multiple series and compare or see how they change over time. All we need to do is bind to a data source containing the data for China and the USA, and the chart will automatically update to fit the additional data. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Spline, as shown in the example below: Angular Spline Chart Styling If you need a Spline Chart with more features such as composite other series, you can configure the markers, marker brushes, marker outlines, series brushes and series outlines as demonstrated below. You can create this type of chart in the IgxCategoryChartComponent control by binding your data and setting the chartType property to Spline, as shown in the example below: Advanced Types of Spline Charts The following sections explain more advanced types of Angular Spline Charts that can be created using the IgxDataChartComponent control instead of IgxCategoryChartComponent control with simplified API. Angular Stacked Spline Chart The Stacked Spline Chart is often used to show the change of value over time such as the amount of renewable electricity produced for several years between regions, as we have shown in the example below. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedSplineSeriesComponent, as shown in the example below: Angular Stacked 100% Spline Chart The Stacked 100% Spline Chart is identical to the Stacked Spline Chart in all aspects except in their treatment of the values on y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Spline Chart presents the data in terms of percent of the sum of all values in a data point. The example below shows a study made for online shopping traffic by departments via tablet, phone and personal computers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100SplineSeriesComponent, as shown in the example below: Additional Resources You can find more information about related chart types in these topics: Area Chart Line Chart Polar Chart Radial Chart Stacked Chart API References The following table lists API members mentioned in the above sections: Chart Type Control Name API Members Spline IgxCategoryChartComponent chartType = Spline Stacked Spline IgxDataChartComponent IgxStackedSplineSeriesComponent Stacked 100% Spline IgxDataChartComponent IgxStacked100SplineSeriesComponent View page on GitHub"
  },
  "components/charts/types/stacked-chart.html": {
    "href": "components/charts/types/stacked-chart.html",
    "title": "Angular Stacked Chart | Data Visualization | Infragistics",
    "keywords": "Angular Stacked Chart The Ignite UI for Angular Stacked Chart belongs to a special group of charts that render multiple values of data items as stacked area/polygons, bars, columns, lines, or splines. Standard Stacked Charts render actual values of data items while Stacked 100% Charts render values as percentage of total values. Angular Stacked Chart Types The following example, you can use the drop-down to switch between all of the different types stacked charts available in the Angular IgxDataChartComponent control. The following sections demonstrate individual types of Ignite UI for Angular Stacked Charts. Angular Stacked Area Chart Stacked Area Charts are rendered using a collection of points connected by line segments, with the area below the line filled in and stacked on top of each other. Stacked Area Charts follow all the same requirements as Area Chart, with the only difference being that visually, the shaded areas are stacked on top of each other. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedAreaSeriesComponent, as shown in the example below. Angular Stacked 100 Area Chart Sometimes the series represent part of a whole being changed over time e.g. a country's energy consumption related to the sources from which it is produced. In such cases representing all stacked elements equally may be a better idea. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100AreaSeriesComponent, as shown in the example below. Angular Stacked Bar Chart A Stacked Bar Chart, or Stacked Bar Graph, is a type of category chart that is used to compare the composition of different categories of data by displaying different sized fragments in the horizontal bars of the chart. The length of each bar, or stack of fragments, is proportionate to its overall value. The Stacked Bar Chart differs from the Bar Chart in that the data points representing your data are stacked next to each other horizontally to visually group your data. Each stack can contain both positive and negative values. All positive values are grouped on the positive side of the X-Axis, and all negative values are grouped on the negative side of the X-Axis. In this example of an Stacked Bar Chart, we have a Numeric X Axis (bottom labels of the chart) and a Category Y Axis (left labels of the chart). You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedBarSeriesComponent, as shown in the example below. Angular Stacked 100% Bar Chart The Angular Stacked 100% Bar Chart is identical to the Angular stacked bar chart in all aspects except in their treatment of the values on X-Axis (bottom labels of the chart). Instead of presenting a direct representation of the data, the stacked 100% bar chart presents the data in terms of percent of the sum of all values in a data point. In this example of a Stacked 100% Bar Chart, the Energy Product values are shown as a 100% value of all of the data in the fragments of the horizontal bars. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100BarSeriesComponent, as shown in the example below. Angular Stacked Column Chart The Stacked Column Chart is identical to the Column Chart in all aspects, except the series are represented on top of one another rather than to the side. The Stacked Column Chart is used to show comparing results between series. Each stacked fragment in the collection represents one visual element in each stack. Each stack can contain both positive and negative values. All positive values are grouped on the positive side of the Y-Axis, and all negative values are grouped on the negative side of the Y-Axis. The Stacked Column Chart uses the same concepts of data plotting as the Stacked Bar Chart but data points are stacked along vertical line (Y-Axis) rather than along horizontal line (X-Axis). You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedColumnSeriesComponent, as shown in the example below. Angular Stacked 100% Column Chart The Stacked 100% Column Chart is identical to the Stacked Column Chart in all aspects except in their treatment of the values on Y-Axis. Instead of presenting a direct representation of the data, the Stacked 100% Column Chart presents the data in terms of percent of the sum of all values in a data point. The example below shows a study made for online shopping traffic by departments via tablet, phone and personal computers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100ColumnSeriesComponent, as shown in the example below. Angular Stacked Line Chart The Stacked Line Chart is often used to show the change of value over time such as the amount of renewable electricity produced for several years between regions. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedLineSeriesComponent, as shown in the example below: Angular Stacked 100% Line Chart The Stacked 100% Line Chart is identical to the Stacked Line Chart in all aspects except in their treatment of the values on y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Line Chart presents the data in terms of percent of the sum of all values in a data point. The example below shows a study made for online shopping traffic by departments via tablet, phone and personal computers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100LineSeriesComponent, as shown in the example below: Angular Stacked Spline Area Chart Stacked Spline Area Charts are rendered using a collection of points connected by curved spline segments, with the area below the curved spline fill in and stacked on top of each other. Stacked Spline Area Charts follow all of the same requirements as Area Chart, with the only difference being that the visually shaded areas are stacked on top of each other. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedSplineAreaSeriesComponent, as shown in the example below. Angular Stacked 100% Spline Area Chart The Stacked 100% Spline Area Chart is identical to the Stacked Spline Area Chart in all aspects except for the treatment of the values on the y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Spline Area Chart presents the data in terms of a percent of the sum of all values in a particular data point. Sometimes the chart represents part of a whole being changed over time. For example, a country's energy consumption related to the sources from which it is produced. In such cases, representing all stacked elements equally may be a better idea. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100SplineAreaSeriesComponent, as shown in the example below. Angular Stacked Spline Chart The Stacked Spline Chart is often used to show the change of value over time such as the amount of renewable electricity produced for several years between regions. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStackedSplineSeriesComponent, as shown in the example below. Angular Stacked 100% Spline Chart The Stacked 100% Spline Chart is identical to the Stacked Spline Chart in all aspects except in their treatment of the values on y-axis. Instead of presenting a direct representation of the data, the Stacked 100% Spline Chart presents the data in terms of percent of the sum of all values in a data point. The example below shows a study made for online shopping traffic by departments via tablet, phone and personal computers. You can create this type of chart in the IgxDataChartComponent control by binding your data to a IgxStacked100SplineSeriesComponent. Additional Resources You can find more information about related chart types in these topics: Area Chart Bar Chart Column Chart Line Chart Spline Chart API References The following table lists API members mentioned in the above sections: Chart Type Control Name API Members Stacked Area IgxDataChartComponent IgxStackedAreaSeriesComponent Stacked Bar IgxDataChartComponent IgxStackedBarSeriesComponent Stacked Column IgxDataChartComponent IgxStackedColumnSeriesComponent Stacked Line IgxDataChartComponent IgxStackedLineSeriesComponent Stacked Spline IgxDataChartComponent IgxStackedSplineSeriesComponent Stacked Spline Area IgxDataChartComponent IgxStackedSplineAreaSeriesComponent Stacked 100% Area IgxDataChartComponent IgxStacked100AreaSeriesComponent Stacked 100% Bar IgxDataChartComponent IgxStacked100BarSeriesComponent Stacked 100% Column IgxDataChartComponent IgxStacked100ColumnSeriesComponent Stacked 100% Line IgxDataChartComponent IgxStacked100LineSeriesComponent Stacked 100% Spline IgxDataChartComponent IgxStacked100SplineSeriesComponent Stacked 100% Spline Area IgxDataChartComponent IgxStacked100SplineAreaSeriesComponent View page on GitHub"
  },
  "components/charts/types/step-chart.html": {
    "href": "components/charts/types/step-chart.html",
    "title": "Angular Step Chart | Data Visualization | Infragistics",
    "keywords": "Angular Step Chart The Ignite UI for Angular Step Chart belongs to a group of category charts that render as a collection of points connected by continuous vertical and horizontal lines. Values are represented on the y-axis and categories are displayed on the x-axis. Step Chart emphasizes the amount of change over a period of time or compares multiple items. Angular Step Area Chart You can create Angular Step Area Chart in the IgxCategoryChartComponent control by setting chartType property to StepArea enum, as shown in the example below. Angular Step Line Chart The Angular Step Line Chart is very similar to Step Area Chart, except that the area below lines are filled in. You can create Step Line Chart in the IgxCategoryChartComponent control by binding your data and setting chartType property to StepLine value, as shown in the example below. Angular Step Chart Styling If you need Step Charts with more features such as composite other series, you can configure the markerTypes, markerBrushes, markerOutlines, lines' brushes, and lines' outlines properties on the IgxCategoryChartComponent control as demonstrated below. Additional Resources You can find more information about related chart types in these topics: Area Chart Line Chart Chart Markers API References The following table lists API members mentioned in the above sections: IgxCategoryChartComponent chartType StepArea StepLine brushes outlines markerBrushes markerOutlines markerTypes View page on GitHub"
  },
  "components/charts/types/stock-chart.html": {
    "href": "components/charts/types/stock-chart.html",
    "title": "Angular Stock/Financial Charts | Ignite UI for Angular",
    "keywords": "Angular Stock Chart The Ignite UI for Angular Stock Chart, sometimes referred to as Angular Financial Chart or Candlestick Chart, is a composite visualization that renders stock ticker data, or price data in an interactive time-series display. Stock Chart shows stock prices for a ticker over time in a Time Series X-Axis. Also, this chart shows information for a company’s ticker data like Open Price, High Price, Low Price and Close Price (OHLC) for configurable period of time. The Stock Chart offers multiple ways in which the data can be visualized and interpreted, including display modes for price and volume and a host of Stock indicators. Angular Stock Chart Example You can create Stock Chart using the IgxFinancialChartComponent control by binding your data and optionally setting chartType property to Line value, as shown in the example below. Stock Chart Recommendations Are Angular Stock Charts right for your project? The typical stock chart is represented with ticker data in a candlestick chart which is used for the technical analysis of the price ranges. A candlestick chart compares the high and low prices of a day to the open and close of the ticker symbol. The body of the candlestick chart shows the open and close trade values (O/C). The wicks of the candlestick chart show the high and low trade prices (H/L). The distance between the top and bottom of the ticker value is the day range of the ticker price. The candlestick chart ticker value is hollow when the asset closed higher than it opened. The candlestick chart ticker value is filled when the asset closed lower than it opened. A black or red candle represents a price with a lower closing price than the prior candle's close. A white or green candle represents a higher closing price than the prior candle's close. The Stock Chart can be set to display one of the following: Candlestick Chart Bar Chart Column Chart Line Chart As a Stock Chart is meant to allow the user to perform data analysis functions, it includes interactive elements such as: Time-based Filters Prices View Volume View Indicators View Trend Lines Navigation / Zoombar View Stock Chart Data Structure: The data source must be an array or a list of data items. The data source must contain at least one data item. All data items must contain at least one date-time (or string) column that represents the date of the ticker data. All data items must contain 1 numeric column for Bar, Line, and Column chart. All data items must contain 4 numeric columns for Open, High, Low, Close (OHLC) for a Candlestick chart. All data items must contain 5 numeric columns for Open, High, Low, Close and Volume for a Candlestick chart. Angular Stock Chart with Multiple Series Angular Stock Chart In this example the Stock Chart is representing the S&P 500 over the course of a year; useful for investors and conducting technical analysis and forecasting future pricing/reports. Angular Stock Chart Styling If you need a Stock Chart with more features such as composite other series, you can configure the thickness, outlines, brushes, negative outlines, negative brushes as demonstrated below. In this example, the stock chart is comparing revenue between Amazon, Microsoft and Tesla. Angular Chart Annotations The Crosshair Annotation Layer provides crossing lines that meet at the actual value of every targeted series. Crosshair types include: Horizontal, Vertical, and Both. The Crosshairs can also be configured to snap to data points by setting the crosshairsSnapToData property to true, otherwise the crosshairs will be interpolated between data points. Annotations can also be enabled to display the crosshair's value along the axis. The Final Value Layer provides a quick view along the axis of the ending value displayed in a series. The Callout Layer displays a callout at X/Y positions. Note: When using the ordinal X axis mode, the CalloutsXMemberPath should point to the numeric index of the item, otherwise CalloutsXMemberPath should point to the time value. Angular Chart Panes The following panes are available: Price Pane - Renders prices using Line, Candlestick, Bar (OHLC), trendlines and financial overlays. Indicator Pane - Renders all the financial indicators in a separate chart while the BollingerBands and PriceChannel overlays are rendered in the Price Pane because they share the same values range on Y-Axis. Volume Pane - Renders stocks volumes using Column, Line, and Area chart types below all above panes. Zoom Pane - Controls the zoom of all the panes and it is always rendered at bottom of the chart. Indicator Pane Financial Indicators are often used by traders to measure changes and to show trends in stock prices. These indicators are usually displayed below the price pane because they do not share the same Y-Axis scale. By default the indicator panes are not displayed. The toolbar allows the end user to select which indicator to display at run time. In order to display an indicator pane initially, the indicatorTypes property must be set to a least one type of indicator, as demonstrated in the following code: Volume Pane The volume pane represents the number of shares traded during a given period. Low volume would indicate little interest, while high volume would indicate high interest with a lot of trades. This can be displayed using column, line or area chart types. The toolbar allows the end user to display the volume pane by selecting a chart type to render the data at runtime. In order the display the pane, a volume type must be set, as demonstrated in the following code: Price Pane This pane displays stock prices and shows the stock's high, low, open and close prices over time. In addition it can display trend lines and overlays. Your end user can choose different chart types from the toolbar. By default, the chart type is set to Auto. You can override the default setting, as demonstrated in the following code: Note that is recommended to use line chart type if plotting multiple data sources or if plotting data source with a lot of data points. Zoom Pane This pane controls the zoom of all the displayed panes. This pane is displayed by default. It can be turned off by setting the zoomSliderType to none as demonstrated in the following code: Note that you should set the zoomSliderType option to the same value as the chartType option is set to. This way, the zoom slider will show correct preview of the price pane. The following code demonstrates how to do this: In this example, the stock chart is plotting revenue for United States. Additional Resources You can find more information about related chart features in these topics: Chart Animations Chart Annotations Chart Navigation Chart Trendlines Chart Performance API References The following table lists API members mentioned in the above sections: chartType crosshairsSnapToData ItemsSource IgxFinancialChartComponent indicatorTypes zoomSliderType View page on GitHub"
  },
  "components/charts/types/treemap-chart.html": {
    "href": "components/charts/types/treemap-chart.html",
    "title": "Angular Treemap | Data Visualization Tools | Orientation | Layout | Data Binding | Infragistics",
    "keywords": "Angular Treemap The Ignite UI for Angular Treemap chart displays hierarchical (tree-structured) data as a set of nested nodes. Each branch of the tree is given a treemap node, which is then tiled with smaller nodes representing sub-branches. Each node’s rectangle has an area proportional to a specified dimension on the data. Often the nodes are colored to show a separate dimension of the data. Angular Treemap Example In the following example, the IgxTreemapComponent demonstrates the 30 largest countries in the world by total area. Treemap Recommendations Are Angular Treemaps right for your project? When the color and size dimensions are correlated in some way with the tree structure, one can often easily see patterns that would be difficult to spot in other ways. A second advantage of treemaps is that, by construction, they make efficient use of space. As a result, they can legibly display thousands of items on the screen simultaneously. Treemaps are more effective than pie charts and other forms of area charts that often do a poor job of classifying data points and communicating the relative differences of their values. Treemaps are designed for drill down scenarios. You can continuously drill down into the data set that is represented by smaller rectangles for more efficient data analysis. Treemaps are not designed to convey numerical quantities; the intent is to show relative rankings. Like any other data visualization, a Treemap chart visualization should be used in specific scenarios. It does not solve the same problem that a visualization like a Bar Chart or a Line Chart would. It is really meant for a more complex, richer data display. Treemap Use Cases There are several common use cases for choosing a Treemap. When you: Have drill-down hierarchical data (data organized as a tree, with branches and sub-branches). Want to illustrate hierarchies of relative weight and comparative values between categories (branches) and subcategories (sub-branches). Want to display large data sets that need a compact, space-efficient visualization. Want to deliver at-a-glance, quick data analysis without precise values. The relative size of the rectangles help identify patterns and/or outliers very quickly. Want to make efficient use of space. Treemaps can legibly display thousands of items on the screen simultaneously. When not to Use a Treemap You are telling a data story that requires precise values You have negative data values You have flat, non-hierarchical data Your data is similar in size Treemap Data Structure The data source must be an array or a list of data items The data source must contain at least one data item otherwise the map will not render any nodes. All data items must contain at least one data column (e.g. string) which should be mapped to the labelMemberPath property. All data items must contain at least one numeric data column which should be mapped using the valueMemberPath property. To categorize data into organized tiles you can optionally use parentIdMemberPath and idMemberPath. Angular Treemap Configuration In the following example, the treemap demonstrates the ability of changing it's algorithmic structure by modifying the layoutType and layoutOrientation properties. Layout Types The Treemap chart displays the relative weight of data. It uses a variety of algorithms to help it determine how the layout of its data items should occur: SliceAndDiced - layout algorithm aims to preserve the initial order at the expense of the aspect ratio. Squarified - layout tiling algorithm has a better aspect ratio than the SliceAndDice and keeps a better order than Squarified. Stripped - layout type algorithm obtains the best aspect ratio but the objects are arranged by size. The Treemap allows you to choose the algorithm that is best for your requirements, defaulting to use the Squarified method. It also includes the ability to allow you to colorize nodes using two mechanisms: A group-based mechanism that colors items with like values A scale-based mechanism similar to a map choropleth, which maps node colors based on their value. Layout Orientation layoutOrientation property enables the user to set the direction in which the nodes of the hierarchy will be expanded. Note that the layoutOrientation property works with the layout types SliceAndDice and Strip. Horizontal – the child nodes are going to be stacked horizontally(SliceAndDice). Vertical – the child nodes are going to be stacked vertically (SliceAndDice). Angular Treemap Styling In the following example, the treemap demonstrates the ability of changing the look and feel of the nodes achieved by styling through the NodeStylingScript event. Additional Resources You can find more information about related chart types in these topics: Area Chart Shape Chart API References The following is a list of API members mentioned in the above sections: IgxTreemapComponent layoutOrientation layoutType View page on GitHub"
  },
  "components/checkbox.html": {
    "href": "components/checkbox.html",
    "title": "Angular Checkbox Component – Ignite UI for Angular",
    "keywords": "Angular Checkbox Component Overview Angular Checkbox is an extension of the standard HTML input type checkbox, providing similar functionality, only enhanced with things like animations and Material Design styling. It enables users to choose one or several predefined options, mostly in forms and surveys. The Ignite UI for Angular Checkbox component is a selection control that allows users to make a binary choice for a certain condition. It behaves similarly to the native browser checkbox. Some of the features it offers are styling options, themes, checked, unchecked, and indeterminate states, and others. Angular Checkbox Example See the checkbox in action in the following Angular Checkbox example below. Getting Started with Ignite UI for Angular Checkbox To get started with the Ignite UI for Angular Checkbox component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxCheckboxModule in the app.module.ts file: // app.module.ts import { IgxCheckboxModule } from 'igniteui-angular'; // import { IgxCheckboxModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxCheckboxModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxCheckboxComponent as a standalone dependency. // home.component.ts import { IgxCheckboxComponent } from 'igniteui-angular'; // import { IgxCheckboxComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-checkbox [checked]=\"true\"> Simple checkbox </igx-checkbox> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxCheckboxComponent] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Checkbox module or component imported, you can start using the igx-checkbox component. Using the Angular Checkbox Component To make the checkbox in the demo, add the following code inside the component template: <igx-checkbox [checked]=\"true\"> Simple checkbox </igx-checkbox> Checkbox properties Let's enhance the code above by binding the checkbox properties to some data. Say, we have an array of task objects, each having two properties: description and done. You can bind the checkbox component checked property to the underlying task object done property. Analogically, you can bind the value property to description. Optionally, you can also bind the change event and add some custom logic in the provided event handler method. // tasks.component.ts @Component({...}) export class HomeComponent { public tasks = [ { done: true, description: 'Research' }, { done: true, description: 'Implement' }, { done: false, description: 'Test' } ]; public statusChanged() { // event handler logic } } Enhance the component template by adding a checkbox for each task and then setting the corresponding property bindings: <!--tasks.component.html--> <igx-checkbox *ngFor=\"let task of tasks\" [checked]=\"task.done\"> {{ task.description }} </igx-checkbox> Add some styles: //task.component.scss :host { display: flex; flex-flow: column nowrap; padding: 16px; } igx-checkbox { margin-top: 16px; } The final result would be something like that: Label Positioning You can position the label using the checkbox's labelPosition property: <igx-checkbox labelPosition=\"before\"></igx-checkbox> If the labelPosition is not set, the label will be positioned after the checkbox. Indeterminate Checkbox in Angular In addition to the checked and unchecked states, there is a third state a checkbox can be in: indeterminate. In this state the checkbox is neither checked, nor unchecked. This is set using the checkbox's indeterminate property: <igx-checkbox [indeterminate]=\"true\"></igx-checkbox> We can create an app that has a list of tasks that need to be done and one master checkbox in Angular that's going to be checked only if all the tasks are completed. Let's update the previous sample. Starting with the template: <!-- app.component.html --> <igx-checkbox [readonly]=\"true\" [(ngModel)]=\"masterCheckbox.checked\" [(indeterminate)]=\"masterCheckbox.indeterminate\" (click)=\"toggleAll()\" > All done </igx-checkbox> <igx-checkbox class=\"tasks\" *ngFor=\"let task of tasks\" [(ngModel)]=\"task.done\"> {{ task.description }} </igx-checkbox> Next, we're going to indent the subtasks, so it's more visual that they are part of the same group. // app.component.scss :host { display: flex; flex-flow: column nowrap; padding: 16px; } igx-checkbox { margin-top: 16px; } igx-checkbox.tasks { padding-left: 10px; } And finally, we'll create the logic of our application: // app.component.ts public tasks = [ { done: true, description: 'Research' }, { done: true, description: 'Implement' }, { done: false, description: 'Test' } ]; public get masterCheckbox() { return this.tasks.reduce( (acc, curr, idx, arr) => { acc.checked = acc.checked && curr.done; acc.done = curr.done ? acc.done + 1 : acc.done; acc.indeterminate = acc.done === arr.length ? false : !!acc.done; return acc; }, { checked: true, done: 0, indeterminate: false } ); } public toggleAll() { if (this.masterCheckbox.checked) { for (const task of this.tasks) { task.done = false; } } else { for (const task of this.tasks) { task.done = true; } } } After all that is done, our application should look like this: Angular Checkbox Styling To get started with styling the checkbox, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Then, we create a new theme that extends the checkbox-theme and use some of its parameters to style the checkbox's items: // in styles.scss $custom-checkbox-theme: checkbox-theme( $border-radius: 10px, $label-color: #011627, $empty-color: #ECAA53, $fill-color: #ECAA53, $tick-color: #011627, ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include checkbox($custom-checkbox-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include checkbox($custom-checkbox-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-checkbox-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-checkbox-theme); } Demo API References IgxCheckboxComponent IgxCheckboxComponent Styles LabelPosition Theming Dependencies IgxRipple Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/chip.html": {
    "href": "components/chip.html",
    "title": "Angular Chip Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Chip Component Overview [The Angular Chip component]({environment:angularApiUrl}/classes/igxchipcomponent.html) is a visual element that displays information in an oval container. The component has various properties - it can be templated, deleted, and selected. Multiple chips can be reordered and visually connected to each other, using the chip area as a container. Angular Chip Example Getting Started with Ignite UI for Angular Chip To get started with the Ignite UI for Angular Chip component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxChipsModule in the app.module.ts file: // app.module.ts import { IgxChipsModule } from 'igniteui-angular'; // import { IgxChipsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxChipsModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxChipComponent as a standalone dependency, or use the IGX_CHIPS_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_CHIPS_DIRECTIVES } from 'igniteui-angular'; import { NgFor } from '@angular/common'; // import { IGX_CHIPS_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\"> {{chip.text}} </igx-chip> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_CHIPS_DIRECTIVES, NgFor] }) export class HomeComponent { public chipList = [ { text: 'Country', id: '1', icon: 'place' }, { text: 'City', id: '2', icon: 'location_city' }, { text: 'Address', id: '3', icon: 'home' }, { text: 'Street', id: '4', icon: 'streetview' } ]; } Now that you have the Ignite UI for Angular Chips module or directives imported, you can start using the igx-chip component. Using the Angular Chip Component The IgxChipComponent has an id input property so that the different chip instances can be easily distinguished. If an id is not provided, it will be automatically generated. <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\"> {{chip.text}} </igx-chip> Selection Selection can be enabled by setting the selectable input property to true. When selecting a chip, the selectedChanging event is fired. It provides the new selected value so you can get the new state and the original event in originalEvent that triggered the selection change. If this is not done through user interaction but instead is done by setting the selected property programmatically, the originalEvent argument has a value of null. <igx-chip *ngFor=\"let chip of chipList\" [selectable]=\"true\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> Removing Removing can be enabled by setting the removable input to true. When enabled, a remove button is rendered at the end of the chip. When removing a chip, the remove event is emitted. By default, the chip doesn't get automatically removed from the DOM tree upon clicking on the remove icon. Removal needs to be handled manually. <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\" [removable]=\"true\" (remove)=\"chipRemoved($event)\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> public chipRemoved(event: IBaseChipEventArgs) { this.chipList = this.chipList.filter((item) => { return item.id !== event.owner.id; }); this.changeDetectionRef.detectChanges(); } Dragging Dragging can be enabled by setting the draggable input to true. When enabled, you can click and drag the chip around. <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\" [draggable]=\"true\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {chip.text}} </igx-chip> Note To reorder the chips you need to handle the event using the IgxChipsAreaComponent. To create the demo sample, we will use the features above: <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\" [selectable]=\"true\" [removable]=\"true\" (remove)=\"chipRemoved($event)\" > <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> Then, we need to add the chipList and the function, that handles the remove event: import { IBaseChipEventArgs } from 'igniteui-angular'; // import { IBaseChipEventArgs } from '@infragistics/igniteui-angular'; for licensed package ... public chipList = [ { text: 'Country', id: '1', icon: 'place' }, { text: 'City', id: '2', icon: 'location_city' }, { text: 'Town', id: '3', icon: 'store' }, { text: 'First Name', id: '4', icon: 'person_pin' } ]; private changeDetectionRef: any; public chipRemoved(event: IBaseChipEventArgs) { this.chipList = this.chipList.filter((item) => { return item.id !== event.owner.id; }); this.changeDetectionRef.detectChanges(); } If everything went well, you should see this in your browser: Chip Templates All of the IgxChipComponent's elements are templatable. You can template the prefix and the suffix of the chip, using the IgxPrefix and the IgxSuffix directives: <igx-chip> <igx-icon igxPrefix>insert_emoticon</igx-icon> <igx-icon igxSuffix style=\"transform: rotate(180deg)\">insert_emoticon</igx-icon> <span>Why not both?</span> </igx-chip> You can customize the size of the chip, using the [--ig-size] CSS variable. By default it is set to var(--ig-size-large). It can also be set to var(--ig-size-medium) or var(--ig-size-small), while everything inside the chip retains its relative positioning: <igx-chip>Hi! My name is Chip!</igx-chip> <igx-chip style=\"--ig-size: var(--ig-size-medium)\"> I can be smaller! </igx-chip> <igx-chip style=\"--ig-size: var(--ig-size-small)\"> <igx-icon igxPrefix>child_care</igx-icon> Even tiny! </igx-chip> You can customize the select icon, using the selectIcon input. It accepts values of type TemplateRef and overrides the default icon while retaining the same functionality. <igx-chip *ngFor=\"let chip of chipList\" [selectable]=\"true\" [selectIcon]=\"mySelectIcon\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> <ng-template #mySelectIcon> <igx-icon>check_circle</igx-icon> </ng-template> You can customize the remove icon, using the removeIcon input. It takes a value of type TemplateRef and renders it instead of the default remove icon. <igx-chip *ngFor=\"let chip of chipList\" [removable]=\"true\" [removeIcon]=\"myRemoveIcon\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> <ng-template #myRemoveIcon> <igx-icon>delete</igx-icon> </ng-template> Chip Area The IgxChipsAreaComponent is used when handling more complex scenarios that require interaction between chips (dragging, selection, navigation, etc.). Reorder Chips The chip can be dragged by the end-user in order to change its position. The dragging is disabled by default but can be enabled using the draggable input property. You need to handle the actual chip reordering manually. This is where the chip area comes in handy since it provides the reorder event that returns the new order when a chip is dragged over another chip. <igx-chips-area (reorder)=\"chipsOrderChanged($event)\"> <igx-chip *ngFor=\"let chip of chipList\" [draggable]=\"'true'\"> <igx-icon igxPrefix>{{chip.icon}}</igx-icon> {{chip.text}} </igx-chip> </igx-chips-area> public chipsOrderChanged(event: IChipsAreaReorderEventArgs) { const newChipList = []; for (const chip of event.chipsArray) { const chipItem = this.chipList.filter((item) => { return item.id === chip.id; })[0]; newChipList.push(chipItem); } this.chipList = newChipList; } Keyboard Navigation The chip can be focused using the Tab key or by clicking on it. When the chips are in a chip area, they can be reordered using keyboard navigation: Keyboard controls when the chip is focused: LEFT - Moves the focus to the chip on the left. RIGHT - Moves the focus to the chip on the right. SPACE - Toggles chip selection if it is selectable. DELETE - Triggers the remove event for the igxChip so the chip deletion can be handled manually. SHIFT + LEFT - Triggers reorder event for the igxChipArea when the currently focused chip should move position to the left. SHIFT + RIGHT - Triggers reorder event for the igxChipArea when the currently focused chip should move one position to the right. Keyboard controls when the remove button is focused: SPACE or ENTER Fires the remove output so the chip deletion can be handled manually. Here's an example of the chip area using IgxAvatar as prefix and custom icons for all chips: <igx-chips-area (reorder)=\"chipsOrderChanged($event)\"> <igx-chip *ngFor=\"let chip of chipList\" [id]=\"chip.id\" [selectable]=\"true\" [selectIcon]=\"mySelectIcon\" [removable]=\"true\" [removeIcon]=\"myRemoveIcon\" (remove)=\"chipRemoved($event)\" [draggable]=\"'true'\"> <igx-avatar class=\"chip-avatar-resized\" igxPrefix [src]=\"chip.photo\" shape=\"circle\" ></igx-avatar> {{chip.name}} </igx-chip> </igx-chips-area> <ng-template #mySelectIcon> <igx-icon>check_circle</igx-icon> </ng-template> <ng-template #myRemoveIcon> <igx-icon>delete</igx-icon> </ng-template> Resize the avatar to fit the chip: .chip-avatar-resized { width: 2em; height: 2em; min-width: 2em; } Add the chipList and the functions that handle the events: import { IBaseChipEventArgs, IChipsAreaReorderEventArgs } from 'igniteui-angular'; // import { IBaseChipEventArgs, IChipsAreaReorderEventArgs } from '@infragistics/igniteui-angular'; for licensed package ... public chipList = [ { id: '770-504-2217', name: 'Terrance Orta', photo: 'https://www.infragistics.com/angular-demos/assets/images/men/27.jpg' }, { id: '423-676-2869', name: 'Richard Mahoney', photo: 'https://www.infragistics.com/angular-demos/assets/images/men/13.jpg' }, { id: '859-496-2817', name: 'Donna Price', photo: 'https://www.infragistics.com/angular-demos/assets/images/women/50.jpg' } ]; private changeDetectionRef: any; public chipRemoved(event: IBaseChipEventArgs) { this.chipList = this.chipList.filter((item) => { return item.id !== event.owner.id; }); this.changeDetectionRef.detectChanges(); } public chipsOrderChanged(event: IChipsAreaReorderEventArgs) { const newChipList = []; for (const chip of event.chipsArray) { const chipItem = this.chipList.filter((item) => { return item.id === chip.id; })[0]; newChipList.push(chipItem); } this.chipList = newChipList; } If everything's set up correctly, you should see this in your browser: Demo Styling To get started with styling the chip, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the chip-theme and accepts some parameters that style the chip's items: $custom-theme: chip-theme( $background: #011627, $hover-background: #011627dc, $focus-background: #0116276c, $selected-background: #ECAA53, $hover-selected-background: #ECAA53, $focus-selected-background: #ECAA53, $text-color: #FEFEFE, $remove-icon-color: #f14545, $remove-icon-color-focus: #da0000, $border-radius: 5px ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include chip($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include chip($custom-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-theme); } Demo Custom sizing You can either use the --size variable, targeting the igx-chip directly: igx-chip { --size: 50px; } Or you can use the universal --igx-chip-size variable to target all instances: <div class=\"my-app\"> <igx-chip></igx-chip> </div> .my-app { --igx-chip-size: 50px; } You can also use one of the predefined sizes, assigning it to the --ig-size variable. The available values for --ig-size are --ig-size-small, --ig-size-medium, and --ig-size-large: igx-chip { --ig-size: var(--ig-size-small); } Learn more about it in the Size article. Known Issues and Limitations Using the Chips Area component on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API IgxChipComponent IgxChipComponent Styles IgxChipsAreaComponent Theming Dependencies IgxIcon Theme References Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/circular-progress.html": {
    "href": "components/circular-progress.html",
    "title": "Angular Circular Progress Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Circular Progress Component Overview The Ignite UI for Angular Circular Progress Indicator component provides a visual indicator of an application’s process as it changes. The circular indicator updates its appearance as its state changes. Angular Circular Progress Example Getting Started with Ignite UI for Angular Circular Progress To get started with the Ignite UI for Angular Circular Progress component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxProgressBarModule in the app.module.ts file: // app.module.ts ... import { IgxProgressBarModule } from 'igniteui-angular'; // import { IgxProgressBarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxProgressBarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxCircularProgressBarComponent as a standalone dependency, or use the IGX_CIRCULAR_PROGRESS_BAR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_CIRCULAR_PROGRESS_BAR_DIRECTIVES } from 'igniteui-angular'; // import { IGX_CIRCULAR_PROGRESS_BAR_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-circular-bar [value]=\"100\" [animate]=\"true\" class=\"custom-size\" ></igx-circular-bar> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_CIRCULAR_PROGRESS_BAR_DIRECTIVES] /* or imports: [IgxCircularProgressBarComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Progress Bar module or directives imported, you can start using the igx-circular-bar component. Using the Angular Circular Progress To have a better understanding how everything works, let's create a simple example, like the one in the demo: <igx-circular-bar [value]=\"100\" [animate]=\"true\" class=\"custom-size\" ></igx-circular-bar> After that, we should have the demo sample in your browser. Note The igx-circular-bar emits onProgressChanged event that outputs an object like this {currentValue: 65, previousValue: 64} on each step. Note The default progress increments by 1% of the max value per update cycle, this happens if the step value is not defined. To change the update rate, the step value should be defined.``` Indeterminate Progress If you want to track a process that is not determined precisely, you can set the indeterminate input property to true. <igx-circular-bar [animate]=\"false\" [indeterminate]=\"true\" [textVisibility]=\"false\" ></igx-circular-bar> Note You can hide the text of the circular progress bar by setting the textVisibility property to false. The final result should be: Dynamic Progress You can dynamically change the value of the progress by using external controls like buttons. To achieve this, we can bind the value to a class property: <div class=\"sample-content\"> <igx-circular-bar [value]=\"currentValue\" [max]=\"100\" [animate]=\"true\" class=\"custom-size\"> </igx-circular-bar> <div class=\"button-container\"> <button igxIconButton=\"flat\" (click)=\"decrementProgress()\"> <igx-icon fontSet=\"material\">remove</igx-icon> </button> <button igxIconButton=\"flat\" (click)=\"incrementProgress()\"> <igx-icon fontSet=\"material\">add</igx-icon> </button> </div> </div> Add the methods that increment and decrement the value: @Component({...}) export class HomeComponent { public currentValue: number; public ngOnInit() { this.currentValue = 0; } public incrementProgress() { this.currentValue += 10; if (this.currentValue > 100) { this.currentValue = 100; } } public decrementProgress() { this.currentValue -= 10; if (this.currentValue < 0) { this.currentValue = 0; } } } Add some styles: .custom-size { width: 100px; height: 100px; } .sample-content { width: 300px; display: flex; align-items: center; margin-top: 30px; } Gradient Progress One way to customize the progress bar is to use a color gradient instead of a solid color. This can be done in one of two ways - by using the IgxProgressBarGradientDirective directive or by implementing a custom theme, albeit custom themes support up to two color stops. If you want to create a gradient with just two color stops, you can do so by using a custom theme. Create a list of colors and pass it to the $progress-circle-color theme parameter: $colors: #695cf9, #ef017c; $custom-theme: progress-circular-theme( $progress-circle-color: $colors ); You can learn more about styling the circular progress bar in the Styling Section To provide a gradient that has more than 2 color stops, we have to use the directive on an ng-template in our igx-circular-bar like that: <div class=\"sample-content\"> <igx-circular-bar [value]=\"currentValue\" [max]=\"100\" [animate]=\"true\" class=\"custom-size\"> <ng-template igxProgressBarGradient let-id> <svg:linearGradient [id]=\"id\" gradientTransform=\"rotate(90)\"> <stop offset=\"0%\" stop-color=\"#ff9a40\"/> <stop offset=\"50%\" stop-color=\"#1eccd4\"/> <stop offset=\"100%\" stop-color=\"#ff0079\"/> </svg:linearGradient> </ng-template> </igx-circular-bar> <div class=\"button-container\"> <button igxIconButton=\"flat\" (click)=\"removeProgress()\"> <igx-icon fontSet=\"material\">remove</igx-icon> </button> <button igxIconButton=\"flat\" (click)=\"addProgress()\"> <igx-icon fontSet=\"material\">add</igx-icon> </button> </div> </div> After reproducing the steps above, you should get this as a result: Styling To get started with styling the circular progress bar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the progress-circular-theme and accepts the $base-circle-color and the $progress-circle-color parameters. $custom-theme: progress-circular-theme( $base-circle-color: lightgray, $progress-circle-color: rgb(32, 192, 17) ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include progress-circular($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include progress-circular($custom-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-theme); } Demo API IgxCircularProgressBarComponent IgxCircularProgressBarComponent Styles View page on GitHub"
  },
  "components/combo.html": {
    "href": "components/combo.html",
    "title": "Angular Combobox Component | Data binding combobox | Infragistics",
    "keywords": "Angular ComboBox Component Overview The Angular ComboBox component represents a drop-down list that provides editable functionalities, allowing users to choose multiple options from a predefined list. The Ignite UI for Angular ComboBox Component also provides filtering capabilities, grouping and adding custom values to a dropdown list. It can be used as an alternative to the HTML select tag and has several out-of-the-box features such as data binding (local and remote), filtering, grouping, custom templates for items, header, and footer, custom values, and more. Angular ComboBox Example In this Angular ComboBox example, you can see how users can filter items and perform selection with the provided data. In addition, the ComboBox exposes keyboard navigation and custom styling capabilities. Angular ComboBox Features The combobox control exposes the following features: Data Binding - local data and remote data Value Binding Filtering Grouping Custom Values Templates Integration with Template Driven Forms and Reactive Forms Getting Started with Ignite UI for Angular ComboBox To get started with the Ignite UI for Angular ComboBox component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxComboModule in your app.module.ts file. import { IgxComboModule } from 'igniteui-angular'; // import { IgxComboModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxComboModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxComboComponent as a standalone dependency, or use the IGX_COMBO_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_COMBO_DIRECTIVES } from 'igniteui-angular'; // import { IGX_COMBO_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-combo></igx-combo>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_COMBO_DIRECTIVES] /* or imports: [IgxComboComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Combo module or directives imported, you can start using the igx-combo component. Using the Angular ComboBox Component After the initial setup, you can bind the igx-combo to data. @Component({ selector: 'app-combo-demo', template: '<igx-combo [data]=\"cities\"></igx-combo>', styleUrls: ['combo-demo.component.scss'], standalone: true, imports: [IGX_COMBO_DIRECTIVES] }) export class ComboDemo implements OnInit { public cities: { name: string, id: string }[] = []; public ngOnInit() { this.cities = [{ name: 'London', id: 'UK01' }, { name: 'Sofia', id: 'BG01'}, ...]; } } Our combobox is now bound to the array of cities, but we still haven't told the component which property to use for the items' text and which to use for the value. Let's do that now. Data value and display properties Since the combobox is bound to an array of complex data (i.e. objects), we need to specify a property that the control will use to handle the selected items. The control exposes two @Input properties - valueKey and displayKey: valueKey - Optional, recommended for object arrays - Specifies which property of the data entries will be stored for the combobox's selection. If valueKey is omitted, the combobox value will use references to the data entries (i.e. the selection will be an array of entries from igxCombo.data). displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the combobox will use the specified valueKey (if any). In our case, we want the combobox to display the name of each city and the combobox value to store the id of each city. Therefore, we are providing these properties to the combobox's displayKey and valueKey, respectively: <igx-combo [data]=\"cities\" displayKey=\"name\" valueKey=\"id\"></igx-combo> Note When the data source is an array of primitives (e.g. string[], number[]), do not specify a valueKey and displayKey. Primitive values will be used for both value and text. Two-Way Binding The combobox component fully supports two-way data-binding with [(ngModel)] as well as usage in template driven and reactive forms. The combobox selection can be accessed either through two-way binding or through the selection API. We can pass an array of items of the same type as the ones in the combobox's selection (based on valueKey) and any time one changes, the other is updated accordingly. In the following example, the cities Sofia and London will initially be selected. Any further changes in the combobox's selection will reflect on the selectedCities array. <igx-combo [data]=\"cities\" [(ngModel)]=\"selectedCities\" displayKey=\"name\" valueKey=\"id\"></igx-combo> export class MyCombo { public cities: { name: string, id: string }[] = [ { name: 'Sofia', id: 'BG01' }, { name: 'London', id: 'UK01' }, ...]; public selectedCities: string[] = ['BG01', 'UK01']; } Two-way binding can also be achieved without a specified valueKey. For example, if valueKey is omitted, the bound model will look like this: export class MyCombo { public cities: { name: string, id: string } [] = [ { name: 'Sofia', id: 'BG01' }, { name: 'London', id: 'UK01' }, ...]; public selectedCities: { name: string, id: string } [] = [this.cities[0], this.cities[1]]; } Selection API The combobox component exposes API that allows getting and manipulating the current selection state of the control. One way to get the combobox's selection is via the selection property. It returns an array of values which correspond to the selected items, depending on the specified valueKey (if any). In our example, selection will return an array of the selected cities' ids: export class MyCombo { ... public selection: string[] = this.combo.selection; } Using the selection API, you can also change the combobox's selected items without user interaction with the control - via a button click, as a response to an Observable changing, etc. For example, we can implement a button that selects a set of cities, using the select() method: <igx-combo [data]=\"cities\" displayKey=\"name\" valueKey=\"id\"></igx-combo> <button igxButton (click)=\"selectFavorites()\">Select Favorites</button> When clicking the button, the cities London and Sofia will be added to the combobox's selection: export class MyExampleCombo { @ViewChild(IgxComboComponent, { read: IgxComboComponent, static: true }) public combo: IgxComboComponent; ... selectFavorites(): void { this.combo.select(['UK01', 'BG01']); } } The combobox also fires an event every time its selection changes - selectionChanging(). The emitted event arguments, IComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the items that were added or removed. The event can also be cancelled, preventing the selection update with the new array of items. Binding to the event can be done through the proper @Output property on the igx-combo tag: <igx-combo [data]=\"cities\" displayKey=\"name\" valueKey=\"id\" (selectionChanging)=\"handleCityChange($event)\"> </igx-combo> In the following example, when a city is added or removed from the selection, a handler that updates the statistic visualization is fired: export class MyExampleCombo { ... handleCityChange(event: IComboSelectionChangeEventArgs): void { for (const item of event.added) { this.addToVisualization(item); } for (const item of event.removed) { this.removeFromVisualization(item); } } } Single Selection By default, the combo control provides multiple selection. The snippet below demonstrates how to achieve single selection in the component by attaching a handler to the selectionChanging event: <igx-combo [data]=\"lData\" (selectionChanging)=\"singleSelection($event)\"></igx-combo> public singleSelection(event: IComboSelectionChangeEventArgs) { if (event.added.length) { event.newSelection = event.added; } } Note: It is recommended to use the igxSimpleCombo instead of modifying the igxCombo like it is shown above. Keyboard Navigation When combobox is closed and focused: ArrowDown or Alt + ArrowDown will open the combobox's drop down and will move focus to the search input. When combobox is opened and search input is focused: ArrowUp or Alt + ArrowUp will close the combobox's drop down and will move focus to the closed combobox. ArrowDown will move focus from the search input to the first list item. If the list is empty and custom values are enabled will move it to the Add new item button. Note Any other key stroke will be handled by the input. When combobox is opened and list item is focused: ArrowDown will move to the next list item. If the active item is the last one in the list and custom values are enabled, the focus will be moved to the Add item button. ArrowUp will move to the previous list item. If the active item is the first one in the list, the focus will be moved back to the search input. End will move to the last list item. Home will move to the first list item. Space will select/deselect the active list item. Enter will confirm the already selected items and will close the list. Esc will close the list. When combobox is opened, allow custom values are enabled and add item button is focused: Enter will add a new item with valueKey and displayKey equal to the text in the search input and will select the new item. ArrowUp focus will be moved back to the last list item or if the list is empty, will be moved to the search input. Angular ComboBox Styling Using the Ignite UI for Angular Theming, we can greatly alter the combobox appearance. First, in order for us to use the functions exposed by the theme engine, we need to import the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the combo-theme and accepts the $search-separator-border-color parameter: $custom-combo-theme: combo-theme( $search-separator-border-color: #1a5214 ); The IgxComboComponent uses the IgxDropDownComponent internally as an item container. It also includes the IgxInputGroup and the IgxCheckbox components. Creating new themes, that extend these components' themes, and scoping them under the respective classes will let you change the combobox styles: $custom-drop-down-theme: drop-down-theme( $background-color: #d9f5d6, $header-text-color: #1a5214, $item-text-color: #1a5214, $focused-item-background: #72da67, $focused-item-text-color: #1a5214, $hover-item-background: #a0e698, $hover-item-text-color: #1a5214, $selected-item-background: #a0e698, $selected-item-text-color: #1a5214, $selected-hover-item-background: #72da67, $selected-hover-item-text-color: #1a5214, $selected-focus-item-background: #72da67, $selected-focus-item-text-color: #1a5214, ); $custom-checkbox-theme: checkbox-theme( $border-radius: 10px, $fill-color: #1a5214, $empty-color: #1a5214, ); The last step is to include the component's theme. :host { @include css-vars($custom-combo-theme); @include css-vars($custom-drop-down-theme); @include css-vars($custom-checkbox-theme); } Note The IgxCombo component uses the IgxOverlay service to hold and display the combobox items list container. To properly scope your styles you might have to use an OverlaySetting.outlet. For more details check the IgxOverlay Styling Guide. Note The default type of the IgxCombo is box unlike the IgxSelect where it is line. Demo Known Issues The combobox input that displays the selected items is not editable. However, due to browser specifics in FireFox, the cursor is visible. The combobox does not have input for sizing its height. In the future, the IgxInputGroup component will expose an option that allows custom sizing, and then the IgxCombo will use the same functionality for proper styling and better consistency. When the combobox is bound to an array of primitive data which contains undefined (i.e. [ undefined, ...]), undefined is not displayed in the dropdown. When it is bound to an array of complex data (i.e. objects) and the value used for valueKey is undefined, the item will be displayed in the dropdown, but cannot be selected. When the combobox is bound to a remote service and there is a predefined selection, its input will remain blank until the requested data is loaded. Note The combobox uses igxForOf directive internally hence all igxForOf limitations are valid for the combobox. For more details see igxForOf Known Issues section. API Summary IgxComboComponent IgxComboComponent Styles Additional angular components and/or directives with relative APIs that were used: IgxDropDownComponent IgxInputGroupComponent IgxCheckboxComponent Theming Dependencies IgxDropDown Theme IgxIcon Theme IgxCheckbox Theme IgxOverlay Theme Additional Resources ComboBox Features ComboBox Remote Binding ComboBox Templates Template Driven Forms Integration Reactive Forms Integration Single Select ComboBox Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/combo-features.html": {
    "href": "components/combo-features.html",
    "title": "ComboBox Features",
    "keywords": "ComboBox Features The Ignite UI for Angular ComboBox control exposes several features including data and value binding, custom values, filtering, grouping, etc. Angular ComboBox Features Example The following demo demonstrates some of the combobox features that are enabled/disabled at runtime: Usage First Steps To get started with the combobox component, first you need to import the IgxComboModule in your app.module.ts file. Our sample also uses the igx-switch component to toggle combobox properties' values, so we will need the IgxSwitchModule as well: import { IgxComboModule, IgxSwitchModule } from 'igniteui-angular'; // import { IgxComboModule, IgxSwitchModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxComboModule, IgxSwitchModule, ... ] }) export class AppModule {} Template Configuration <div class=\"combo-container\"> <igx-combo #combo [data]=\"lData\" displayKey=\"field\" valueKey=\"field\" [allowCustomValues]=\"customValues\" [filterable]=\"filterable\" [showSearchCaseIcon]=\"showSearchCaseIcon\" [disabled]=\"disabled\"> </igx-combo> </div> <div class=\"switch-container\"> <igx-switch [(ngModel)]=\"customValues\">Allow Custom Values</igx-switch> <igx-switch (change)=\"enableGroups($event)\">Enable Grouping</igx-switch> <igx-switch [(ngModel)]=\"disabled\">Disable Combo</igx-switch> <igx-switch [(ngModel)]=\"filterable\">Enable Filtering</igx-switch> <igx-switch *ngIf=\"filterable\" [(ngModel)]=\"showSearchCaseIcon\">Show Case-sensitive Icon</igx-switch> </div> Component Definition Note that grouping is enabled/disabled by setting the groupKey property to a corresponding data source entity or setting it to an empty string. @ViewChild('combo', { read: IgxComboComponent }) public combo: IgxComboComponent; public filterable = true; public showSearchCaseIcon = true; public customValues = true; public disabled = false; public enableGroups(event) { this.combo.groupKey = event.checked ? 'region' : ''; } Features Data Binding The following code snippet illustrates a basic usage of the igx-combo bound to a local data source. The valueKey specifies which property of the data entries will be stored for the combobox's selection and the displayKey specifies which property will be used for the combobox text: <igx-combo [data]=\"lData\" valueKey=\"ProductID\" displayKey=\"ProductName\"></igx-combo> import { localData } from './local-data'; export class ComboDemo implements OnInit { public lData: any[]; public ngOnInit() { this.lData = localData; } } Note If the displayKey property is omitted then the valueKey entity will be used instead. Follow the ComboBox Remote Binding topic for more details about binding the combobox component with remote data. Custom Overlay Settings The combobox component allows users to change the way a list of items is shown. This can be done by defining Custom OverlaySettings and passing them to the ComboBox's OverlaySettings input: export class CustomOverlayCombo { ... public customSettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy( { openAnimation: scaleInCenter, closeAnimation: scaleOutCenter }), modal: true, closeOnOutsideClick: true, }; } <igx-combo [data]=\"items\" [overlaySettings]=\"customSettings\"></igx-combo> If everything is set up correctly, the combobox's list will display centered, using the GlobalPositionStrategy: Note The combobox component uses the AutoPositionStrategy as a default position strategy. Filtering By default, filtering in the combobox is enabled. It can be disabled by setting the filterable property to false. Filtering options can be further enhanced by enabling the search case sensitivity. To display the case-sensitive icon in the search input, set the showSearchCaseIcon property to true: <igx-combo [filterable]=\"false\" [showSearchCaseIcon]=\"true\"></igx-combo> Custom Values The allowCustomValues property controls whether custom values can be added to the collection. If it is enabled, a missing item could be included using the UI of the combobox. <igx-combo [allowCustomValues]=\"true\"></igx-combo> Search Input Focus The combobox's autoFocusSearch property controls if the search input should receive focus when a combobox's dropdown list is opened. By default, the property is set to true. When set to false, the focus goes to the combobox's items container. For mobile devices, this can be used to prevent the software keyboard from popping up when opening the combobox's dropdown list. <igx-combo [autoFocusSearch]=\"false\"></igx-combo> Disable ComboBox You can disable a combobox using the following code: <igx-combo [disabled]=\"true\"></igx-combo> Grouping Defining a combobox's groupKey option will group the items, according to the provided key: <igx-combo [groupKey]=\"'primaryKey'\"></igx-combo> You can set whether groups should be sorted in ascending or descending order. By default the sorting order is ascending. <igx-combo [groupSortingDirection]=\"groupSortingDirection\"></igx-combo> ... import { SortingDirection } from 'igniteui-angular' // import { SortingDirection } from '@infragistics/igniteui-angular'; for licensed package export class ComboDemo { ... public groupSortingDirection: SortingDirection = SortingDirection.Asc; } API Summary IgxComboComponent IgxComboComponent Styles Additional components and/or directives with relative APIs that were used: IgxSwitchComponent Additional Resources ComboBox Component ComboBox Remote Binding ComboBox Templates Template Driven Forms Integration Reactive Forms Integration Single Select ComboBox Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/combo-remote.html": {
    "href": "components/combo-remote.html",
    "title": "ComboBox Remote Binding",
    "keywords": "ComboBox Remote Binding The Ignite UI for Angular ComboBox Component exposes an API that allows binding a combobox to a remote service and retrieving data on demand. Angular ComboBox Remote Binding Example The sample below demonstrates remote binding using the dataPreLoad property to load new chunk of remote data: Usage To get started with the ComboBox component, first you need to import the IgxComboModule in your app.module.ts file. In this demo, a remote service is used for server requests, therefore, we also need to include the HttpClientModule: import { IgxComboModule } from 'igniteui-angular'; // import { IgxComboModule } from '@infragistics/igniteui-angular'; for licensed package import { HttpClientModule } from '@angular/common/http'; @NgModule({ imports: [ ... IgxComboModule, HttpClientModule, ... ] }) export class AppModule {} Define Remote Service When binding a combobox to remote data, we need to have an available service that will load data on demand from a server. The combobox component exposes the virtualizationState property which gives the current state of a combobox - the first index and the number of items that need to be loaded. In order to show properly the scroll size, the totalItemCount property should have value that corresponds to the total items on the server. The code below defines a simple service that has a getData() method, which receives combobox's current state information and returns data as an observable: import { HttpClient } from '@angular/common/http'; import { Injectable } from '@angular/core'; import { IForOfState } from 'igniteui-angular'; // import { IForOfState } from '@infragistics/igniteui-angular'; for licensed package import { BehaviorSubject, Observable } from 'rxjs'; @Injectable() export class RemoteService { public remoteData: Observable<any[]>; private _remoteData: BehaviorSubject<any[]>; constructor(private http: HttpClient) { this._remoteData = new BehaviorSubject([]); this.remoteData = this._remoteData.asObservable(); } // Use combobox current virtualization state and search text to build URL and request the new data. public getData(data?: IForOfState, searchText?: string, cb?: (any) => void): any { } } Binding ComboBox to Remote Service When data is returned from a service as an observable, we can set it to the combobox component using the async pipe: <igx-combo [data]=\"rData | async\" [valueKey]=\"'ProductID'\" [displayKey]=\"'ProductName'\" (dataPreLoad)=\"dataLoading($event)\" (searchInputUpdate)=\"handleSearchInputUpdate($event)\" (selectionChanging)=\"handleSelectionChanging($event)\" (closing)=\"onClosing()\" (opened)=\"onOpened()\" (closed)=\"onClosed()\" [filterable]=\"true\"> </igx-combo> Here are some common cases when the combobox component needs to request new data: - when the combobox is initialized - when we scroll combobox's list - it will emit dataPreLoad along with the new combobox virtualizationState, which allows making a new request to the remote service. - when searching in a combobox - we need to make request to filter remote results. - when combobox is opened - we need to clear the results from any previous filter operations. Below are listed the handlers that listen to the already defined actions and execute requests to the server: import { ChangeDetectorRef, Component, OnInit, ViewChild } from '@angular/core'; import { IgxComboComponent } from 'igniteui-angular'; // import { IgxComboComponent } from '@infragistics/igniteui-angular'; for licensed package import { RemoteService } from '../../grid/services/remote.service'; @Component({ providers: [RemoteService], selector: 'app-combo-remote', styleUrls: ['./combo-remote.component.scss'], templateUrl: './combo-remote.component.html' }) export class ComboRemoteComponent implements OnInit { @ViewChild('remoteCombo', { read: IgxComboComponent }) public remoteCombo: IgxComboComponent; public prevRequest: any; public rData: any; private searchText: string = null; private defaultVirtState: IForOfState = { chunkSize: 6, startIndex: 0 }; private currentVirtState: IForOfState = { chunkSize: 6, startIndex: 0 }; private itemID: number = 1; private itemCount: number = 0; private hasSelection: boolean; private additionalScroll: number = 0; constructor(private remoteService: RemoteService, public cdr: ChangeDetectorRef) { } public ngOnInit() { this.rData = this.remoteService.remoteData; } public ngAfterViewInit() { const initSize = { startIndex: 0, chunkSize: Math.ceil(250 / this.remoteCombo.itemHeight) }; this.remoteService.getData(initSize, null, (data) => { this.remoteCombo.totalItemCount = data['@odata.count']; this.itemCount = this.remoteCombo.totalItemCount; }); } public dataLoading(evt) { if (this.prevRequest) { this.prevRequest.unsubscribe(); } this.prevRequest = this.remoteService.getData( this.remoteCombo.virtualizationState, this.searchText, (data) => { this.remoteCombo.totalItemCount = data['@odata.count']; this.cdr.detectChanges(); }); } public handleSearchInputUpdate(searchData: IComboSearchInputEventArgs) { this.currentVirtState.startIndex = 0; this.currentVirtState.chunkSize = Math.ceil(this.remoteCombo.itemsMaxHeight / this.remoteCombo.itemHeight); this.searchText = searchData?.searchText || ''; this.remoteService.getData( this.searchText ? this.currentVirtState : this.defaultVirtState, this.searchText, (data) => { this.remoteCombo.totalItemCount = data['@odata.count']; } ); } public onOpened() { const scroll: number = this.remoteCombo.virtualScrollContainer.getScrollForIndex(this.itemID - 1); this.remoteCombo.virtualScrollContainer.scrollPosition = scroll + this.additionalScroll; this.cdr.detectChanges(); } public onClosing() { this.searchText = ''; } public onClosed() { this.currentVirtState.startIndex = (this.itemID || 1) - 1; this.remoteService.getData( this.currentVirtState, this.searchText, (data) => { this.remoteCombo.totalItemCount = data['@odata.count']; this.cdr.detectChanges(); } ); } public handleSelectionChanging(evt: IComboSelectionChangingEventArgs) { this.hasSelection = !!evt?.newSelection.length; if (!this.hasSelection) { this.itemID = 1; this.currentVirtState = this.defaultVirtState; return; } const currentSelection = evt.newSelection[evt.newSelection.length - 1] this.currentVirtState.chunkSize = Math.ceil(this.remoteCombo.itemsMaxHeight / this.remoteCombo.itemHeight); this.itemCount === currentSelection ? this.additionalScroll = this.remoteCombo.itemHeight : this.additionalScroll = 0; if (this.itemCount - currentSelection >= this.currentVirtState.chunkSize - 1) { this.itemID = this.currentVirtState.startIndex = currentSelection; } else { this.itemID = this.currentVirtState.startIndex = this.itemCount - (this.currentVirtState.chunkSize - 1); } } } Note Anytime new data is loaded, we update the totalItemCount property, in order to have proper size of the list's scroll bar. In that case, the service returns total size using the property @odata.count. Note A service needs to be included as a provider. Handling Selection When using a combobox bound to remote data loaded in chunks and dealing with a more complex data type (e.g. objects), it is necessary to define a valueKey. As stated in the combobox topic, when no valueKey is specified, the combobox will try to handle selection by equality (===). Since the objects that will be marked as selected will not be the same as the object that are continuously loaded, the selection will fail. Note When binding a combobox to remote data, make sure to specify a valueKey, representing a property that is unique to each item. When the combobox is bound to remote data, setting value/selected items through API will only take into account the items that are loaded in the current chunk. If you want to set an initial value, make sure those specific items are loaded before selecting. API Summary IgxComboComponent IgxComboComponent Styles Additional Resources ComboBox Component ComboBox Features ComboBox Templates Template Driven Forms Integration Reactive Forms Integration Single Select ComboBox Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/combo-templates.html": {
    "href": "components/combo-templates.html",
    "title": "ComboBox Templates",
    "keywords": "ComboBox Templates The Ignite UI for Angular ComboBox Component allows defining custom templates for different areas such as header, footer, items, empty list and adding button. Angular ComboBox Templates Example Usage To get started with the ComboBox component, first you need to import the IgxComboModule in your app.module.ts file: import { IgxComboModule } from 'igniteui-angular'; // import { IgxComboModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxComboModule, ... ] }) export class AppModule {} Template Types When defining combobox templates, you need to reference them using the following predefined reference names: Item template Use selector [igxComboItem]: <igx-combo #templateCombo [data]=\"lData\" [valueKey]=\"'field'\" > <ng-template igxComboItem let-display let-key=\"valueKey\"> <div class=\"item\"> <span class=\"state\">{{ display[key] }}</span> <span class=\"region\">{{ display.region }}</span> </div> </ng-template> </igx-combo> Header Item template Use selector [igxComboHeaderItem]: <igx-combo #templateCombo [data]=\"lData\" [groupKey]=\"'region'\"> <ng-template igxComboHeaderItem let-display let-key=\"groupKey\"> <div class=\"header-item\">Region: {{ display[key] }}</div> </ng-template> </igx-combo> Header template Use selector [igxComboHeader]: <igx-combo> <ng-template igxComboHeader> <div class=\"header-class\">State - Region</div> </ng-template> </igx-combo> Footer template Use selector [igxComboFooter]: <igx-combo> <ng-template igxComboFooter> <div class=\"footer-class\">Infragistics 2018</div> </ng-template> </igx-combo> Empty template Use selector [igxComboEmpty]: <igx-combo> <ng-template igxComboEmpty> <span class=\"empty-class\">No available states</span> </ng-template> </igx-combo> Add template Use selector [igxComboAddItem]: <igx-combo> <ng-template igxComboAddItem> <button igxButton=\"flat\"> Add Location </button> </ng-template> </igx-combo> Toggle Icon Template Use selector [igxComboToggleIcon]: <igx-combo> <ng-template igxComboToggleIcon let-collapsed> <igx-icon>{{ collapsed ? 'expand_more' : 'expand_less'}}</igx-icon> </ng-template> </igx-combo> Clear Icon Template Use selector [igxComboClearIcon]: <igx-combo> <ng-template igxComboClearIcon> <igx-icon>cancel</igx-icon> </ng-template> </igx-combo> Templating ComboBox Input When used with templates, the igxComboClearIcon and the igxComboToggleIcon selectors, change how the respective buttons appear in the combobox input. Passing content inside of the igx-combo also allows templating of the combobox input similar to the way an igx-input-group can be templated (using igx-prefix, igx-suffix and igxLabel). The code snippet below illustrates how to add an appropriate label and prefix to the combobox input: <igx-combo> <label igxLabel>Locations</label> <igx-prefix><igx-icon>pin_drop</igx-icon></igx-prefix> </igx-combo> API Summary IgxComboComponent IgxComboComponent Styles Additional Resources ComboBox Component ComboBox Features ComboBox Remote Binding Template Driven Forms Integration Reactive Forms Integration Single Select ComboBox Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/date-picker.html": {
    "href": "components/date-picker.html",
    "title": "Angular Datepicker Component – Ignite UI for Angular",
    "keywords": "Angular Datepicker Component Overview Angular DatePicker is a feature rich component used for entering a date through manual text input or choosing date values from a calendar dialog that pops up. Lightweight and simple to use, the DatePicker in Angular lets users to navigate to a desired date with several view options – month, year, decade. There are the usual min, max, and required properties to add validation. The Ignite UI for Angular DatePicker Component lets users pick a single date through a month-view calendar dropdown or editable input field. The Angular DatePicker also supports a dialog mode for selection from the calendar only, locale-aware and customizable date formatting and validation integration. Angular Datepicker Example Below you can see a sample that demonstrates how the Angular DatePicker works when users are enabled to pick a date through a manual text input and click on the calendar icon on the left to navigate to it. See how to render it. Getting Started with Ignite UI for Angular Datepicker To get started with the Ignite UI for Angular Datepicker component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDatePickerModule in your app.module.ts file. Note As the picker uses the IgxCalendarComponent, it is also dependent on the BrowserAnimationsModule and on the HammerModule for touch interactions, so they need to be added to the module as well: import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxDatePickerModule } from 'igniteui-angular'; // import { IgxDatePickerModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDatePickerModule, BrowserAnimationsModule, HammerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDatePickerComponent as a standalone dependency, or use the IGX_DATE_PICKER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IGX_DATE_PICKER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_DATE_PICKER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-date-picker> <label igxLabel>Date</label> </igx-date-picker> `, styleUrls: ['home.component.scss'], standalone: true, imports: [BrowserAnimationsModule, HammerModule, IGX_DATE_PICKER_DIRECTIVES] /* or imports: [BrowserAnimationsModule, HammerModule, IgxDatePickerComponent, IgxLabelDirective] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Datepicker module or directives imported, you can start using the igx-date-picker component. Using the Angular Datepicker Component Display Datepicker To instantiate a Datepicker in its default dropdown state, use the following code: <igx-date-picker> <label igxLabel>Date</label> </igx-date-picker> Options The IgxDatePickerComponent can be bound to a date or a string. <igx-date-picker [value]=\"date\"></igx-date-picker> public date = new Date(2000, 0, 1); If a string is bound to the picker, it needs to be a date-only string in the ISO 8601 format: <igx-date-picker [value]=\"'2000-01-01'\"></igx-date-picker> More information about this can be found in DateTime Editor's ISO section. Two-way binding is possible through ngModel: <igx-date-picker [(ngModel)]=\"date\"></igx-date-picker> As well as through the value input: <igx-date-picker [(value)]=\"date\"></igx-date-picker> Additionally, formControlName can be set on the picker, to use it in a reactive form: <form [formGroup]=\"form\"> <igx-date-picker formControlName=\"datePicker\"></igx-date-picker> </form> export class SampleFormComponent { // ... public form: FormGroup; constructor(private fb: FormBuilder) { this.form = this.fb.group({ datePicker: ['', Validators.required] }); } } Note The picker always returns a Date value, this means that If it is model bound or two-way bound to a string variable, after a new date has been chosen, it will be of type Date. Projecting components The IgxDatePickerComponent allows the projection of child components that the IgxInputGroupComponent supports (with the exception of IgxInput) - igxLabel, igx-hint / IgxHint, igx-prefix / igxPrefix, igx-suffix / igxSuffix. More detailed information about this can be found in the Label & Input topic. <igx-date-picker #datePicker> <igx-icon igxSuffix (click)=\"datePicker.open()\">keyboard_arrow_down</igx-icon> </igx-date-picker> The above snippet will add an additional toggle icon at the end of the input, right after the default clear icon. This will not remove the default toggle icon, though as prefixes and suffixes can be stacked one after the other. Customizing the toggle and clear icons The IgxDatePickerComponent can be configured with IgxPickerToggleComponent and IgxPickerClearComponent. These can be used to change the toggle and clear icons without having to add your own click handlers. <igx-date-picker> <label igxLabel>Select a Date</label> <igx-picker-toggle igxPrefix> <igx-icon>calendar_view_day</igx-icon> </igx-picker-toggle> <igx-picker-clear igxSuffix> <igx-icon>delete</igx-icon> </igx-picker-clear> </igx-date-picker> Custom action buttons The picker's action buttons can be modified in two ways: the button's text can be changed using the todayButtonLabel and the cancelButtonLabel input properties: <igx-date-picker [todayButtonLabel]=\"'今日'\" [cancelButtonLabel]=\"'キャンセル'\"></igx-date-picker> the whole buttons can be templated using the igxPickerActions directive: With it you gain access to the date picker's calendar and all of its members: <igx-date-picker> <ng-template igxPickerActions let-calendar> <button igxButton=\"flat\" (click)=\"calendar.viewDate = today\">Today</button> </ng-template> </igx-date-picker> Keyboard Navigation Opening and closing the IgxDatePickerComponent's calendar UI with the keyboard is available only for dropdown mode and can be triggered via the key combinations below: Keys Description Space Displays the calendar pop-up and focuses it Alt + ↓ Displays the calendar pop-up and focuses it Esc Closes the calendar pop-up and focuses the input field Enter Closes the calendar pop-up, selecting the focused date and moves the focus to the input field Alt + ↑ Closes the calendar pop-up and focuses the input field Since the IgxDatePickerComponent uses the IgxDateTimeEditorDirective it inherits its keyboard navigation. Examples Dialog Mode The IgxDatePickerComponent also supports a dialog mode: <igx-date-picker [mode]=\"'dialog'\"></igx-date-picker> Display and input format inputFormat and displayFormat are properties which can be set to make the picker's editor follow a specified format. The inputFormat property is used when the picker is in dropdown mode and it governs the input's editable mask, as well as its placeholder (if none is set). Additionally, the inputFormat is locale based, so if none is provided, the picker will default to the one used by the browser. A good thing to note is that the the Angular DatePicker Component in Ignite UI will always add a leading zero on the date and month portions if they were provided in a format that does not have it, e.g. d/M/yy becomes dd/MM/yy. This applies only during editing. displayFormat on the other hand uses Angular's DatePipe and is used to format the picker's input when it is not focused. If no displayFormat is provided, the picker will use the inputFormat as its displayFormat. More information about these can be found in the IgxDateTimeEditor examples section. Note The IgxDatePicker now supports IME input. When composition ends, the control converts the wide-character numbers to ASCII characters. Increment and decrement The IgxDatePickerComponent exposes increment and decrement methods. Both of which come from the IgxDateTimeEditorDirective and can be used for incrementing and decrementing a specific DatePart of the currently set date. <igx-date-picker #datePicker> <igx-icon igxPrefix (click)=\"datePicker.increment(DatePart.Month, 3)\">keyboard_arrow_up</igx-icon> <igx-icon igxPrefix (click)=\"datePicker.decrement(DatePart.Year. 4)\">keyboard_arrow_down</igx-icon> </igx-date-picker> It also has as a spinDelta input property which can be used to increment or decrement a specific date part of the currently set date. <igx-date-picker [spinDelta]=\"{date: 2, month: 3, year: 4}\"></igx-date-picker> In Angular Forms The IgxDatePickerComponent supports all directives from the core FormsModule, NgModel and ReactiveFormsModule (FormControl, FormGroup, etc.). This also includes the Forms Validators functions. In addition, the component's minValue and maxValue properties act as form validators. You can see the IgxDatePickerComponent in a reactive form by visiting our Reactive Forms Integration topic. Using date and time picker together In some cases when the IgxDatePicker and the IgxTimePicker are used together, we might need them to be bound to one and the same Date object value. To achieve that in template driven forms, use the ngModel to bind both components to the same Date object. In reactive forms, we can handle the valueChange event of each component and update the value of the other. Calendar Specific settings The IgxDatePickerComponent uses the IgxCalendarComponent and you can modify some of its settings via the properties that the date picker exposes. Some of these include displayMonthsCount which allows more than one calendar to be displayed when the picker expands, weekStart which determines the starting day of the week, showWeekNumbers which shows the number for each week in the year and more. Internationalization The localization of the IgxDatePickerComponent can be controlled through its locale input. Additionally, using the igxCalendarHeader and the igxCalendarSubheader templates, provided by the IgxCalendarComponent, you can specify the look of your header and subheader. More information on how to use these templates can be found in the IgxCalendarComponent topic. Here is how an Angular DatePicker with Japanese locale definition would look like: <igx-date-picker locale=\"ja-JP\" [value]=\"date\"> <ng-template igxCalendarHeader let-format> {{ format.month.combined | titlecase }}{{format.day.combined }}{{ format.weekday.combined }} </ng-template> <ng-template igxCalendarSubheader let-format> <span (click)=\"format.yearView()\">{{ format.year.combined }}</span> <span (click)=\"format.monthView()\">{{ format.month.combined | titlecase }}</span> </ng-template> </igx-date-picker> Styling To get started with styling the date picker, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The Angular DatePicker uses the calendar's theme, so we have to create a new theme that extends the calendar-theme and use some of its parameters to style the date picker's items: $custom-datepicker-theme: calendar-theme( $header-background: #345779, $content-background: #fdfdfd, $header-text-color: #ffffff, $date-current-text-color: #2dabe8, $picker-arrow-color: #2dabe8, $date-selected-text-color: #fdfdfd, $date-current-bg-color: #fdfdfd, $picker-arrow-hover-color: #345779, $year-current-text-color: #2dabe8, $year-hover-text-color: #2dabe8, $month-current-text-color: #2dabe8, $month-hover-text-color: #2dabe8, $picker-text-color: #2dabe8, $picker-text-hover-color: #345779, ); Using CSS variables The last step is to pass the custom Angular DatePicker theme: @include css-vars($custom-datepicker-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include calendar($custom-datepicker-theme); } } API References IgxDatePickerComponent IgxDateTimeEditorDirective IgxCalendarComponent IgxCalendarComponent Styles IgxOverlay Styles IgxInputGroupComponent Theming Dependencies IgxCalendar Theme IgxOverlay Theme IgxIcon Theme IgxButton Theme IgxInputGroup Theme IgxDropDown Theme Additional Resources Time Picker Date Time Editor Date Range Picker Reactive Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/date-range-picker.html": {
    "href": "components/date-range-picker.html",
    "title": "Angular Date Range Picker Component | Ignite UI for Angular",
    "keywords": "Angular Date Range Picker Component Overview Angular Date Range Picker is a lightweight component that includes text input and a calendar pop-up to allow users to easily select start and end date values. It can be customized to match app requirements with features like range restrictions, formats, data range selection, grouping the start and end values together and many more. The Date Range Picker in Angular also allows developers to change the default view property and set it to month, year or multi-year. Angular Date Range Picker Example We have created this basic Angular Date Range Picker example to show you the component in action. In this case, you see a calendar pop-up, letting users select start and end date values. Getting Started with Ignite UI for Angular Date Range Picker To get started with the Ignite UI for Angular Datepicker component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDateRangePickerModule in your app.module.ts file. As IgxDateRangePicker uses the IgxCalendarComponent, it also has a dependency on the BrowserAnimationsModule and the HammerModule for touch interactions, so they need to be added to the AppModule as well: // app.module.ts import { IgxDateRangePickerModule } from 'igniteui-angular'; // import { IgxDateRangePickerModule } from '@infragistics/igniteui-angular'; for licensed package import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; @NgModule({ ... imports: [..., IgxDateRangePickerModule, BrowserAnimationsModule, HammerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDateRangePickerComponent as a standalone dependency, or use the IGX_DATE_RANGE_PICKER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IGX_DATE_RANGE_PICKER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_DATE_RANGE_PICKER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-date-range-picker [value]=\"range\"></igx-date-range-picker>', styleUrls: ['home.component.scss'], standalone: true, imports: [BrowserAnimationsModule, HammerModule, IGX_DATE_RANGE_PICKER_DIRECTIVES] /* or imports: [BrowserAnimationsModule, HammerModule, IgxDateRangePickerComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Date Range Picker module or directives imported, you can start using the igx-date-range-picker component. Using the Angular Date Range Picker Component Display Date Range Picker To instantiate a date range picker in its default mode, use the following code: <igx-date-range-picker [value]=\"range\"></igx-date-range-picker> public range: DateRange = { start: new Date(2020, 4, 20), end: new Date(2020, 4, 25) }; Note The Date Range Picker value is of type DateRange, which contains a start and an end date. To create a two-way data-binding, use ngModel: <igx-date-range-picker [(ngModel)]=\"range\"></igx-date-range-picker> Projecting components To enrich the default Date Range Picker UX, the component allows projecting child components - the same as in the IgxInputGroupComponent: igxLabel, igx-hint / igxHint, igx-prefix / igxPrefix, igx-suffix / igxSuffix, excluding IgxInput. More detailed information about this can be found in the Label & Input topic. In addition, the Ignite UI for Angular Date Range Picker can be configured to project IgxPickerToggleComponent - a component that controls the calendar toggle and can be modified as shown in the Calendar toggle section. <igx-date-range-picker #dateRangePicker [(ngModel)]=\"range\"> <label igxLabel>Flight dates</label> <igx-hint *ngIf=\"dateRangePicker.invalid\"> Please choose start and end date! </igx-hint> </igx-date-range-picker> Display Separate Editable Inputs The Angular Date Range Picker component also allows configuring two separate inputs for start and end date. This can be achieved by using the IgxDateRangeStartComponent and IgxDateRangeEndComponent as children of the date range picker, as shown in the demo below: <igx-date-range-picker [(ngModel)]=\"range\"> <igx-date-range-start> <input igxInput igxDateTimeEditor type=\"text\"> </igx-date-range-start> <igx-date-range-end> <input igxInput igxDateTimeEditor type=\"text\"> </igx-date-range-end> </igx-date-range-picker> Both the IgxDateRangeStartComponent and IgxDateRangeEndComponent extend the existing IgxInputGroupComponent. For such a configuration to work, defining an IgxInput is required. In addition, all other components and directives available to the IgxInputGroupComponent can also be used. In order to enable date editing for both inputs, you need to decorate them with igxDateTimeEditor directive. User Experience In a default configuration, with a single read-only input, the calendar can be opened by clicking anywhere in the input, including the calendar icon. When there are two separate inputs for start and end date, the calendar can only be opened from the calendar icon, since both inputs are editable by default. When the calendar is visible, a range can be selected by choosing the start and end dates. Picking a date will set the start and end date, until a second date is chosen. If there is a selected range, clicking any other date from the calendar will start a new range selection. Start and end date are separated by a hyphen when shown in the component's read-only input. When defining different inputs for start and end, they are separated by the to preposition. The latter can be localized or overwritten via a template. See the Templating example below, for more details. Examples Label To define the label for the date range picker the igxLabel directive should be used as shown in the snippet below: <igx-date-range-picker [(ngModel)]=\"range\"> <label igxLabel>Flight dates</label> </igx-date-range-picker> Calendar toggle In the default configuration, with a single read-only input, a default calendar icon is shown as a prefix. The calendar icon can be changed or redefined using the IgxPickerToggleComponent component. It can be decorated with either igxPrefix or igxSuffix, which will define its position - at the start of the input or at the end respectively. To change the default position and show the icon as a suffix, you need to do the following: <igx-date-range-picker> <igx-picker-toggle igxSuffix> <igx-icon>calendar_view_day</igx-icon> </igx-picker-toggle> </igx-date-range-picker> When a Date Range Picker has two separate inputs, for start and end dates, it doesn't expose a calendar icon by default. The IgxPickerToggleComponent should be manually added as a child of the IgxDateRangeStartComponent or IgxDateRangeEndComponent like so: <igx-date-range-picker> <igx-date-range-start> ... <igx-picker-toggle igxPrefix> <igx-icon>calendar_view_day</igx-icon> </igx-picker-toggle> ... </igx-date-range-start> <igx-date-range-end> ... </igx-date-range-end> </igx-date-range-picker> Dialog mode The IgxDateRangePickerComponent component has two modes - dropdown (default) and dialog. To switch to dialog mode, do the following: <igx-date-range-picker [mode]=\"'dialog'\"></igx-date-range-picker> The range value is set when dates are picked from the calendar. You will notice that in dropdown mode, the Done button is not available. Custom Action Buttons The Date Range Picker’s action buttons can be templated using the igxPickerActions directive. A common scenario is allowing the user to select from pre-defined ranges, as in the following demo: Keyboard Navigation Note Use the demos for Dialog mode and Display Separate Editable Inputs to try the keyboard combinations defined below. Opening and closing the IgxDateRangePickerComponent calendar UI with the keyboard is available only for dropdown mode and can be triggered via the key combinations below: Alt + Down Arrow - Opens the dropdown containing the calendar UI and focuses it Alt + Up Arrow - Closes the dropdown and focuses the input field (range start input field when two separate inputs are used) Esc - Closes the dropdown and focuses the input field (range start input field when two separate inputs are used) Keyboard navigation within the calendar UI of the Date Range Picker is available in all modes and configurations. When the calendar is opened it takes focus and the following keyboard combinations can be used: Enter selects start and end dates PageUp, PageDown, Shift + PageUp, Shift + PageDown, Home, End, Tab - navigate the calendar The calendar keyboard navigation section contains all keyboard combinations that can be used in the calendar. When two separate inputs are used, keyboard navigation for the igxDateTimeEditor directive is also applicable to the Date Range Picker component: Ctrl / Cmd + Arrow Left / Right - navigates between date sections. On Ctrl / Cmd + Right it goes to the end of the section. If already there it goes to the end of the next section. It works the same way in the opposite direction. Arrow Up / Down - increments/decrements date portions. Ctrl / Cmd + ; - sets the current day and time in the editor. Formatting The Date Range Picker Component supports different display and input formats. The display format of the value can be one of the listed Angular DatePipe formats. This allows it to support predefined format options, such as shortDate and longDate. The inputFormat property accepts a constructed format string using characters supported by the DatePipe, e.g. MM/dd/yyyy, but doesn't support predefined format options, such as shortDate and longDate. If the inputFormat property is not defined then the Angular locale ID token is used when building it. <igx-date-range-picker [(ngModel)]=\"range\" required inputFormat=\"dd/MM/yyyy\" displayFormat=\"shortDate\"> </igx-date-range-picker> Note The IgxDateRangePicker now supports IME input. When composition ends, the control converts the wide-character numbers to ASCII characters. Forms and Validation The Date Range Picker Component supports all directives from the core FormsModule, NgModel and ReactiveFormsModule (FormControl, FormGroup, etc.). This also includes the Forms Validators functions. In addition, the component's min and max values also act as form validators. The NgModel and validators can be set on the IgxDateRangePickerComponent or on the individual start and end date inputs. The following snippets and examples illustrate the use of the required validator in a Template-driven form. First, we need to set up the model for a single read-only range component, which is done on the component level: <igx-date-range-picker [(ngModel)]=\"range\" required> <label igxLabel>Period</label> </igx-date-range-picker> The same configuration can be used when setting two separate inputs. Note that in this case, validation is also applied to both inputs. <igx-date-range-picker [(ngModel)]=\"range\" required> <igx-date-range-start> <label igxLabel>Start Date</label> <input igxInput igxDateTimeEditor type=\"text\"> <igx-picker-toggle igxPrefix> <igx-icon>calendar_today</igx-icon> </igx-picker-toggle> </igx-date-range-start> <igx-date-range-end> <label igxLabel>End Date</label> <input igxInput igxDateTimeEditor type=\"text\"> </igx-date-range-end> </igx-date-range-picker> When using two separate inputs, it is possible to set the model and required properties on each input. Note that validation is specific for each individual input. <igx-date-range-picker> <igx-date-range-start> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.start\" type=\"text\" required> </igx-date-range-start> <igx-date-range-end> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.end\" type=\"text\" required> </igx-date-range-end> </igx-date-range-picker> Min and max values You can specify minValue and maxValue properties to restrict the user input by disabling calendar dates that are outside the range defined by those values. public minDate = new Date(2020, 1, 15); public maxDate = new Date(2020, 11, 1); <igx-date-range-picker [(ngModel)]=\"range\" required [minValue]=\"minDate\" [maxValue]=\"maxDate\"> </igx-date-range-picker> <igx-date-range-picker [minValue]=\"minDate\" [maxValue]=\"maxDate\"> <igx-date-range-start> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.start\" type=\"text\" required> </igx-date-range-start> <igx-date-range-end> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.end\" type=\"text\" required> </igx-date-range-end> </igx-date-range-picker> The IgxDateRangePickerComponent is also a validator which means it controls its validity internally using minValue and maxValue. You can also access both of them through ngModel: <igx-date-range-picker #dateRangePicker=\"ngModel\" [(ngModel)]=\"range\" required [minValue]=\"minDate\" [maxValue]=\"maxDate\"> <igx-date-range-start> <input igxInput igxDateTimeEditor type=\"text\"> </igx-date-range-start> <igx-date-range-end> <input igxInput igxDateTimeEditor type=\"text\"> </igx-date-range-end> </igx-date-range-picker> <!-- minValue & maxValue will be true if the current range does not satisfy them --> <div *ngIf=\"dateRangePicker.minValue || dateRangePicker.maxValue\"> <p>Value not in range.</p> </div> Templating When two editors are used, the default separator can be replaced using the igxDateRangeSeparator directive. Here is how to change the date separator to a hyphen -: <igx-date-range-picker> <igx-date-range-start> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.start\" type=\"text\" required> </igx-date-range-start> <ng-template igxDateRangeSeparator>-</ng-template> <igx-date-range-end> <input igxInput igxDateTimeEditor [(ngModel)]=\"range.end\" type=\"text\" required> </igx-date-range-end> </igx-date-range-picker> Styling To get started with styling the igxDateRangePicker, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The Date Range Picker Component exposes date-range-picker-theme and utilizes several components and directives, including igxInputGroupComponent, igxCalendar and igxOverlay. Any global styling for the aforementioned components and directives will affect the igxDateRangeComponent. As the Date Range Picker Component uses the input group and calendar themes, we have to create new themes that extend the calendar-theme and input-group-theme and use some of their parameters to style the date range picker in conjunction with the date range picker theme. We will use a single custom color palette to define the colors to use across all themes: // COMMON $purple: #9E379F; $blue: #61AEDB; $custom-palette: palette($primary: $blue, $secondary: $purple); $today-text: color($custom-palette, \"primary\", 500); $text-color: color($custom-palette, \"secondary\", 200); $color-focused: color($custom-palette, \"secondary\", 500); // DATE-RANGE $custom-date-range-theme:date-range-picker-theme( $label-color: $color-focused ); // INPUT GROUP $custom-input-group-theme: input-group-theme( $palette: $custom-palette, $filled-text-color: $text-color, $idle-text-color: $text-color, $focused-text-color: $color-focused, $hover-bottom-line-color: $color-focused, $idle-bottom-line-color: $purple ); // CALENDAR $custom-calendar-theme: calendar-theme( $palette: $custom-palette, $date-current-text-color: $today-text, $border-radius: 0.5, $date-border-radius: 0.5 ); Using CSS variables The last step is to pass the custom themes: @include css-vars($custom-date-range-theme); @include css-vars($custom-input-group-theme); @include css-vars($custom-calendar-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate it using ::ng-deep. To prevent the custom theme from leaking into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include date-range-picker($custom-date-range-theme); @include input-group($custom-input-group-theme); @include calendar($custom-calendar-theme); } } Scoping Styles Regarding style scoping, you should refer to both styling sections [Overlay Scoped Component Styles](overlay-styling.md#Scoped Overlay Styles) and Input Group Scoping Styles as they provide more information. Application Demo The demo below defines a form for flight tickets that uses the IgxDateRangePickerComponent. If no dates are selected, an IgxHint is used to display a validation error. The selection of the dates is restricted by the minValue and maxValue properties of the IgxDateRangePickerComponent API References IgxDateRangePickerComponent IgxCalendarComponent IgxCalendarComponent Styles IgxOverlay Styles IgxInputGroupComponent Theming Dependencies IgxCalendar Theme IgxOverlay Theme IgxIcon Theme IgxButton Theme IgxInputGroup Theme IgxDropDown Theme Additional Resources Related topics: Date Time Editor Label & Input Reactive Forms Integration Date Picker Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/date-time-editor.html": {
    "href": "components/date-time-editor.html",
    "title": "Angular Date Time Editor Component | Ignite UI for Angular",
    "keywords": "Angular Date Time Editor Directive The Ignite UI for Angular Date Time Editor Directive allows the user to set and edit the date and time in a chosen input element. The user can edit the date or time portion, using an editable masked input. Additionally, one can specify a desired display and input format, as well as min and max values to utilize validation. Angular Date Time Editor Directive Example Getting Started with Angular Date Time Editor Directive To get started with the Ignite UI for Angular Date Time Editor directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDateTimeEditorModule in your app.module.ts file. // app.module.ts ... import { IgxDateTimeEditorModule } from 'igniteui-angular'; // import { IgxDateTimeEditorModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDateTimeEditorModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDateTimeEditorDirective as a standalone dependency. // home.component.ts import { IgxDateTimeEditorDirective, IGX_INPUT_GROUP_DIRECTIVES } from 'igniteui-angular'; // import { IgxDateTimeEditorDirective, IGX_INPUT_GROUP_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-input-group> <input type=\"text\" igxInput igxDateTimeEditor [value]=\"date\" /> </igx-input-group> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxDateTimeEditorDirective, IGX_INPUT_GROUP_DIRECTIVES] }) export class HomeComponent { public date = new Date(); } Now that you have the Ignite UI for Angular Date Time Editor module or directive imported, you can start using the igxDateTimeEditor directive. Using the Angular Date Time Editor Directive To use an input as a date time editor, set an igxDateTimeEditor directive and a valid date object as value. In order to have complete editor look and feel, wrap the input in an igx-input-group. This will allow you to not only take advantage of the following directives igxInput, igxLabel, igx-prefix, igx-suffix, igx-hint, but will cover common scenarios when dealing with form inputs as well. Binding A basic configuration scenario setting a Date object as a value: public date = new Date(); <igx-input-group> <input type=\"text\" igxInput igxDateTimeEditor [value]=\"date\" /> </igx-input-group> To create a two-way data-binding, set an ngModel: <igx-input-group> <input type=\"text\" igxInput igxDateTimeEditor [(ngModel)]=\"date\"/> </igx-input-group> Binding to ISO strings The IgxDateTimeEditorDirective accepts an ISO 8601 strings. The string can be a full ISO string, in the format YYYY-MM-DDTHH:mm:ss.sssZ or it could be separated into date-only and time-only portions. Date-only If a date-only string is bound to the directive, it needs to follow the format - YYYY-MM-DD. This applies only when binding a string value to the directive, the inputFormat is still used when typing values in the editor and it does not have to be in the same format. Additionally, when binding a date-only string, the directive will prevent time shifts by coercing the time to be T00:00:00. Time-only Time-only strings are normally not defined in the ECMA specification, however to allow the directive to be integrated in scenarios which require time-only solutions, it supports the 24 hour format - HH:mm:ss. The 12 hour format is not supported. Please also note that this applies for bound values only. Full ISO string If a full ISO string is bound, the directive will parse it only if all elements required by Date.parse are provided. All falsy values, including InvalidDate will be parsed as null. Incomplete date-only, time-only, or full ISO strings will be parsed as InvalidDate. Keyboard Navigation Date Time Editor Directive has intuitive keyboard navigation that makes it easy to increment, decrement, or jump through different DateParts among others without having to touch the mouse. Ctrl / Cmd + Arrow Left / Right - navigates between date sections. On Ctrl / Cmd + Right it goes to the end of the section. If already there it goes to the end of next section if any. It works in a similar fashion in the opposite direction. Arrow Up / Down - increment/decrement date portions. See related spinLoop Ctrl / Cmd + ; - set the current day and time in the editor. Examples Display and input format The IgxDateTimeEditor supports different display and input formats. It uses Angular's DatePipe, which allows it to support predefined format options, such as shortDate and longDate. It can also accept a constructed format string using characters supported by the DatePipe, e.g. EE/MM/yyyy. Notice that formats like shortDate, longDate, etc., can be used as displayFormat only. Also, if no displayFormat is provided, the editor will use the inputFormat as its displayFormat. To set a specific input format, pass it as a string to the IgxDateTimeEditor directive. This will set both the expected user input format and the mask for the editor. Additionally, the inputFormat is locale based, so if none is provided, the editor will default to the one used by the browser. <igx-input-group> <input type=\"text\" igxInput [displayFormat]=\"'shortDate'\" [igxDateTimeEditor]=\"'dd/MM/yyyy'\" [(ngModel)]=\"date\"/> </igx-input-group> The table bellow shows formats that are supported by the directive's inputFormat: Format Description d Date, will be coerced with a leading zero while editing. dd Date with an explicitly set leading zero. M Month, will be coerced with a leading zero while editing. MM Month with an explicitly set leading zero. yy Short year format. yyyy Full year format. h Hours in 12-hour format, will be coerced with a leading zero while editing. hh Hours in 12-hour format with an explicitly set leading zero. H Hours in 24-hour format, will be coerced with a leading zero while editing. HH Hours in 24-hour format, with an explicitly set leading zero. m Minutes, will be coerced with a leading zero while editing. mm Minutes with an explicitly set leading zero. tt AM/PM section for 12-hour format. Note The IgxDateTimeEditorDirective directive supports IME input. When typing in an Asian language input, the control will display input method compositions and candidate lists directly in the control’s editing area, and immediately re-flow surrounding text as the composition ends. Min max value You can specify minValue and maxValue properties to restrict input and control the validity of the ngModel. public minDate = new Date(2020, 1, 15); public maxDate = new Date(2020, 11, 1); <igx-input-group> <input type=\"text\" igxInput igxDateTimeEditor [minValue]=\"minDate\" [maxValue]=\"maxDate\" [(ngModel)]=\"date\"/> </igx-input-group> The minValue and minValue inputs can also be of type string, see Binding to ISO strings. Increment and decrement igxDateTimeEditor directive exposes public increment and decrement methods. They increment or decrement a specific DatePart of the currently set date and time and can be used in a couple of ways. In the first scenario, if no specific DatePart is passed to the method, a default DatePart will increment or decrement, based on the specified inputFormat and the internal directive implementation. In the second scenario, you can explicitly specify what DatePart to manipulate as it may suite different requirements. Also, both methods accept an optional delta parameter of type number which can be used to set the increment/decrement step. You may compare both in the following sample: Additionally, spinDelta is an input property of type DatePartDeltas and it can be used to apply a different delta to each date time segment. It will be applied when spinning with the keyboard, as well as when spinning with the increment and decrement methods, as long as they don't have the delta parameter provided since it will take precedence over spinDelta. In Angular Forms The Date Time Editor Directive supports all of the form directives from the core FormsModule NgModel and ReactiveFormsModule (FormControl, FormGroup, etc.). This also includes the Forms Validators functions. The following example illustrates the use of the required validator in a Template-driven Form. Note If needed, you can revert back to a valid state by handling the validationFailed event and changing the newValue property of the available arguments. Template-driven form example: <form> <igx-input-group> <input igxInput type=\"text\" [(ngModel)]=\"date\" name=\"form\" required (valueChanged)=\"onValueChanged($event)\" (validationFailed)=\"onValidationFailed($event)\" [igxDateTimeEditor]=\"'dd/MM/yyyy'\" [minValue]=\"minDate\" [maxValue]=\"maxDate\" [isSpinLoop]=\"false\" /> </igx-input-group> </form> <div class=\"divider--half\"></div> Text Selection You can force the component to select all of the input text on focus using igxTextSelection. Find more info on igxTextSelection at Label & Input. <igx-input-group> <input igxInput [igxDateTimeEditor]=\"'dd/MM/yyyy'\" [igxTextSelection]=\"true\"/> </igx-input-group> Note In order for the component to work properly, it is crucial to set igxTextSelection after the igxDateTimeEditor directive. The reason for this is both directives operate on the input focus event so text selection should happen after the mask is set. Styling For details check out the Input Group styling guide. API References IgxDateTimeEditorDirective IgxHintDirective IgxInputDirective IgxInputGroupComponent IgxInputGroupComponent Styles Additional Resources Related topics: Mask Label & Input Reactive Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/dialog.html": {
    "href": "components/dialog.html",
    "title": "Angular Dialog Window Component",
    "keywords": "Angular Dialog Window Component Overview Use the Ignite UI for Angular Dialog Window component to display messages or present forms for users to fill out. The component opens a dialog window centered on top of app content. You can also provide a standard alert message that users can cancel. Angular Dialog Window Example Getting Started with Ignite UI for Angular Dialog Window To get started with the Ignite UI for Angular Dialog Window component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDialogModule in your app.module.ts file. // app.module.ts ... import { IgxDialogModule } from 'igniteui-angular'; // import { IgxDialogModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDialogModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDialogComponent as a standalone dependency, or use the IGX_DIALOG_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_DIALOG_DIRECTIVES, IgxButtonDirective, IgxRippleDirective } from 'igniteui-angular'; // import { IGX_DIALOG_DIRECTIVES, IgxButtonDirective, IgxRippleDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button igxButton=\"contained\" igxRipple=\"white\" (click)=\"alert.open()\">Show Alert Dialog</button> <igx-dialog #alert title=\"Notification\" message=\"Your email has been sent successfully!\" leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\"> </igx-dialog> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_DIALOG_DIRECTIVES, IgxButtonDirective, IgxRippleDirective] /* or imports: [IgxDialogComponent, IgxButtonDirective, IgxRippleDirective] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Dialog Window module or directives imported, you can start using the igx-dialog component. Using the Angular Dialog Window Alert Dialog To create an alert dialog, in the template of our email component, we add the following code. We have to set the title, message, leftButtonLabel and handle leftButtonSelect event: <!--email.component.html--> <button igxButton=\"contained\" igxRipple=\"white\" (click)=\"alert.open()\">Show Alert Dialog</button> <igx-dialog #alert title=\"Notification\" message=\"Your email has been sent successfully!\" leftButtonLabel=\"OK\" (leftButtonSelect)=\"alert.close()\"> </igx-dialog> If everything's done right, you should see the demo sample shown above in your browser. Standard Dialog To create a standard dialog, in the template of our file manager component, we add the following code. We have to set the title, message, leftButtonLabel, rightButtonLabel, and handle leftButtonSelect and rightButtonSelect events: <!--file-manager.component.html--> <button igxButton=\"contained\" igxRipple=\"white\" (click)=\"dialog.open()\">Show Confirmation Dialog</button> <igx-dialog #dialog title=\"Confirmation\" leftButtonLabel=\"Cancel\" (leftButtonSelect)=\"dialog.close()\" rightButtonLabel=\"OK\" (rightButtonSelect)=\"onDialogOKSelected($event)\" message=\"Are you sure you want to delete the Microsoft_Annual_Report_2015.pdf and Microsoft_Annual_Report_2015.pdf files?\"> </igx-dialog> Custom Dialog To create a custom dialog, in the template of our sign-in component, we add the following code. The dialog title area can be customized using the igxDialogTitle directive or the igx-dialog-title selector. The actions area can be customized using the igxDialogActions directive or the igx-dialog-actions selector. We add two input groups consisting of a label and and input decorated with the igxLabel and igxInput directives. <!--sign-in.component.html--> <button igxButton=\"contained\" igxRipple=\"white\" (click)=\"alert.open()\">Show Custom Dialog</button> <igx-dialog #form [closeOnOutsideSelect]=\"true\"> <igx-dialog-title> <div class=\"dialog-container\"> <igx-icon>vpn_key</igx-icon> <div class=\"dialog-title\">Sign In</div> </div> </igx-dialog-title> <form class=\"signInForm\"> <igx-input-group> <igx-prefix> <igx-icon>person</igx-icon> </igx-prefix> <label igxLabel for=\"username\">Username</label> <input igxInput id=\"username\" type=\"text\"/> </igx-input-group> <igx-input-group> <igx-prefix> <igx-icon>lock</igx-icon> </igx-prefix> <label igxLabel>Password</label> <input igxInput id=\"password\" type=\"password\"/> </igx-input-group> </form> <div igxDialogActions> <button igxButton (click)=\"form.close()\">CANCEL</button> <button igxButton (click)=\"form.close()\">SIGN IN</button> </div> </igx-dialog> Position and Animation Settings There are two ways to change the position at which the igx-dialog will be shown: Using open method and pass a valid overlaySettings. Example: import { PositionSettings, OverlaySettings, GlobalPositionStrategy, NoOpScrollStrategy, HorizontalAlignment, VerticalAlignment } from 'igniteui-angular'; // import { PositionSettings, OverlaySettings, GlobalPositionStrategy, NoOpScrollStrategy, HorizontalAlignment, VerticalAlignment } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class HomeComponent { public positionSettingsOnOpen: PositionSettings = { horizontalDirection: HorizontalAlignment.Right, verticalDirection: VerticalAlignment.Middle, horizontalStartPoint: HorizontalAlignment.Right, verticalStartPoint: VerticalAlignment.Middle, }; public overlaySettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy(this.positionSettingsOnOpen), scrollStrategy: new NoOpScrollStrategy(), modal: false, closeOnOutsideClick: true }; public openDialog() { this.alert.open(this.overlaySettings); } } Using the positionSettings @Input. Example: <igx-dialog #alert title=\"Notification\" [positionSettings]=\"positionSettings\" > </igx-dialog> import { useAnimation } from '@angular/animations'; import { PositionSettings, HorizontalAlignment, VerticalAlignment } from 'igniteui-angular'; // import { PositionSettings, HorizontalAlignment, VerticalAlignment } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class HomeComponent { public positionSettings: PositionSettings = { openAnimation: useAnimation(slideInTop, { params: { duration: '2000ms' } }), closeAnimation: useAnimation(slideOutBottom, { params: { duration: '2000ms'} }), horizontalDirection: HorizontalAlignment.Left, verticalDirection: VerticalAlignment.Middle, horizontalStartPoint: HorizontalAlignment.Left, verticalStartPoint: VerticalAlignment.Middle, minSize: { height: 100, width: 100 } }; } Note The same approach should be used for the animation settings, use the openAnimation and closeAnimation properties to define animation params like duration. params object example: params: { delay: '0s', duration: '350ms', easing: EaseOut.quad, endOpacity: 1, fromPosition: 'translateX(-500px)', startOpacity: 0, toPosition: 'translateY(0)' } Trap focus inside dialog By default when the dialog is opened the Tab key focus is trapped within it, i.e. the focus does not leave the element when the user keeps tabbing through the focusable elements. When the focus leaves the last element, it moves to the first one and vice versa, when SHIFT + TAB is pressed, when the focus leaves the first element, the last element should be focused. In case the dialog does not contain any focusable elements, the focus will be trapped on the dialog container itself. This behavior can be changed by setting the focusTrap property. Styling To get started with styling the dialog window, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the dialog-theme and accepts parameters that style the dialog. $my-dialog-theme: dialog-theme( $background: #011627, $title-color: #ECAA53, $message-color: #FEFEFE, $border-radius: .3, ); Note In order to style any additional components that are used as part of the dialog window's content (such as the IgxButton), an additional theme should be created that is specific to the respective component and is placed under the dialog window's scope only (so it does not affect the rest of the application). Since the dialog window uses the IgxOverlayService, in order for our custom theme to reach down the dialog window that we want to style, we will provide a specific outlet where the dialog window will be placed in the DOM when it is visible. <div igxOverlayOutlet> <igx-dialog #dialog1> <!-- .... --> </igx-dialog> </div> Note In order to learn more about the various options for providing themes to elements that are shown by using the IgxOverlayService, you can take a look at the Overlay styling topic. Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the theme like that: @include dialog($my-dialog-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include dialog($my-dialog-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($my-dialog-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($my-dialog-theme); } Demo API Summary IgxDialogComponent IgxDialogComponent Styles IgxOverlay IgxOverlay Styles Theming Dependencies IgxButton Theme IgxRipple Theme IgxOverlay Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/display-density.html": {
    "href": "components/display-density.html",
    "title": "Size (Display Density) | Ignite UI for Angular",
    "keywords": "Size (Display Density) Size (display density) configuration can significantly improve the visual representation of large amounts of data. In Ignite UI for Angular, we provide a pre-defined set of options – large (comfortable), medium (cosy), and small (compact). Using the --ig-size custom CSS property, you can configure the size on an application or a component level. Angular Size Example Note To start using Ignite UI for Angular components in your own projects, make sure you have configured all necessary dependencies and have performed the proper setup of your project. You can learn how to do this in the installation topic. Usage Setting size on an application/component level To set the size, use the --ig-size CSS custom property. You can set the size for all components in your app by setting the aforementioned property on the body element. The available values for --ig-size are --ig-size-small, --ig-size-medium, and --ig-size-large. body { --ig-size: var(--ig-size-small); } To set the size on a component level, target the element selector. For instance, to set the size of the input group to small, you can do: igx-input-group { --ig-size: var(--ig-size-small); } Incorporating size in your own components and layouts Ignite UI for Angular exposes a few Sass functions and a mixin that allow you to implement layouts that react to changes of the --ig-size CSS property. Here's an example on how we can make an element change its width and height based on the value of --ig-size. <div class=\"my-elem\"></div> @use \"igniteui-angular/theming\" as *; .my-elem { // Make the element sizable @include sizable(); // Define the default size of the element and hook it to the `--ig-size` property --component-size: var(--ig-size, var(--ig-size-large)); // Define sizes for small (10px), medium (20px), and large (30px) --size: #{sizable(10px, 20px, 30px)}; width: var(--size); height: var(--size); } Now any time the value of --ig-size changes, .my-elem will change its size. API References Themes - Sizable Mixin Themes - Sizable Function Sizing and Spacing Functions Utilities - Pad Utilities - Pad Inline Utilities - Pad Block Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/divider.html": {
    "href": "components/divider.html",
    "title": "Angular Divider Component",
    "keywords": "Angular Divider Component Overview The divider component enables users to separate content both horizontally and vertically. Angular Divider Example By default the divider is a solid horizontal line. Getting Started with Ignite UI for Angular Divider To get started with the Ignite UI for Angular Divider component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDividerModule in your app.module.ts file. // app.module.ts ... import { IgxDividerModule } from 'igniteui-angular'; // import { IgxDividerModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDividerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDividerDirective as a standalone dependency. // home.component.ts import { IgxDividerDirective } from 'igniteui-angular'; // import { IgxDividerDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-divider></igx-divider>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxDividerDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Divider module or directive imported, you can start using the igx-divider component. Using the Angular Divider Vertical Divider By adding the vertical attribute and setting its value to true, you can change the direction of the divider from horizontal to vertical. <igx-divider [vertical]=\"true\"></igx-divider> Dashed Divider The default style of the divider is a solid line but it can also be dashed. To change the default look simply use the type attribute of the divider and set its value to dashed. <igx-divider type=\"dashed\"></igx-divider> Inset Divider The divider can be set in on both sides. To inset the divider, set the middle attribute of the divider to true and provider the desired inset value, the divider will start shrinking from both ends. Keep in mind that you have to add unit(px,rem,%...) at the end of the value otherwise, it will not work. // Both side <igx-divider [middle]=\"true\" inset=\"80px\"></igx-divider> // Left side only <igx-divider inset=\"40px\"></igx-divider> If the value of the middle attribute is set to a falsy value, or if the attribute is omitted altoghether, the divider will set in only on the left. API References IgxDividerDirective IgxDividerDirective Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/dock-manager.html": {
    "href": "components/dock-manager.html",
    "title": "Manage Angular Page Layout | Dock Manager | Ignite UI | Infragistics",
    "keywords": "Dock Manager The Ignite UI Dock Manager component provides means to manage the layout of your application through panes, allowing your end-users to customize it further by pinning, resizing, moving and hiding panes. Angular Dock Manager Example Usage The Dock Manager is a standard web component and as such can be used in an Angular application. Follow the steps below to add the Dock Manager package to your Angular project and set it up in order to use the component. First, install the igniteui-dockmanager package npm install igniteui-dockmanager Then, include the CUSTOM_ELEMENTS_SCHEMA schema in the AppModule: import { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core'; @NgModule({ ... schemas: [CUSTOM_ELEMENTS_SCHEMA] }) export class AppModule {} Next, one should call the defineCustomElements() function in the main.ts file: import { AppModule } from './app/app.module'; import { defineCustomElements } from 'igniteui-dockmanager/loader'; import { enableProdMode } from '@angular/core'; import { environment } from '.environments/environment'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; if (environment.production) { enableProdMode(); } platformBrowserDynamic().bootstrapModule(AppModule) .catch(err => console.log(err)); defineCustomElements(); This is it, you are now ready to use the Dock Manager component in an Angular component template. To do so simply use its tag name: <igc-dockmanager> </igc-dockmanager> For further information on the usage of the Dock Manager component, you can check out this topic. For a more advanced example of the usage of the Dock Manager component with panes hosting various Ignite UI for Angular components, see this version of the data analysis sample. View page on GitHub"
  },
  "components/drag-drop.html": {
    "href": "components/drag-drop.html",
    "title": "Angular Drag and Drop | IgniteUI for Angular | Infragistics",
    "keywords": "Angular Drag and Drop Directives Overview The Ignite UI for Angular Drag and Drop directives enable dragging of elements around the page. The supported features include free dragging, using a drag handle, drag ghost, animations and multiple drop strategies. Angular Drag and Drop Example Drag and drop icon to reposition it. Getting Started with Ignite UI for Angular Drag and Drop To get started with the Ignite UI for Angular Drag and Drop directives, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDragDropModule in your app.module.ts file. // app.module.ts ... import { IgxDragDropModule } from 'igniteui-angular'; // import { IgxDragDropModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDragDropModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDragDirective and IgxDropDirective as standalone dependencies, or use the IGX_DRAG_DROP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_DRAG_DROP_DIRECTIVES } from 'igniteui-angular'; // import { IGX_DRAG_DROP_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <div igxDrag>Drag me</div> <div igxDrop>Drop here</div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_DRAG_DROP_DIRECTIVES] /* or imports: [IgxDragDirective, IgxDropDirective] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Drag and Drop module or directives imported, you can start using the igxDrag and igxDrop directives. Using the Angular Drag Directive When an element inside your Angular application needs to be dragged from one place to another on the page, the igxDrag directive is designed to help achieve this behavior. In combination with the igxDrop directive, the placing of the dragged element can be done as well, so you can have fully interactive application. Dragging Fundamentals A drag operation starts when the end user swipes at least 5px in any direction. This is customizable and can be changed using the dragTolerance input. Otherwise the interaction is considered as a click and a dragClick event is triggered. When the dragging starts, the dragStart event is triggered. To prevent any actual movement to occur, the event can be canceled by setting the cancel property to true. Before any actual movement is about to be performed, the dragMove event is also triggered, containing the last and next position of the pointer. It is triggered every time a movement is detected while dragging an element around. After the user releases the mouse/touch the drag ghost element is removed from the DOM and the dragEnd event will be emitted. Note Due to the nature of the dragMove event, it can be triggered many times in a short period of time, which may cause performance issues for complex operations done when triggered. Dragging With Ghost The igxDrag directive can be applied on any DOM element by just adding it to its template. <div igxDrag>Drag me</div> The default behavior of igxDrag directive is to leave the base element unmodified and to create a ghost element when drag operation is performed by the end user. Before the ghost is rendered on the page, a ghostCreate event is triggered containing information of the ghost element that is about to be added. The event is triggered right after the dragStart event. If the dragStart is canceled, no ghost will be created and the ghostCreate event will not trigger accordingly. Right before the ghost is about to be removed, the ghostDestroy event will be triggered. Customizing The Ghost The ghost element by default is a copy of the base element the igxDrag is used on. It can be customized by providing a template reference to the ghostTemplate input directly. <div class=\"email-content flexlist\" igxDrag [ghostTemplate]=\"customGhost\"> <div class=\"sender\"> {{email.sender}} </div> <div class=\"email-title\"> {{email.title}} </div> </div> <ng-template #customGhost> <div class=\"dragGhost\"> <igx-icon fontSet=\"material\">email</igx-icon> Moving {{ draggedElements }} item{{ (draggedElements > 1 ? 's' : '')}} </div> </ng-template> Dragging Without Ghost If you would like to move the base element, to which the igxDrag directive is applied, you can do that by setting the ghost input to false. That way there will be no extra ghost element rendered and if you need to apply custom styling when dragging and element, you can apply it directly to the base element. <div igxDrag [ghost]=\"false\">Drag me</div> Dragging Using a Handle You can specify an element that is a child of the igxDrag by which to drag, since by default the whole element is used to perform that action. It can be done using the igxDragHandle directive and can be applied to multiple elements inside the igxDrag. <div igxDrag [ghost]=\"false\" [dragTolerance]=\"0\" (dragMove)=onDragMove($event)> <igx-icon igxDragHandle fontSet=\"material\" class=\"dialogHandle\">drag_indicator</igx-icon> <div class=\"igx-dialog__window\"> </div> </div> Drag the dialog using the handle in the following demo. Animations When an element is being dragged, there are no animations applied by default. You can apply transition animation to the igxDrag at any time, but it is advised to use it when dragging ends or the element is not currently dragged. This can be achieved by using the transitionToOrigin and the transitionTo methods. The transitionToOrigin method, as the name suggests, animates the currently dragged element or its ghost to the start position, where the dragging began. The transitionTo method animates the element to a specific location relative to the page (i.e. pageX and pageY) or to the position of a specified element. If the element is not being currently dragged, it will animate anyway or create ghost and animate it to the desired position. Both functions have arguments that you can set to customize the transition animation and set duration, timing function or delay. If specific start location is set it will animate the element starting from there. When the transition animation ends, if a ghost is created, it will be removed and the igxDrag directive will return to its initial state. If no ghost is created, it will keep its position. In both cases, then the transitioned event will be triggered, depending on how long the animation lasts. If no animation is applied, it will be triggered instantly. You can have other types of animations that involve element transformations. That can be done like any other element either using the Angular Animations or straight CSS Animations to either the base igxDrag element or its ghost. If you want to apply them to the ghost, you would need to define a custom ghost and apply animations to its element. Reorder items in the list using the drag handle. While dragging a list item other list items will re-order with animation. Ignoring draggable elements If the user wants to have interactable children of the main element which have igxDrag instanced, he can set the igxDragIgnore directive in order to make them be ignored by the igxDrag and not perform any dragging action. This will leave these elements be fully interactable and receive all mouse events. <div [igxDrag]=\"myData\"> <span>Drag me!</span> <igx-icon igxDragIgnore fontSet=\"material\" (click)=\"remove()\">bin</igx-icon> </div> Using the Angular Drop Directive When an element that is being dragged using the igxDrag directive needs to be placed in an area, the igxDrop can be used to achieve this behavior. It provides events that you can use to determine if an element is entering the boundaries of the element it is applied to and if it is being released inside it. The igxDrop directive can be applied to any DOM element just like the igxDrag directive. By default, the igxDrop directive doesn't apply any logic for modifying the dragged element position in the DOM. That's why you need to specify a dropStrategy or apply custom logic. Drop strategies are discussed in the next section. Drop Strategies The igxDrop comes with 4 drop strategies which are: Default, Prepend, Insert and Append: Default - does not perform any action when an element is dropped onto an igxDrop element and is implemented as a class named IgxDefaultDropStrategy. Append - always inserts the dropped element as a last child and is implemented as a class named IgxAppendDropStrategy. Prepend - always inserts the dropped element as first child and is implemented as a class named IgxPrependDropStrategy. Insert - inserts the dragged element at last position. If there is a child under the element when it was dropped though, the igxDrag instanced element will be inserted at that child's position and the other children will be shifted. It is implemented as a class named IgxInsertDropStrategy. The way a strategy can be applied is by setting the dropStrategy input to one of the listed classes above. The value provided has to be a type and not an instance, since the igxDrop needs to create and manage the instance itself. public appendStrategy = IgxAppendDropStrategy; <div igxDrop [dropStrategy]=\"appendStrategy\"></div> Canceling a drop strategy When using a specific drop strategy, its behavior can be canceled in the dropped events by setting the cancel property to true. The dropped event is specific to the igxDrop. If you does not have drop strategy applied to the igxDrop canceling the event would have no side effects. Example: <div igxDrag></div> <!-- ... --> <div igxDrop (dropped)=\"onDropped($event)\"></div> public onDropped(event) { event.cancel = true; } If you would like to implement your own drop logic, we advise binding to the dropped event and execute your logic there or extend the IgxDefaultDropStrategy class. Linking Drag to Drop Element Using the dragChannel and dropChannel input on respectively igxDrag and igxDrop directives, you can link different elements to interact only between each other. For example, if an igxDrag element needs to be constrained so it can be dropped on specific igxDrop element and not all available, this can easily be achieved by assigning them the same channel. <div igxDrag [dragChannel]=\"['Mammals', 'Land']\"> Human </div> <div igxDrag [dragChannel]=\"['Mammals', 'Water']\"> Dolphin </div> <div igxDrag [dragChannel]=\"['Insects', 'Air']\"> Butterfly </div> <div igxDrag [dragChannel]=\"['Insects', 'Land']\"> Ant </div> <div igxDrop [dropChannel]=\"['Mammals']\"> Mammals </div> <div igxDrop [dropChannel]=\"['Insects']\"> Insects </div> <div igxDrop [dropChannel]=\"['Land']\"> Land </div> Drag e-mails on the right into the folders on the left. Advanced Configuration Since both igxDrag and igxDrop combined can be used in many different and complex application scenarios, the following example demonstrates how they can be used in an Kanban board. The user could reorder the cards in each column. It is done by setting each card also a drop area, so we can detect when another card has entered its area and switch them around at runtime, to provide better user experience. It won't be Kanban board without also the ability to switch cards between columns. A card can be directly moved from one column to another column at a specific position. It is achieved here with a dummy object, so it would create a visual area where the card will be position if released. The dummy object is removed once the dragging of a card ends or exits another column. Drag items around the kanban board. API IgxDragDirective IgxDropDirective IgxDefaultDropStrategy IgxAppendDropStrategy IgxPrependDropStrategy IgxInsertDropStrategy References Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/drop-down.html": {
    "href": "components/drop-down.html",
    "title": "Angular Drop Down Component – Ignite UI For Angular",
    "keywords": "Angular Drop Down Component Overview The Ignite UI for Angular Drop Down is a component, which displays a toggleable list of predefined values and allows users to easily select a single option item with a click. It can be quickly configured to act as a drop down menu or you can simply use it to deliver more useful visual information by grouping data. With grouping you can use both flat and hierarchical data. Drop Down component allows declarative binding, which makes it possible for you to embed additional content and links. This also leaves room for further UI customization and styling of the Angular drop down list appearance. In addition to this, it is packed with key features like keyboard dropdown navigation and virtualization. Angular Drop Down Example This Angular drop down example demonstrates the basic functionalities of a drop down list. Click on it to expand the preset options, select an item, and then close the drop down. Getting Started with Ignite UI for Angular Drop Down To get started with the Ignite UI for Angular Drop Down component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxDropDownModule in your app.module.ts file. // app.module.ts ... import { IgxDropDownModule } from 'igniteui-angular'; // import { IgxDropDownModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxDropDownModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxDropDownComponent as a standalone dependency, or use the IGX_DROP_DOWN_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { NgFor } from '@angular/common'; import { IGX_DROP_DOWN_DIRECTIVES, IgxToggleActionDirective, IgxButtonDirective } from 'igniteui-angular'; // import { IGX_DROP_DOWN_DIRECTIVES, IgxToggleActionDirective, IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button igxButton=\"contained\" [igxToggleAction]=\"dropdown\" [igxDropDownItemNavigation]=\"dropdown\"> Options </button> <igx-drop-down #dropdown> <igx-drop-down-item *ngFor=\"let item of items\"> {{ item.field }} </igx-drop-down-item> </igx-drop-down> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_DROP_DOWN_DIRECTIVES, IgxToggleActionDirective, IgxButtonDirective, NgFor] /* or imports: [IgxDropDownComponent, IgxDropDownItemComponent, IgxToggleActionDirective, IgxButtonDirective, NgFor] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Drop Down module or directives imported, you can start using the igx-drop-down component. Using the Angular Drop Down Add Drop Down Let's create a simple drop-down that provides several option items to choose from. To achieve this, we will use the IgxDropDownComponent as well as the IgxToggleAction to open/close the drop-down. <!-- dropdown.component.html --> <button igxButton=\"contained\" [igxToggleAction]=\"dropdown\" [igxDropDownItemNavigation]=\"dropdown\"> Options </button> <igx-drop-down #dropdown> <igx-drop-down-item *ngFor=\"let item of items\"> {{ item.field }} </igx-drop-down-item> </igx-drop-down> // dropdown.component.ts @Component({...}) export class MyDropDownComponent { public items: Array<{ field: string }> = [ { field: 'Option 1' }, { field: 'Option 2' }, { field: 'Option 3' } ]; } More Angular Drop Down Examples The default demo shows the use of a toggleable Drop Down List in Angular that lets end-users expand all predefined items and opt for one of them. Check out the following example and see the Angular Drop Down list in action. Predefined selected item Let's say we want to have a predefined selected item. One way to do this, is by handling the opening event of the drop-down component. <!-- dropdown.component.html --> <button igxButton=\"contained\" [igxToggleAction]=\"dropdown\" [igxDropDownItemNavigation]=\"dropdown\"> Options </button> <igx-drop-down #dropdown (opening)=\"dropdown.setSelectedItem(0)\"> <igx-drop-down-item *ngFor=\"let item of items\"> {{ item.field }} </igx-drop-down-item> </igx-drop-down> // dropdown.component.ts export class MyDropDownComponent { public items: Array<{ field: string }> = [ { field: 'Option 1' }, { field: 'Option 2' }, { field: 'Option 3' } ]; } Grouping items To provide a more useful visual information, use the isHeader property to group items semantically or the disabled property to display an item as a non-interactive. You can also set the selected property on a particular item to make it the selected item. The igx-drop-down items have out-of-the-box support for igxPrefix, igxSuffix, and igx-divider directives that can contain or be set on HTML elements or other web components. <!-- dropdown.component.html --> <button igxButton=\"contained\" [igxToggleAction]=\"dropdown\" [igxDropDownItemNavigation]=\"dropdown\"> Countries </button> <igx-drop-down #dropdown [width]=\"'240px'\"> <div class=\"drop-down__scroll-container\"> <igx-drop-down-item *ngFor=\"let item of items\" [disabled]=\"item.disabled\" [isHeader]=\"item.header\" [selected]=\"item.selected\"> <igx-icon igxPrefix>place</igx-icon> {{ item.field }} <span igxSuffix>{{ item.code }}</span> <igx-divider></igx-divider> </igx-drop-down-item> </div> </igx-drop-down> // dropdown.component.ts export class MyDropDownComponent { public items: any[] = [ { field: 'European Union', code: 'EU', header: true }, { field: 'Germany', code: 'DE' }, { field: 'Bulgaria', code: 'BG', selected: true }, { field: 'France', code: 'FR', disabled: true }, { field: 'North America', code: 'NA', header: true }, { field: 'Canada', code: 'CA' }, { field: 'United States', code: 'US' }, { field: 'Mexico', code: 'MX' } ]; } If the sample is configured properly, a list of countries should be displayed as a group under European Union header, France as a non-interactive item, and Bulgaria as a selected item: Grouping hierarchical data The igx-drop-down items can also be grouped using the igx-drop-down-item-group container, making it easier for users to differentiate separate categories. The igx-drop-down-item-group accepts igx-drop-down-item elements as its content and renders them in a grouped fashion. // dropdown.component.ts export class MyCustomDropDownComponent { ... public foods: { name: string, entries: { name: string, refNo: string }[] }[] = [ { name: 'Vegetables', entries: [{ name: 'Cucumber', refNo: '00000' }, { name: 'Lettuce', refNo: '00001' }, ...] }, { name: 'Fruits', entries: [{ name: 'Banana', refNo: '10000' }, { name: 'Tomato', refNo: '10001' }, ...] }, { name: 'Meats', entries: [{ name: 'Chicken', refNo: '20000' }, { name: 'Beef', refNo: '20001' }, ...] }]; } <igx-drop-down> <igx-drop-down-item-group *ngFor=\"let foodGroup of foods\" [label]=\"foodGroup.name\"> <igx-drop-down-item *ngFor=\"let food of foodGroup.entries\" [value]='food.refNo'> {{ food.name }} </igx-drop-down-item> </igx-drop-down-item-group> </igx-drop-down> The group also has the additional functionality of disabling items inside of its body. For example, lets say we do not want the Meats food group to be selectable in our drop-down. Instead of disabling all of the entries in Meats separately, we can disable the group, as well as all of the child items inside: <igx-drop-down> <igx-drop-down-item-group *ngFor=\"let foodGroup of foods\" [label]=\"foodGroup.name\" [disabled]=\"foodGroup.name === 'Meats'\"> <igx-drop-down-item *ngFor=\"let food of foodGroup.entries\" [value]='food.refNo'> {{ food.name }} </igx-drop-down-item> </igx-drop-down-item-group> </igx-drop-down> You can see the results in the sample below: Drop Down as menu You can configure the drop-down to behave as a menu. To do this, set the ISelectionEventArgs interface cancel member to true in the selectionChanging event handler. In this way, the selected item is not preserved when opening the menu and previous selections get invalidated. Still, you can get the clicked item through the newSelection member value in the event. <!-- dropdown.component.html --> <div> <igx-navbar title=\"Contacts\"> <button [igxToggleAction]=\"menu\" [igxToggleOutlet]=\"outlet\" [overlaySettings]=\"overlaySettings\" [igxDropDownItemNavigation]=\"menu\" igxIconButton=\"flat\"> <igx-icon fontSet=\"material\">more_vert</igx-icon> </button> <igx-drop-down #menu (selectionChanging)=\"selectionHandler($event)\"> <igx-drop-down-item *ngFor=\"let item of items\" [value]=\"item.text\"> <div>{{ item.text }}</div> </igx-drop-down-item> </igx-drop-down> </igx-navbar> <div> <ng-container *ngIf=\"text\"> <label igxLabel>{{ text }}</label> </ng-container> </div> <div igxOverlayOutlet #outlet=\"overlay-outlet\"></div> </div> // dropdown.component.ts export class MyMenuComponent { public items: Array<{ text: string }> = [{ text: 'Add New Contact' }, { text: 'Edit Contact' }, { text: 'Refresh' }, { text: 'Help' }]; public text: string; public overlaySettings = { positionStrategy: new ConnectedPositioningStrategy({ horizontalDirection: HorizontalAlignment.Left, horizontalStartPoint: HorizontalAlignment.Right, verticalStartPoint: VerticalAlignment.Bottom }), scrollStrategy: new NoOpScrollStrategy() }; public selectionHandler(eventArgs: ISelectionEventArgs) { this.text = eventArgs.newSelection.value; eventArgs.cancel = true; } } Mutli-Level Drop Down menu The following sample demonstrates how to implement a multi-level drop down menu that allows the user to quickly and easily navigate through a hierarchy of content by hovering on a series of nested menus. For the implementation of the multi-level drop down menu we will use the IgxDropDownComponent as well as a custom directive and service described below. In order to configure the IgxDropDownItem to open an additional drop down, add the multiLevel directive that would handle the overlay settings of the nested drop down and manages its opened/closed state through its innerDropdown property. <igx-drop-down #dropdown1> <igx-drop-down-item [value]=\"'Web'\" multiLevel [innerDropdown]=\"web\"> Web <igx-icon igxSuffix>chevron_right</igx-icon> </igx-drop-down-item> ... </igx-drop-down> <igx-drop-down #web> <igx-drop-down-item [value]=\"'App Builder'\"> App Builder </igx-drop-down-item> ... </igx-drop-down> To configure the multi-level drop down to behave as a menu, you need to handle the selectionChanging event of all drop downs in the hierarchy and cancel the default behavior. Then, in order to handle the selection properly you could use the MultiLevelService's handleSelection method and in order to prevent closing the drop down when clicking on a menu item, use the MultiLevelService's handleClosing methods. @ViewChildren(IgxDropDownComponent, { read: IgxDropDownComponent }) private _dropdowns: QueryList<IgxDropDownComponent>; @ViewChild('dropdown1', { read: IgxDropDownComponent }) private _multiLevelDropdown: IgxDropDownComponent; constructor(private _multiLevelService: MultiLevelService) { } public ngAfterViewInit(): void { this._dropdowns.forEach((dropdown) => { dropdown.selectionChanging.subscribe((args) => { args.cancel = true; const value = args.newSelection.value; const categories = this._multiLevelService.categories; if (categories.includes(value)) { this.selection = ''; return; } if (this._multiLevelService.isMultiLevel(dropdown)) { this._multiLevelService.handleSelection(); } else { dropdown.close(); } this.selection = value; }); }); this._multiLevelDropdown.closing.subscribe((args) => { this._multiLevelService.handleClosing(args); }); } The result from the above configurations could be seen in the below sample. Note To display the Dropdown component opened initially, it is recommended to set the open method as a callback of the requestAnimationFrame method. This will ensure that the DOM tree is repainted and all elements are correctly positioned. Navigation directive Use the igxDropDownItemNavigation directive to enable keyboard navigation for the igxDropDown component. In order to allow the directive to handle all triggered events, it should be applied to the active (focused) element or a parent container. By default, a drop-down or its items don't take focus, so the directive can be placed on a button or input that will control the drop-down. The navigation directive value should target a component that is an instance or a descendant of the IgxDropDownBaseDirective class. The following sample demonstrates an input that opens and closes the igxDropDown instance on click. Applying the igxDropDownItemNavigation directive on the input itself will enable keyboard navigation when using the up and down arrow keys. This relies on the default drop-down behavior with the allowItemsFocus property set to false to allow the input to maintain focus. <!-- input-dropdown.component.html --> <igx-input-group #inputGroup [igxToggleAction]=\"dropDown\"> <input type=\"text\" igxInput [igxDropDownItemNavigation]=\"dropDown\" readonly= \"true\" placeholder=\"choose an option\" [value]=\"dropDown.selectedItem?.value\" (keydown.ArrowDown)=\"openDropDown()\"/> <igx-suffix igxIconButton=\"flat\" igxRipple> <igx-icon>arrow_drop{{ dropDown.collapsed ? '_down' : '_up' }}</igx-icon> </igx-suffix> </igx-input-group> <span>Selected: {{ dropDown.selectedItem?.value }}</span> <igx-drop-down #dropDown [width]=\"'160px'\"> <igx-drop-down-item *ngFor=\"let item of items\" [value]=\"item.field\"> {{ item.field }} </igx-drop-down-item> </igx-drop-down> // input-dropdown.component.ts export class InputDropDownComponent { @ViewChild(IgxDropDownComponent) public igxDropDown: IgxDropDownComponent; @ViewChild('inputGroup', { read: IgxInputGroupComponent}) public inputGroup: IgxInputGroupComponent; public items: Array<{ field: string }> = [ { field: 'Option 1' }, { field: 'Option 2' }, { field: 'Option 3' } ]; public openDropDown() { if (this.igxDropDown.collapsed) { this.igxDropDown.open({ modal: false, positionStrategy: new ConnectedPositioningStrategy({ target: this.inputGroup.element.nativeElement }) }); } } } Applying the directive will ensure the following actions are executed as a result from the keyboard navigation: Name Description Enter Select item from the drop down and closes the drop down. Space Select item from the drop down and closes the drop down. Esc Closes the drop down. Arrow Down Navigate to the next item in the target component. Arrow Up Navigate to the previous item in the target component. End Navigate to the last item in the target component. Home Navigate to the first item in the target component. When the allowItemsFocus property is enabled, the drop down items gain tab index and are focused when active. The focused drop-down items are the ones that trigger events, during keyboard navigation, which means that the navigation directive should be applied on the individual drop-down items. <igx-input-group [igxToggleAction]=\"dropDown\"> <input igxInput type=\"text\"> </igx-input-group> <igx-drop-down #dropDown [allowItemsFocus]=\"true\"> <igx-drop-down-item *ngFor=\"let p of provinceData\" [igxDropDownItemNavigation]=\"dropDown\"> {{ p }} </igx-drop-down-item> </igx-drop-down> Styling Using the Ignite UI for Angular Theming, we can greatly alter the drop-down appearance. First, in order for us to use the functions exposed by the theme engine, we need to import the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the drop-down-theme and accepts some of the default theme's parameters. $custom-drop-down-theme: drop-down-theme( $background-color: #fdfdfd, $header-text-color: #345779, $item-text-color: #2dabe8, $selected-item-background: #345779, $selected-item-text-color: #fdfdfd, $selected-hover-item-background: #345779, $selected-hover-item-text-color: #fdfdfd, $selected-focus-item-background: #345779, $selected-focus-item-text-color: #fdfdfd, $hover-item-background: rgba(0, 0, 0, 0.12), $hover-item-text-color: #345779, ); Using CSS variables The last step is to pass the custom drop-down theme: @include css-vars($custom-drop-down-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down-theme); } } Note The IgxDropDown component uses the IgxOverlay to hold and display the igx-drop-down-items list container. To properly scope your styles you might have to use an OverlaySetting.outlet. For more details check: IgxOverlay styling guide. Demo API Summary IgxDropDownComponent IgxDropDownComponent Styles IgxDropDownItemComponent. IgxOverlay IgxOverlay Styles IgxDividerDirective IgxDividerDirective Styles Theming Dependencies IgxOverlay Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/drop-down-hierarchical-selection.html": {
    "href": "components/drop-down-hierarchical-selection.html",
    "title": "Multi-select Hierarchical Drop Down- Ignite UI for Angular",
    "keywords": "Multi-select Hierarchical Drop Down The following samples demonstrate how to create a multi-select hierarchical drop-down that allows the user to select single or multiple options from a tree-style hierarchical drop-down list. Topic Overview For the drop-down list we will use the IgxDropDownComponent as well as the IgxToggleActionDirective to open/close the drop-down. To visualize the hierarchical data in the drop-down, you can use either the IgxTreeComponent or the IgxTreeGridComponent. The IgxChipComponent is used to display the selected items. Selection To display selected nodes/rows from the list use the IgxChipComponent by handling the events that notify of selection changes and populate the selectedNodes / selectedRows array. This can be done by subscribing to the IgxTreeComponent's nodeSelection event and to the IgxTreeGridComponent's rowSelectionChanging event. To remove the chip from the DOM and deselect the item from the tree/grid, you have to handle the IgxChipComponent's remove event. Additionally, a way to prevent the drop-down from closing on chip deletion would be to check the event's composite path for an igx-chip node and then cancel the event in the IgxDropDownComponent's closing event handler. Demo Note To display the Dropdown component opened initially, it is recommended to set the open method as a callback of the requestAnimationFrame method. This will ensure that the DOM tree is repainted and all elements are correctly positioned. API References IgxDropDownComponent IgxChipComponent IgxChipsAreaComponent IgxTreeComponent IgxTreeNodeComponent IgxTreeGridComponent Additional Resources Drop Down overview Chip overview Tree overview Tree Grid overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/drop-down-virtual.html": {
    "href": "components/drop-down-virtual.html",
    "title": "Angular Drop Down Component – Ignite UI for Angular | Infragistics",
    "keywords": "Virtual Drop Down The Ignite UI for Angular Drop Down component can fully integrate with the IgxForOf directive in order to display a very large list of items for its selection. Angular Virtual Drop Down Example Usage First Steps In order to configure the drop-down to display a list of virtual items, you need to fulfill some prerequisites. First, we need to import the IgxForOfModule in the module of the component that will declare our drop-down. // app.module.ts import { IgxForOfModule } from 'igniteui-angular'; // import { IgxForOfModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxForOfModule ] }) export class AppModule {} Template Configuration Next, we need to create the drop-down component's template, looping through the data using *igxFor instead of *ngFor. The *igxFor directive needs some additional configuration in order to properly display all of the items: <!-- drop-down-virtual.component.html --> <button igxButton [igxToggleAction]=\"dropdown\" [igxDropDownItemNavigation]=\"dropdown\"> Item Series </button> <igx-drop-down #dropdown> <div class=\"drop-down-virtual-wrapper\" style=\"height: {{ itemsMaxHeight }}px;\"> <igx-drop-down-item *igxFor=\"let item of items; index as index; scrollOrientation: 'vertical'; containerSize: itemsMaxHeight; itemSize: itemHeight;\" [value]=\"item\" [isHeader]=\"item.header\" role=\"option\" [disabled]=\"item.disabled\" [index]=\"index\"> {{ item.name }} </igx-drop-down-item> </div> </igx-drop-down> <div>Selected Model: <span>{{ dropdown.selectedItem?.value.name }}</span></div> The additional parameters passed to the *igxFor directive are: index - captures the index of the current item in the data set scrollOrientation - should always be 'vertical' containerSize - the size of the virtualized container (in px). This needs to be enforced on the wrapping <div> as well itemSize - the size of the items that will be displayed (in px) In order to assure uniqueness of the items, pass item inside of the value input and index inside of the index input of the igx-drop-down-item. To preserve selection while scrolling, the drop-down item needs to have a reference to the data items it is bound to. Note For the drop-down to work with a virtualized list of items, value and index inputs must be passed to all items. Note It is strongly advised for each item to have an unique value passed to the [value] input. Otherwise, it might lead to unexpected results (incorrect selection). Note When the drop-down uses virtualized items, the type of dropdown.selectedItem becomes { value: any, index: number }, where value is a reference to the data item passed inside of the [value] input and index is the item's index in the data set Component Definition Inside of the component's constructor, we'll declare a moderately large list of items (containing both headers and disabled items), which will be displayed in the drop-down. We will also need to declare itemHeight and itemsMaxHeight: // drop-drop-virtual.component.ts export class DropDownVirtualComponent { public items: DataItem[]; public itemHeight = 48; public itemsMaxHeight = 320; constructor() { const itemsCollection: DataItem[] = []; for (let i = 0; i < 50; i++) { const series = (i * 10).toString(); itemsCollection.push({ id: series, name: `${series} Series`, header: true, disabled: false }); for (let j = 0; j < 10; j++) { itemsCollection.push({ id: `${series}_${j}`, name: `Series ${series}, ${i * 10 + j} Model`, header: false, disabled: j % 9 === 0 }); } } this.items = itemsCollection; } } Styles The last part of the configuration is to set overflow: hidden to the wrapping div in order to prevent the appearance of two scroll bars (one from the igxFor and one from the container itself): // drop-drop-virtual.component.scss .drop-down-virtual-wrapper { overflow: hidden; } Remote Data The igx-drop-down supports loading chunks of remote data using the *igxFor structural directive. The configuration is similar to the one with local items, the main difference being how data chunks are loaded. Template The drop-down template does not need to change much compared to the previous example - we still need to specify a wrapping div, style it accordingly and write out the complete configuration for the *igxFor. Since we'll be getting our data from a remote source, we need to specify that our data will be an observable and pass it through Angular's async pipe: <igx-drop-down #remoteDropDown> <div class=\"drop-down-virtual-wrapper\"> <igx-drop-down-item *igxFor=\"let item of rData | async; index as index; scrollOrientation: 'vertical'; containerSize: itemsMaxHeight; itemSize: itemHeight;\" [value]=\"item.ProductName\" role=\"option\" [disabled]=\"item.disabled\" [index]=\"index\"> {{ item.ProductName }} </igx-drop-down-item> </div> </igx-drop-down> Handling chunk load As you can see, the template is almost identical to the one in the previous example. In this remote data scenario, the code behind will do most of the heavy lifting. First, we need to define a remote service for fetching data: // remote.service.ts import { HttpClient } from '@angular/common/http'; import { Injectable } from '@angular/core'; import { IForOfState } from 'igniteui-angular'; // import { IForOfState } from '@infragistics/igniteui-angular'; for licensed package import { BehaviorSubject, Observable } from 'rxjs'; @Injectable() export class RemoteService { public remoteData: Observable<any[]>; private _remoteData: BehaviorSubject<any[]>; constructor(private http: HttpClient) { this._remoteData = new BehaviorSubject([]); this.remoteData = this._remoteData.asObservable(); } public getData(data?: IForOfState, cb?: (any) => void): any { // Assuming that the API service is RESTful and can take the following: // skip: start index of the data that we fecth // count: number of records we fetch this.http.get(`https://dummy.db/dummyEndpoint?skip=${data.startIndex}&count=${data.chunkSize}`).subscribe((data) => { // emit the values through the _remoteData subject this._remoteData.next(data); }) } The service exposes an Observable under remoteData. We will inject our service and bind to that property in our remote drop-down component: // remote-drop-down.component.ts @Component({ providers: [RemoteService], selector: 'app-drop-down-remote', templateUrl: './drop-down-remote.component.html', styleUrls: ['./drop-down-remote.component.scss'] }) export class DropDownRemoteComponent implements OnInit, OnDestroy { @ViewChild(IgxForOfDirective, { read: IgxForOfDirective }) public remoteForDir: IgxForOfDirective<any>; @ViewChild('remoteDropDown', { read: IgxDropDownComponent }) public remoteDropDown: IgxDropDownComponent; public itemHeight = 48; public itemsMaxHeight = 480; public prevRequest: Subscription; public rData: any; private destroy$ = new Subject(); constructor(private remoteService: RemoteService) { } public ngAfterViewInit() { const initialState = { startIndex: 0, chunkSize: Math.ceil(this.itemsMaxHeight / this.itemHeight) } this.remoteService.getData(initialState, (data) => { this.remoteForDir.totalItemCount = data['@odata.count']; }); // Subscribe to igxForOf.chunkPreload and load new data from service this.remoteForDir.chunkPreload.pipe(takeUntil(this.destroy$)).subscribe((data) => { this.dataLoading(data); }); } public dataLoading(evt) { if (this.prevRequest) { this.prevRequest.unsubscribe(); } this.prevRequest = this.remoteService.getData( evt, (data) => { this.remoteForDir.totalItemCount = data['@odata.count']; }); } public ngOnInit() { this.rData = this.remoteService.remoteData; } public ngOnDestroy() { this.destroy$.next(); this.destroy$.complete(); } } Inside of the ngAfterViewInit hook, we call to get data for the initial state and subscribe to the igxForOf directive's chunkPreload emitter. This subscription will be responsible for fetching data everytime the loaded chunk changes. We use pipe(takeUntil(this.destroy$)) so we can easily unsubscribe from the emitter on component destroy. Remote Virtualization - Demo The result of the above configuration is a drop-down that dynamically loads the data it should display, depending on the scrollbar's state: Notes and Limitations Using the drop-down with a virtualized list of items enforces some limitations. Please, be aware of the following when trying to set up a drop-down list using *igxFor: The drop-down items that are being looped need to be passed in a wrapping element (e.g. <div>) which has the following css: overflow: hidden and height equal to containerSize in px <igx-drop-down-item-group> cannot be used for grouping items when the list is virtualized. Use the isHeader propery instead The items accessor will return only the list of non-header drop-down items that are currently in the virtualized view. dropdown.selectedItem is of type { value: any, index: number } The object emitted by selection changes to const emittedEvent: { newSelection: { value: any, index: number }, oldSelection: { value: any, index: number }, cancel: boolean, } dropdown.setSelectedItem should be called with the item's index in the data set setting the drop-down item's [selected] input will not mark the item in the drop-down selection API References IgxForOfDirective IgxDropDownComponent View page on GitHub"
  },
  "components/excel-library.html": {
    "href": "components/excel-library.html",
    "title": "Angular Excel Library| Data Spreadsheet and Table | Infragistics",
    "keywords": "Angular Excel Library Overview The Infragistics Angular Excel Library allows you to work with spreadsheet data using familiar Microsoft® Excel® spreadsheet objects like workbook, Worksheet, IgxCell, Formula and many more. The Infragistics Angular Excel Library makes it easy for you to represent the data of your application in an Excel spreadsheet as well as transfer data from Excel into your application. Angular Excel Library Example Dependencies When installing the excel package, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-excel Component Modules The Angular excel library requires the following modules: // app.module.ts import { IgxExcelModule } from 'igniteui-angular-excel'; @NgModule({ imports: [ // ... IgxExcelModule, // ... ] }) export class AppModule {} Modules Implementation The Excel Library contains 5 modules that you can use to limit bundle size of your app: IgxExcelCoreModule – This contains the object model and much of the excel infrastructure IgxExcelFunctionsModule – This contains the majority of the functions for formula evaluations, such as Sum, Average, Min, Max, etc. The absence of this module won’t cause any issues with formula parsing if the formula is to be calculated. For example, if you apply a formula like “=SUM(A1:A5)” and ask for the Value of the cell, then you would get a #NAME! error returned. This is not an exception throw – it’s an object that represents a particular error since formulas can result in errors. IgxExcelXlsModule – This contains the load and save logic for xls (and related) type files – namely the Excel97to2003 related WorkbookFormats. IgxExcelXlsxModule – This contains the load and save logic for xlsx (and related) type files – namely the Excel2007 related and StrictOpenXml WorkbookFormats. IgxExcelModule – This references the other 4 modules and so basically ensures that all the functionality is loaded/available. Supported Versions of Microsoft Excel The following is a list of the supported versions of Excel.** Microsoft Excel 97 Microsoft Excel 2000 Microsoft Excel 2002 Microsoft Excel 2003 Microsoft Excel 2007 Microsoft Excel 2010 Microsoft Excel 2013 Microsoft Excel 2016 Load and Save Workbooks Now that the Excel Library module is imported, next step is to load a workbook. In the following code snippet, an external ExcelUtility class is used to save and load a workbook. In order to load and save workbook objects, you can utilize the save method of the actual workbook object, as well as its static Load method. import { Workbook } from \"igniteui-angular-excel\"; import { WorkbookSaveOptions } from \"igniteui-angular-excel\"; import { WorkbookFormat } from \"igniteui-angular-excel\"; import { ExcelUtility } from \"ExcelUtility\"; var workbook = ExcelUtility.load(file); ExcelUtility.save(workbook, \"fileName\"); Managing Heap Due to the size of the Excel Library, it's recommended to disable the source map generation. Modify angular.json by setting the vendorSourceMap option under architect => build => options and under serve => options: \"architect\": { \"build\": { \"builder\": \"...\", \"options\": { \"vendorSourceMap\": false, \"outputPath\": \"dist\", \"index\": \"src/index.html\", \"main\": \"src/main.ts\", \"tsConfig\": \"src/tsconfig.app.json\", // ... }, // ... }, \"serve\": { \"builder\": \"...\", \"options\": { \"vendorSourceMap\": false, \"browserTarget\": \"my-app:build\" }, // ... }, // ... } API References Load WorkbookInProcessRuntime Worksheet workbook View page on GitHub"
  },
  "components/excel-library-using-cells.html": {
    "href": "components/excel-library-using-cells.html",
    "title": "Angular Excel Library| Using Cells | Infragistics",
    "keywords": "Angular Using Cells The WorksheetCell objects in an Excel worksheet is the object that holds your actual data values for the worksheet. This topic goes over the many operations that you can perform on these cells, such as accessing them and their regions by name, adding formulas and comments to the cells, and merging and formatting them. Angular Using Cells Example References The following code shows the imports needed to use the code-snippets below: import { Workbook } from \"igniteui-angular-excel\"; import { WorkbookFormat } from \"igniteui-angular-excel\"; import { Worksheet } from \"igniteui-angular-excel\"; import { WorksheetTable } from \"igniteui-angular-excel\"; import { NamedReference } from \"igniteui-angular-excel\"; import { WorksheetCellComment } from \"igniteui-angular-excel\"; import { FormattedString } from \"igniteui-angular-excel\"; Referencing Cells and Regions You can access a WorksheetCell object or a WorksheetRegion object by calling the worksheet object’s getCell or getRegion methods, respectively. Both methods accept a string parameter that references a cell. Getting a reference to a cell is useful when applying formats or working with formulas and cell contents. The following example code demonstrates how to reference cells and regions: var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); //Accessing a single cell var cell = worksheet.getCell(\"E2\"); //Accessing a range of cells var region = worksheet.getRegion(\"G1:G10\"); Accessing Cells and Regions by Name In Microsoft Excel, individual cells, as well as cell regions can have names assigned to them. The name of a cell or region can be used to reference that cell or region instead of their address. The Infragistics Angular Excel Library supports the referencing of cells and regions by name through the getCell and getRegion methods of the worksheet object. You refer to the cell or region using the NamedReference instance that refers to that cell or region. You can use the following code snippet as an example for naming a cell or region: var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); var cell_reference = workbook.namedReferences().add(\"myCell\", \"=Sheet1:A1\"); var region_reference = workbook.namedReferences().add(\"myRegion\", \"=Sheet1!A1:B2\"); The following code can be used to the get the cell and region referenced by the \"myCell\" and \"myRegion\" named references above: var cell = worksheet.getCell(\"myCell\"); var region = worksheet.getRegion(\"myRegion\"); Adding a Comment to a Cell A comment allows you to display hints or notes for a cell when the end user’s mouse hovers over a cell. The comments display as a tooltip-like callout that contains text. The Infragistics Angular Excel Library allows you to add comments to a cell by setting a WorksheetCell object’s comment property. The following example code demonstrates how to add a comment to a cell: var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); var cellComment = new WorksheetCellComment(); var commentText = new FormattedString(\"This cell has a comment.\"); cellComment.text = commentText; worksheet.rows(0).cells(0).comment = cellComment; Adding a Formula to a Cell The Infragistics Angular Excel Library allows you to add Microsoft Excel formulas to a cell or group of cells in a worksheet. You can do this using the WorksheetCell object’s applyFormula method or by instantiating a formula object and applying it to a cell. Regardless of the manner in which you apply a formula to a cell, you can access the formula object using the WorksheetCell object’s formula property. If you need the value, use the cell’s value property. The following code shows you how to add a formula to a cell. var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.rows(5).cells(0).applyFormula(\"=SUM(A1:A5)\"); //Using a Formula object to apply a formula var sumFormula = Formula.parse(\"=SUM(A1:A5)\", CellReferenceMode.A1); sumFormula.applyTo(worksheet.rows(5).cells(0)); Copying a Cell’s Format Cells can have different formatting, including background color, format string, and font style. If you need a cell to have the same format as a previously formatted cell, instead of individually setting each option exposed by the WorksheetCell object’s cellFormat property, you can call the cellFormat object’s setFormatting method and pass it a cellFormat object to copy. This will copy every format setting from the first cell to the second cell. You can also do this for a row, merged cell region, or column. The following code shows you how to copy the format of the 2nd column to the 4th column: var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); //Format 2nd column worksheet.columns(1).cellFormat.fill = CellFill.createSolidFill(\"Blue\"); worksheet.columns(1).cellFormat.font.bold = true; //Copy format of 2nd column to 4th column worksheet.columns(3).cellFormat.setFormatting(worksheet.columns(1).cellFormat); Formatting a Cell The Infragistics Angular Excel Library allows you to customize the look and behavior of a cell. You can customize a cell by setting properties exposed by the cellFormat property of the WorksheetCell, WorksheetRow, WorksheetColumn, or WorksheetMergedCellsRegion objects. You can customize every aspect of a cell’s appearance. You can set a cell’s font, background, and borders, as well as text alignment and rotation. You can even apply a different format on a character-by-character basis for a cell’s text. You can also format cell values by assigning a format string. An acceptable format string follows the traditional format standards and formatting codes. The following code shows you how to format a cell to display numbers as currency: var workbook = new Workbook(format); var workbook = workbook.worksheets().add(\"Sheet1\"); worksheet.columns(2).cellFormat.formatString = \"\\\"$\\\"#,##0.00\"; Excel 2007 Color Model The color palette is analogous to the color dialog in Microsoft Excel 2007 UI. You can open this color dialog by navigating to Excel Options => Save => Colors. You can create all possible fill types using static properties and methods on the CellFill class. They are as follows: NoColor - A property that represents a fill with no color, which allows a background image of the worksheet, if any, to show through. CreateSolidFill - Returns a CellFillPattern instance which has a pattern style of Solid and a background color set to the color or WorkbookColorInfo specified in the method. CreatePatternFill - Returns a CellFillPattern instance which has the specified pattern style and the color or WorkbookColorInfo values, specified for the background and pattern colors. CreateLinearGradientFill - Returns a CellFillLinearGradient instance with the specified angle and gradient stops. CreateRectangularGradientFill - Returns a CellFillRectangularGradient instance with the specified left, top, right, and bottom of the inner rectangle and gradient stops. If the inner rectangle values are not specified, the center of the cell is used as the inner rectangle. The derived types, representing the various fills which can be created, are as follows: CellFillPattern - A pattern that represents a cell fill of no color, a solid color, or a pattern fill for a cell. It has background color info and a pattern color info which correspond directly to the color sections in the Fill tab of the Format Cells dialog of Excel. CellFillLinearGradient - Represents a linear gradient fill. It has an angle, which is degrees clockwise of the left to right linear gradient, and a gradients stops collection which describes two or more color transitions along the length of the gradient. CellFillRectangularGradient - Represents a rectangular gradient fill. It has top, left, right, and bottom values, which describe, in relative coordinates, the inner rectangle from which the gradient starts and goes out to the cell edges. It also has a gradient stops collection which describes two or more color transitions along the path from the inner rectangle to the cell edges. The following code snippet demonstrates how to create a solid fill in a WorksheetCell: var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); var cellFill = CellFill.createSolidFill(\"Blue\"); worksheet.rows(0).cells(0).cellFormat.fill = cellFill; You can specify a color (the color of Excel cells background, border, etc) using linear and rectangular gradients in cells. When workbooks with these gradients are saved in .xls file format and opened in Microsoft Excel 2007/2010, the gradients will be visible, but when these files are opened in Microsoft Excel 2003, the cell will be filled with the solid color from the first gradient stop. These are the ways a color can be defined, as follows: The automatic color (which is the WindowText system color) Any user defined RGB color A theme color If an RGB or a theme color is used, an optional tint can be applied to lighten or darken the color. This tint cannot be set directly in Microsoft Excel 2007 UI, but various colors in the color palette displayed to the user are actually theme colors with tints applied. Each workbook has 12 associated theme colors. They are the following: Light 1 Light 2 Dark 1 Dark 2 Accent1 Accent2 Accent3 Accent4 Accent5 Accent6 Hyperlink Followed Hyperlink There are default values when a workbook is created, which can be customized via Excel. Colors are defined by the WorkbookColorInfo class, which is a sealed immutable class. The class has a static Automatic property, which returns the automatic color, and there are various constructors which allow you to create a WorkbookColorInfo instance with a color or a theme value and an optional tint. The getResolvedColor method on WorkbookColorInfo allows you to determine what color will actually be seen by the user when they open the file in Excel. If the WorkbookColorInfo represents a theme color, you must pass in a Workbook instance to the method so it can get the theme color’s RGB value from the workbook. When saving out in the newer file formats such as .xlsx, the newer color information is saved directly into the file. When saving out in an older file format such as .xls, the index to the closest color in the palette will be saved out. In addition, the older formats have future feature records that can be saved out to indicate the newer color information. When the older formats are opened in Microsoft Excel 2003 and earlier versions, these future features records are ignored, but when the older file formats are opened in Excel 2007 and later, their records are read and the color information from them overwrites the indexed color that was previously loaded from the normal format records. Excel Format Support You can set a host of different formats on a WorksheetCell by using the cellFormat object returned by the cellFormat property of that cell. This cellFormat object enables you to style many different aspects of the cell such as borders, font, fill, alignments, and whether or not the cell should shrink to fit or be locked. You can also access the built-in styles to Microsoft Excel 2007 using the styles collection of the workbook object. The full list of styles in Excel can be found in the Cell Styles gallery of the Home tab of Microsoft Excel 2007. There is a special type of style on the workbook's styles collection known as the \"normal\" style, which can be accessed using that collection's normalStyle property, or by indexing into the collection with the name \"Normal\". The normalStyle contains the default properties for all cells in the workbook, unless otherwise specified on a row, column, or cell. Changing the properties on the normalStyle will change all of the default cell format properties on the workbook. This is useful, for example, if you want to change the default font for your workbook. You can clear the styles collection or reset it to its predefined state by using the clear and reset methods, respectively. Both of these will remove all user-defined styles, but clear will clear the styles collection entirely. With this feature, a style property has been added to the cellFormat object. This is a reference to a WorkbookStyle instance, representing the parent style of the format. For formats of a style, this property will always be null, because styles cannot have a parent style. For row, column, and cell formats, the style property always returns the normalStyle by default. If the style property is set to null, it will revert back to the normalStyle. If it is set to another style in the styles collection, that style will now hold the defaults for all unset properties on the cell format. When the style property is set on a cell format, the format options included on the style are removed from the cell format. All other properties are left intact. For example, if a cell style including border formatting was created and that style was set as the cell's style, the border format option on the cell format would be removed and the cell format only includes fill formatting. When a format option flag is removed from a format, all associated properties are reset to their unset values, so the cell format’s border properties are implicitly reset to default/unset values. You can determine what would really be seen in cells by using the getResolvedCellFormat method on classes which represent a row, column, cell, and merged cell. This method returns a cellFormat instance which refers back to the associated cellFormat on which it is based. So subsequent changes to the cellFormat property will be reflected in the instance returned from a getResolvedCellFormat call. Merging Cells Aside from setting the value or format of cells, you can also merge cells to make two or more cells appear as one. If you merge cells, they must be in a rectangular region. When you merge cells, each cell in the region will have the same value and cell format. The merged cells will also be associated with the same WorksheetMergedCellsRegion object, accessible from their associatedMergedCellsRegion property. The resultant WorksheetMergedCellsRegion object will also have the same value and cell format as the cells. Setting the value (or cell format) of the region or any cell in the region will change the value of all cells and the region. If you un-merge cells, all of the previously merged cells will retain the shared cell format they had before they were unmerged. However, only the top-left cell of the region will retain the shared value. In order to create a merged cell region, you must add a range of cells to the worksheet object’s mergedCellsRegions collection. This collection exposes an Add method that takes four integer parameters. The four parameters determine the index of the starting row and column (top-left most cell) and the index of the ending row and column (bottom-right most cell). var workbook = new Workbook(); var worksheet = workbook.worksheets().add(\"Sheet1\"); // Make some column headers worksheet.rows(1).cells(1).value = \"Morning\"; worksheet.rows(1).cells(2).value = \"Afternoon\"; worksheet.rows(1).cells(3).value = \"Evening\"; // Create a merged region from column 1 to column 3 var mergedRegion1 = ws.mergedCellsRegions().add(0, 1, 0, 3); // Set the value of the merged region mergedRegion1.value = \"Day 1\"; // Set the cell alignment of the middle cell in the merged region. // Since a cell and its merged region shared a cell format, this will ultimately set the format of the merged region worksheet.rows(0).cells(2).cellFormat.alignment = HorizontalCellAlignment.Center; Retrieving the Cell Text as Displayed in Excel The text displayed in a cell depends on several factors other than the actual cell value, such as the format string and the width of the column that the cell is contained in. The format string determines how the value of cell is converted to text and what literal character should be displayed with the formatted value. You can find more detailed information about format codes here. The amount of horizontal space available in a cell plays a big part in how the value is displayed to the user. Displayed text can be different depending on varying column widths. When displaying numbers and using format string containing \"General\" or \"@\", there are various formats which are tried to find a formatting which fits the cell width. A list of example formats are shown below: Normal Value - Number is displayed as it would be if there is unlimited amount of space. Remove decimal digits - Decimal digits will be removed one at a time until a format is found which fits. For example, a value of 12345.6789 will be reduced to the following formats until one fits: 12345.679, 12345.68, 12345.7, and 12346. This will stop when the first significant digit is the only one left, so for example value like 0.0001234567890 can only be reduced to 0.0001. Scientific, 5 decimal digits - Number is displayed in the form of 0.00000E+00, such as 1.23457E+09, or 1.23457E-04 Scientific, 4 decimal digits - Number is displayed in the form of 0.0000E+00, such as 1.2346E+09, or 1.23456E-04 Scientific, 3 decimal digits - Number is displayed in the form of 0.000E+00, such as 1.235E+09, or 1.235E-0 Scientific, 2 decimal digits - Number is displayed in the form of 0.00E+00, such as 1.23E+09, or 1.23E-04 Scientific, 1 decimal digits - Number is displayed in the form of 0.0E+00, such as 1.2E+09, or 1.2E-04 Scientific, 0 decimal digits - Number is displayed in the form of 0E+00, such as 1E+09, or 1E-04 Rounded value - If the first significant digit is in the decimal potion of the number, the value will be rounded to the nearest integer value. For example, for a value 0.0001234567890, it will be rounded to 0, and the displayed text in cell will be 0. Hash marks - If no condensed version of the number can be displayed, hashes (#) will be repeated through the width of the cell. Empty string - If no hash marks can fit in the cell, an empty string will be returned as displayed cell text. If the format string for numeric value does not contain General or @, there are only the following stages of resizing: Normal value, Hash marks, Empty string If a text is used in the cell, the cell displayed text will always be full value, regardless of whether it is cut off or not in the cell. The only time when this is not the case is when padding characters are used in format string. Then the value will be displayed as all hash marks when there is not enough room for the text. You can set the worksheet's displayOptions' showFormulasInCells property to have formulas be displayed in cells instead of their results, and format strings and cell widths are ignored. Text values display as if their format string were @ , non-integral numeric values display as if their format string were 0.0 and integral numeric values display as if their format string were 0 . Additionally, if the value cannot fit, it will not display as all hashes. Display text will still return its full text as the cell text, even though it may not be fully seen. The following code snippet demonstrates the usage of the getText method to get the text as it would be displayed in Excel: var workbook = new Workbook(); var worksheet = this.workbook.worksheets().add(\"Sheet1\"); var cellText = worksheet.rows(0).cells(0).getText(); API References Add CellFillLinearGradient CellFillPattern CellFillRectangularGradient CellFill cellFormat displayOptions' formula mergedCellsRegions WorkbookColorInfo WorkbookStyle workbook WorksheetCell WorksheetColumn WorksheetRegion WorksheetRow worksheet View page on GitHub"
  },
  "components/excel-library-using-tables.html": {
    "href": "components/excel-library-using-tables.html",
    "title": "Angular Excel Library| Using Tables | Infragistics",
    "keywords": "Angular Using Tables The Infragistics Angular Excel Engine's WorksheetTable functionality allows you to format your data in rows and columns The data in a worksheet table can be managed independently from the data in the other rows and columns in a worksheet. Adding a Table to a Worksheet Worksheet tables in the Infragistics Angular Excel Engine are represented by the WorksheetTable object and are added in the worksheet's tables collection. In order to add a table, you need to invoke the Add method on this collection. In this method, you can specify the region in which you would like to add a table, whether or not the table should contain headers, and optionally, specify the table's style as a WorksheetTableStyle object. The following code demonstrates how you can add a table with headers to a worksheet spanning a region of A1 to G10, where A1 to G1 will be the column headers: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = this.workbook.worksheets().add(\"Sheet1\"); worksheet.tables().add(\"A1:G10\", true); Once you have added a table, you can modify it by adding or deleting rows and columns by calling the insertColumns, insertDataRows, deleteColumns, or deleteDataRows methods on the WorksheetTable. You can also set a new table range by using the resize method of the table. The following code snippet shows the usage of these methods: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); var table = worksheet.tables().add(\"A1:G10\", true); //Will add 5 columns at index 1. table.insertColumns(1, 5); //Will add 5 rows at index 0. table.insertDataRows(0, 5); //Will delete 5 columns starting at index 1. table.deleteColumns(1, 5); //Will delete 5 rows starting at index 0. table.deleteDataRows(0, 5); //Will resize the table to be in the region of A1:G15. table.resize(\"A1:G15\"); Filtering Tables Filtering is done by applying a filter on a column in the WorksheetTable. When the filter is applied on a column, all filters in the table will be reevaluated to determine which rows meet the criteria of all filters applied. If the data in the table is subsequently changed or you change the Hidden property of the rows, the filter conditions will not automatically reevaluate. The filter conditions in a table are only reapplied when table column filters are added, removed, modified, or when the reapplyFilters method is called on the table. The following are the filter types available to the columns of your WorksheetTable: AverageFilter - Cells can be filtered based on whether they are above or below the average value of all cells in the column. CustomFilter - Cells can be filtered based on one or more custom conditions. DatePeriodFilter - Only cells with dates in a specific month or quarter of any year will be displayed. FillFilter - Only cells with a specific fill will be displayed. FixedValuesFilter - Cells which only match specific display values or which fall within a specific group of dates/times will be displayed. FontColorFilter - Only cells with a specific font color will be displayed. RelativeDateRangeFilter - Cells with date values can be filtered based on whether they occur within a relative time range of the date when the filter was applied, such as the next day or previous quarter. TopOrBottomFilter - This filter allows for filtering the top or bottom N values. It also allows filtering the top or bottom N% values. YearToDateFilter - Cells with date values can be filtered if they occur between the start of the year and the date on which the filter was applied. The following code snippet demonstrates how to apply an \"above average\" filter to a WorksheetTable's first column: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); var table = worksheet.tables().add(\"A1:G10\", true); table.columns(0).applyAverageFilter(AverageFilterType.AboveAverage); Sorting Tables Sorting is done by setting a sorting condition on a table column. When a sorting condition is set on a column, all sorting conditions in the table will be reevaluated to determine the order of the cells in the table. When cells need to be moved to meet their sort criteria, the entire row of cells in the table is moved as a unit. If the data in the table is subsequently changed, the sort conditions do not automatically reevaluate. The sort conditions in a table are only reapplied when sort conditions are added, removed, modified, or when the reapplySortConditions method is called on the table. When sorting conditions are reevaluated, only the visible cells are sorted. All cells in hidden rows are kept in place. In addition to accessing sort conditions from the table columns, they are also exposed off the WorksheetTable's sortSettings property's sortConditions collection. This is an ordered collection of columns/sort condition pairs. The order of this collection is the precedence of the sorting. The following sort condition types are available to set on columns: OrderedSortCondition - Sort cells in an ascending or descending order based on their value. CustomListSortCondition - Sort cells in a defined order based on their text or display value. For example, this might be useful for sorting days as they appear on a calendar, rather than alphabetically. FillSortCondition - Sort cells based on whether their fill is a specific pattern or gradient. FontColorSortCondition - Sort cells based on whether their font is a specific color. There is also a caseSensitive property on the sortSettings of the WorksheetTable to determine whether strings should be sorted case sensitively or not. The following code snippet demonstrates how to apply an OrderedSortCondition to a WorksheetTable: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = this.workbook.worksheets().add(\"Sheet1\"); var table = worksheet.tables().add(\"A1:G10\", true); table.columns(0).sortCondition = new OrderedSortCondition(SortDirection.Ascending); //Alternative: table.sortSettings.sortConditions().addItem(table.columns(0), new OrderedSortCondition(SortDirection.Ascending)); API References deleteColumns deleteDataRows FillFilter insertColumns insertDataRows sortConditions sortSettings tables WorksheetTableStyle WorksheetTable View page on GitHub"
  },
  "components/excel-library-using-workbooks.html": {
    "href": "components/excel-library-using-workbooks.html",
    "title": "Angular Excel Library| Using Workbooks| Infragistics",
    "keywords": "Angular Using Workbooks The Infragistics Angular Excel Engine enables you to save data to and load data from Microsoft® Excel®. You can create workbooks and worksheets, input data, and export the data to Excel using the library’s various classes. The Infragistics Angular Excel Engine makes it easy to export the data in your application as an Excel spreadsheet as well as import data from Excel into your application. Angular Using Workbooks Example Change Default Font First create a new instance of IWorkbookFont. Next, add the new font to the styles collection of the Workbook. This style contains the default properties for all cells in the workbook, unless otherwise specified on a row, column, or cell. Changing properties of the style will change the default cell format properties in the workbook. var workbook = new Workbook(); var font: IWorkbookFont; font = workbook.styles().normalStyle.styleFormat.font; font.name = \"Times New Roman\"; font.height = 16 * 20; Setting Workbook Properties Microsoft Excel® document properties provide information to help organize and keep track of your documents. You can use the Infragistics Angular Excel Library to set these properties using the Workbook object’s documentProperties property. The available properties are: Author Title Subject Keywords Category Status Comments Company Manager The following code demonstrates how to create a workbook and set its title and status document properties. var workbook = new Workbook(); workbook.documentProperties.title = \"Expense Report\"; workbook.documentProperties.status = \"Complete\"; Workbook Protection The workbook protection feature allows you to protect the structure of the workbook. That is, the ability for a user to add, rename, delete, hide, and reorder the worksheets in that workbook. The protection is not enforced via the Infragistics Excel Engine's object model. It is a responsibility of the UI visualizing this object model to honor these protection settings and allow or restrict the user from performing the corresponding operations. Protection is applied to a workbook by invoking its protect method. When a Workbook is protected without a password, the end user may unprotect the Workbook in Excel without having to supply a password. To programmatically unprotect a Workbook, one may use the unprotect method. When a Workbook is protected, the values of the properties of the WorkbookProtection instance from this Workbook's protection property indicate the disabled operations. If isProtected is already true, the protect method will be ignored. var workbook = new Workbook(); workbook.protect(false, false); Check if a workbook has protection. This read-only property returns true if the workbook has any protection set using the overloads of the Protect method. var workbook = new Workbook(); var protect = workbook.isProtected; This read-only property returns an object of type WorkbookProtection which contains properties for obtaining each protection setting individually. var workbook = new Workbook(); var protection = workbook.protection; API References documentProperties WorkbookProtection Workbook Workbook View page on GitHub"
  },
  "components/excel-library-using-worksheets.html": {
    "href": "components/excel-library-using-worksheets.html",
    "title": "Angular Excel Library| Using Worksheets | Infragistics",
    "keywords": "Angular Using Worksheets The Infragistics Angular Excel Engine's worksheet is where your data is kept. You can input data by working with the Worksheet's rows and cells and setting their corresponding values. The worksheet allows you to filter, sort, and customize the formats of the cells, as shown below. Angular Using Worksheets Example The following code shows the imports needed to use the code-snippets below: import { Workbook } from \"igniteui-angular-excel\"; import { Worksheet } from \"igniteui-angular-excel\"; import { WorkbookFormat } from \"igniteui-angular-excel\"; import { Color } from \"igniteui-angular-core\"; import { CustomFilterCondition } from \"igniteui-angular-excel\"; import { ExcelComparisonOperator } from \"igniteui-angular-excel\"; import { FormatConditionTextOperator } from \"igniteui-angular-excel\"; import { OrderedSortCondition } from \"igniteui-angular-excel\"; import { RelativeIndex } from \"igniteui-angular-excel\"; import { SortDirection } from \"igniteui-angular-excel\"; import { WorkbookColorInfo } from \"igniteui-angular-excel\"; Configuring the Gridlines The gridlines are used to visually separate the cells in the worksheet. You may show or hide the gridlines and also change their color. You can show or hide the gridlines using the showGridlines property of the displayOptions of the worksheet. The following code demonstrates how you can hide the gridlines in your worksheet: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.displayOptions.showGridlines = false; You can configure the gridlines' color using the gridlineColor property of the displayOptions of the worksheet. The following code demonstrates how you can change the gridlines in your worksheet to be red: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.displayOptions.gridlineColor = \"Red\"; Configuring the Headers The column and row headers are used to visually identify columns and rows. They are also used to visually highlight the currently selected cell or cell region. You can show or hide the column and row headers using the showRowAndColumnHeaders property of the displayOptions of the worksheet. The following code demonstrates how you can hide the row and column headers: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.displayOptions.showRowAndColumnHeaders = false; Configuring Editing of the Worksheet By default, the worksheet objects that you save will be editable. You can disable editing of a worksheet by protecting it using the worksheet object's protect method. This method has a lot of nullable bool arguments that determine which pieces are protected, and one of these options is to allow editing of objects, which if set to false will prevent editing of the worksheet. The following code demonstrates how to disable editing in your worksheet: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.protect(); You can also use the worksheet object's protect method to protect a worksheet against structural changes. When protection is set, you can set the cellFormat object's locked property on individual cells, rows, merged cell regions, or columns to override the worksheet object's protection on those objects. For example, if you need all cells of a worksheet to be read-only except for the cells of one column, you can protect the worksheet and then set the cellFormat object's locked property to false on a specific WorksheetColumn object. This will allow your users to edit cells within the column while disabling editing of the other cells in the worksheet. The following code demonstrates how you can do this: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.protect(); worksheet.columns(0).cellFormat.locked = false; Filtering Worksheet Regions Filtering is done by setting a filter condition on a worksheet's WorksheetFilterSettings which can be retrieved from the worksheet object's filterSettings property. Filter conditions are only reapplied when they're added, removed, modified, or when the reapplyFilters method is called on the worksheet. They are not constantly evaluated as data within the region changes. You can specify the region to apply the filter by using the setRegion method on the WorksheetFilterSettings object. Below is a list of methods and their descriptions that you can use to add a filter to a worksheet: Method Description applyAverageFilter Represents a filter which can filter data based on whether the data is below or above the average of the entire data range. applyDatePeriodFilter Represents a filter which can filter dates in a Month, or quarter of any year. applyFillFilter Represents a filter which will filter cells based on their background fills. This filter specifies a single CellFill. Cells of with this fill will be visible in the data range. All other cells will be hidden. ApplyFixedValuesFilter Represents a filter which can filter cells based on specific, fixed values, which are allowed to display. applyFontColorFilter Represents a filter which will filter cells based on their font colors. This filter specifies a single color. Cells with this color font will be visible in the data range. All other cells will be hidden. applyIconFilter Represents a filter which can filter cells based on their conditional formatting icon. applyRelativeDateRangeFilter Represents a filter which can filter date cells based on dates relative to the when the filter was applied. applyTopOrBottomFilter Represents a filter which can filter in cells in the upper or lower portion of the sorted values. applyYearToDateFilter Represents a filter which can filter in date cells if the dates occur between the start of the current year and the time when the filter is evaluated. applyCustomFilter Represents a filter which can filter data based on one or two custom conditions. These two filter conditions can be combined with a logical \"and\" or a logical \"or\" operation. You can use the following code snippet as an example to add a filter to a worksheet region: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.filterSettings.setRegion(\"Sheet1!A1:A10\"); worksheet.filterSettings.applyAverageFilter(0, AverageFilterType.AboveAverage); Freezing and Splitting Panes You can freeze rows at the top of your worksheet or columns at the left using the freezing panes features. Frozen rows and columns remain visible at all times while the user is scrolling. The frozen rows and columns are separated from the rest of the worksheet by a single, solid line, which cannot be removed. In order to enable pane freezing, you need to set the panesAreFrozen property of the worksheet object's displayOptions to true. You can then specify the rows or columns to freeze by using the FrozenRows and FrozenColumns properties of the display options frozenPaneSettings, respectively. You can also specify the first row in the bottom pane or first column in the right pane using the FirstRowInBottomPane and FirstColumnInRightPane properties, respectively. The following code snippet demonstrates how to use the freezing panes features in a worksheet: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.displayOptions.panesAreFrozen = true; worksheet.displayOptions.frozenPaneSettings.frozenRows = 3; worksheet.displayOptions.frozenPaneSettings.frozenColumns = 1; worksheet.displayOptions.frozenPaneSettings.firstColumnInRightPane = 2; worksheet.displayOptions.frozenPaneSettings.firstRowInBottomPane = 6; Setting the Worksheet Zoom Level You can change the zoom level for each worksheet independently using the MagnificationInNormalView property on the worksheet object's displayOptions. This property takes a value between 10 and 400 and represents the percentage of zoom that you wish to apply. The following code demonstrates how you can do this: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.displayOptions.magnificationInNormalView = 300; Worksheet Level Sorting Sorting is done by setting a sorting condition on a worksheet level object on either columns or rows. You can sort columns or rows in ascending or descending order. This is done by specifying a region and sort type to the worksheet object's WorksheetSortSettings that can be retrieved using the sortSettings property of the sheet. The sort conditions in a sheet are only reapplied when sort conditions are added, removed, modified, or when the reapplySortConditions method is called on the worksheet. Columns or rows will be sorted within the region. \"Rows\" is the default sort type. The following code snippet demonstrates how to apply a sort to a region of cells in a worksheet: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.sortSettings.sortConditions().addItem(new RelativeIndex(0), new OrderedSortCondition(SortDirection.Ascending)); Worksheet Protection You can protect a worksheet by calling the protect method on the worksheet object. This method exposes many nullable bool parameters that allow you to restrict or allow the following user operations: Editing of cells. Editing of objects such as shapes, comments, charts, or other controls. Editing of scenarios. Filtering of data. Formatting of cells. Inserting, deleting, and formatting of columns. Inserting, deleting, and formatting of rows. Inserting of hyperlinks. Sorting of data. Usage of pivot tables. You can remove worksheet protection by calling the unprotect method on the worksheet object. The following code snippet shows how to enable protection of all of the above-listed user operations: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); worksheet.protect(); Worksheet Conditional Formatting You can configure the conditional formatting of a worksheet object by using the many \"Add\" methods exposed on the conditionalFormats collection of that worksheet. The first parameter of these \"Add\" methods is the string region of the worksheet that you would like to apply the conditional format to. Many of the conditional formats that you can add to your worksheet have a cellFormat property that determines the way that the WorksheetCell elements should look when the condition in that conditional format holds true. For example, you can use the properties attached to this cellFormat property such as fill and font to determine the background and font settings of your cells under a particular conditional format, respectively. There are a few conditional formats that do not have a cellFormat property, as their visualization on the worksheet cell behaves differently. These conditional formats are the DataBarConditionalFormat, ColorScaleConditionalFormat, and IconSetConditionalFormat. When loading a pre-existing workbook from Excel, the formats will be preserved when that workbook is loaded. The same is true for when you save the workbook out to an Excel file. The following code example demonstrates usage of conditional formats on a worksheet: var workbook = new Workbook(WorkbookFormat.Excel2007); var worksheet = workbook.worksheets().add(\"Sheet1\"); var color = new Color(); color.colorString = \"Red\"; var format = worksheet.conditionalFormats().addAverageCondition(\"A1:A10\", FormatConditionAboveBelow.AboveAverage); format.cellFormat.font.colorInfo = new WorkbookColorInfo(color); API References cellFormat ColorScaleConditionalFormat conditionalFormats DataBarConditionalFormat displayOptions filterSettings showGridlines showRowAndColumnHeaders sortSettings workbook WorksheetCell WorksheetColumn WorksheetFilterSettings WorksheetSortSettings worksheet View page on GitHub"
  },
  "components/excel-library-working-with-charts.html": {
    "href": "components/excel-library-working-with-charts.html",
    "title": "Angular Excel Library| Working with Charts | Infragistics",
    "keywords": "Angular Working with Charts The Infragistics Angular Excel Engine's WorksheetChart functionality allows you to add visual charting representations of data trends across regions of cells in a worksheet. For example, if you want to see your Excel data in a region of cells visualized as a column, line, or over 70 other chart types, this feature can help you to achieve that. Angular Working with Charts Example Usage In order to add a chart to a worksheet, you must use the AddChart method of the worksheet's shapes collection. In this method, you can specify the chart type that you wish to use, the top-left cell, the bottom-right cell, and the percentages of those cells that you wish for the chart to take up. The AddChart method returns the worksheet chart element to be added to the worksheet. Once you have this, you can use the setSourceData method on the chart to set a cell address of the region of worksheet cells that you wish to use as a data source, as well as whether or not you want to switch the mapping of columns and rows to the X and Y axis. There are over 70 supported chart types, including Line, Area, IgxColumn, and Pie. The following code demonstrates how to use the Excel charting feature. The below snippet will add a column chart to between the first cell and the 13th cell in the first row of the worksheet. The source data is then set for the data in the region of A2:M6, switching the mapping of columns and rows for the X and Y axis of the column chart: var chart = ws.shapes().addChart(ChartType.ColumnClustered, ws.rows(0).cells(0), { x: 0, y: 0 }, ws.rows(0).cells(12), { x: 100, y: 100 }); chart.setSourceData(\"A2:M6\", true); API References AddChart Area IgxColumn Line Pie WorksheetChart View page on GitHub"
  },
  "components/excel-library-working-with-grids.html": {
    "href": "components/excel-library-working-with-grids.html",
    "title": "Angular Excel Library| Data Spreadsheet | Infragistics",
    "keywords": "Angular Working with Grids TODO Angular Working with Grids Example Usage The following code demonstrates how to use ... TODO TODO View page on GitHub"
  },
  "components/excel-library-working-with-sparklines.html": {
    "href": "components/excel-library-working-with-sparklines.html",
    "title": "Angular Excel Library| Working with Sparklines | Infragistics",
    "keywords": "Angular Working with Sparklines The Infragistics Angular Excel Library has support for adding sparklines to an Excel Worksheet. These can be used to show simple visual representations of data trends across a region of cells of data in your worksheet. For example, if you wanted to see your Excel data across a particular cell region visualized as a simple column or line sparkline chart, this feature can help you to achieve that. Angular Working with Sparklines Example Supported Sparklines The following is a list of the supported predefined sparkline types. Line Column Stacked (Win/Loss) The following code demonstrates how to programmatically add Sparklines to a Worksheet via the sparklineGroups collection: var workbook: Workbook; var sheet1 = workbook.worksheets().add(\"Sparklines\"); var sheet2 = workbook.worksheets().add(\"Data\"); sheet1.sparklineGroups().add(SparklineType.Line, \"Sparklines!A1:A1\", \"Data!A2:A11\"); sheet1.sparklineGroups().add(SparklineType.Column, \"Sparklines!B1:B1\", \"Data!A2:A11\"); workbook.save(workbook, \"Sparklines.xlsx\"); API References Workbook View page on GitHub"
  },
  "components/excel-utility.html": {
    "href": "components/excel-utility.html",
    "title": "Angular Excel Library | Excel Utility | Infragistics",
    "keywords": "Angular Excel Utility This topic provides utility function for loading and saving Microsoft Excel files using Excel Library import { saveAs } from \"file-saver\"; // npm package: \"file-saver\": \"^1.3.8\" import { Workbook } from 'igniteui-angular-excel'; import { WorkbookFormat } from 'igniteui-angular-excel'; import { WorkbookSaveOptions } from 'igniteui-angular-excel'; export class ExcelUtility { public static getExtension(format: WorkbookFormat) { switch (format) { case WorkbookFormat.StrictOpenXml: case WorkbookFormat.Excel2007: return \".xlsx\"; case WorkbookFormat.Excel2007MacroEnabled: return \".xlsm\"; case WorkbookFormat.Excel2007MacroEnabledTemplate: return \".xltm\"; case WorkbookFormat.Excel2007Template: return \".xltx\"; case WorkbookFormat.Excel97To2003: return \".xls\"; case WorkbookFormat.Excel97To2003Template: return \".xlt\"; } } public static load(file: File): Promise<Workbook> { return new Promise<Workbook>((resolve, reject) => { ExcelUtility.readFileAsUint8Array(file).then((a) => { Workbook.load(a, null, (w) => { resolve(w); }, (e) => { reject(e); }); }, (e) => { reject(e); }); }); } public static loadFromUrl(url: string): Promise<Workbook> { return new Promise<Workbook>((resolve, reject) => { const req = new XMLHttpRequest(); req.open(\"GET\", url, true); req.responseType = \"arraybuffer\"; req.onload = (d) => { const data = new Uint8Array(req.response); Workbook.load(data, null, (w) => { resolve(w); }, (e) => { reject(e); }); }; req.send(); }); } public static save(workbook: Workbook, fileNameWithoutExtension: string): Promise<string> { return new Promise<string>((resolve, reject) => { const opt = new WorkbookSaveOptions(); opt.type = \"blob\"; workbook.save(opt, (d) => { const fileExt = ExcelUtility.getExtension(workbook.currentFormat); const fileName = fileNameWithoutExtension + fileExt; saveAs(d as Blob, fileName); resolve(fileName); }, (e) => { reject(e); }); }); } private static readFileAsUint8Array(file: File): Promise<Uint8Array> { return new Promise<Uint8Array>((resolve, reject) => { const fr = new FileReader(); fr.onerror = (e) => { reject(fr.error); }; if (fr.readAsBinaryString) { fr.onload = (e) => { const rs = (fr as any).resultString; const str: string = rs != null ? rs : fr.result; const result = new Uint8Array(str.length); for (let i = 0; i < str.length; i++) { result[i] = str.charCodeAt(i); } resolve(result); }; fr.readAsBinaryString(file); } else { fr.onload = (e) => { resolve(new Uint8Array(fr.result as ArrayBuffer)); }; fr.readAsArrayBuffer(file); } }); } } API References WorkbookFormat WorkbookSaveOptions Workbook View page on GitHub"
  },
  "components/expansion-panel.html": {
    "href": "components/expansion-panel.html",
    "title": "Angular Expansion Panel – Ignite UI for Angular",
    "keywords": "Angular Expansion Panel Component Overview Ignite UI for Angular provides developers with one of the most useful and easy-to-use layout components - Expansion Panel. This feature-rich component is used to create an expandable/collapsible detailed summary view. The content can include Angular Expansion Panel animation, text, icons, header, action bar, and other elements. Ignite UI Expansion Panel igx-expansion-panel is a lightweight Angular accordion component which can be rendered in two states - collapsed or expanded. The Expansion Panel in Angular can be toggled using mouse click, or keyboard interactions. You can also combine multiple Angular Expansion Panels into Angular accordion. Angular Expansion Panel Example We've created this simple Angular Expansion Panel Example using Ignite UI Angular. See how the sample works. Getting Started with Ignite UI for Angular Expansion Panel To get started with the Ignite UI for Angular Drop Down component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxExpansionPanelModule in your app.module.ts file. // app.module.ts ... import { IgxExpansionPanelModule } from 'igniteui-angular'; // import { IgxExpansionPanelModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxExpansionPanelModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxExpansionPanelComponent as a standalone dependency, or use the IGX_EXPANSION_PANEL_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_EXPANSION_PANEL_DIRECTIVES } from 'igniteui-angular'; // import { IGX_EXPANSION_PANEL_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-expansion-panel> <igx-expansion-panel-header> <igx-expansion-panel-title> Golden Retriever </igx-expansion-panel-title> <igx-expansion-panel-description> Medium-large gun dog </igx-expansion-panel-description> </igx-expansion-panel-header> <igx-expansion-panel-body> The Golden Retriever is a medium-large gun dog that retrieves shot waterfowl, such as ducks and upland game birds, during hunting and shooting parties. The name \"retriever\" refers to the breed's ability to retrieve shot game undamaged due to their soft mouth. Golden retrievers have an instinctive love of water, and are easy to train to basic or advanced obedience standards. </igx-expansion-panel-body> </igx-expansion-panel> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_EXPANSION_PANEL_DIRECTIVES] /* or imports: [IgxExpansionPanelComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelTitleDirective, IgxExpansionPanelDescriptionDirective, IgxExpansionPanelBodyComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Expansion Panel module or directives imported, you can start using the igx-expansion-panel component. Using the Angular Expansion Panel The table below shows all the available markup parts for the Angular Expansion Panel. Tag Name Description igx-expansion-panel The component host - stores header and body. igx-expansion-panel-header Stores the component header. This is always visible. Stores title and description as well as any additional content igx-expansion-panel-title Use it to set expansion panel title. igx-expansion-panel-description It can be used to provide a short summary. The description will always appear after the title (if the title is set). igx-expansion-panel-icon Use it to change the default expand/collapse icon. igx-expansion-panel-body This is the expandable container and it's only visible when the panel is expanded. Properties Binding and Events We can add some logic to our component to make it show/hide the igx-expansion-panel-description depending on the current state of the panel. We can do this by binding the description to the control collapsed property: // in expansion-panel.component.ts import { IgxExpansionPanelComponent } from 'igniteui-angular'; // import { IgxExpansionPanelComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class ExpansionPanelComponent { @ViewChild(IgxExpansionPanelComponent, {read: IgxExpansionPanelComponent}) public panel: IgxExpansionPanelComponent; } <!-- in expansion-component.component.html --> <igx-expansion-panel> <igx-expansion-panel-header> Golden Retriever <igx-expansion-panel-description *ngIf=\"panel.collapsed\"> Medium-large gun dog </igx-expansion-panel-description> </igx-expansion-panel-header> ... </igx-expansion-panel> The following code sample will show the short description only when the component is in its collapsed state. If we want to add more complex functionality depending on the component state, we could also bind to an event emitter. // in expansion-panel.component.ts @Component({...}) export class ExpansionPanelComponent { ... public handleExpansion(args: {event: Event}): void { ... // Some functionality } } <!-- in expansion-component.component.html --> <igx-expansion-panel (onExpanded)=\"handleExpansion($event)\" (contentCollapsed)=\"handleCollapse($event)\"></igx-expansion-panel> Below we have the results: Component Customization The IgxExpansionPanelComponent allows for easy customization of the header. Configuring the position of the header icon can be done through the iconPosition input on the igx-expansion-panel-header. The possible options for the icon position are left, right and none. The next code sample demonstrates how to configure the component's button to go on the right side. <!-- in expansion-component.component.html --> <igx-expansion-panel> <igx-expansion-panel-header [iconPosition]=\"'right'\"></igx-expansion-panel-header> ... </igx-expansion-panel> Note The iconPosition property works with RTL - e.g. an icon set to show up in right will show in the leftmost part of the header when RTL is on. The default icon for the toggle state of the control can be templated. We can do that by passing content in an igx-expansion-panel-icon tag: <!-- in expansion-component.component.html --> <igx-expansion-panel> <igx-expansion-panel-header [iconPosition]=\"'right'\"> ... <igx-expansion-panel-icon> <span class=\"example-icon\" *ngIf=\"panel.collapsed\">Show More</span> <span class=\"example-icon\" *ngIf=\"!panel.collapsed\">Show Less</span> </igx-expansion-panel-icon> </igx-expansion-panel-header> ... </igx-expansion-panel> Our Angular Expansion Panel will now render \"Show More\" when the panel is collapsed and \"Show Less\" once it's fully expanded. The IgxExpansionPanel control allows all sorts of content to be added inside of the igx-expansion-panel-body. It can render IgxGrids, IgxCombo, charts and even other expansion panels! For the sake of simplicity let's add some basic markup to the body of our expansion panel. <!-- in expansion-panel.component.html --> ... <igx-expansion-panel-body> <div class=\"example-content\"> <img [src]=\"imgSource\" alt=\"dog-image\"> The Golden Retriever is a medium-large gun dog that retrieves shot waterfowl, such as ducks and upland game birds, during hunting and shooting parties. The name \"retriever\" refers to the breed's ability to retrieve shot game undamaged due to their soft mouth. Golden retrievers have an instinctive love of water, and are easy to train to basic or advanced obedience standards. <a igxButton=\"outlined\" target=\"_blank\" [href]=\"readMore\">Read more</a> </div> </igx-expansion-panel-body> ... Lets see the result from all the above changes: Styling Angular Expansion Panel Demo Palettes & Colors Fist we create a custom palette which can later be passed to our component: // In real life, this should be in our main sass file so we can share the palette between all components. // In our case, it's in the component SCSS file \"expansion-styling.component.scss\". @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; // Add your brand colors. $my-primary-color:#353a4b; $my-secondary-color: #ffd351; // Create custom palette. $my-color-palette: palette( $primary: $my-primary-color, $secondary: $my-secondary-color ); Creating the Component Theme Now let's create our component theme and pass the $my-color-palette palette from the above sniped. // In expansion-styling.component.scss // Create expansion panel theme. $custom-panel-theme: expansion-panel-theme( // pass `$my-color-palette` palette. $palette: $my-color-palette, // Styling parameters. $header-background: color($my-color-palette, \"primary\", 700), $header-focus-background: color($my-color-palette, \"primary\", 700), $header-title-color: color($my-color-palette, \"secondary\"), $header-icon-color: color($my-color-palette, \"secondary\"), $body-background: color($my-color-palette, \"primary\", 700), $body-color: color($my-color-palette, \"secondary\" 100), $border-radius: .5 ); Note To see all the available parameters for styling trough the theming engine check the API documentation Applying the Component Theme Now to apply the component theme all that's left is to include css-vars mixin and pass the $custom-panel-theme map. // In expansion-styling.component.scss // Pass our custom-panel-theme to `igx-expansion-panel` mixin. // The `:host` here makes sure that all the theming will affect only this component. :host { @include css-vars($custom-panel-theme); } Note If you need to support Internet explorer 11 you have to use the component mixin igx-expansion-panel instead of css-vars and because our component have Emulated ViewEncapsulation we have to penetrate it by using ::ng-deep. Also in order to prevent our custom theme from leaking into other components, we have to include the :host selector before ::ng-deep: // In expansion-styling.component.scss // The `:host` here makes sure that all the theming will affect only this component after the ViewEncapsulation Penetration. :host { // Penetrate the ViewEncapsulation. ::ng-deep { @include expansion-panel($custom-panel-theme); } } To find out more on how you can use Ignite UI theming engine click here Angular Expansion Panel Animations Using specific animation It is possible to use other than default animation when expanding and collapsing the component. Assuming the igxExpansionPanel is already imported in app.module.ts as previously described, you can create a custom animation setting object and set it to be used in the Ignite UI for Agular Expansion Panel. The approach requires the useAnimation method and the specific animations to be used so we start importing these and defining the animation settings like: // in expansion-panel.component.ts import { useAnimation } from '@angular/animations'; import { IgxExpansionPanelComponent, slideInLeft, slideOutRight } from 'igniteui-angular'; // import { IgxExpansionPanelComponent, slideInLeft, slideOutRight } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class ExpansionPanelComponent { @ViewChild(IgxExpansionPanelComponent, {read: IgxExpansionPanelComponent}) public panel: IgxExpansionPanelComponent; public animationSettingsCustom = { closeAnimation: useAnimation(slideOutRight, { params: { duration: '100ms', toPosition: 'translateX(25px)' } }), openAnimation: useAnimation(slideInLeft, { params: { duration: '500ms', fromPosition: 'translateX(-15px)', startOpacity: 0.1 } }) }; public collapsed() { return this.panel && this.panel.collapsed; } } As you can see, we are going to use slideInLeft and slideOutRight animations from our inbuilt suite of animations to make the component content appear more dramatically from the left side and disappear on the right when collapsing the content. In the process, we override some of the existing parameters with the specific ones we want to use. The sample shows some user information and the key point here is passing the animation settings to the component like: [animationSettings] = \"animationSettingsCustom\" <!-- in expansion-panel.component.html --> ... <igx-expansion-panel [animationSettings] = \"animationSettingsCustom\" class=\"my-expansion-panel\"> <igx-expansion-panel-header> <igx-expansion-panel-title class=\"sample-title\">Angular</igx-expansion-panel-title> </igx-expansion-panel-header> <igx-expansion-panel-body> Angular (commonly referred to as \"Angular 2+\" or \"Angular v2 and above\") is a TypeScript-based open-source web application framework led by the Angular Team at Google and by a community of individuals and corporations. </igx-expansion-panel-body> </igx-expansion-panel> ... You can see the results below: Multiple panel scenario See the igxAccordion topic API Reference IgxExpansionPanel API IgxExpansionPanelHeader API IgxExpansionPanelBody API IgxExpansionPanel Styles Theming Dependencies IgxExpansionPanel Theme IgxIcon Theme View page on GitHub"
  },
  "components/exporter-csv.html": {
    "href": "components/exporter-csv.html",
    "title": "Export to CSV/TSV Component - Native Angular | Ignite UI for Angular",
    "keywords": "CSV Exporter The IgniteUI CSV Exporter service can export data in a Character Separated Values format from both raw data (array) or from an IgxGrid, IgxHierarchicalGrid and IgxTreeGrid. The exporting functionality is encapsulated in the IgxCsvExporterService class. Angular CSV Exporter Example To start using the IgniteUI CSV Exporter first import the IgxCsvExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts ... import { IgxCsvExporterService } from 'igniteui-angular'; // import { IgxCsvExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxCsvExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <button (click)=\"exportButtonHandler()\">Export Data to CSV</button> You may access the exporter service by defining an argument of type IgxCsvExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in CSV format you need to invoke the exporter service's exportData method. This method accepts as a first argument the data you want to export and the second argument is of type IgxCsvExporterOptions and allows you to configure the export process. Here is the code which will execute the export process in the component's typescript file: // component.ts ... import { IgxCsvExporterService, IgxCsvExporterOptions, CsvFileTypes } from 'igniteui-angular'; // import { IgxCsvExporterService, IgxCsvExporterOptions, CsvFileTypes } from '@infragistics/igniteui-angular'; for licensed package ... public localData = [ { Name: 'Eric Ridley', Age: '26' }, { Name: 'Alanis Brook', Age: '22' }, { Name: 'Jonathan Morris', Age: '23' } ]; constructor(private csvExportService: IgxCsvExporterService) { } public exportButtonHandler() { this.csvExportService.exportData(this.localData, new IgxCsvExporterOptions('ExportedDataFile'), CsvFileTypes.CSV); } If all went well, you should see an export button. When pressed, it will trigger the export process and the browser will download a file named \"ExportedDataFile.csv\" which contains the data from the localData array in CSV format. Exporting IgxGrid's Data The CSV Exporter service can also export data in CSV format from an IgxGrid. The only difference is that you need to invoke the IgxCsvExporterService's export method and pass the IgxGrid as first argument. Here is an example: <igx-grid #igxGrid1 [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid> <button (click)=\"exportButtonHandler()\">Export IgxGrid</button> // component.ts ... import { IgxCsvExporterService, IgxCsvExporterOptions, CsvFileTypes, IgxGridComponent } from 'igniteui-angular'; // import { IgxCsvExporterService, IgxCsvExporterOptions, CsvFileTypes, IgxGridComponen } from '@infragistics/igniteui-angular'; for licensed package ... @ViewChild('igxGrid1') public igxGrid1: IgxGridComponent; public localData = [ { Name: 'Eric Ridley', Age: '26' }, { Name: 'Alanis Brook', Age: '22' }, { Name: 'Jonathan Morris', Age: '23' } ]; constructor(private csvExportService: IgxCsvExporterService) { } public exportButtonHandler() { this.csvExportService.export(this.igxGrid1, new IgxCsvExporterOptions('ExportedDataFile', CsvFileTypes.CSV)); } Customizing the Exported Format The CSV Exporter supports several types of exporting formats. The export format may be specified: as a second argument of the IgxCsvExporterOptions objects's constructor using the IgxCsvExporterOptions object's fileType property Different export formats have different file extensions and value delimiters. The following table maps the export formats and their respective file extensions and delimiters: Format File Extension Default Delimiter CsvFileTypes.CSV .csv Comma CsvFileTypes.TAB .tab Tab CsvFileTypes.TSV .tsv Tab You can also specify a custom delimiter using the IgxCsvExporterOptions objects's valueDelimiter property. Customizing the Exported Content In the above examples the CSV Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude a column from the export if its name is \"Age\" and if its index is 1: // component.ts this.csvExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Age' && args.columnIndex == 1) { args.cancel = true; } }); this.csvExportService.export(this.igxGrid1, new IgxCsvExporterOptions('ExportedDataFile')); When you are exporting data from IgxGrid the export process takes in account features like row filtering and column hiding and exports only the data visible in the grid. You can configure the exporter service to include filtered rows or hidden columns by setting properties on the IgxCsvExporterOptions object. These properties are described in the table below. API Summary The CSV Exporter service has a few more APIs to explore, which are listed below. IgxCsvExporterService API IgxCsvExporterOptions API Additional components that were used: IgxGridComponent API IgxGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/exporter-excel.html": {
    "href": "components/exporter-excel.html",
    "title": "Export to Excel Component - Native Angular | Ignite UI for Angular",
    "keywords": "Excel Exporter The Ignite UI for Angular Excel Exporter service can export data in Microsoft® Excel® format from raw data (array) or from the IgxGrid, IgxTreeGrid and IgxHierarchicalGrid components. The exporting functionality is encapsulated in the IgxExcelExporterService class and the data is exported in MS Excel table format. This format allows features like filtering, sorting, etc. Angular Excel Exporter Example Usage To start using the IgniteUI Excel Exporter first import the IgxExcelExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts ... import { IgxExcelExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxExcelExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <button (click)=\"exportButtonHandler()\">Export Data to Excel</button> You may access the exporter service by defining an argument of type IgxExcelExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in MS Excel format you need to invoke the exporter service's exportData method. This method accepts as a first argument the data you want to export and the second argument is of type IgxExcelExporterOptions and allows you to configure the export process. Here is the code which will execute the export process in the component's typescript file: // component.ts ... import { IgxExcelExporterService, IgxExcelExporterOptions } from 'igniteui-angular'; // import { IgxExcelExporterService, IgxExcelExporterOptions } from '@infragistics/igniteui-angular'; for licensed package ... public localData = [ { Name: 'Eric Ridley', Age: '26' }, { Name: 'Alanis Brook', Age: '22' }, { Name: 'Jonathan Morris', Age: '23' } ]; constructor(private excelExportService: IgxExcelExporterService) { } public exportButtonHandler() { this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions('ExportedDataFile')); } If all went well, you should see an export button. When pressed, it will trigger the export process and the browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the localData array in MS Excel format. Customizing the Exported Content In the above examples the Excel Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude a column from the export if its header is \"Age\" and if its index is 1: // component.ts this.excelExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Age' && args.columnIndex == 1) { args.cancel = true; } }); this.excelExportService.export(this.igxGrid1, new IgxExcelExporterOptions('ExportedDataFile')); API References The Excel Exporter service has a few more APIs to explore, which are listed below. IgxExcelExporterService API IgxExcelExporterOptions API Grids Excel Exporters: IgxGrid Excel Exporters IgxTreeGrid Excel Exporters Additional components that were used: IgxGridComponent API IgxGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/for-of.html": {
    "href": "components/for-of.html",
    "title": "Angular Virtual For Directive",
    "keywords": "Angular Virtual ForOf Directive Overview The Ignite UI for Angular igxForOf directive is an alternative to ngForOf for templating large amounts of data. It uses virtualization behind the scenes to optimize DOM rendering and memory consumption. Angular Virtual For Directive Example Getting Started with Ignite UI for Angular Virtual ForOf Directive To get started with the Ignite UI for Angular igxFor directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxForOfModule in your app.module.ts file. // app.module.ts import { IgxForOfModule } from 'igniteui-angular'; // import { IgxForOfModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxForOfModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxForOfDirective as a standalone dependency. // home.component.ts import { IgxForOfDirective } from 'igniteui-angular'; // import { IgxForOfDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <span #container> <ng-template *igxFor=\"data\"></ng-template> </span> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxForOfDirective] }) export class HomeComponent { public data: Employee []; } Now that you have the Ignite UI for Angular Tree Grid module or directives imported, you can start using the igxFor directive. Using the Angular Virtual ForOf Now that we have the module or directive imported, let’s get started with a basic configuration of the igxFor that binds to local data: <span #container> <ng-template *igxFor=\"data\"></ng-template> </span> The data property is an array that provides the data objects used to construct the virtualized DOM. Examples The igxFor directive can be used to virtualize the data in vertical, horizontal or both directions. Virtualization works similarly to Paging by slicing the data into smaller chucks which are swapped from a container viewport while the user scrolls the data horizontally/vertically. The difference with the Paging is that virtualization mimics the natural behavior of the scrollbar. The igxFor directive is creating scrollable containers and renders small chunks of the data. It is used inside the igxGrid and it can be used to build a virtual igx-list. Vertical virtualization <igx-list> <div [style.height]=\"'500px'\" [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\"> <igx-list-item [style.width]=\"'calc(100% - 18px)'\" *igxFor=\"let item of data | igxFilter: fo; scrollOrientation : 'vertical'; containerSize: '500px'; itemSize: '50px'\"> <div class=\"contact\"> <span class=\"name\">{{item.name}}</span> </div> </igx-list-item> </div> </igx-list> Note: It is strongly advised that the parent container of the igxForOf template has the following CSS rules applied: height for vertical and width for horizontal, overflow: hidden and position: relative. This is because the smooth scrolling behavior is achieved through content offsets that could visually affect other parts of the page if they remain visible. Horizontal virtualization <igx-list> <div [style.width]=\"'880px'\" [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\"> <igx-list-item [style.width]=\"'220px'\" *igxFor=\"let item of data | igxFilter: fo; scrollOrientation : 'horizontal'; containerSize: '880px'; itemSize: '220px'\"> <div class=\"contact\"> <span class=\"name\">{{item.name}}</span> </div> </igx-list-item> </div> </igx-list> Horizontal and vertical virtualization <table #container [style.width]='width' [style.height]='height' [style.overflow]='\"hidden\"' [style.position]='\"relative\"'> <ng-template #scrollContainer igxFor let-rowData [igxForOf]=\"data\" [igxForScrollOrientation]=\"'vertical'\" [igxForContainerSize]='height' [igxForItemSize]='\"50px\"'> <tr [style.display]=\"'flex'\" [style.height]=\"'50px'\"> <ng-template #childContainer igxFor let-col [igxForOf]=\"cols\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\" [igxForContainerSize]='width'> <td [style.min-width]='col.width + \"px\"'> {{rowData[col.field]}} </td> </ng-template> </tr> </ng-template> </table> The igxFor directivе is used to virtualize data in both vertical and horizontal directions inside the igxGrid. Follow the Grid Virtualization topic for more detailed information and demos. igxFor bound to remote service The igxForOf directive can be bound to a remote service using the Observable property - remoteData (in the following case). The chunkLoading event should also be utilized to trigger the requests for data. <div style='height: 500px; overflow: hidden; position: relative;'> <ng-template igxFor let-item [igxForOf]=\"remoteData | async\" (chunkPreload)=\"chunkLoading($event)\" [igxForScrollOrientation]=\"'vertical'\" [igxForContainerSize]='\"500px\"' [igxForItemSize]='\"50px\"' [igxForRemote]='true' let-rowIndex=\"index\" #virtDirRemote> <div style='height:50px;'>{{item.ProductID}} : {{item.ProductName}}</div> </ng-template> </div> Note: There is a requirement to set the totalItemCount property in the instance of igxForOf. this.virtDirRemote.totalItemCount = data['@odata.count']; In order to access the directive instance from the component, it should be marked as ViewChild: @ViewChild('virtDirRemote', { read: IgxForOfDirective }) public virtDirRemote: IgxForOfDirective<any>; After the request for loading the first chunk, the totalItemCount can be set: public ngAfterViewInit() { this.remoteService.getData(this.virtDirRemote.state, (data) => { this.virtDirRemote.totalItemCount = data['@odata.count']; }); } When requesting data you can take advantage of the IgxForOfState interface, which provides the startIndex and chunkSize properties. Note that initialy the chunkSize will be 0, so you have to specify the size of the first loaded chunk (the best value is the initial igxForContainerSize divided by the igxForItemSize). public getData(data?: IForOfState, cb?: (any) => void): any { var dataState = data; return this.http .get(this.buildUrl(dataState)) .map((response) => response.json()) .map((response) => { return response; }) .subscribe((data) => { this._remoteData.next(data.value); if (cb) { cb(data); } }); } private buildUrl(dataState: any): string { let qS: string = '?', requiredChunkSize: number; if (dataState) { const skip = dataState.startIndex; requiredChunkSize = dataState.chunkSize === 0 ? // Set initial chunk size, the best value is igxForContainerSize // initially divided by igxForItemSize 10 : dataState.chunkSize; const top = requiredChunkSize; qS += `$skip=${skip}&$top=${top}&$count=true`; } return `${this.url}${qS}`; } Every time the chunkPreload event is thrown, a new chunk of data should be requested: chunkLoading(evt) { if(this.prevRequest){ this.prevRequest.unsubscribe(); } this.prevRequest = this.remoteService.getData(evt, ()=> { this.virtDirRemote.cdr.detectChanges(); }); } Local Variables The igxFor directive includes the following helper properties in its context: even, odd, first and last. They are used to identify the current element position in the collection. The following code snippet demonstrates how to use the even property in an ng-template. Аn even class will be assigned to every even div element: <ng-template igxFor let-item let-isEven=\"even\" [igxForOf]=\"data\" [igxForScrollOrientation]=\"'vertical'\" > <div [ngClass]=\"{even: isEven}\"></div> </ng-template> Known Limitations Limitation Description scrollTo method does not work correctly when the content size of the rendered templates changes post initialization When the elements inside the template have a size, that changes runtime after initialization (for example as a result of content projection, remote request resolution etc.), then the scrollTo method will not be able to scroll to the correct index. The method will scroll to the position of the index before the runtime size change occurs, hence the location will not be correct after the size is changed later. A possible workaround is to use templates that do not change their size based on their content if the content is loaded later. API References IgxForOfDirective IgxGridComponent IgxListComponent Additional Resources Our community is active and always welcoming to new ideas. * [Ignite UI for Angular **Forums**](https://www.infragistics.com/community/forums/f/ignite-ui-for-angular) * [Ignite UI for Angular **GitHub**](https://github.com/IgniteUI/igniteui-angular) View page on GitHub"
  },
  "components/general/angular-grid-overview-guide.html": {
    "href": "components/general/angular-grid-overview-guide.html",
    "title": "A Complete Guide to Angular Grid and Angular App Development",
    "keywords": "A Complete Guide to Angular Grid and Angular App Development Get to know the Angular Data Grid and how to use it by checking out this informative section part of our Grid Overview topic. Ignite UI - Our Framework for Angular App Development Ignite UI for Angular is an advanced toolset from Infragistics that includes feature-rich, high-performing UI components such as data grids and other components including charts, data visualization maps, editors, and more. The Ignite UI Angular data grid is among the fastest in the industry and is used by many of the leading financial and insurance companies. Built on Google’s Angular framework, Ignite UI provides over 50 UI components and Material-based components, and over 50 chart types, including financial charting. Among its many benefits, Ignite UI for Angular offers easy integration, rapid development and design, and responsive, cross-browser compatibility. Installing and Creating a Project You can install Ignite UI for Angular with either the Angular CLI or with the Ignite UI CLI. To start quickly with the Angular CLI, run the following command: ng add igniteui-angular This is the preferred option when you need to add Ignite UI for Angular to an existing Angular application. If you’re creating a new application from scratch, we recommend the following approach: npm install –g igniteui-cli Once the igniteui cli is installed you can easily bootstrap an application by following cli’s guided experience using the Ignite UI CLI or Ignite UI for Angular Schematics, which builds a configured app that the end user can run with a single command: ig Use this rich set of cli commands to perform other functions, including generating an Ignite UI project and adding a new component to building and serving the entire application. Importing Dependencies When it comes to importing product dependencies, we strongly recommend using our Ignite UI CLI. By simply using ng add igniteui-angular you can install the Ignite UI for Angular package, along with all of its dependencies, font imports, styles preferences, and more to your project. To start using Ignite UI for Angular components without the Ignite UI CLI, make sure you have configured all necessary dependencies and have performed the proper setup of your project. You can learn how to do this manually in the Getting started topic. Adding Components to a Template Once you finish with the development environment setup, you can continue adding and configuring other Ignite UI components. Here’s how to use our schematics to add a grid with basic configuration and add templates to some of our columns. <igx-grid #grid1 [data]=\"localData\" height=\"600px\" (selected)=\"cellSelection($event)\"> <igx-column header=\"Rank\" headerClasses=\"myClass\" width=\"115px\" field=\"Id\" sortable=\"true\" [filterable]=\"false\"></igx-column> <igx-column field=\"Name\" header=\"Athlete\" width=\"280\"></igx-column> <igx-column field=\"Speed\" header=\"Speed\" [width]=\"'190px'\" [filterable]=\"false\"></igx-column> <igx-column field=\"TrackProgress\" sortable=\"true\" header=\"Track Progress\" [filterable]=\"false\"> <ng-template igxCell let-val> <div class=\"linear-bar-container\"> <igx-linear-bar [textVisibility]=\"false\" class=\"cell__inner_2\" [value]=\"val\"></igx-linear-bar> </div> </ng-template> </igx-column> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-grid> The grid itself consist of different components such as the IgxColumnComponent which is used to define the grid's columns collection and to enable features per column like sorting and paging. Each of the columns of the grid can be templated separately. The column expects ng-template tags decorated with one of the grid module directives. Configuring Your Components Now that you’ve defined columns to our Grid you can set different cell, header, and footer templates as follows: IgxHeader directive targets the column header providing the column object itself as a context. <igx-column field=\"Name\"> <ng-template igxHeader let-column> {{ column.field | uppercase }} </ng-template> </igx-column> igxCell applies the provided template to all cells in the column. The context object provided in the template consists of the cell value provided implicitly and the cell object itself. The column also accepts one last template that will be used when a cell is in edit mode. As with the other column templates, the provided context object is again the cell value and the cell object itself <igx-column field=\"Price\" [dataType]=\"'number'\" editable=\"true\"> <ng-template igxCellEditor let-cell=\"cell\"> <label for=\"price\"> Enter the new price tag </label> <input name=\"price\" type=\"number\" [(ngModel)]=\"cell.editValue\" /> </ng-template> </igx-column> Adding Data to Your Tables and Charts While some Angular apps will use static data, most app development today uses data stored in a database. Angular data-binding, which is the process of establishing a connection between the app UI and the data it displays, is easy to implement to allow for dynamic tables. You can set the grid to bind to a remote data service, which is the common scenario in large-scale applications. A good practice is to separate all data-fetching-related logic in a separate data service. Here is a way to create a service which will handle the fetching of data from the server: The service itself is pretty simple consisting of one method: fetchData that will return an Observable<NorthwindRecord[]>. @Injectable() export class NorthwindService { private url = 'http://services.odata.org/V4/Northwind/Northwind.svc/Alphabetical_list_of_products'; constructor(private http: HttpClient) {} public fetchData(): Observable<NorthwindRecord[]> { return this.http .get(this.url) .pipe( map(response => response['value']), catchError( this.errorHandler('Error loading northwind data', []) ) ); } private errorHandler<T>(message: string, result: T) { return (error: any): Observable<any> => { console.error(`${message}: ${error.message}`); return of(result as T); }; } } After implementing the service, you’ll want to inject it in our component's constructor and use it to retrieve the data. The ngOnInit lifecycle hook is a good place to dispatch the initial request @Component({ ... }) export class MyComponent implements OnInit { public records: NorthwindRecord[]; constructor(private northwindService: NorthwindService) {} ngOnInit() { this.records = []; this.northwindService.fetchData().subscribe((records) => this.records = records); } } <igx-grid [data]=\"records\"> <igx-column field=\"ProductId\"></igx-column> <!-- rest of the column definitions --> ... </igx-grid> Check out our Data-binding topic for more detailed information. The same data binding technique is applicable to the other Ignite UI components, such as the igxDataChart. <igx-data-chart [dataSource]=\"data\" width=\"700px\" height=\"500px\"> <igx-numeric-x-axis name=\"xAxis\" isLogarithmic=\"true\" ></igx-numeric-x-axis> <igx-numeric-y-axis name=\"yAxis\" isLogarithmic=\"true\" ></igx-numeric-y-axis> <igx-bubble-series name=\"series1\" [xAxis]=\"xAxis\" [yAxis]=\"yAxis\" xMemberPath=\"population\" yMemberPath=\"gdpTotal\" radiusMemberPath=\"gdpPerCapita\" [dataSource]=\"data\" ></igx-bubble-series> </igx-data-chart> Setting a data source on the chart component will apply to all series, but you can also set different data sources on each series added in the data chart. Sorting, Filtering and Pagination Angular data grids support easy sorting, filtering, and pagination. With rich APIs and an intuitive feature set-up, using Ignite UI for Angular components has never been easier. <igx-grid #grid1 (sortingDone)=\"removeSorting($event)\" [data]=\"data\" [allowFiltering]=\"true\"> <igx-column field=\"OrderID\" header=\"Order ID\"> </igx-column> <igx-column field=\"CategoryName\" header=\"Category Name\" [dataType]=\"'string'\" sortable=\"true\"> </igx-column> <igx-paginator [perPage]=\"10\"> </igx-paginator> The Grid provides three types of Filtering with custom filtering conditions: Filter row per column with default filtering strategy provided out of the box, as well as all the standard filtering conditions. Excel style filtering, with a configurable menu of features like sorting, moving, pinning, and hiding features. Advanced filtering that provides a dialog which allows the creation of groups with filtering conditions across all columns. Our Angular 9 release includes plenty of new key features – from data analysis to a rich visualization, grid state persistence, and theming widget. Styling Your Components Ignite UI has the most expressive styling capabilities of the major Angular frameworks. With just a few lines of code, you can easily change the theme of your components. Being developed in SASS, the API is easy and allows for theming granularity on different levels from a single component, multiple components, or the entire suite. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $primary-color: #2ab759; // Some green shade I like $secondary-color: #f96a88; // Watermelon pink $my-color-palette: palette( $primary: $primary-color, $secondary: $secondary-color ); // IMPORTANT: Make sure you always includecore first! @include core(); // Pass the color palette we generated to thetheme mixin @include theme($my-color-palette); Since Ignite UI for Angular bases its component designs on the Material Design Principles, we try to get as close as possible to colors, sizes, typography, and the overall look and feel of our components to those created by Google. Example: Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. We want to also to mention our samples browser Theming widget. Now, you can change themes at runtime in the Ignite UI sample browser with just one click. Theming widget allows you to change the styles, colors, roundness, and elevation. Customization of theming has never been easier. Once you are ready with your theme, just press \"DOWNLOAD SASS\" and you have your SCSS file at your disposal and you can use it in your app: Data Analysis with Ignite UI The Ignite Angular UI toolset also includes data analysis capabilities. We strive to give you all of the business capabilities you will need to deliver great experiences to your customers. So, we now provide directives that will give you a more Excel-like experience. For example, by selecting a portion of data you are now able to click a button and perform a quick data analysis on that subset of your data. Tools for Code Generation and Design Ignite UI for Angular is part of the Indigo.Design System which lets you generate native Angular code from designs created in Sketch with the Indigo.Design UI Kit. You can generate a mobile-friendly or data-dense grid supporting various editing and filtering modes, but you can also use many of the popular grid features such as sorting, paging, summaries, and group by. Moreover, on every column you can specify various operations like moving, resizing, hiding, and pinning to achieve the most sophisticated data manipulations scenarios at design time and have a pixel-perfect user interface running in minutes. Performance Benchmarks Grid components, in general, are intended to visualize large quantities of tabular data. When it comes to performance, our Grid excels at load-time, run-time, and soft performance. In order to satisfy the requirements of a web application for load time and run-time performance, it is important to virtualize the Document Object Model (DOM) elements that are rendered, and to either swap or reuse DOM elements when the user performs vertical and horizontal scrolling on the component’s container. The igxGrid has great tun-time scrolling performance without visual tears as well as soft performance (defined by the general usability of your software). Here’s an example of a Gif with scrolling performance: Check out our Grid and see how easy it is to find and navigate to the feature you want to use, or how appealing the look and feel of it would be in your application. Learn more about this in our Medium Software Performance (Web) article. View page on GitHub"
  },
  "components/general/cli/auth-template.html": {
    "href": "components/general/cli/auth-template.html",
    "title": "Authentication Project Template | Ignite UI for Angular | Infragistics",
    "keywords": "Authentication Project Template There are multiple versions of a project (called project templates) to choose from when using either the new command with Ignite UI CLI, with Ignite UI for Angular Schematics or the Step by step mode using Ignite UI CLI or Ignite UI for Angular Schematics. When creating Ignite UI for Angular project with Angular Schematics or Ignite UI CLI you can select a template with an basic implementation of a client-side authentication module that require as little additional setup as possible to jump-start apps with user management. Create Authentication Project You can select an authentication project either when going through the Step by step experience after selection 'Ignite UI for Angular' project type: Or through the new command: ig new \"Auth Project\" --framework=angular --type=igx-ts --template=side-nav-auth If you are using the Schematics collection run: ng new \"Auth Project\" --collection=\"@igniteui/angular-schematics\" --template=side-nav-auth Description This template builds upon the Side Navigation default and adds a profile page and a login section to the app's nav bar that will display a login button or an avatar of the logged in user: The login bar also integrates dialogs to sign in or up: The project also supports various external authentication providers. In code Everything related to user management is under the src/app/authentication folder. Notable exports include: AuthenticationModule in authentication.module.ts exports all components and services to the main app module. auth.guard.ts exports an AuthGuard you can apply to routes authentication-routing.module.ts sets up login-related routes UserService in services/user.service.ts keeps the current user state AuthenticationService in services/authentication.service.ts is used to communicate with the backend API ExternalAuthService in services/external-auth.service.ts handles providers for third-party logins Required configuration The project is setup for a single page app with REST API services, so the AuthenticationService is used to send requests to the following URLs: /login - login with username and password /register - register with user details /extlogin - passes along user info from external source All endpoints are expected to return an JSON Wen Token(JWT) or an error state with message. Note: For demonstration purposes the project has a services/fake-backend.service.ts that intercepts requests . The BackendProvider in authentication.module.ts should not be used in production. Both the provider and the file should be removed when development starts. As with any authentication model, using JWT-s requires security considerations. Particularly, the tokens received from the REST API are stored on the client. For seamless app reloads during development, the user data is stored in the browser local storage, which is potentially vulnerable to XSS attacks. Note: Disable the local storage before production. Consider keeping tokens in memory only if the app requirements allow or take alternative route to protect them. Using cookies (consider CSRF protection) is an alternative, also splitting the token signature or an additional 'fingerprint' in a hardened cookie. As usual, always evaluate security aspects and adjust accordingly, the project structure provided is merely a starting point. Add a third-party (social) provider Your project's main module src/app/app.module.ts should be generated with the external authentication service injected and commented out initialization similar to: // in app.module.ts export class AppModule { constructor(private externalAuthService: ExternalAuthService) { // this.externalAuthService.addGoogle('<CLIENT_ID>'); // this.externalAuthService.addMicrosoft('<CLIENT_ID>'); // this.externalAuthService.addFacebook('<CLIENT_ID>'); } } To enable user login with a specific third-party provider all that is required is to un-comment the specific line and replace the `` with your app's client ID. If you need to obtain one, for example for Google Account sign in, follow the provider-specific guide at: Obtain credentials More detailed version Keep in mind, redirect URLs and allowed domain origins should be configured per provider to match the project. When creating the Google OAuth 2.0 client ID for development you can provide http://localhost:4200/redirect-google as the redirect URI. See redirect URLs for details. Once you have your ID (for example 123456789.apps.googleusercontent.com) you can enable the Google provider for the project like so: // in app.module.ts export class AppModule { constructor(private externalAuthService: ExternalAuthService) { this.externalAuthService.addGoogle('123456789.apps.googleusercontent.com'); // this.externalAuthService.addMicrosoft('<CLIENT_ID>'); // this.externalAuthService.addFacebook('<CLIENT_ID>'); } } This will automatically enable the respective button in the login dialog: You can do the same with Microsoft following this guide: https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-v2-register-an-app And for Facebook: https://developers.facebook.com/docs/apps/#register As you enable providers, all buttons will become active: Provider details Here are the default providers the project template comes with: Provider Uses Redirect URL Google OpenID Connect* <app root>/redirect-google Microsoft OpenID Connect* <app root>/redirect-microsoft Facebook Facebook Connect** <app root>/redirect-facebook Where the app is hosted will determine the root URL, for example by default on the first app run that will be http://localhost:4200. * OpenID Connect functionality implemented using https://github.com/damienbod/angular-auth-oidc-client ** Facebook Connect functionality implemented using Facebook JS SDK View page on GitHub"
  },
  "components/general/cli/component-templates.html": {
    "href": "components/general/cli/component-templates.html",
    "title": "Component and Scenario CLI Templates | Ignite UI for Angular | Infragistics",
    "keywords": "Component Templates The following table provides a list of the Ignite UI Angular components that can be generated using the Ignite UI Angular Schematics or Ignite UI CLI commands. In addition you can find links to the available demos in our documentation, but note that those are not exactly identical to the ones generated by the CLI. Template Code and description Demo Grids & Lists grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c grid newGrid Ignite UI CLI: ig add grid newGrid Basic template for IgxGrid. IgxGrid component with auto generated columns grid-batch-editing Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c grid-batch-editing newGridBatchEditing Ignite UI CLI: ig add grid-batch-editing newGridBatchEditing Sample IgxGrid with batch editing. IgxGrid that uses Transaction service for batch editing custom-grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c custom-grid newCustomGrid Ignite UI CLI: ig add custom-grid newCustomGrid IgxGrid with optional features like sorting, filtering, editing, etc. IgxGrid with optional features like Sorting, Filtering, Cell Editing, Row Editing, Group By, Resizing, Selection, Paging, Column Pinning, Column Moving, Column Hiding grid-summaries Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c grid-summaries newGridSummaries Ignite UI CLI: ig add grid-summaries newGridSummaries IgxGrid with summaries feature. IgxGrid with summaries feature. grid-multi-column-headers Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c grid-multi-column-headers newGridMultiColumnHeaders Ignite UI CLI: ig add grid-multi-column-headers newGridMultiColumnHeaders IgxGrid with multiple header columns. IgxGrid with multi-column headers tree grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c custom-tree-grid newCustomTreeGrid Ignite UI CLI: ig add custom-tree-grid newCustomTreeGrid IgxTreeGrid with optional features like sorting, filtering, row editing, etc. IgxTreeGrid with optional features like Sorting, Filtering, Cell Editing, Row Editing, Resizing, Row Selection, Paging, Column Pinning, Column Moving, Column Hiding list Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c list newList Ignite UI CLI: ig add list newList Basic IgxList. IgxList with search and filtering logic. combo Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c combo newCombo Ignite UI CLI: ig add combo newCombo Basic IgxCombo with templating. IgxCombo with custom templating. Charts category chart Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c category-chart newCategoryChart Ignite UI CLI: ig add category-chart newCategoryChart Basic category chart with chart type selector. Basic category chart with chart type selector. financial chart Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c financial-chart newFinancialChart Ignite UI CLI: ig add financial-chart newFinancialChart Basic financial chart with automatic toolbar and type selection. Basic financial chart with automatic toolbar and type selection. Gauges bullet graph Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c bullet-graph newBulletGraph Ignite UI CLI: ig add bullet-graph newBulletGraph IgxBulletGraph with different animations. IgxBulletGraph with different animations. linear gauge Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c linear-gauge newLinearGauge Ignite UI CLI: ig add linear-gauge newLinearGauge IgxLinearGauge with different animations. IgxLinearGauge with different animations. radial gauge Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c radial-gauge newRadialGauge Ignite UI CLI: ig add radial-gauge newRadialGauge IgxRadialGauge with different animations. IgxRadialGauge with different animations. Layouts dock-manager Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c dock-manager newDockManager Ignite UI CLI: ig add dock-manager newDockManager Basic IgcDockManager. IgcDockManager with nine content slots. carousel Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c carousel newCarousel Ignite UI CLI: ig add carousel newCarousel Basic IgxCarousel. IgxCarousel cycling through a series of images. tabs Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c tabs newTabs Ignite UI CLI: ig add tabs newTabs Basic IgxTabs. IgxTabs component that includes three customized tab-groups. bottom-nav Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c bottom-nav newBottomNav Ignite UI CLI: ig add bottom-nav newBottomNav Three item bottom-nav template. Three item bottom navbar template. Data Entry & Display chip Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c chip newChip Ignite UI CLI: ig add chip newChip Basic IgxChip. IgxChip components inside igx-chips-area. dropdown Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c dropdown newDropDown Ignite UI CLI: ig add dropdown newDropDown Basic IgxDropDown. Basic IgxDropDown that displays a list of items. select (v4.1.0) Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c select newSelect Ignite UI CLI: ig add select newSelect Basic IgxSelect. Simple IgxSelect that displays a list of items.. select (v4.1.0) Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c select-groups newGroupsSelect Ignite UI CLI: ig add select-groups newGroupsSelect Select With Groups. IgxSelect displaying grouped items. select (v4.1.0) Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c select-in-form newFormSelect Ignite UI CLI: ig add select-in-form newFormSelect IgxSelect in a form. IgxSelect component usage in a form. input group Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c input-group newInputGroup Ignite UI CLI: ig add input-group newInputGroup Basic IgxInputGroup form view. Form view created with IgxInputGroup. Interactions dialog Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c dialog newDialog Ignite UI CLI: ig add dialog newDialog Basic IgxDialog. Sample of the IgxDialog used as a standard confirmation dialog. tooltip Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c tooltip newTooltip Ignite UI CLI: ig add tooltip newTooltip A fully customizable tooltip. Basic tooltip created with the IgxTooltip. Scheduling date-picker Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c date-picker newDatePicker Ignite UI CLI: ig add date-picker newDatePicker Basic IgxDatePicker. Basic IgxDatePicker with one-way data binding. time-picker Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c time-picker newTimePicker Ignite UI CLI: ig add time-picker newTimePicker Basic IgxTimePicker. Basic IgxTimePicker with initial value set and one-way data binding. calendar Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c calendar newCalendar Ignite UI CLI: ig add calendar newCalendar IgxCalendar with single selection. Basic IgxDatePicker with one-way data binding. Scenario templates Template Code and description Demo awesome-grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c awesome-grid newAwesomeGrid Ignite UI CLI: ig add awesome-grid newAwesomeGrid IgxGrid with custom cell templating. IgxGrid with cell templating and controls embedded into the cells. crm-grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c crm-grid newCrmGrid Ignite UI CLI: ig add crm-grid newCrmGrid IgxGrid with custom search implementation. IgxGrid with custom search implementation. fintech-grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c fintech-grid newFinTechGrid Ignite UI CLI: ig add fintech-grid newFinTechGrid IgxGrid handling thousands of live updates per second. IgxGrid Live Updating demo handling thousands of updates per second. fintech-tree-grid Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c fintech-tree-grid newFinTechTreeGrid Ignite UI CLI: ig add fintech-tree-grid newFinTechTreeGrid IgxGrid handling thousands of live updates per second. IgxTreeGrid Live Updating demo handling thousands of updates per second. login Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c login newLogin Ignite UI CLI: ig add login newLogin Registration and login forms created with IgxInputGroup. Registration and login forms created with IgxInputGroup.. weather-forecast Ignite UI Schematics collection: ng g @igniteui/angular-schematics:c weather-forecast newWeatherForecast Ignite UI CLI: ig add weather-forecast newWeatherForecast Template with igxExpansionPanel. The template uses the IgxExpansionPanel to display daily weather forecast details. View page on GitHub"
  },
  "components/general/cli/getting-started-with-angular-schematics.html": {
    "href": "components/general/cli/getting-started-with-angular-schematics.html",
    "title": "Getting Started with Ignite UI for Angular Schematics | Ignite UI for Angular | Infragistics",
    "keywords": "Getting Started with Ignite UI for Angular Schematics To get started install Ignite UI for Angular Schematics globally: npm i -g @igniteui/angular-schematics The above install will make the schematics available to use a collection parameter for the ng new command. If you are using yarn package manager: yarn global add @igniteui/angular-schematics Using guided experience The shortest and easiest way to bootstrap an application is to use the step by step guide using Ignite UI for Angular Schematics. To activate the guide using the Ignite UI for Angular Schematics run: ng new --collection=\"@igniteui/angular-schematics\" Create a new project To create an application that is configured to use the Ignite UI for Angular controls, run the ng new command providing @igniteui/angular-schematics to the collection option. ng new newAngularProject --collection=\"@igniteui/angular-schematics\" --template=side-nav Additionally, by setting the type of the project, like so --type=igx-ts-legacy, you can specify that you prefer your project to be generated using module based bootstrapping. Not specifying it will default to a project that uses standalone components. If you already have an Angular project, created without providing the @igniteui/angular-schematics collection as described above, you can add the Ignite UI for Angular product, using the following command: ng add igniteui-angular The new application is created in a directory with the same name (newAngularProject). There are several project templates from which you can choose when creating an Ignite UI for Angular application: template id template description empty Project structure with routing and a home page side-nav Project structure with side navigation drawer side-nav-auth Side navigation project extended with user authentication module. Angular Authentication Project Template topic covers the project template in detail. Additionally, you can specify arguments to control the theme or skip packages install: name name (alias: -n) The name of the application. The application is created inside a directory with the same name. framework (Ignite UI CLI only) --framework (alias: -f) default value: \"jquery\" Framework to setup project for. The supported frameworks are jQuery, Angular and React. type (Ignite UI CLI only) --type (alias: -t) The available project types depend on the selected framework. theme --theme (alias: -th) Project theme (depends on project type). skip-git --skip-git (alias: --sg) When this option is used, the automatic repository initialization with Git will be skipped. If the option is omitted, then the global skip-git configuration property is used. skip-install --skip-install (alias: --si) The new command will install package dependencies on project creation. Passing this flag will skip the initial installation. template --template Use this option if there are different project templates for a specific framework type. Currently this option is available only for Ignite UI for Angular igx-ts project types. Add template To add one of the available Ignite UI Angular templates you need to provide template ID and a name for the new component or use the Step-by-Step Guide. Their usage is supported only inside existing projects created with the Angular Schematics, Ignite UI CLI or where Ignite UI for Angular has been installed using ng add. With Schematics, use ng generate with the Ignite UI for Angular collection and component [template] [name]: ng g @igniteui/angular-schematics:component grid newGrid List of all the available templates. Additionally, you can specify the module in which the component will be registered or skip the auto-generation of app navigation route: module --module (alias: -m) note: module argument is applicable only in Angular projects. Path to the module.ts file, relative to the /src/app/ folder, for the module where the new component should be registered: ng g @igniteui/angular-schematics:component combo newCombo --module=myModule/myModule.module.ts skip-route --skip-route (alias: -srk) Don't auto-generate an app navigation route for the new component Run the application The start schematic will build the application, start a web server and open it in your default browser. ng g @igniteui/angular-schematics:start View page on GitHub"
  },
  "components/general/cli/getting-started-with-cli.html": {
    "href": "components/general/cli/getting-started-with-cli.html",
    "title": "Getting Started with Ignite UI CLI | Ignite UI for Angular | Infragistics",
    "keywords": "Getting Started with Ignite UI CLI If you are creating a new Angular application from scratch, we recommend using the approach described bellow as it will provide you with an user-friendly guided experience. The guide will lead you through all the setup options and your project will be scaffolded in a blink of an eye. To get started install Ignite UI CLI globally: npm install -g igniteui-cli If you are using yarn package manager: yarn global add igniteui-cli Using guided experience The shortest and easiest way to bootstrap an application is to use the step by step guide using Ignite UI CLI. To activate the guide using the Ignite UI CLI run: ig or ig new Building Your First Ignite UI CLI App Create a new project When using Ignite UI CLI you need to provide angular as framework and igx-ts as your project type argument to the new command: ig new newAngularProject --framework=angular --type=igx-ts --template=side-nav Note As of v13.1.0, the igx-ts project type will generate a project that uses standalone components by default. If you prefer to use the module-based bootstrapping instead you can set the type to be igx-ts-legacy. The new application is created in a directory with the same name (newAngularProject). There are several project templates from which you can choose when creating an Ignite UI for Angular application: template id template description empty Project structure with routing and a home page side-nav Project structure with side navigation drawer side-nav-auth Side navigation project extended with user authentication module. Angular Authentication Project Template topic covers the project template in detail. Additionally, you can specify arguments to control the theme or skip packages install: name name (alias: -n) The name of the application. The application is created inside a directory with the same name. framework (Ignite UI CLI only) --framework (alias: -f) default value: \"jquery\" Framework to setup project for. The supported frameworks are jQuery, Angular and React. type (Ignite UI CLI only) --type (alias: -t) The available project types depend on the selected framework. theme --theme (alias: -th) Project theme (depends on project type). skip-git --skip-git (alias: --sg) When this option is used, the automatic repository initialization with Git will be skipped. If the option is omitted, then the global skip-git configuration property is used. skip-install --skip-install (alias: --si) The new command will install package dependencies on project creation. Passing this flag will skip the initial installation. template --template Use this option if there are different project templates for a specific framework type. Currently this option is available only for Ignite UI for Angular igx-ts project types. Add template To add one of the available Ignite UI Angular templates you need to provide template ID and a name for the new component or use the Step-by-Step Guide. Their usage is supported only inside existing projects created with the Ignite UI CLI, Angular Schematics or where Ignite UI for Angular has been installed using ng add. We use the ig add [template] [name] command: ig add grid newGrid To get a list of all the available templates you can also execute the ig list command in your project directory. Additionally, you can specify the module in which the component will be registered or skip the auto-generation of app navigation route: module --module (alias: -m) note: module argument is applicable only in Angular projects. Path to the module.ts file, relative to the /src/app/ folder, for the module where the new component should be registered: ig add combo newCombo --module=myModule/myModule.module.ts skip-route --skip-route (alias: -srk) Don't auto-generate an app navigation route for the new component Run the application The start command will build the application, start a web server and open it in your default browser: ig start Ignite UI CLI Commands A full list of the available Ignite UI CLI commands and their usage (like passing flags, etc.), can be found at the Ignite UI CLI wiki pages: Command Alias Description ig start Builds the application, starts a web server and opens the application in the default browser. ig build Builds the application into an output directory ig generate g Generates a new custom template for supported frameworks and project types ig help -h Lists the available commands and provides a brief description of what they do. ig config Performs read and write operation on the Ignite UI CLI configuration settings. ig doc Searches the Infragistics knowledge base for information about a given search term ig list l Lists all templates for the specified framework and type. When you run the command within a project folder it will list all templates for the project's framework and type, even if you provide different ones. ig test Executes the tests for the current project. ig version -v Shows Ignite UI CLI version installed locally, or globally if local is missing View page on GitHub"
  },
  "components/general/cli/step-by-step-guide-using-angular-schematics.html": {
    "href": "components/general/cli/step-by-step-guide-using-angular-schematics.html",
    "title": "Step-by-Step Guide Using Ignite UI for Angular Schematics | Ignite UI for Angular | Infragistics",
    "keywords": "Step-by-Step Guide Using Ignite UI for Angular Schematics If you want to get a guided experience through the available options, you can initialize the step by step mode that will help you create and setup your new application, as well as update project previously created with the Ignite UI Angular Schematics. To activate the guide using the Schematics collection run: ng new --collection=\"@igniteui/angular-schematics\" This will activate the step by step mode and you will be asked a series of questions to help you create your new project. Note Step by step mode relies on Inquirer.js, see supported terminals Create new project First you will be prompted to choose the way your application will be bootstrapped, using modules or standalone components: Then you can enter a name for your application: Then you will be guided to choose one of the available project templates. You can create an empty project, project with side navigation or authentication project with basic authentication module. Navigate through the available options using the arrow keys and press ENTER to confirm the selection: The next step is to choose a theme for your application. If you select the default option a pre-compiled CSS file (igniteui-angular.css) with the default Ignite UI for Angular theme is included in your project's angular.json. The custom option generates code for a color palette and theme with our Theming API in the app/styles.scss. After completing the above steps the application structure will be generated, git repository will be initialized and the project will be committed. Then you will be asked if you want to complete the process or to add a new view to your application: Add view Ignite UI CLI supports multiple component templates, as well as some more elaborated scenario templates, that can be added to a project. This mode can be activated either after completing project creation or inside an existing project using the commands below. To activate the the step by step mode using the Schematics collection run the component(alias:c) schematic: ng g @igniteui/angular-schematics:component In case you choose to add a new control, you will be provided with a list of the available templates, grouped in categories. Use the arrow keys to navigate through the options and ENTER to choose the selected one. For some templates, like Custom Grid, for example you will be provided with a list of options that you might enable. Options can be toggled with the SPACE key: If you choose to add a scenario to your application you will also get a list of the available scenario templates: After adding a template to your application, you will be asked weather you want to complete the process or to proceed with adding more controls. When you choose to complete the process, the required packages will be installed (on project creation) and the application will be served and opened in your default browser. You can always add more Ignite UI for Angular views to your application at latter moment using the ng g @igniteui/angular-schematics:c [template] [name] command. View page on GitHub"
  },
  "components/general/cli/step-by-step-guide-using-cli.html": {
    "href": "components/general/cli/step-by-step-guide-using-cli.html",
    "title": "Step-by-Step Guide Using Ignite UI CLI| Ignite UI for Angular | Infragistics",
    "keywords": "Step-by-Step Guide using Ignite UI CLI If you want to get a guided experience through the available options, you can initialize the step by step mode that will help you create and setup your new application, as well as update project previously created with the Ignite UI CLI. To start the guide using the Ignite UI CLI, simply run the ig command: ig or ig new This will activate the step by step mode and you will be asked a series of questions to help you create your new project. Note Step by step mode relies on Inquirer.js, see supported terminals Create new project First you will be prompted to enter a name for your application: After selecting Angular as a freamework, you will be prompted to choose the type of the project that is to be generated: Then you will be guided to choose one of the available project templates. You can create an empty project, project with side navigation or authentication project with basic authentication module. Navigate through the available options using the arrow keys and press ENTER to confirm the selection: The next step is to choose a theme for your application. If you select the default option a pre-compiled CSS file (igniteui-angular.css) with the default Ignite UI for Angular theme is included in your project's angular.json. The custom option generates code for a color palette and theme with our Theming API in the app/styles.scss. After completing the above steps the application structure will be generated, git repository will be initialized and the project will be committed. Then you will be asked if you want to complete the process or to add a new view to your application: Add view Ignite UI CLI supports multiple component templates, as well as some more elaborated scenario templates, that can be added to a project. This mode can be activated either after completing project creation or inside an existing project using the commands below. When using Ignite UI CLI, run the add command: ig add In case you choose to add a new control, you will be provided with a list of the available templates, grouped in categories. Use the arrow keys to navigate through the options and ENTER to choose the selected one. For some templates, like Custom Grid, for example you will be provided with a list of options that you might enable. Options can be toggled with the SPACE key: If you choose to add a scenario to your application you will also get a list of the available scenario templates: After adding a template to your application, you will be asked weather you want to complete the process or to proceed with adding more controls. When you choose to complete the process, the required packages will be installed (on project creation) and the application will be served and opened in your default browser. You can always add more Ignite UI for Angular views to your application at latter moment using the add command using the following syntax: ig add [template] [name]. View page on GitHub"
  },
  "components/general/cli-overview.html": {
    "href": "components/general/cli-overview.html",
    "title": "Angular Schematics | Angular CLI | Ignite UI for Angular | Infragistics",
    "keywords": "Angular Schematics & Ignite UI CLI Our CLI tools provide project templates pre-configured for Ignite UI for Angular that help you get your next app off the ground in record time. A selection of views with Ignite UI for Angular components that can be further added to projects provide a substantial productivity boost for developers. Ignite UI CLI is a stand-alone command-line tool for creating and scaffolding applications for a variety of frameworks. You can find more information and examples about its usage in the Getting Started with Ignite UI CLI topic. Ignite UI for Angular Schematics are available as a collection that can be used with the Angular CLI. They offer similar core Ignite UI CLI functionality, but one that's integrated with the Schematics workflow and focused specifically on this product. The schematics collection is added to your project when you install Ignite UI for Angular. You can find more information and examples about its usage in the Getting Started with Ignite UI for Angular Schematics topic. Both versions of the tooling allow for various projects, component and scenario views (templates) and offer guided step-by-step mode using Ignite UI CLI and Ignite UI for Angular Schematics. View page on GitHub"
  },
  "components/general/data-analysis.html": {
    "href": "components/general/data-analysis.html",
    "title": "Data analysis capabilities | Angular Universal | Ignite UI for Angular | Infragistics",
    "keywords": ".full-screen-btn { display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; -webkit-box-align: center; -ms-flex-align: center; align-items: center; font-size: 13px; font-weight: 400; color: #fff; border: 0; text-transform: uppercase; padding: 8px 16px; margin: 24px 0; outline-style: none; -webkit-transition: all 0.25s ease-out; transition: all 0.25s ease-out; background: #0099ff; } .full-screen-btn:hover, .full-screen-btn:focus { color: white; -webkit-box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.26), 0 8px 10px 1px rgba(0, 0, 0, 0.12), 0 3px 14px 2px rgba(0, 0, 0, 0.08); box-shadow: 0 5px 5px -3px rgba(0, 0, 0, 0.26), 0 8px 10px 1px rgba(0, 0, 0, 0.12), 0 3px 14px 2px rgba(0, 0, 0, 0.08); } .full-screen-btn::before { content: \"\"; display: inline-block; width: 28px; height: 28px; margin-right: 8px; background-image: url(\"../../images/general/fullscreen-white-18dp.svg\"); background-size: 100%; background-repeat: no-repeat; } .full-screen-btn[disabled] { color: rgba(0, 0, 0, 0.28); background: #eee; -webkit-box-shadow: none; box-shadow: none; } .full-screen-btn[disabled]::before { background-image: url(\"../../images/general/fullscreen-white-18dp.svg\"); } Data Analysis Data analysis is the process of examining, transforming, and arranging data in a specific way to generate useful information based on it. It also allows for reaching certain outcomes and conclusions through analytical and logical reasoning. Note This functionality will be introduced in Ignite UI for Angular as external package in order to ease the configuration and limit the required code at minimum Data Analysis with DockManager Go ahead and perform a cell range selection or column selection in order to enable the Chart types view based on the selected data. This view is part of Dock Manager's right pane. From there you can: Choose specific chart type and visualize it in separate pane. Or use the Data Analysis context button to show different text formatting options. View in full screen Note The Dock Manager Web component provides means to manage the layout of the application through panes, and allowing the end-users to customize it further by pinning, resizing, moving and hiding panes. After selecting data, go ahead and create a couple of charts and pin them (by dragging) to the available areas Keep in mind (sample related): On new data selection chart data will be updated. If multi-cell range selection is applied, only the Text formatting functionality will be available. If selected data is not compatible for any of the charts - an \"Incompatible data\" warning message will be shown. Data Analysis Package You can start using this functionality by following the steps below. Keep in mind that igniteui-angular-extras package is only available through our private npm feed. If you have a valid commercial license, you will have access to the private feed. Lets start with: Installing the package in your application npm install @infragistics/igniteui-angular-extras Installing the package peer dependencies npm install @infragistics/igniteui-angular igniteui-angular-core igniteui-angular-charts After the installation of the packages go ahead and: Add the IgxExtrasModule to your app.module.ts Apply igxChartIntegration, igxConditionalFormatting, igxContextMenu directives to your grid <igx-grid #grid1 igxChartIntegration igxConditionalFormatting igxContextMenu [data]=\"localData\" [autoGenerate]=\"true\"> <igx-paginator> </igx-paginator> </igx-grid> And that's it! You can now perform cell range selection and follow the data analysis flow. Data Analysis Button The data analysis button is the outlet to visualize your selected data in various ways: This way every range selection performed in the grid can be easily analyzed in a single click. The button is rendered on every range selection at the bottom-right of the selection and hides when the selection is inactive. Horizontal and vertical scrolling reposition the button so that it is always rendered at its designated position. Chart Integration This section introduces Grid's integration with charting functionality, which allows the end user to visualize a chart based on Grid's selected data and choose different chart types if needed. The chart will be shown by selecting a range of cells and by clicking on the show analysis button. Note The chart creation option is only available when there are numeric values in the selected data. View in full screen We currently support the following Chart types: Column Chart, Area Chart, Line Chart, Bar Chart, Stacked Chart, Stacked 100% Chart, Pie Chart, Scatter Chart, Bubble Chart In order to show meaningful Bubble Chart we disable the preview when the data is not in valid format. Conditional Cell Formatting If you have a Grid with thousands of rows of data it would be very difficult to see patterns and trends just from examining the raw information. Similar to charts and sparklines, Conditional formatting provides another way to visualize data and make it easier to understand. Understanding conditional formatting - it allows for applying formatting such as colors and data bars to cells based on their value in the range selection. The sample below demonstrates how you can configure the Grid to apply Conditional Formatting. It depends on the Conditional formatting selection type what condition rules will be shown. Below you will find the predefined styles (presets) that you can use in order to quickly apply conditional formatting to your data. The formatting of a range gets cleared when performing formatting on different range or through the clear button. The clear button is only active when there is an applied formatting. Number range selection Data Bars - Data bars can help you spot larger and smaller numbers, such as top-selling and bottom-selling products. This preset makes it very easy to visualize values in a range of selected cells. A longer bar represents a higher value. A cell that holds value of 0 has no data bar all other cells are filled proportionally. Positive values are with green color and negative values will be red Color Scale - The shade of the color represents the value in the cell. The cells that hold values below the *Lowest threshold will be colored in red. The cells that are above the *Highest threshold will be colored in green. And all the cells that are between the Lowest and Highest threshold will be colored in yellow. Lowest threshold - Below 33% of the maximum cell value in range selection. Highest threshold - Above 66% of the maximum cell value in range selection. Top 10% - Use this preset to highlight the values which are equivalent to top 10% of the selected data. Greater than - This preset marks all values Greater than the avarege Duplicate values - Marks all duplicate values. Unique values - All cell values that are unique will be marked (blue background color). Empty- Marks all cells with undefined values Text range selection Text contains - Marks all cells that contain the cell value from the top-left most selected cell. Example: Duplicate values - Marks all duplicate values. Unique values - All cell values that are unique will be marked (blue background color). Empty- Marks all cells with undefined values Demo View in full screen Data Analysis Package API IgxConditionalFormattingDirective API Description Arguments ConditionalFormattingType An enum, which represents the conditional formatting types IFormatColors An interface, which represents the formatting colors formatter: string An input property, which sets/gets the current formatting type formatColors An input property, which sets/gets the current formatting colors val: IFormatColors onFormattersReady An event, which emits the applicable formatting types for the selected data, when they are determined. formatCells Applies conditional formatting for the selected cells. Usage: this.conditonalFormatting.formatCells(ConditionalFormattingType.dataBars) formatterName: string, formatRange?: GridSelectionRange [ ], reset: boolean (true by default) clearFormatting Removes the conditional formatting from the selected cells. Usage: this.conditonalFormatting.clearFormatting() IgxChartIntegrationDirective API Description Arguments CHART_TYPE An enum, representing the supported chart types OPTIONS_TYPE An enum, representing the supported options type, which can be applied to a chart component IOptions An interface for chart property options chartFactory Creates a chart component, based on the provided chart type. Usage: this.chartIntegration.chartFactory(CHART_TYPE.COLUMN_GROUPED, this.viewContainerRef) type: any[ ], viewContainerRef: ViewContainerRef setChartComponentOptions Sets property options to a chart component. Usage: this.chartIntegration.setChartComponentOptions(CHART_TYPE.PIE, OPTIONS_TYPE.CHART, {allowSliceExplosion: true, sliceClick: (evt) => { evt.args.isExploded = !evt.args.isExploded; } }) chart: CHART_TYPE, optionsType: OPTIONS_TYPE, options: IOptions getAvailableCharts Returns the enabled chart types enableCharts Enables the provided chart types. By default all chart types are enabled types: CHART_TYPE [ ] disableCharts Disables the provided chart types types: CHART_TYPE [ ] onChartTypesDetermined An event, emitted when the chart types, applicable for the chartData, are determined. This event emits an object of type IDeterminedChartTypesArgs, which has 2 properties: chartsAvailabilty: Map<CHART_TYPE, boolean> - the enabled/disabled chart types, chartsForCreation: CHART_TYPE[] - the applicable chart types for the chartData onChartCreationDone An event, emitted when a chart is created. This event emits the chart component, which is created chartData: any[ ] An input property, which sets/gets the data for the charts selectedData: any[ ] useLegend: boolean An input, which enables/disables the legend usage for all chart types. By default it is set to true defaultLabelMemberPath: string An input property, which sets/gets the default label member path for the charts. By default the label member path will be determined, based on the provided data. ( if the provided data records have properties with string values, the first string property name of the first data record in the chartData will be selected as a label member path for the charts, if not, the label member path will have value 'Index'. ) scatterChartYAxisValueMemberPath: string An input property, which sets/gets the default radius member path for the scatter bubble chart. If not set, the default Y axis value member path will be the first numeric property name of the first data record in the chartData path: string bubbleChartRadiusMemberPath: string An input property, which sets/gets the default radius member path for the scatter bubble chart. If not set, the default radius member path will be the second numeric property name of the first data record in the chartData path: string Useful resources Angular Universal guide Ignite UI Starter Kit Server-side rendering terminology Getting started with Ignite UI for Angular Ignite UI CLI Guide Ignite UI for Angular Schematics Guide View page on GitHub"
  },
  "components/general/getting-started.html": {
    "href": "components/general/getting-started.html",
    "title": "Getting Started | Ignite UI for Angular | Infragistics",
    "keywords": "Getting started with Ignite UI for Angular Ignite UI for Angular is a complete set of Material-based UI Widgets, Components & Sketch UI kits and supporting directives for Angular by Infragistics. It enables developers to build modern high-performance HTML5 & JavaScript apps for desktop browsers, mobile experiences and progressive web apps (PWA’s) targeting Google's Angular framework. Prerequisites Install NodeJS. Install Visual Studio Code. DOWNLOAD NODE DOWNLOAD VS CODE Installing Ignite UI for Angular The Ignite UI for Angular can be installed either wth the Angular CLI or with the Ignite UI CLI. Quick Start with the Angular CLI The Angular CLI provides support for external libraries to your project through the ng add command, which installs a library's npm packages to your workspace and configures the project in the current working directory to use that library. To create an Angular application with the Angular CLI, open your preferred terminal and type in the following command: ng new <project name> --style=scss You can specify the file extension or preprocessor to use for your application's style files with the --style option. We recommend using SCSS since our components' styles are based on the Ignite UI for Angular theming library. Later on, when you install the Ignite UI for Angular package, your application will be configured to use the default styling theme which can be then easily customized either for all or for specific component instances. Thereafter you can install the Ignite UI for Angular package, along with all of its dependencies, font imports and styles references to your project, by running the following command: ng add igniteui-angular Note You don't need to install the igniteui-theming package explicity, it comes with Ignite UI for Angular. Keep in mind that with the command above you will install the Trial version of Ignite UI for Angular. During the installation process you will be asked if you would like to enable polyfills for IE, Edge and Safari. This will install the web-animations-js package in your project, which is required if you use AnimationBuilder in your application and one of these browsers. You can also choose to add CSS library to reset HTML element styles across browsers and the minireset.css will be installed in your application. If you want to start using the Licensed Ignite UI for Angular package it is strongly recommended to follow the Upgrading packages guide with Schematics and Ignite UI CLI. Following is a quick overview of the steps that you need to perform in order to start using the Licensed version of Ignite UI for Angular. Depending on your project setup, either run the following schematic in your project: ng g @igniteui/angular-schematics:upgrade-packages or if using igniteui-cli: ig upgrade-packages The schematic will take care of switching the package dependencies of the project and update source references. You'll be asked to login to our npm registry if not already setup. Login to our npm registry with a new setup The approach described above covers only the scenarios where Ignite UI for Angular Trial package is already installed. If you are performing a new setup of a project or just starting with using Ignite UI for Angular, follow the guidance below. It's very important to perform a correct setup of the private npm feed environment, by: Ensuring a valid setup of the private registry. Log in to our private feed using npm by specifying a non-trial user account and password. Details on the entire process could be found here. Quick Start with Angular Schematics & Ignite UI CLI To create an application from scratch and configure it to use the Ignite UI for Angular components you can use either the Ignite UI for Angular Schematics or the Ignite UI CLI. The first step is to install the respective package globally as follows: npm i -g @igniteui/angular-schematics or: npm install -g igniteui-cli Our guided experience using the Ignite UI CLI or Ignite UI for Angular Schematics is the easiest way to bootstrap a configured application. To activate the guide using the Ignite UI for Angular Schematics run: ng new --collection=\"@igniteui/angular-schematics\" or run the following command in case you are using the CLI tool: ig Note At some point during the steps execution you'll be asked to login to our npm registry if not already setup. This is part of the Trial to License account setup. Building Your First Ignite UI CLI App Learn more about our Angular Schematics & Ignite UI CLI. Using Ignite UI for Angular We are now ready to start using Ignite UI for Angular components! Add components automatically Import modules and use components Now we can add new components to our application using either the component schematic or the add command: ng g @igniteui/angular-schematics:component ig add Note Please note that the ig add command can be used if the application was created by using the Ignite UI CLI or if it was created by using the Angular CLI with Ignite UI for Angular added to it by using the ng add igniteui-angular command. After going through the options of the menu and choosing which component we want to add to our application, we will notice that we have a brand new component in our project, which we can use anywhere on our page! Run application Now let’s run our application to see our awesome page! npm start Add components manually Import modules First we have to import the respective modules of the components we want to use in the app.module.ts file. We will go ahead and do this for the igxGrid! Please note that some components have animations depending on BrowserAnimationsModule, so let’s import that one as well: // app.module.ts import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; // Here we import the IgxGridModule, so we can use the igxGrid! import { IgxGridModule } from 'igniteui-angular'; // import { IgxGridModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, BrowserAnimationsModule, IgxGridModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Use components We are now ready to use the igxGrid in our markup! Let's go ahead and define it in our app.component.html file: <!-- app.component.html --> <div style=\"text-align:center; margin-bottom: 20px;\"> <h1> Welcome to {{title}}! </h1> </div> <div style=\"text-align: center;\"> <igx-grid [data]=\"localData\" width=\"600px\" height=\"400px\" style=\"margin: auto\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" dataType=\"string\"></igx-column> <igx-column field=\"Age\" dataType=\"number\"></igx-column> </igx-grid> </div> We will also define the data of the grid and the title of our application that are referenced from the app.component.ts: // app.component.ts import { Component } from '@angular/core'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { localData = [ { Name:'John', Age: 29 }, { Name:'Alice', Age: 27 }, { Name:'Jessica', Age: 31 }, ]; title = 'My Ignite UI project'; } Run application Finally, we can run our new application by using one of the following commands: If the application was created by using the Ignite UI CLI: ig start If the application was created by using the Angular CLI: ng serve The final result should look something like this: API References In this article we learned how to create our own Ignite UI for Angular application from scratch by taking advantage of the fully-automated process of Ignite UI for Angular projects creation in the Ignite UI CLI. We also learned and how to add Ignite UI for Angular to an existing application by using the Angular CLI. We designed our own page by including the IgxGridComponent to it, which itself offers some awesome features, which you can take a look at by referring to the navigation menu. IgxGridComponent IgxGridComponent Styles Additional Resources Ignite UI CLI Ignite UI CLI Commands Grid overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/how-to/how-to-customize-theme.html": {
    "href": "components/general/how-to/how-to-customize-theme.html",
    "title": "Customizing Ignite UI Theming - Angular | Ignite UI for Angular",
    "keywords": "Customizing Ignite UI for Angular Theming This article will walk you through the details of customizing Ignite UI for Angular application theming and optimizing the size of the produced stylesheet. The article shows details of how the Ignite UI for Angular theming engine works and presents advanced usage of it. The article is very useful for both making full customization of the component styles, such that your Angular application is tailored to match your desired look and feel, and for making your application optimal for deployment by reducing the style sizes down to only what is used by the app. Note This document describes the theming system in Ignite UI for Angular from version 15 forward. Examples include both using the Sass APIs provided by the theming engine and exposed CSS variables. Getting Started We will be using the App Builder to produce an Angular application and then we will modify the styling of it in the generated repository. We start by creating a new app from \"Header + mini nav + content + side pane\" template in the App Builder and we add some components to the design surface. Then we generate our app, using Angular as a target, to a GitHub repository, on top of which we will work both from the App Builder and modifying the generated code itself. After cloning the repository and building the project, we get the running Angular application in its initial state. As you can see, the application has applied default theming, which is material light variant. The generated styles.scss file looks like this: /* You can add global styles to this file, and also import other style files */ // Standard CSS normalize, comment out if not required or using a different module @use \"minireset.css/minireset\"; @use \"@infragistics/igniteui-angular/theming\" as *; @include core(); @include typography(); @include light-theme($light-material-palette); body { background: hsla(var(--ig-surface-500)); color: var(--ig-surface-500-contrast); } html, body { height: 100%; } .ig-typography { h1, h2, h3, h4, h5, h6, p, .ig-typography__body-1 { margin: 0; } } .outer-wrapper > *:not(router-outlet) { width: 100%; } Theme Customization We want a dark variant of the same theme, add our own color palette to match our branding, and change the font to Poppins instead of the default Titillium Web, all of which we can change directly through the App Builder and we can push the change as a pull request from the App Builder into the repository. The updated styles.scss looks like this: @include core(); @include typography($font-family: \"Poppins\"); $custom-palette: palette( $primary: #1028c7, $secondary: #e0d94c, $surface: #000, $gray: #fff ); @include theme( $palette: $custom-palette, $schema: $dark-material-schema ); As you can see, the code generation changed from the specific @include light-theme($light-material-palette);, which is the default theme and color palette, to a generic theme() include, which provides as parameters our custom color palette and a dark material schema for the theming structure. The running Angular app result looks like this now: We want to dig deeper and customize a specific component theme in our application and we will do this by bringing in the CSS variables for an individual component theme, in this case the grid toolbar theme. @include core(); @include typography($font-family: \"Poppins\"); $primary: #1028c7; /* All of the components will use this custom color palette */ $custom-palette: palette( $primary: $primary, $secondary: #e0d94c, $surface: #000, $gray: #fff ); @include theme( $palette: $custom-palette, $schema: $dark-material-schema ); /* Grid Toolbar */ /* All grid toolbars will have custom background and elevations */ $toolbar-theme: grid-toolbar-theme( $background-color: $primary ); @include css-vars($toolbar-theme); /* END Grid Toolbar */ And the result in our app now looks like this: The same process can be applied to override and customize any of the component themes individually. Switching custom themes at runtime Now let's dig even deeper and create two custom versions of the theme, which can be switched between at runtime. We can do this with user control/preference and let them switch it at any time. For the example, however, we will use the OS defined user preference (light or dark) in order to apply a theme, which matches the current OS setting. In order to do this, we will need two color palettes: @use \"minireset.css/minireset\"; @use \"@infragistics/igniteui-angular/theming\" as *; @include core(); @include typography($font-family: \"Poppins\"); $primary-dark: #1028c7; $primary-light: #3c55f1; $secondary-dark: #e0d94c; $secondary-light: #b4a904; $custom-palette-dark: palette( $primary: $primary-dark, $secondary: $secondary-dark, $surface: #000, $gray: #ccc ); $custom-palette-light: palette( $primary: $primary-light, $secondary: $secondary-light, $surface: #fff, $gray: #222 ); Then our theme definition will go in the general scope, which we will use for the light variation and we will create a palette override in a @media query when dark color schema OS preference is detected: @include theme( $palette: $custom-palette-light, $schema: $light-material-schema ); @media (prefers-color-scheme: light) { /* Grid Toolbar override for light color scheme */ igx-grid-toolbar { --background-color: #{$primary-light}; --title-text-color: #{text-contrast($primary-light)}; } /* END Grid Toolbar */ } @media (prefers-color-scheme: dark) { // changes native element schema (scrollbars, select, etc.) :root { color-scheme: dark; } @include palette($custom-palette-dark); /* Grid Toolbar override for dark color scheme */ igx-grid-toolbar { --background-color: #{$primary-dark}; --title-text-color: #{text-contrast($primary-dark)}; } /* END Grid Toolbar */ } Note I have switched the igx-grid-toolbar theme override to overriding just two of its variables, instead of reincluding all of the theme variables using css-vars(). All theme variables can be found in the corresponding sass api doc and are equivalent to the sass variables, but prefixed with -- instead of $. And the result now looks like this with light OS theme: And this is how it looks with dark OS theme: Note Full runtime switch, including Ignite UI theme schema preset switch is possible, only if two full themes are built. In the example above, we're switching the color palettes, but the theme schema remains $light-material-schema, so not all of the correct shades from the color palette are used when we switch to the dark color palette. What can be customized Ignite UI theming abstracts multiple dimensions of theming and provides for very robust retheming capabilities. Developers and designers can take advantage of the theming engine APIs to make tailored visual design for their applications, which gives them unique look and feel when using Ignite UI for Angular. The theming engine also exposes variables from each of the dimensions, which can be used to apply theming to the rest of the application structure, which is not directly built with Ignite UI for Angular components as UI. The dimensions exposed for modifications are: Colors (color palette) Shape (borders and radiuses) Elevations (shadows) Typography (fonts and font sizes) Size (Display Density) (the size of information that is fitted on the screen) Note If you really want a fully custom visual design, you will need to modify all of the supported theming dimensions and you will take full advantage of the Sass APIs. If you just need to change things like the fonts and а few colors, then you can just take a look at the section for palettes and typography. In most cases, all you will need is to change a few CSS variables and you won't need the full Sass APIs. We've made this as granular as possible, so modifications can be applied without unexpected side results on the visual design of your applications. Theme Optimization After making some customizations, we're going to build the application we generated and modified to see what our application theme looks like in terms of size. As you can see, the application theme is slightly over 400kb, which comes down to ~40kb when compressed and transferred over. This is not large, but can it be more optimal? The answer is yes, unless every single component from the Ignite UI for Angular suite is used. Calling @include theme() brings in all of the component themes, but we have a mechanism for telling the function what to exclude. There's an $exclude parameter to the theming mixin, which takes component names as an array and excludes those from the theme at build time. Since it's not so easy to find and list all of the components available in the package, it's preferable if you can just list all of the components you use. We expose the full component list as a varialble, which you have access to once you @use \"@infragistics/igniteui-angular/theming\" as *; The components array is found at $components and you can reduce this list with the components you use and exclude all the rest, like in this example: $include: ( igx-navbar, igx-ripple, igx-icon, igx-button, igx-input-group, igx-combo, igx-nav-drawer, igx-grid, igx-grid-toolbar ); @include theme( $palette: $custom-palette, $schema: $dark-material-schema, /* Removing all included components from the full list and excluding the rest */ $exclude: map.keys(map.remove($components, $include...)) ); Note Some component themes depend on other component themes. Even if you exclude certain themes, they will be retained by the build if you use a component theme, which depends on an excluded theme. What does our build look like after we've excluded certain themes? As you can see, our styles size is reduced to almost half it's original size. This looks pretty good at the moment, but can we reduce this even further? In fact, we can. Most of the styles size is taken by the largest components in the suite, in this case the IgxTreeGridComponent that we have in one of our views. However, we don't use this component in any other view. We can make the view with the igx-tree-grid a lazy-loaded route and we can include the theme for the grids only for that route, hence making our top-level css even smaller. How is this done? We will start by creating a new module and a new routing module in the folder with the employees component in our app. // employees.module.ts import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { EmployeesRoutingModule } from './employees-routing.module'; import { EmployeesComponent } from './employees.component'; import { IgxButtonModule, IgxComboModule, IgxTreeGridModule } from '@infragistics/igniteui-angular'; @NgModule({ declarations: [ EmployeesComponent ], imports: [ CommonModule, EmployeesRoutingModule, IgxComboModule, IgxTreeGridModule, IgxButtonModule ] }) export class EmployeesModule { } // employees-routing.module.ts import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router'; import { EmployeesComponent } from './employees.component'; const routes: Routes = [{ path: '', component: EmployeesComponent }]; @NgModule({ imports: [RouterModule.forChild(routes)], exports: [RouterModule] }) export class EmployeesRoutingModule { } // Updated top-level app-routing.module.ts import { NgModule } from '@angular/core'; import { Routes, RouterModule } from '@angular/router'; import { PageNotFoundComponent } from './error-routing/not-found/not-found.component'; import { UncaughtErrorComponent } from './error-routing/error/uncaught-error.component'; import { ErrorRoutingModule } from './error-routing/error-routing.module'; import { StatisticsComponent } from './statistics/statistics.component'; export const routes: Routes = [ { path: '', redirectTo: 'statistics', pathMatch: 'full' }, { path: 'error', component: UncaughtErrorComponent }, // { path: 'employees', component: EmployeesComponent, data: { text: 'Employees' } }, // lazy-loading the employees route { path: 'employees', loadChildren: () => import('./employees/employees.module').then(m => m.EmployeesModule) }, { path: 'statistics', component: StatisticsComponent, data: { text: 'Statistics' } }, { path: '**', component: PageNotFoundComponent } // must always be last ]; @NgModule({ imports: [RouterModule.forRoot(routes), ErrorRoutingModule], exports: [RouterModule, ErrorRoutingModule] }) export class AppRoutingModule { } Now we remove the IgxTreeGridModule and IgxComboModule imports, as well as the EmployeesComponent from our app.module.ts because we don't use the imports in any other views and we can have only one component declaration in all modules. Then we will proceed by removing the igx-grid, igx-grid-toolbar and igx-combo from our theme includes, and we will include them on the employees.component.scss level. /* employees.component.scss */ @use \"@infragistics/igniteui-angular/theming\" as *; :host ::ng-deep { height: 100%; display: flex; justify-content: flex-start; align-items: stretch; align-content: flex-start; $primary: #1028c7; @include core(); @include grid(grid-theme()); @include combo(combo-theme()); @include grid-toolbar( grid-toolbar-theme( $background-color: $primary, ); } /* Updated styles.scss */ @use \"sass:map\"; @use \"minireset.css/minireset\"; @use \"@infragistics/igniteui-angular/theming\" as *; @include core(); @include typography($font-family: \"Poppins\"); $primary: #1028c7; $custom-palette: palette( $primary: $primary, $secondary: #e0d94c, $surface: #000, $gray: #fff ); $include: ( igx-navbar, igx-ripple, igx-icon, igx-button, igx-nav-drawer ); @include theme( $palette: $custom-palette, $schema: $dark-material-schema, $exclude: map.keys(map.remove($components, $include...),) ); Note You probably want to put all your variables, like color palette values in a separate _variables.scss file, which you can include from multiple components to reuse the variables. The result in terms of build is the following: As you can see, our top-level styles.css came down to a little over 70kb, which is a little less than 6kb when compressed. We started at ~428kb, ~40kb compressed and managed to bring this down about 7 times in terms of compressed size. The rest is being delievered only when the view containing the igx-tree-grid and igx-combo components is being loaded. Additional Resources Related topics: Palettes Elevations Typography Theming with Sass Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/how-to/how-to-perform-crud.html": {
    "href": "components/general/how-to/how-to-perform-crud.html",
    "title": "How to enable CRUD operations in Angular.",
    "keywords": "What is CRUD CRUD is an acronym in computer programming that stands for the CREATE, READ, UPDATE, DELETE operations that can be performed against a data collection. In computer world, talking about CRUD applications, is a main difference compared to applications that provide read-only data to users. Angular CRUD While talking about Angular CRUD, or CRUD operations in Angular, it is important to note that the data storage is on a remote server. The Angular application can not directly access the data layer, so it needs to communicate with it through a Web API that provides endpoints for the CRUD operations, i.e.: API Operation HTTP methods \"api/entities\" READ all entities GET \"api/entities/id\" READ the entity with corresponding id GET \"api/entities/update\" UPDATE the entity with corresponding id PUT / PATCH \"api/entities/create\" CREATE a new entity POST \"api/entities/delete\" DELETE the entity with corresponding id DELETE Notice that the CRUD operations also map conceptually to the HTTP methods that are used to communicate with APIs over HTTP. The entire code that will work with the above mentioned API can be abstracted in an Angular service. Such a service is injectable and can be reused by any component that needs to perform CRUD operations against the same database. A good practice is to write such service as generic as possible, thus making it suitable to be reused in many components, and against different servers as well. A generic example of such service will look like this: @Injectable() export class CRUDService { /** See https://angular.io/api/common/http/HttpClient */ constructor(private http: HttpClient) { } /** Gets all entities from server */ public getData() { return this.http.get(`${this.serverURL}\\api\\entities`); } /** Gets entity with corrresponding id */ public getRecord(id) { return this.http.get(`${this.serverURL}\\api\\entities\\${id}`); } /** Creates entity from body */ public add(entity) { return this.http.post(`${this.serverURL}\\api\\entities\\create`, entity); } /* Updates entity with data from body */ public update(entity) { return this.http.put(`${this.serverURL}\\api\\entities\\update`, entity); } /** Deletes the corresponding entity */ public delete(entity) { return this.http.delete(`${this.serverURL}\\api\\entities\\delete`, entity); } } What the above service is missing is configuration for filtering/sorting/paging, etc. Depending on the exact API implementation of the endpoints, requests to the server may need optional parameters to handle filtering/sorting/paging for you. See our Remote Data Operations for demos accompanied with code examples. For more examples and guidance, refer to the HTTP Services tutorial in the official Angular documentation. CRUD Operations with Grid Enabling CRUD in the Grid means providing UI for the users to perform these CRUD operations from within the grid. This is quite easy - the Grid provides Cell Editing, Row Editing, Row Adding and Row Deleting UI out of the box, and powerful API to do this on your own. Next, we want to take the result of each editing action and communicate it to the corresponding method in our CRUD service, thus preserving all changes to the original database. By completing this, we may say the grid is CRUD enabled. This section is written as HOW-TO tutorial on enabling CRUD operations in Grid, accompanied by code snippets that you can take and copy paste in your code. How to Let's first enable the rowEditing behavior, bring the UI we need for the editing actions, benefiting from the IgxActionStrip (see more about the IgxActionStrip), and attach event handlers: <igx-grid primaryKey=\"ID\" [rowEditable]=\"true\" (rowAdded)=\"rowAdded($event)\" (rowDeleted)=\"rowDeleted($event)\" (rowEditDone)=\"rowEditDone($event)\"> <igx-action-strip #actionstrip> <igx-grid-editing-actions [addRow]=\"true\"></igx-grid-editing-actions> </igx-action-strip> In the Angular component, inject the data service using DI. Now we are ready to use the service to do full CRUD operations against our data layer: constructor(private crudService: CRUDService) { } public rowDeleted(event: IRowDataEventArgs) { this._crudService.delete(event.data).subscribe((rec) => { // notification or do any adittional handling this.snackbar.open(`Row with ID of ${rec.ID} was deleted.`); }); } public rowAdded(event: IRowDataEventArgs) { this._crudService.add(event.data); } public rowEditDone(event: IGridEditDoneEventArgs) { this._crudService.update(event.newValue); } In the above example, we only call the corresponding methods and pass the data that is read from the event arguments. Most API endpoints will return the updated/added/deleted entity, which indicates that the request was successful. A good practice is to add validation, notifying the users that all actions have been completed successfully or that an error has occurred. In such case, you may want to pass handlers for the error and complete notifications too: this._crudService.delete(event.data).subscribe({ next: (data: any) => { console.log('success'); }, error: err => { console.log(err); }, complete: () => { console.log('Complete notification') } }); Note The above examples are based on the default grid UI for editing actions. Another valid approach is if you provide your own external UI. In such case, responding to user interactions with the UI should work with the grid editing API (make sure the grid has a primaryKey set). See API section for reference. Note Make sure to follow best practices and prevent any differences in your local data compared to the server database. For example - you may decide to first make a request to the server to delete a record, but if the request fails, do not delete the data on the local grid data: this._crudService.delete(event.data).subscribe({ next: (data: any) => { this.grid.getRowByKey(event.data[this.grid.primaryKey]).delete(); }, error: err => { console.log(err); // notify and don't delete the grid row } }); Demo See the demo that was built following the guidance. Play around with it and try the examples for customization to fit your scenario in the best possible way. Customizations The rich Grid API allows you to customize the editing process in almost any way in order to fit your needs. This includes, but is not limited to: Batch Editing: Enable Batch Editing to batch all updates, and commit everything with single request. Templating: Add templates for cell editing, or use your own external UI for row/cell editing, row adding and row deleting. Events: Monitor the editing flow and react accordingly. Attach event handlers for all events emitted during editing, will allow you to do: data validation per cell data validation per row prompt user for expected type of input cancel further processing, based on business rules manual committing of the changes Rich API Batch Editing Enable Batch Editing to keep your updates on the client, and commit all of them with single request. Batch updating is enabled bysetting batchEditing option to true: <igx-grid [batchEditing]=\"'true'\" ...> Go to Batch Editing for more details and demo samples. Templates You can see and learn more about default cell editing templates in the general editing topic. If you want to provide a custom template which will be applied when a cell is in edit mode, you can make use of the igxCellEditor directive. To do this, you need to pass an ng-template marked with the igxCellEditor directive and properly bind your custom control to the cell.editValue: <igx-column field=\"class\" header=\"Class\" [editable]=\"true\"> <ng-template igxCellEditor let-cell=\"cell\" let-value> <igx-select class=\"cell-select\" [(ngModel)]=\"cell.editValue\" [igxFocus]=\"true\"> <igx-select-item *ngFor=\"let class of classes\" [value]=\"class\"> {{ class }} </igx-select-item> </igx-select> </ng-template> </igx-column> For more information and demos, see the Cell Editing topic. Events The grid exposes a wide array of events that provide greater control over the editing experience. These events are fired during the Row Editing and Cell Editing lifecycle - when starting, committing or canceling the editing action. Event Description Arguments Cancellable rowEditEnter If rowEditing is enabled, fires when a row enters edit mode IGridEditEventArgs true cellEditEnter Fires when a cell enters edit mode (after rowEditEnter) IGridEditEventArgs true cellEdit If value is changed, fires just before a cell's value is committed (e.g. by pressing Enter) IGridEditEventArgs true cellEditDone If value is changed, fires after a cell has been edited and cell's value is committed IGridEditDoneEventArgs false cellEditExit Fires when a cell exits edit mode IGridEditDoneEventArgs false rowEdit If rowEditing is enabled, fires just before a row in edit mode's value is committed (e.g. by clicking the Done button on the Row Editing Overlay) IGridEditEventArgs true rowEditDone If rowEditing is enabled, fires after a row has been edited and new row's value has been committed. IGridEditDoneEventArgs false rowEditExit If rowEditing is enabled, fires when a row exits edit mode IGridEditDoneEventArgs false Go to Events for more details and demo samples. Editing API Updating data in the grid is achieved through methods exposed both by the grid: updateRow updateCell deleteRow addRow and update method exposed by the IgxGridCell and IgxGridRow instances: // Through the grid methods this.grid.updateRow(newData, rowKey); this.grid.updateCell(newData, rowKey, columnField); this.grid1.deleteRow(0); this.grid.addRow(data); // Through the methods exposed by cell/row this.grid.getCellByColumn(rowIndex, columnField).update(newData); this.grid.getCellByKey(rowKey, columnField).value = newData; this.grid.getRowByKey(rowID).update(newData); this.grid.getRowByKey(rowID).delete(); More details and information about using the grid API can be found in the Cell Editing CRUD Operations section. Takeaway Enabling CRUD in a robust way is major milestone for any data-driven application. In order to streamline the entire process, we've built the IgxGrid with the CRUD capabilities in mind, providing out-of-the-box UI and flexible APIs. How will this benefit you? It will save you lots of time when implementing CRUD against any database out there. And when we talk about modern-day data-driven apps, it all comes down to robustness, speed, and flexibility. API References IgxGridComponent IgxGridRow IgxGridCell IgxActionStripComponent API IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent View page on GitHub"
  },
  "components/general/how-to/how-to-use-standalone-components.html": {
    "href": "components/general/how-to/how-to-use-standalone-components.html",
    "title": "How to Use Standalone Components - Angular | Ignite UI for Angular",
    "keywords": "Using Standalone Components with Ignite UI for Angular Angular 14 introduced the concept of standalone components which allows for a simplified way of building applications by reducing the need for using NgModules. Standalone components were in developer preview until Angular 15. To support this new paradigm, all Ignite UI for Angular components are now exported as standalone with version 16.0.0. All the existing NgModules are still exported by the library for backward compatibility. However, they no longer declare any of the Ignite UI for Angular components. Instead they import and export the standalone components. How to use the new standalone components Starting with Angular 16 and Ignite UI for Angular 16.0 you can now simply add the imports that your standalone component needs in the imports property. In the following example IGX_GRID_DIRECTIVES can be used to import all grid related components and directives. import { IGX_GRID_DIRECTIVES } from 'igniteui-angular'; @Component({ selector: 'app-grid-sample', styleUrls: ['grid.sample.scss'], templateUrl: 'grid.sample.html', standalone: true, imports: [IGX_GRID_DIRECTIVES, AsyncPipe] }) But you can also import all components used by your standalone component individually. Example with the IgxGridComponent and IgxColumnComponent when only these two are used by another component is as follows. import { IgxGridComponent, IgxColumnComponent } from 'igniteui-angular'; @Component({ selector: 'app-grid-sample', styleUrls: ['grid.sample.scss'], templateUrl: 'grid.sample.html', standalone: true, imports: [IgxGridComponent, IgxColumnComponent, AsyncPipe] }) In addition, as all existing modules are preserved but now only import and export the standalone components, you can also use them for your standalone component. // `NgModule` import of the `IgxGridModule` module, which is equivalent to IGX_GRID_DIRECTIVES in terms of exported components and directives. import { IgxGridModule } from 'igniteui-angular'; @Component({ selector: 'app-grid-sample', styleUrls: ['grid.sample.scss'], templateUrl: 'grid.sample.html', standalone: true, imports: [IgxGridModule, AsyncPipe] }) Utility Directives The IGX_GRID_DIRECTIVES shown in the previous examples is a utility directive that exports all grid related components and directives. The following table lists all new utility directives that are available in Ignite UI for Angular. Directive Collection Description IGX_ACCORDION_DIRECTIVES Exports all accordion related components and directives. IGX_ACTION_STRIP_DIRECTIVES Exports all action strip related components and directives. IGX_BANNER_DIRECTIVES Exports all banner related components and directives. IGX_BOTTOM_NAV_DIRECTIVES Exports all bottom navigation related components and directives. IGX_BUTTON_GROUP_DIRECTIVES Exports all button group related components and directives. IGX_CALENDAR_DIRECTIVES Exports all calendar related components and directives. IGX_CARD_DIRECTIVES Exports all card related components and directives. IGX_CAROUSEL_DIRECTIVES Exports all carousel related components and directives. IGX_CHIPS_DIRECTIVES Exports all chip related components and directives. IGX_CIRCULAR_PROGRESS_BAR_DIRECTIVES Exports all circular progress bar related components and directives. IGX_COMBO_DIRECTIVES Exports all combo related components and directives. IGX_DATE_PICKER_DIRECTIVES Exports all date-picker related components and directives. IGX_DATE_RANGE_PICKER_DIRECTIVES Exports all date-range picker related components and directives. IGX_DIALOG_DIRECTIVES Exports all dialog related components and directives. IGX_DRAG_DROP_DIRECTIVES Exports all drag and drop related components and directives. IGX_DROP_DOWN_DIRECTIVES Exports all drop-down related components and directives. IGX_EXPANSION_PANEL_DIRECTIVES Exports all expansion panel related components and directives. IGX_GRID_DIRECTIVES Exports all grid related components and directives. IGX_HIERARCHICAL_GRID_DIRECTIVES Exports all hierarchical grid related components and directives. IGX_INPUT_GROUP_DIRECTIVES Exports all input group related components and directives. IGX_LINEAR_PROGRESS_BAR_DIRECTIVES Exports all linear progress bar related components and directives. IGX_LIST_DIRECTIVES Exports all list related components and directives. IGX_NAVBAR_DIRECTIVES Exports all navbar related components and directives. IGX_NAVIGATION_DRAWER_DIRECTIVES Exports all navigation drawer related components and directives. IGX_PAGINATOR_DIRECTIVES Exports all paginator related components and directives. IGX_PIVOT_GRID_DIRECTIVES Exports all pivot grid related components and directives. IGX_PROGRESS_BAR_DIRECTIVES Exports all linear and circular progress bar related components and directives. IGX_QUERY_BUILDER_DIRECTIVES Exports all query builder related components and directives. IGX_RADIO_GROUP_DIRECTIVES Exports all radio group related components and directives. IGX_SELECT_DIRECTIVES Exports all select related components and directives. IGX_SIMPLE_COMBO_DIRECTIVES Exports all simple combo related components and directives. IGX_SLIDER_DIRECTIVES Exports all slider related components and directives. IGX_SPLITTER_DIRECTIVES Exports all splitter related components and directives. IGX_STEPPER_DIRECTIVES Exports all stepper related components and directives. IGX_TABS_DIRECTIVES Exports all tabs related components and directives. IGX_TIME_PICKER_DIRECTIVES Exports all time picker related components and directives. IGX_TOOLTIP_DIRECTIVES Exports all tooltip related components and directives. IGX_TREE_DIRECTIVES Exports all tree-view related components and directives. IGX_TREE_GRID_DIRECTIVES Exports all tree grid related components and directives. Additional Resources Related topics: Standalone Components Getting started with Ignite UI for Angular Server-side Rendering with Angular Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/how-to/signal-r-service-live-data.html": {
    "href": "components/general/how-to/signal-r-service-live-data.html",
    "title": "How to create ASP.NET Core SignalR service for live-data streaming.",
    "keywords": "Real-time Web App with ASP.NET Core SignalR In this topic, we’ll see how to create applications for both streaming and receiving data with ASP.NET Core SignalR. What you'll need: A basic knowledge of ASP.NET Core and Angular. .NET Core 3.1 installed and IDE such as Visual Studio. What you'll know by the end of this article: How to add and use SignalR. How to open Client connection and use the method invocation concept to stream data per Client. How to consume the SignalR service with Angular application by using Observables. SignalR takes advantage of several transports and it automatically selects the best available transport given the client and server's capabilities - WebSockets, Server Send Events or Long-polling. When we talk in terms of WebSockets (Putting SSE and Long-polling out of the equation) when the client is real-time connected to the server, whenever something happens the server will know to send a message over that WebSocket back to the client. With old-school clients and servers, the Long-polling transport would be used. This is how SignalR handles modern clients and servers, it uses WebSockets under the hood when available, and gracefully falls back to other techniques and technologies when it isn't: It's like a handshake, the Client and Server agree on what to use and they use it. This is called process negotiation. SignalR Example The purpose of this demo is to showcase a financial screen board with a Real-time data stream using ASP.NET Core SignalR. SignalR Server Configuration Create ASP.NET Core App Let's see how to set up the ASP.NET Core SignalR application. In Visual Studio from File >> New project choose ASP.NET Core Web Application and follow the setup. Feel free to follow the official Microsoft documentation tutorial if you experience any configuration difficulties. SignalR Config Setup Add the following code to the Startup.cs file: Endpoint part of the Configure method. app.UseEndpoints(endpoints => { endpoints.MapControllers(); endpoints.MapHub<StreamHub>(\"/streamHub\"); }); Add SignalR usage to the ConfigureServices method. services.AddSignalR(options => { options.EnableDetailedErrors = true; }); The changes above are adding SignalR to the ASP.NET Core dependency injection and routing system. Now, let's set up additional basic configuration. Open the properties/launchSettings.json file and modify it accordingly: \"profiles\": { \"WebAPI\": { \"commandName\": \"Project\", \"launchBrowser\": false, \"applicationUrl\": \"https://localhost:5001;http://localhost:5000\", \"environmentVariables\": { \"ASPNETCORE_ENVIRONMENT\": \"Development\" } } } Our server-side project will run on localhost:5001 and the client side will run on localhost:4200, so in order to establish communication between those two, we need to enable CORS. Let’s open the Startup.cs class and modify it: public void ConfigureServices(IServiceCollection services) { services.AddCors(options => { options.AddPolicy(\"CorsPolicy\", builder => builder .AllowAnyMethod() .AllowAnyHeader() .AllowCredentials() .WithOrigins(\"http://localhost:4200\")); }); ... public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { ... app.UseCors(\"CorsPolicy\"); ... If you experience a specific problem with enabling Cross-origin resource sharing, check out the official Microsoft topic. SignalR Hub Setup Let's start by explaining what is a SignalR hub? The SignalR Hub API enables you to call methods on connected clients from the server. In the server code, you define methods that are called by the client. In SignalR there is this concept called Invocation - you can actually be calling the hub from the client with a particular method. In the client code, you define methods that are called from the server. The actual hub lives on the server-side. Imagine you have Clients and the Hub is between all of them. You can say something to all the Clients with Clients.All.doWork() by invoking a method on the hub. This will goes to all connected clients. Also, you can communicate with only one client, which is the Caller, because he is the caller of that particular method. We've created a StreamHub class that inherits the base Hub class, which is responsible for managing connections, groups, and messaging. It's good to keep in mind that the Hub class is stateless and each new invocation of a certain method is in a new instance of this class. It's useless to save state in instance properties, rather we suggest using static properties, in our case we use static key-value pair collection to store data for each connected client. Other useful properties of this class are Clients, Context, and Groups. They can help you to manage certain behavior based on the unique ConnectionID. Also, this class provides you with the following useful methods: OnConnectedAsync() - Called when a new connection is established with the hub. OnDisconnectedAsync(Exception) - Called when a connection with the hub is terminated. They allow us to perform any additional logic when a connection is established or closed. In our application, we've also added UpdateParameters method that gets a Context connection ID and use it to send back data at a certain interval. As you can see we communicate over a unique ConnectionID which prevents a streaming intervention from other Clients. public async void UpdateParameters(int interval, int volume, bool live = false, bool updateAll = true) { ... var connection = Context.ConnectionId; var clients = Clients; ... if (!clientConnections.ContainsKey(connection)) { clientConnections.Add(connection, new TimerManager(async() => { ... await Send(newDataArray, client, connection); }, interval)); } else { clientConnections[connection].Stop(); clientConnections[connection] = new TimerManager(async () => { var client = clients.Client(connection); .. await Send(newDataArray, client, connection); }, interval); } ... } When the data is ready we transfer it by emitting a transferdata event with the help of SendAsync Method. public async Task Send(FinancialData[] array, IClientProxy client, string connection) { await client.SendAsync(\"transferdata\", array); } ... // Called when a connection with the hub is terminated public override Task OnDisconnectedAsync(Exception exception) { StopTimer(); clientConnections.Remove(Context.ConnectionId); return base.OnDisconnectedAsync(exception); } Our client application would be listening to the registered events: private registerSignalEvents() { this.hubConnection.onclose(() => { this.hasRemoteConnection = false; }); this.hubConnection.on('transferdata', (data) => { this.data.next(data); }) } The public GitHub repository of the ASP.NET Core Application could be found here. Create SignalR Client Library We will create an Angular project in order to consume the SignalR service. Github repository with the actual application can be found here. First, start by installing SignalR: npm install @microsoft/signalr Keep in mind that we are going to send the HTTP request towards our server, so we need HttpClientModule as well. Below you will find the signal-r.service.ts file that handles the hub connection builder. export class SignalRService implements OnDestroy { public data: BehaviorSubject<any[]>; public hasRemoteConnection: boolean; private hubConnection: signalR.HubConnection; ... constructor(private zone: NgZone, private http: HttpClient) { this.data = new BehaviorSubject([]); } ... // Start Hub Connection and Register events public startConnection = (interval = 500, volume = 1000, live = false, updateAll = true) => { this.hubConnection = new signalR.HubConnectionBuilder() .configureLogging(signalR.LogLevel.Trace) .withUrl('https://www.infragistics.com/angular-apis/webapi/streamHub') .build(); this.hubConnection .start() .then(() => { ... this.registerSignalEvents(); this.broadcastParams(interval, volume, live, updateAll); }) .catch(() => { ... }); } // Change the broadcast parameters like frequency and data volume public broadcastParams = (frequency, volume, live, updateAll = true) => { this.hubConnection.invoke('updateparameters', frequency, volume, live, updateAll) .then(() => console.log('requestLiveData', volume)) .catch(err => { console.error(err); }); } // Register events private registerSignalEvents() { this.hubConnection.onclose(() => { this.hasRemoteConnection = false; }); this.hubConnection.on('transferdata', (data) => { this.data.next(data); }); } ... In your app.component add use the newly created startConnection method constructor(public dataService: SignalRService) {} public ngOnInit() { this.dataService.startConnection(this.frequency, this.dataVolume, true, false); } ... Grid Data Binding As we have seen so far in our client code we set up a listener for transferdata event, which receives as an argument the updated data array. To pass the newly received data to our grid we use an observable. To set that, we need to bind the grid's data source to the data observable like so: <igx-grid [data]='data | async'> ... </igx-grid> Every time when new data is received from the server to the client we call the next() method of the data observable. this.hubConnection.on('transferdata', (data) => { this.data.next(data); }) Topic Takeaways If you don’t want to refresh your application, rather just see when the data is updated, you should consider ASP.NET Core SignalR. I definitely recommend going for streaming content when you think your data is large, or if you want a smooth user experience without blocking the client by showing endless spinners. Using SignalR Hub communication is easy and intuitive and with the help of Angular Observables, you can create a powerful application that uses data streaming with WebSockets. View page on GitHub"
  },
  "components/general/ignite-ui-licensing.html": {
    "href": "components/general/ignite-ui-licensing.html",
    "title": "Ignite UI Licensing",
    "keywords": "License FAQ and Installation License Agreements It is important to know all the legal terms and conditions regarding the products that you purchase and use. Note We have updated our license terms and subscription model in second quarter of 2020. If your trial has ended or your subscription has expired, each developer on your team using Ignite UI will need to purchase a subscription. This will enable you to use our private npm feed hosted on https://packages.infragistics.com/npm/js-licensed/ for development. There you will find the latest versions of the Ignite UI for Angular packages. If you have a current subscription, you can use this private feed and you will have access to the full version of Ignite UI for Angular. For detailed explanation of the Ignite UI license agreement and terms of use, click here. Infragistics offers free, non-commercial, not-for-resale (NFR) licenses for the following: If you are part of a developer program like the Microsoft MVP, Microsoft Regional Director, Google Developer Expert, etc. If you are a primary, secondary or university student, or an academic institution, or a professor. If you qualify for a free, non-commercial, NFR license or if you have any license questions, please contact us. Ignite UI for Angular npm packages - Using the Private npm feed Npm is the most popular package manager and is also the default one for the runtime environment Node.js. Highly adopted, it is one of the fastest and easiest ways to manage the packages that you depend on in your project. For more information on how npm works, read the official npm documentation. Infragistics Ignite UI for Angular is available as a npm package and you can add it as a dependency to your project in a few easy steps using the Ignite UI CLI or using Ignite UI for Angular Schematics. Choosing this approach will not require configuring npm. By installing this package you will start using the Ignite UI for Angular Trial version of the product. Note What does it mean to start using a trial version? It means that you will be using a version of our product with a Watermark part of your web view. It doesn’t mean that you will be using the licensed package for a certain amount of time before it expires. For example, for a month. Infragistics Ignite UI Dock Manager Web Component is available as a separate npm package and by installing it you will start using the Ignite UI Dock Manager Web Component Trial version of the product. More information on how to start using the Ignite UI for Angular npm package can be found in this topic. Additional information on Ignite UI Dock Manager Web Component can be found here. Upgrading packages using our Angular Schematics or Ignite UI CLI If Ignite UI for Angular has been added to the project using ng add or the project has been created through our schematics collection or Ignite UI CLI, you can use our upgrade-packages to automatically upgrade your app to using our licensed packages. You project package dependencies will include either @igniteui/angular-schematics or igniteui-cli, with both of them supporting the upgrade command. Note As the process changes the packages, we recommend that you update your project first before switching. This way you will avoid picking up a higher version of Ignite UI Angular and missing on potential update migrations. Follow our Update Guide. Depending on your project setup, either run the following schematic in your project: ng g @igniteui/angular-schematics:upgrade-packages or use igniteui-cli: ig upgrade-packages The schematic or command will take care of switching the package dependencies of the project and update source references. You'll be asked to login to our npm registry if not already setup. Note If your project is using yarn, make sure to run upgrade-packages with the --skip-install flag. Then execute yarn install after to properly update your yarn.lock as the upgrade command currently uses npm for the install. How to setup your environment to use the private npm feed (Step by step guide) First you need to setup the private registry and to associate this registry with the Infragistics scope. This will allow you to seamlessly use a mix of packages from the public npm registry and the Infragistics private registry. Note If your account is not licensed (you are still using a Trial account) the private package feed won't be accessible to you e.g. it will return 404 or 403 error message. Only licensed accounts can access the packages.infragistics private feed. Now, to log in to our private feed using npm npm version 9+ Our private feed doesn't currently support login/adduser commands with npm v9, so we recommend the following steps instead to add the required auth fields to the config: npm config set @infragistics:registry https://packages.infragistics.com/npm/js-licensed/ npm config set //packages.infragistics.com/npm/js-licensed/:username=YOUR_USERNAME npm config set //packages.infragistics.com/npm/js-licensed/:email=YOUR_IG_EMAIL npm config set //packages.infragistics.com/npm/js-licensed/:_auth=YOUR_IG_AUTH_TOKEN You can generate Access Token through your Infragistics profile. This approach is applicable to all prior versions of npm. npm version up to v8 Run the adduser command and specify a user account and password: npm adduser --registry=https://packages.infragistics.com/npm/js-licensed/ --scope=@infragistics You will be asked to provide the username and the password that you use for logging into your Infragistics account. You should also provide the email that is registered to your Infragistics profile. Note npm is disallowing the use of the \"@\" symbol inside your username as it is considered as being \"not safe for the net\". Because your username is actually the email that you use for your Infragistics account it always contains the symbol \"@\". That's why you must escape this limitation by replacing the \"@\" symbol with \"!!\" (two exclamation marks). For example, if your username is \"username@example.com\" when asked about your username you should provide the following input: \"username!!example.com\". After this is done, you will be logged in and you will be able to install the latest versions of the Ignite UI packages into your project: npm uninstall igniteui-angular npm install @infragistics/igniteui-angular npm uninstall igniteui-dockmanager npm install @infragistics/igniteui-dockmanager Have in mind that we have set the Ignite UI for Angular package to be scoped, meaning that no changing the registries is needed if you want to install packages from our private feed and from npmjs.org simultaneously. Some additional changes might have to be made in your project source If you are upgrading from trial to licensed package and you are not using the automated CLI migrations: Add a paths mapping in the project tsconfig.json. { /* ... */ \"compilerOptions\": { \"baseUrl\": \"./\", \"outDir\": \"./dist/out-tsc\", /* ... */ \"paths\": { \"igniteui-dockmanager\": [\"./node_modules/@infragistics/igniteui-dockmanager\"], \"igniteui-dockmanager/*\": [\"./node_modules/@infragistics/igniteui-dockmanager/*\"], } } } Add a stylePreprocessorOptions mapping to your project angular.json { \"projects\": { .. \"prefix\": \"app\", \"architect\": { \"build\": { \"builder\": \"@angular-devkit/build-angular:browser\", \"options\": { ... \"aot\": true, \"stylePreprocessorOptions\": { \"includePaths\": [ \"node_modules/@infragistics\" ] } ... }, remove the ~ sign from your project sass imports for igniteui-angular/lib source: @use \"~igniteui-angular/lib/core/styles/themes/index\" as *; // Should be changed to @use \"igniteui-angular/lib/core/styles/themes/index\" as *; So, if you've already adopted npm and you have an Ignite UI for Angular license, don't hesitate setting up the Infragistics private feed and boost your productivity, using the full potential of Ignite UI for Angular. Access Token Usage You can also authenticate to our private npm feed using an access token, which you can acquire through your infragistics.com user account. The access token authentication is the preferred alternative when you want to integrate a CI process in a publicly accessible repository which uses the Ignite UI for Angular licensed packages. The following information is on how to setup authentication to our private npm registry using an access token in local configuration, Azure Pipelines build procedures and Travis CI build process: Generate a token from https://account.infragistics.com/package-feeds Note Each token is with Base64 encoding. Add the following into your .npmrc file @infragistics:registry=https://packages.infragistics.com/npm/js-licensed/ //packages.infragistics.com/npm/js-licensed/:_auth=YOUR_ACCESS_TOKEN //packages.infragistics.com/npm/js-licensed/:username=YOUR_USERNAME Azure Pipelines Configuration Update the azure-pipelines.yml with the following steps: steps: - script: npm config set @infragistics:registry $(npmRegistry) displayName: 'Npm add registry' - script: npm config set $(igScope):_auth=$(token) displayName: 'Npm config auth' Now we need to add variables for the npm registry, scope and token. There are two ways to do so: Define Variable Group from the Library page under Pipelines. This article explains how to use a variable group to store values that you want to control and make available across multiple pipelines. Define the variables in the Pipeline Settings UI and reference them in your YAML file. In the most common case, you set the variables and use them within the YAML file. Travis CI Configuration We will follow almost the same approach here. The only difference would be that the configuration will be set on before_install before_install: - echo \"@infragistics:registry=https://packages.infragistics.com/npm/js-licensed/\" >> ~/.npmrc - echo \"//packages.infragistics.com/npm/js-licensed/:_auth=$TOKEN\" >> ~/.npmrc The best way to define an environment variable depends on what type of information it will contain. So you have two options: encrypt it and add it to your .travis.yml add it to your Repository Settings GitHub Actions Configuration Add the following scripts before the npm i(ci) step to your CI workflow configuration: - run: echo \"@infragistics:registry=https://packages.infragistics.com/npm/js-licensed/\" >> ~/.npmrc - run: echo \"//packages.infragistics.com/npm/js-licensed/:_auth=${{ secrets.NPM_TOKEN }}\" >> ~/.npmrc Define secrets (encrypted environment variables) and use them in the GitHub actions workflow for sensitive information like the access token. View page on GitHub"
  },
  "components/general/localization.html": {
    "href": "components/general/localization.html",
    "title": "Localization (i18n) - Native Angular | Ignite UI for Angular",
    "keywords": "Localization (i18n) Currently, Ignite UI for Angular ships with resource strings for the following languages and scripts: Bulgarian, Czech, Danish, Dutch, English, French, German, Hungarian, Italian, Japanese, Korean, Norwegian, Polish, Portuguese, Romanian, Spanish, Swedish, Turkish, Traditional Chinese (zh-Hant) and Simplified Chinese (zh-Hans). These are available via the igniteui-angular-i18n package, except for English which comes as a default localization in igniteui-angular. With only a few lines of code, users can easily change the localization strings in Ignite UI for Angular components. Angular Localization Example Note: Hindi (HI) included in the sample is only for illustrational purposes and to emphasize on the possibility to pass a custom localization object. In this sample, it contains only several localized strings for the summary. More details at Utilize own localized resources section below. Usage Load localized resources from npm package You can localize an application in one of the languages available in the igniteui-angular-i18n package like this: Install the package by executing npm install igniteui-angular-i18n --save-dev Import the resource strings for the desired language and either change the strings for a component instance, using the component's resourceStrings input. <igx-grid [data]=\"data\" [resourceStrings]=\"resourcesDE\" [locale]=\"locale\"> <igx-grid-toolbar> <igx-grid-toolbar-title>German Locale</igx-grid-toolbar-title> </igx-grid-toolbar> <igx-column field=\"ProductName\" header=\"Product Name\" [groupable]=\"true\"> </igx-column> <igx-column field=\"QuantityPerUnit\" header=\"Quantity Per Unit\" [groupable]=\"true\"> </igx-column> <igx-column field=\"UnitPrice\" header=\"Unit Price\" [sortable]=\"true\" [hasSummary]=\"true\" [dataType]=\"'currency'\" [groupable]=\"true\"> </igx-column> <igx-column field=\"OrderDate\" header=\"Order Date\" [dataType]=\"'date'\" [groupable]=\"true\"> </igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" [dataType]=\"'boolean'\" [groupable]=\"true\"> </igx-column> </igx-grid> import { Component } from '@angular/core'; import { registerLocaleData } from '@angular/common'; import localeDE from '@angular/common/locales/de'; import { GridResourceStringsDE } from 'igniteui-angular-i18n'; @Component({ selector: 'app-locale', styleUrls: ['./locale.component.scss'], templateUrl: 'locale.component.html' }) export class LocaleComponent implements OnInit { public resourcesDE = GridResourceStringsDE; public locale = 'DE'; public data: any[]; constructor() { registerLocaleData(localeDE); } } Alternatively, you can call the changei18n() function passing the corresponding resource object to change the localization for all components. // app.component.ts import { Component, OnInit } from '@angular/core'; import { changei18n } from \"igniteui-angular\"; import { IgxResourceStringsJA } from 'igniteui-angular-i18n'; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent implements OnInit { public ngOnInit(): void { changei18n(IgxResourceStringsJA); } } Note: Feel free to contribute to the igniteui-angular-i18n package with more languages! Utilize own localized resources changei18n function expects an IResourceStrings object. If the language you want to use is not available in the igniteui-angular-i18n package, or simply want to change a particular string, you can pass a custom object containing your string resources for the language and components you need. This will change the global i18n for the igniteui-angular components. // app.component.ts import { Component, OnInit } from '@angular/core'; import { changei18n, IGridResourceStrings } from \"igniteui-angular\"; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent implements OnInit { public partialCustomHindi: IGridResourceStrings; public ngOnInit(): void { this.partialCustomHindi = { igx_grid_summary_count: 'गणना', igx_grid_summary_min: 'न्यून', igx_grid_summary_max: 'अधिक', igx_grid_summary_sum: 'योग', igx_grid_summary_average: 'औसत' }; // This will change all grid application instances' strings to the newly provided ones changei18n(this.partialCustomHindi); } } Alternatively, you may get all currently available component resource strings. There is objects for each component containing localizable strings. The values could be replaced in order to be localized and then the object can be passed to the changei18n function, as a parameter. // app.component.ts import { Component, OnInit } from '@angular/core'; import { changei18n, GridResourceStringsEN, TimePickerResourceStringsEN } from \"igniteui-angular\"; @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent implements OnInit { public ngOnInit(): void { const currentRS = { ...GridResourceStringsEN, ...TimePickerResourceStringsEN }; for (const key of Object.keys(currentRS)) { currentRS[key] = '[Localized] '+ currentRS[key]; } changei18n(currentRS); } } Localize specific strings for a specific instance of a component If only a single igx-grid instance should be localized, there is a way. The resourceStrings property should be used and it should be set to a new instance of IGridResourceStrings type. const newGridRes: IGridResourceStrings = { igx_grid_filter: '[Localized]Filter', igx_grid_filter_row_close: '[Localized]Close' } this.grid.resourceStrings = newGridRes; Available resource strings IgxResourceStringsBG IgxResourceStringsCS IgxResourceStringsDA IgxResourceStringsDE IgxResourceStringsES IgxResourceStringsFR IgxResourceStringsHU IgxResourceStringsIT IgxResourceStringsJA IgxResourceStringsKO IgxResourceStringsNB IgxResourceStringsNL IgxResourceStringsPL IgxResourceStringsPT IgxResourceStringsRO IgxResourceStringsSV IgxResourceStringsTR IgxResourceStringsZHHANS IgxResourceStringsZHHANT Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub Ignite UI for Angular ResourceStrings View page on GitHub"
  },
  "components/general/ssr-rendering.html": {
    "href": "components/general/ssr-rendering.html",
    "title": "Server-side rendering | Angular Universal | Ignite UI for Angular | Infragistics",
    "keywords": "Server-side Rendering with Angular Universal This topic aims at describing what Server-side Rendering is and how to configure it within Ignite UI for Angular application. Angular Universal All Angular applications run in the client's browser and often this may result in a negative performance hit on the First Meaningful Paint (FMP) i.e. when a browser first renders the primary content of a page. This is when Angular Universal comes in handy, you can generate the full HTML for a page on the server. It renders a client-side page to HTML on the server that is later bootstrapped on the client. Okay, but how it works? FMP measures when the primary content of a page is visible to the user, as for FCP metric, it measures how long it takes the browser to render the first piece of DOM content after a user navigates to your page. See Lighthouse performance scoring for more information. How it works? With Angular Universal, you will serve a static version of your apps' landing page, while at the same time the full Angular application loads in the background. The landing page will be pure HTML and will be displayed even if the JavaScript is disabled. More about Server Rendering you can find here. Usage Server-side rendering is one of the many techniques part of Rendering on Web guidelines, that can: Ease web crawlers to index your website higher in searches - will improve your Search Engine Optimization (SEO). Show the first page quickly - slow initial page load is disengaging for the users (if it takes more than 3 seconds to load). Improve your app performance - it will have a positive impact on both First Meaningful Paint and First Contentful Paint. It gives you full control over SEO and social-media previews, and it improves the overall perceived performance of your application by allowing users to see an initial painted view. Add SSR to existing Ignite UI application Step 1 - Add @nguniversal By using Angular CLI schematic we can run the following command: ng add @nguniversal/express-engine --clientProject ssr-example This schematic will perform several changes to your app client and server configurations, as well as npm commands and app.module updates. Step 2 - Define all browser-specific objects that are missing Since Universal apps run on the server and not in the browser, there are a few things you need to watch out for in your code. Browser-specific objects, such as window, document, or location are missing, so we recommend using of domino for Server-side DOM abstraction. Domino is a Server-side DOM implementation based on Mozilla's dom.js. install domino npm install domino - for server-side dom abstraction install xmlhttprequest npm i xmlhttprequest - If using IgxIconService to register icons Configure the \"server.ts\" // server.ts const domino = require('domino'); const fs = require('fs'); const path = require('path'); const template = fs .readFileSync(path.join('dist/browser', 'index.html')) .toString(); const window = domino.createWindow(template); // Ignite UI browser objects abstractions (global as any).window = window; (global as any).document = window.document; (global as any).Event = window.Event; (global as any).KeyboardEvent = window.KeyboardEvent; (global as any).MouseEvent = window.MouseEvent; (global as any).FocusEvent = window.FocusEvent; (global as any).PointerEvent = window.PointerEvent; (global as any).HTMLElement = window.HTMLElement; (global as any).HTMLElement.prototype.getBoundingClientRect = () => { return { left: '', right: '', top: '', bottom: '' }; }; // If using IgxIconService to register icons (global as any).XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest; // Other optional depending on your application configuration (global as any).object = window.object; (global as any).navigator = window.navigator; (global as any).localStorage = window.localStorage; (global as any).DOMTokenList = window.DOMTokenList; Step 3 - Start your universal app Run the following command: npm run build:ssr && npm run serve:ssr As alternative to Angular Express Engine you may use ASP.NET Core Engine for running Angular Apps with Server-side Rendering. Build a new application from scratch Use ng new or the Ignite UI CLI ig new command. Execute ng add igniteui-angular which installs the library's npm packages to your workspace and configures the project in the current working directory to use that library. Add Angular Universal with ng add @nguniversal/express-engine --clientProject ig-ssr-example. \"ig-ssr-example\" is your project name. Add Ignite UI for Angular components - e.g. Grid, Calendar et Configure the \"server.ts\" file to define all needed browser-specific objects, such as \"window\", \"document\", or \"location\". install domino npm install domino - for server-side dom abstraction install xmlhttprequest npm i xmlhttprequest - If using IgxIconService to register icons Use starter project Use the starter project that includes Ignite UI for Angular components. The project uses Angular CLI to quickly build a simple application with Angular Universal. Step 1 - Clone the starter repository git clone https://github.com/IgniteUI/ng-universal-example.git Step 2 - Use NPM to install the needed dependencies npm install Step 3 - Build and start the application by using: npm run build:ssr && npm run serve:ssr Other considerations If your application is using other browser-specific objects, wrap their usage in a conditional statement, so that they’ll only be used by Angular on the browser. You can do this by importing the functions isPlatformBrowser and isPlatformServer from @angular/common, injecting the PLATFORM_ID token into your component, and running the imported functions to see whether you’re on the server or the browser. If using ElementRef for HTML element handling, don’t use the nativeElement to manipulate attributes on the element. Instead, inject and use the Renderer2 methods. All URLs for server requests should be absolute, keep in mind that data requests from relative URLs will fail when running from the server. For handling browser events the Angular team provides the preboot library. This library buffers the events and replay them once the client-side script is loaded. When using Angular Universal, the server will pre-render pages that will be visible to the users, however, interactions will be limited. Once the client-side app is loaded in the background, it will seamlessly switch from showing the server-rendered pages to the client-side app. Useful resources Angular Universal guide Ignite UI Starter Kit Server-side rendering terminology Getting started with Ignite UI for Angular Ignite UI CLI Guide Ignite UI for Angular Schematics View page on GitHub"
  },
  "components/general/update-guide.html": {
    "href": "components/general/update-guide.html",
    "title": "Update Guide | Ignite UI for Angular | Infragistics",
    "keywords": "Update Guide In the Ignite UI for Angular versioning the first number always matches the major version of Angular the code supports and the second is dedicated for major version releases. Breaking changes may be introduced between major releases. A comprehensive list of changes for each release of Ignite UI for Angular can be found in the product CHANGELOG The Ignite UI for Angular package also supports automatic version migration through ng update schematics. Those will attempt to migrate all possible breaking changes (renamed selectors, classes and @Input/Output properties), however there might be still changes that cannot be migrated. Those are usually related to typescript application logic and will be described additionally below. First run the ng update command which will analyze your application and available updates for its packages. ng update To update the Ignite UI for Angular licensed package run the following command: ng update @infragistics/igniteui-angular To update the Ignite UI for Angular free package run the following command: ng update igniteui-angular When you update @infragistics/igniteui-angular or igniteui-angular - it's recommended to update @angular/core, @angular/cli and igniteui-cli packages to their matching versions. To update the Ignite UI CLI package run the following command: ng update igniteui-cli To update the Angular Core package run the following command: ng update @angular/core To update the Angular CLI package use the following command: ng update @angular/cli Note If the ng update command fails because of package dependency mismatches, then revert the update, delete the node_modules folder and rerun the update with --force flag. Additional manual changes Unfortunately not all changes can be automatically updated. Changes below are split into sections as they occur in the versions, so if any updates are required you should start from your current version and apply further updates from bottom to top. For example: if you are updating from version 6.2.4 to 7.1.0 you'd start from the \"From 6.x ..\" section apply those changes and work your way up: From 17.0.x to 17.1.x Breaking changes In version 17.1.x the icon type of the igxButton directive has been changed to the igxIconButton directive of type flat. Automatic migrations are available and will be applied on ng update. However, some of the igxButton input properties that could previously be used with the icon type buttons, cannot be applied to the newly created igxIconButton. If you have used the igxButtonColor or the igxButtonBackground properties with a button of type icon, you should update it as follows: // version 17.0.x <button igxButton=\"icon\" [igxButtonBackground]=\"'red'\"> <igx-icon fontSet=\"material\">search</igx-icon> </button> // version 17.1.x <button igxIconButton=\"flat\" [style.background]=\"'red'\"> <igx-icon fontSet=\"material\">search</igx-icon> </button> NOTE: Users have to manually add the IgxIconButtonDirective into their imports: import { IgxIconButtonDirective } from 'igniteui-angular'; @Component({ ... imports: [IgxIconButtonDirective] }) From 16.1.x to 17.0.x General In 17.0 Angular have removed the @nguniversal/* packages. If the project uses these packages a standard ng update call will cause an error in the igniteui-angular migrations due to improperly modified package-lock.json - more details can be found here. To update to 17.0.x one of the following additional steps needs to be taken: Delete the package-lock.json file before running ng update Run npm dedupe --legacy-peer-deps before running ng update igniteui-angular Breaking change In IgxCombo's selectionChanging event arguments type IComboSelectionChangingEventArgs has these changes: properties newSelection and oldSelection have been renamed to newValue and oldValue respectively to better reflect their function. Just like Combo's value, those will emit either the specified property values or full data items depending on whether valueKey is set or not. Automatic migrations are available and will be applied on ng update. two new properties newSelection and oldSelection are exposed in place of the old ones that are no longer affected by valueKey and consistently emit items from Combo's data. properties added and removed now always contain data items, regardless of valueKey being set. This aligns them with the updated newSelection and oldSelection properties. If your code in selectionChanging event handler was depending on reading valueKeys from the event argument, update it as follows: // version 16.1.x public handleSelectionChanging(e: IComboSelectionChangingEventArgs): void { this.addedItems = e.added; this.removedItems = e.removed; } // version 17.0.x public handleSelectionChanging(e: IComboSelectionChangingEventArgs): void { this.addedItems = e.added.map(i => { return i[e.owner?.valueKey] }); this.removedItems = e.removed.map(i => { return i[e.owner?.valueKey] }); } getCurrentResourceStrings has been removed. Use the specific component string imports instead. E.g. EN strings come from igniteui-angular: import { GridResourceStringsEN } from 'igniteui-angular'; E.g. DE or other language strings come from igniteui-angular-i18n: import { GridResourceStringsDE } from 'igniteui-angular-i18n'; Usage examples can be found in the updated Localization (i18n) doc. From 16.0.x to 16.1.x General Non-breaking changes We are moving away from the DisplayDensityToken injection token as a way to set the size of the components in favor of a simpler, more robust way - using CSS custom properties. For that reason the DisplayDensityToken injection token is now deprecated. This ripples across all components that expose the displayDensity input property. The token and input properties will be removed in 17.0.0. We urge you to do the following: Remove all declarations where the DisplayDensityToken is provided: // *.component.ts // remove the provider declaration for `DisplayDensityToken` providers: [{ provide: DisplayDensityToken, useValue: { displayDensity: DisplayDensity.compact } }], Remove all bindings or programmatic assignments to the displayDensity input property: <!-- Remove `[displayDensity]=\"'compact'\"` --> <igx-grid [displayDensity]=\"'compact'\">...</igx-grid> Instead, use the custom CSS property --ig-size to achieve the same result as with displayDensity: /* Add --ig-size to a component or global file. Available values are: - compact: --ig-size-small - cosy: --ig-size-medium - comfortable: --ig-size-large */ igx-grid { --ig-size: var(--ig-size-small); } From 15.1.x to 16.0.x The upgrade to Angular 16 comes with changes in how NgModules operate under the hood. Previously, adding a module that internally depends on another would make the declarations of both available in your app. This behavior was not intended and Angular 16 changes it. If your app was depending on this behavior, e.g. you were only importing a module containing many internal dependencies like IgxGridModule and using components coming with those, you will need to manually add the modules for each component your app uses separately. Breaking changes In 16.0.x, all grid properties, related to paging, are removed. Paging behavior is now configured and controlled entirely through the IgxPaginatorComponent. To enable paging in the grid, initialize the IgxPaginatorComponent in the grid and set related input properties and attach to event handlers to the paginator itself: <igx-grid ...> <igx-paginator #paginator [totalRecords]=\"totalRecords\" [perPage]=\"25\" (pageChange)=\"pageChange($event) (perPageChange)=\"perPageChange($event)\"> </igx-paginator> <igx-grid> @ViewChild('grid', { static: true }) private grid: IgxGridComponent; @ViewChild('paginator', { static: true }) private paginator: IgxPaginatorComponent; // prior version 16.0.x public onButtonClick(event) { this.grid.nextPage(); this.grid.previousPage(); this.grid.paginate(0); } // from version 16.0.x public onButtonClick(event) { this.paginator.nextPage(); this.paginator.previousPage(); this.paginator.paginate(0); } In 16.0.x, grid method getCellByColumnVisibleIndex(rowIndex: number, index: number) is removed. Instead, use: getCellByKey(rowSelector: any, columnField: string) or getCellByColumn(rowIndex: number, columnField: string). Example: // prior version 16.0.x const cell = grid.getCellByColumnVisibleIndex(rowIndex, columnIndex); // after version 16.0.x const rowKey = grid.getRowByIndex(rowIndex).key; const columnField = grid.getColumnByVisibleIndex(columnIndex).field; const cell = grid.getCellByKey(rowKey, columnField); const cell = grid.getCellByColumn(rowIndex, columnField); From 15.0.x to 15.1.x Breaking change rowSelectionChanging arguments type is changed. Now the oldSelection, newSelection, added and removed collections, part of the IRowSelectionEventArgs interface, no longer consist of the row keys of the selected elements (when the grid has set a primaryKey), but now in any case the row data is emitted. When the grid is working with remote data and a primaryKey is set - for the selected rows that are not currently part of the grid view, a partial row data object will be emitted. If your code in rowSelectionChanging event handler was depending on reading primaryKeys from the event argument, update it as follows: // prior version 15.1.x public handleRowSelection(e: IRowSelectionEventArgs): void { this.selectedRows = e.newSelection; } // after version 15.1.x public handleRowSelection(e: IRowSelectionEventArgs): void { this.selectedRows = e.newSelection.map(rec => { return rec[e.owner?.primaryKey] }); } Behavioral Change When selected row is deleted from the grid component, rowSelectionChanging event is not emitted. Visual Change In 15.1 the sizes of the input components have increased. This is more noticeable when using the Material theme. We do this to match Material spec. If your application is negatively affected by the change, you can use the displayDensity input and set it to a more dense setting, e.g. from comfortable to cozy or from cozy to compact. Example <igx-input-group displayDensity=\"cosy\"> ... </igx-input-group> <igx-select displayDensity=\"cosy\"> ... </igx-select> <igx-combo displayDensity=\"cosy\"> </igx-combo> <igx-simple-combo displayDensity=\"cosy\"> ... </igx-simple-combo> In 15.1 select and combo component now have background around the toggle icon. You can change the background and the icon color using scss or css. Example $my-select: select-theme( $toggle-button-background: red, $toggle-button-foreground: #fff, ); $my-combo: combo-theme( $toggle-button-background: red, $toggle-button-foreground: #fff, ); @include css-vars($my-select); @include css-vars($my-combo); **Example** .igx-select { --igx-select-toggle-button-background: red; --igx-select-toggle-button-foreground: #fff; } .igx-combo { --igx-combo-toggle-button-background: red; --igx-combo-toggle-button-foreground: #fff; } From 14.2.x to 15.0.x General igxGrid, igxHierarchicalGrid, igxTreeGrid Parameters in grid templates now have types for their context. This can also cause issues if the app is in strict template mode and uses the wrong type. References to the template that may require conversion: IgxColumnComponent - ColumnType (for example the column parameter in igxFilterCellTemplate) IgxGridCell - CellType (for example the cell parameter in igxCell template) Ignite UI for Angular has a dependency on igniteui-theming. Add the following preprocessor configuration in your angular.json file. \"build\": { \"options\": { \"stylePreprocessorOptions\": { \"includePaths\": [\"node_modules\"] } } } Breaking Change - All global CSS variables for theme configuration, colors, elevations, and typography have changed the prefix from --igx to --ig. This change doesn't affect global component variables; Example: In 14.2.x: :root { --igx-typography: 'Titillium Web', sans-serif; } In 15.0.x this becomes: :root { --ig-typography: 'Titillium Web', sans-serif; } Themes Breaking Change - The grays input argument has been renamed to gray. Here's how that will affect existing code: In 14.2.x: $my-palette: palette( $primary: #09f, $secondary: #e41c77, $grays: #000 ); .my-class { background: color($color: 'grays', $variant: 300); color: contrast-color($color: 'grays', $variant: 300); border-color: hsl(var(--igx-grays-500)); } In 15.0.x and going forward: $my-palette: palette( $primary: #09f, $secondary: #e41c77, $gray: #000 ); .my-class { background: color($color: 'gray', $variant: 300); color: contrast-color($color: 'gray', $variant: 300); border-color: hsl(var(--ig-gray-500)); } Breaking Change - Generating CSS variables for a palette is now done by the palette mixin, instead of the palette-vars mixin. Breaking Change - The palette function now requires a surface color to be passed, while passing a value for the gray color is optional. If a value for the gray base color is not provided, it will be generated automatically based on the lightness of the surface color - light surface color results in a black(#000) gray base color, whereas a dark surface color generates a white(#fff) base gray color. When you're generating a palette, you have to keep in mind that there are no longer default values for info, success, error and warn colors. You have to set them explicitly if you want to use them. You can also grab those colors from an existing palette if you don't want to come up with the values yourself. Example: $my-palette: palette( $primary: #09f, $secondary: #e41c77, $surface: #fff, $info: color($light-material-palette, 'info'), $success: color($light-material-palette, 'success'), $error: color($light-material-palette, 'error'), $warn: color($light-material-palette, 'warn'), ); @include palette($my-palette); Breaking Change - The palette parameter is now removed from all component themes. You can use the palette mixin to scope a custom palette in for a custom component component theme. Since we dropped support for IE11 all component themes refer to the global CSS variables for colors, elevations, typography, etc., therefore passing a custom palette to a component theme is no longer necessary. Generating a custom theme with a custom palette: // app.component.scss $my-palette: palette( $primary: royalblue, $secondary: orange, $surface: white ); $avatar: avatar-theme( $background: color($color: 'primary'), $color: contrast-color($color: 'primary') ); :host ::ng-deep { // Include the custom palette in the scope of the app component. // It will have a higher specificity than the global palette. @include palette($my-palette): .my-avatar { @include avatar($avatar); } } Typography Breaking Change - The type-style mixin now doesn't accept type-scale as a parameter, only the category name. In 14.2.x and prior: .my-class { @include type-style($type-scale: $my-type-scale, $category: h1); } In 15.0.x and forward: .my-class { @include type-style(h1); } Elevations Breaking Change - The elevation function now has only one named argument - $name (the elevation name). Breaking Change - The elevations function has been removed, you can now configure the elevation colors, using the configure-elevations mixin. In 14.2.x and prior: .my-class { box-shadow: elevation($elevations, $elevation: 8); } In 15.0.x and forward: .my-class { box-shadow: elevation(8); } Grid Toolbar Breaking Change - The IgxGridToolbarTitleDirective and IgxGridToolbarActionsDirective have been converted to components, keeping only the element selector. For apps using the preferred element markup of <igx-grid-toolbar-title> and <igx-grid-toolbar-actions> there should be no functional change. Apps using the igxGridToolbarTitle and igxGridToolbarActions directives on other elements will need to convert those to the mentioned elements instead: From: <igx-grid-toolbar> <span igxGridToolbarTitle>Title</span > <div igxGridToolbarActions> ... </div> </igx-grid-toolbar> To: <igx-grid-toolbar> <igx-grid-toolbar-title>Title</igx-grid-toolbar-title> <igx-grid-toolbar-actions> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> From 13.1.x to 13.2.x Themes Breaking Change - All RTL specific stylesheets have been removed. Ignite UI themes now support RTL directon by default. Users who have previously used *-rtl.css specific themes must switch to the regular theme files. From 13.0.x to 13.1.x General igxGrid, igxHierarchicalGrid, igxTreeGrid Breaking Change - The columns' movable property has been deprecated. Use the exposed grid moving property instead: <igx-grid [moving]=\"true\"> </igx-grid> IgxHierarchicalGrid Breaking Change - The public API service for igxHierarchicalGrid and igxRowIsland components hgridAPI is renamed to gridAPI. IgxToast Breaking Change - The igx-toast deprecated position property has been removed. We suggest using positionSettings property as follows: @ViewChild('toast', { static: true }) public toast: IgxToastComponent; public ngOnInit(): void { this.toast.positionSettings.verticalDirection = VerticalAlignment.Middle; } From 12.2.x to 13.0.x General IE discontinued support IgxDialog Breaking Change - The default positionSettings open/close animation has been changed to fadeIn/fadeOut. igxGrid, igxHierarchicalGrid, igxTreeGrid Breaking Change - The following deprecated inputs have been removed - showToolbar, toolbarTitle, columnHiding, columnHidingTitle, hiddenColumnsText, columnPinning, columnPinningTitle, pinnedColumnsText. Use IgxGridToolbarComponent, IgxGridToolbarHidingComponent, IgxGridToolbarPinningComponent instead. Breaking Change - Upon adding of igx-toolbar component, now you should manually specify which features you want to enable - Column Hiding, Pinning, Excel Exporting. Advanced Filtering may be enabled through the allowAdvancedFiltering input property on the grid, but it is recommended to enable it declaratively with markup, as with the other features. Breaking Change - The rowSelected event is renamed to rowSelectionChanging to better reflect its function. Breaking Change - The columnSelected event is renamed to columnSelectionChanging to better reflect its function. Breaking Change - columnsCollection is removed. Use columns instead. If at certain ocasions columns return empty array, query the columns using ViewChildren and access those in ngAfterViewInit: @ViewChildren(IgxColumnComponent, { read: IgxColumnComponent }) public columns: QueryList<IgxColumnComponent>; Breaking change - when applying a custom directive on the grid, inject the IGX_GRID_BASE token in the constructor in order to get reference to the hosting grid: <igx-grid customDirective ...></igx-grid> @Directive({ selector: '[customDirective]' }) export class customDirective { constructor(@Host() @Optional() @Inject(IGX_GRID_BASE) grid: IgxGridBaseDirective) { } RowDirective, RowType Breaking Change - rowData and rowID properties are removed from RowDirective and from classes implementing the RowType interface. Use data and key instead. Use ng update for automatic migration. Automatic migration will not be able to pick up some examples from templates, where the template context object is not typed: <ng-template igxCell let-cell=\"cell\"> <span>{{ cell.rowID }}</span> <span>{{ cell.row.rowData.ProductID }}</span> </ng-template> Update such templates manually to <span>{{ cell.key }}</span> <span>{{ cell.row.data.ProductID }}</span> igxGrid Exposed a groupStrategy input that functions similarly to sortStrategy, allowing customization of the grouping behavior of the grid. IgxCsvExporterService, IgxExcelExporterService Exporter services are no longer required to be provided in the application since they are now injected on a root level. IgxGridToolbarPinningComponent, IgxGridToolbarHidingComponent Exposed new input buttonText which sets the text that is displayed inside the dropdown button in the toolbar. IgxCombo Added groupSortingDirection input, which allows you to set groups sorting order. IgxGrid, IgxTreeGrid, IgxHierarchicalGrid Added new directives for re-templating header sorting indicators - IgxSortHeaderIconDirective, IgxSortAscendingHeaderIconDirective and IgxSortDescendingHeaderIconDirective. IgxDialog Added focusTrap input to set whether the Tab key focus is trapped within the dialog when opened. Defaults to true. IgxColumnActionsComponent Breaking Change - The following input has been removed Input columns. Use igxGrid columns input instead. IgxCarousel Breaking Changes -The carousel animation type CarouselAnimationType is renamed to HorizontalAnimationType. IgxGridStateDirective - now supports disableHiding column prop and column groups Theming Icon component color property has been deprecated. Use style.color CSS property to change its default color. Examples: <igx-icon [style.color]=\"'#e41c77'\">home</igx-icon> <igx-icon style.color=\"{{ col.hasSummary ? '#e41c77' : '' }}\">functions</igx-icon> Sass Modules: The theming engine has switched to Sass modules. This change means all theming library functions(comopnent themes, etc.), mixins(component mixins, etc.), and variables are now being forwarded from a single file. To correctly use the Sass theming library, your project should utilize Dart Sass version 1.33.0 or later and change all imports of the theming library from: // free version @import '~igniteui-angular/lib/core/styles/themes/index'; // licensed version @import '~@infragistics/igniteui-angular/lib/core/styles/themes/index'; to: // free version @use 'igniteui-angular/theming' as *; // licensed version: @use '@infragistics/igniteui-angular/theming' as *; If you want to import the entire theming library only once and then use it in other Sass files in your app, make sure to do forward it. Imported Sass files are not going to be automatically forwarded. Before: // _variables.scss // free version @import '~igniteui-angular/lib/core/styles/themes/index'; // licensed version @import '~@infragistics/igniteui-angular/lib/core/styles/themes/index'; // _other-file.scss @import 'variables'; After: // _variables.scss // free versioin @use 'igniteui-angular/theming' as *; @forward 'igniteui-angular/theming'; // licensed version @use '@infragistics/igniteui-angular/theming' as *; @forward '@infragistics/igniteui-angular/theming'; // _other-file.scss @use 'variables' as *; Palettes and Schemas: CSS palette variables do not refer to HEX values anymore, instead they represent a list of 3 values H, S, and L, which means they should be passed to either the hsl or hsla CSS functions. Before: .some-class { background: var(--igx-surface-500); // returns HEX color } After: .some-class { background: hsl(var(--igx-surface-500)); // returns a list of H, S, L } This was done so that palettes can be changed at runtime using CSS variables only. In this way the alpha channel for a given palette color can be modified at runtime without affecting the underlying palette color. Please ensure the correct palette and component schema are passed to your custom-made component and global themes. If you want to create a global dark theme, make sure to select a lighter color shade for your gray color, for instance: $my-dark-palette: palette( $primary: olive, $secondary: yellow, $grays: #fff ); @include dark-theme($palette: $my-dark-palette); Likewise, light themes require a darker shade of gray and a light color schema. If you've not excluded any component themes from the global theme but you still want to create your own custom replacement themes using the css-vars mixin, make sure the theme is passed the correct palette and correspoding schema: $my-custom-grid: grid-theme( $palette: $my-dark-palette, $schema: $dark-schema ); @include css-vars($my-custom-grid); Excluded Component Themes: In case you've excluded some component themes from the global theme and you've created custom replacement themes, you should ensure that the component mixin is included and is passed the correct component theme: $my-dark-palette: palette( ... $exclude: ('igx-grid') ); $my-custom-grid: grid-theme( $palette: $my-dark-palette, $schema: $dark-schema ); // Ensuregrid is included: @include grid($my-custom-grid); In case your custom component themes are declared in a separate component Sass file, other than the global styles.scss, ensure the core mixin is also included. // free version @use 'igniteui-angular/theming' as *; // licensed version @use '@infragistics/igniteui-angular/theming' as *; // Include the core module mixin. @include core(); // Create your theme. $my-custom-grid: grid-theme( $palette: $my-dark-palette, $schema: $dark-schema ); // Include your custom theme styles. @include grid($my-custom-grid); To get a better grasp on the Sass Moule System, you can read this great article by Miriam Suzanne; From 12.0.x to 12.1.x Grids Breaking Changes: IgxPaginatorComponent - The way the Paginator is instantiated in the grid has changed. It is now a separate component projected in the grid tree. Thus the [paging]=\"true\" property is removed from all grids and all other properties related to the paginator in the grid are deprecated. It is recommended to follow the guidance for enabling Grid Paging features as described in the Paging topic. IgxPageSizeSelectorComponent and IgxPageNavigationComponent are introduced to ease the implementation of any custom content: <igx-paginator #paginator> <igx-paginator-content> <igx-page-size></igx-page-size> [My custom text] <igx-page-nav></igx-page-nav> </igx-paginator-content> </igx-paginator> The API for the paging component was changed during the refactor and many of the old properties are now deprecated. Unfortunately, having an adequate migration for some of these changes is complicated to say the least, so any errors should be handled at application level. The following properties are deprecated from the Grid: paging, perPage page, totalPages, isFirstPage, isLastPage, pageChange, perPageChange, pagingDone The following methods, also are deprecated: nextPage() previousPage() The following property has been removed: paginationTemplate - in order to define a custom template, use the igx-paginator-content HierarchicalGrid specifics - The following usage of *igxPaginator Directive is necessary when it comes to enabling paging on RowIslands: <igx-hierarchical-grid #hGrid > <igx-column *ngFor=\"let c of hColumns\" [field]=\"c.field\"> </igx-column> <igx-row-island [key]=\"'childData'\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'childData'\" [autoGenerate]=\"true\"> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-row-island [key]=\"'childData2'\" [autoGenerate]=\"true\"> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-paginator></igx-paginator> </igx-hierarchical-grid> While the migration will move your template content inside the igx-paginator-content content, it might not resolve all template bindings. Make sure to check your template files after the migration. The following bindings should be changed manually as these properties have been removed (pagerEnabled, pagerHidden, dropdownEnabled, dropdownHidden): From: <igx-paginator #paginator [pagerEnabled]=\"!isPagerDisabled\" [pagerHidden]=\"isPagerHidden\" [dropdownHidden]=\"isDropdownHidden\"> </igx-paginator> To: <igx-paginator #paginator *ngIf=\"!isPagerDisabled\"> <igx-paginator-content> <igx-page-size *ngIf=\"isDropdownHidden\"></igx-page-size> <igx-page-nav *ngIf=\"isPagerHidden\"></igx-page-nav> </igx-paginator-content> </igx-paginator> IgxGridCellComponent, IgxTreeGridCellComponent, IgxHierarchicalGridCellComponent, IgxGridExpandableCellComponent are no longer exposed in the public API. See sections below for detail guide on upgrading to the new IgxGridCell. Grid Deprecation: The DI pattern for providing IgxGridTransaction is deprecated. The following will still work, but you are advised to refactor it, as it will likely be removed in a future version: @Component({ template: `<igx-grid [data]=\"data\"> ... </igx-grid>`, providers: [{ provide: IgxGridTransaction, useClass: IgxTransactionService }], ... }) export class MyCustomComponent { ... } In order to achieve the above behavior, you should use the the newly added batchEditing input: @Component({ template: `<igx-grid [data]=\"data\" [batchEditing]=\"true\"> ... </igx-grid>` ... }) export class MyCustomComponent { ... } getCellByColumnVisibleIndex is now deprecated and will be removed in next major version. Use getCellByKey, getCellByColumn instead. IgxGridCell migration IgxGridCellComponent, IgxTreeGridCellComponent, IgxHierarchicalGridCellComponent, IgxGridExpandableCellComponent are no longer exposed in the public API. Public APIs, which used to return an instance of one of the above, now return an instance of IgxGridCell: const cell = grid.getCellByColumn(0, 'ProductID'); // returns IgxGridCell const cell = grid.getCellByKey('ALFKI', 'ProductID'); // returns IgxGridCell const cell = grid.getCellByColumnVisibleIndex(0, 0); // returns IgxGridCell const rowCells = grid.getRowByIndex(0).cells; // returns IgxGridCell[] const selectedCells = grid.selectedCells; // returns IgxGridCell[] const cells = grid.getColumnByName('ProductID').cells; // returns IgxGridCell[] cell property in the IGridCellEventArgs event arguments emitted by cellClick, selected, contextMenu and doubleClick events is now an instance of IgxGridCell let-cell property in cell template is now IgxGridCell. getCellByColumnVisibleIndex is now deprecated and will be removed in next major version. Use getCellByKey, getCellByColumn instead. Please note: ng update will migrate the uses of IgxGridCellComponent, IgxTreeGridCellComponent, IgxHierarchicalGridCellComponent, IgxGridExpandableCellComponent, like imports, typings and casts. If a place in your code using any of the above is not migrated, just remove the typing/cast, or change it with IgxGridCell. getCellByIndex and other methods will return undefined, if the row at that index is not a data row, but is IgxGroupByRow, IgxSummaryRow, details row, etc. Themes Due to complaints pertaining to compilation warnings (see #9793) we now use the math.div function; This functionality is supported by Dart Sass from version 1.33.0 onward. Solution If for any reason you see Sass compilation errors saying math.div is not a known function it means you are using an outdated version of Sass in your project. Update to the latest version of Angular using ng update - Angular 12.1.0+ uses the dart-sass compiler by default. ng update [options] If for some reason you don't use the Ignite UI/Angular CLI, you'd need to replace node-sass with sass in your Node project. npm uninstall node-sass npm install sass --save-dev If for some reason you cannot upgrade to the latest version of Angular using the method above, you can fall back to the old Sass division method by setting a global flag in your Sass file: $__legacy-libsass: true; From 11.1.x to 12.0.x Themes Breaking Changes: IgxAvatar theme has been simplified. The number of theme params (avatar-theme) has been reduced significantly and no longer includes prefixed parameters(icon-*, initials-*, image-*) and suffixed parameters(border-radius-*). Updates performed with ng update will migrate existing avatar themes, but some additional tweaking may be required to account for the absence of prefixed and suffixed params. You will need to modify existing type specific avatar themes in the following way: For example, this: ```scss $avatar-theme: avatar-theme( $initials-background: blue, $initials-color: orange, $icon-background: blue, $icon-color: orange, ); @include avatar($avatar-theme); ``` Needs to be transformed into this: ```scss $initials-avatar: avatar-theme( $background: blue, $color: orange, ); $icon-avatar: avatar-theme( $background: blue, $color: orange, ); .initials-avatar { @include avatar($initials-avatar); } .icon-avatar { @include avatar($icon-avatar); } ``` IgxButton theme has been simplified. The number of theme params (button-theme) has been reduced significantly and no longer includes prefixed parameters (flat-*, raised-*, etc.). Updates performed with ng update will migrate existing button themes, but some additional tweaking may be required to account for the absence of prefixed params. In order to achieve the same result as from the code snippet below. ```html <button igxButton=\"raised\">Raised button</button> <button igxButton=\"outlined\">Outlined button</button> ``` ```scss $my-button-theme: button-theme( $raised-background: red, $outlined-outline-color: green ); @include css-vars($my-button-theme); ``` You have to create a separate theme for each button type and scope it to a CSS selector. html <div class=\"my-raised-btn\"> <button igxButton=\"raised\">Raised button</button> </div> <div class=\"my-outlined-btn\"> <button igxButton=\"outlined\">Outlined button</button> </div> ```scss $my-raised-button: button-theme( $background: red ); $my-outlined-button: button-theme( $border-color: red ); .my-raised-btn { @include css-vars($my-raised-button); } .my-outlined-btn { @include css-vars($my-outlined-button); } ``` As you can see, since the button-theme params now have the same names for each button type, we have to scope our button themes to a CSS selector in order to have different colors for different types. Here you can see all the available properties of the button-theme The typography mixin is no longer implicitly included with core. To use our typography styles you have to include the mixin explicitly after core and before theme: // in styles.scss @include core(); @include typography( $font-family: $material-typeface, $type-scale: $material-type-scale ); @include theme(); Important The core mixin should always be included first. For each theme included in Ignite UI for Angular we provide specific font-family and type-scale variables which you can use: Theme Font Family Type Scale Material $material-typeface $material-type-scale Fluent $fluent-typeface $fluent-type-scale Bootstrap $bootstrap-typeface $bootstrap-type-scale Indigo $indigo-typeface $indigo-type-scale IgxBottomNav component The IgxBottomNavComponent was completely refactored in order to provide more flexible and descriptive way to define tab headers and contents. It is recommended that you update via ng update in order to migrate the existing igx-bottom-nav definitions to the new ones. Template The new structure defines bottom navigation item components each wrapping a header and a content component. The headers usually contain an icon (Material guidelines) but may as well have a label or any other custom content. For header styling purposes we introduced two new directives - igxBottomNavHeaderLabel and igxBottomNavHeaderIcon. Since the header component now allows adding any content, the igxTab directive, which was previously used to retemplate the tab's header, was removed because it is no longer necessary. When the component is used in navigation scenario, the routerLink directive needs to be attached to the header component. <igx-bottom-nav> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon igxBottomNavHeaderIcon>folder</igx-icon> <span igxBottomNavHeaderLabel>Tab 1</span> </igx-bottom-nav-header> <igx-bottom-nav-content> Content 1 </igx-bottom-nav-content> </igx-bottom-nav-item> ... </igx-bottom-nav> API changes The id, itemStyle, panels, viewTabs, contentTabs and tabs properties were removed. Currently, the items property returns the collection of tabs. The following properties were changed: The tab item's isSelected property was renamed to selected. The selectedTab property was renamed to selectedItem. The onTabSelected and onTabDeselected events were removed. We introduced three new events, selectedIndexChanging,selectedIndexChange and selectedItemChange, which provide more flexibility and control over the tabs' selection. Unfortunately, having an adequate migration for these event changes is complicated to say the least, so any errors should be handled at project level. IgxTabs component The IgxTabsComponent was completely refactored in order to provide more flexible and descriptive way to define tab headers and contents. It is recommended that you update via ng update in order to migrate the existing igx-tabs definitions to the new ones. Template The new structure defines tab item components each wrapping a header and a content component. The headers usually contain an icon and a label but may as well have any other custom content. For header styling purposes we introduced two new directives - igxTabHeaderLabel and igxTabHeaderIcon. Since the header component now allows adding any content, the igxTab directive, which was previously used to retemplate the tab's header, was removed because it is no longer necessary. When the component is used in navigation scenario, the routerLink directive needs to be attached to the header component. <igx-tabs> <igx-tab-item> <igx-tab-header> <igx-icon igxTabHeaderIcon>folder</igx-icon> <span igxTabHeaderLabel>Tab 1</span> </igx-tab-header> <igx-tab-content> <h1>Tab 1 Content</h1> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p> </igx-tab-content> </igx-tab-item> ... </igx-tabs> API changes The id, groups, viewTabs, contentTabs and tabs properties were removed. Currently, the items property returns the collection of tabs. The following properties were changed: The tab item's isSelected property was renamed to selected. The selectedTabItem property was shortten to selectedItem. The type property, with its contentFit and fixed options, is no longer available. The header sizing & positioning mode is currently controlled by the tabAlignment input property which accepts four different values - start (default), center, end and justify. The old contentFit type corresponds to the current start alignment value and the old fixed type - to the current justify value. The tabItemSelected and tabItemDeselected events were removed. We introduced three new events, selectedIndexChanging, selectedIndexChange and selectedItemChange, which provide more flexibility and control over the tabs' selection. Unfortunately, having an adequate migration for these event changes is complicated to say the least, so any errors should be handled at project level. IgxGridComponent, IgxTreeGridComponent, IgxHierarchicalGridComponent IgxGridRowComponent, IgxTreeGridRowComponent, IgxHierarchicalRowComponent, IgxGridGroupByRowComponent are no longer exposed in the public API. Public APIs, which used to return an instance of one of the above, now return objects implementing the public RowType interface: const row = grid.getRowByIndex(0); const row = grid.getRowByKey(2); const row = cell.row; While the public API of RowType is the same as what IgxRowComponent and others used to expose, please note: toggle method, exposed by the IgxHierarchicalRowComponent is not available. Use expanded property for all row types: grid.getRowByIndex(0).expanded = false; row.rowData and row.rowID are deprecated and will be entirely removed with version 13. Please use row.data and row.key instead. row property in the event arguments emitted by onRowPinning, and dragData property in the event arguments emitted by onRowDragStart, onRowDragEnd is now implementing RowType ng update will migrate most of the uses of IgxGridRowComponent, IgxTreeGridRowComponent, IgxHierarchicalRowComponent, IgxGridGroupByRowComponent , like imports, typings and casts. If a place in your code using any of the above is not migrated, just remove the typing/cast, or change it with RowType. getRowByIndex will now return a RowType object, if the row at that index is a summary row (previously used to returned undefined). row.isSummaryRow and row.isGroupByRow return true if the row at the index is a summary row or a group by row. IgxInputGroupComponent The disabled property has been removed. The property was misleading, as the state of the input group was always managed by the underlying igxInput. Running ng update will handle all instances in which [disabled] was used as an @Input in templates. If you are referencing the property in a .ts file: export class CustomComponent { public inputGroup: IgxInputGroupComponent ... this.inputGroup.disabled = false; } you should please manually update your code to reference the underlying input directive's disabled property: export class CustomComponent { public input: IgxInputDirective ... this.input.disabled = false; } IgxDateTimeDirective, IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent The value property for IgxDateTimeDirective, IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent now accepts ISO 8601 string format. This means that value type could be Date or string. The inputFormat property of IgxDateTimeDirective, IgxDatePickerComponent, IgxTimePickerComponent, IgxDateRangePickerComponent now doesn't accept y for the year part. You should update it to yy. From 10.2.x to 11.0.x IgxGrid, IgxTreeGrid, IgxHierarchicalGrid The way the toolbar is instantiated in the grid has changed. It is now a separate component projected in the grid tree. Thus the showToolbar property is removed from all grids and all other properties related to the toolbar in the grid are deprecated. It is recommended to follow the recommended way for enabling toolbar features as described in the Toolbar topic. The igxToolbarCustomContent directive is removed. While the migration will move your template content inside the toolbar content, it does not try to resolve template bindings. Make sure to check your template files after the migration. The API for the toolbar component was changed during the refactor and many of the old properties are now removed. Unfortunately, having an adequate migration for these changes is complicated to say the least, so any errors should be handled at project level. From 10.0.x to 10.1.x IgxGrid, IgxTreeGrid, IgxHierarchicalGrid Since we have removed the IgxExcelStyleSortingTemplateDirective, IgxExcelStyleHidingTemplateDirective, IgxExcelStyleMovingTemplateDirective, IgxExcelStylePinningTemplateDirective, and IgxExcelStyleSelectingTemplateDirective directives used for templating some parts of the Excel style filter menu, you could use the newly added directives for templating the column and filter operations areas - IgxExcelStyleColumnOperationsTemplateDirective and IgxExcelStyleFilterOperationsTemplateDirective. We have also exposed all internal components of the Excel style filter menu so that they can be used inside custom templates. You can find more information about the new template directives in the Excel-Style Filtering Topic. IgxGrid The selectedRows() method has been refactored into an input property named. This breaking change allows users to easily change the grid's selection state at runtime. Pre-selection of rows is also supported. All instances where the selectedRows() method is called have to be rewritten without any parentheses. Binding to the selectedRows input property could look something like this: public mySelectedRows = [0, 1, 2]; <igx-grid [data]=\"myData\" rowSelection=\"multiple\" primaryKey=\"ID\" [selectedRows]=\"mySelectedRows\"> <!-- ... --> </igx-grid> From 9.0.x to 10.0.x IgxDropdown The display property of the dropdown item has been changed from flex to block. We have done this in order to have truncated text enabled by default. Due to that change, if there is more than text in the content of the dropdown item, the layout needs to be handled on the application level. The following example demonstrates how to style a dropdown item with an icon and text content so that they are vertically aligned. <igx-drop-down-item> <div class=\"my-styles\"> <igx-icon>alarm</igx-icon> <span>item text</span> </div> </igx-drop-down-item> .my-styles { display: flex; align-items: center; span { margin-left: 8px; } } From 8.x.x to 9.0.x Due to a breaking change in Angular 9 Hammer providers are no longer implicitly added please, refer to the following document for details: Because of this the following components require HammerModule to be imported in the root module of the application in order for touch interactions to work as expected: igxGrid igxHierarchicalGrid igxTreeGrid igxList igxNavigationDrawer igxTimePicker igxDatePicker igxMonthPicker igxSlider* igxCalendar igxCarousel * Note - igxSlider requires the HammerModule for all user interactions. You can use the following code snippet to update your app's root module file. import { HammerModule } from \"@angular/platform-browser\"; @NgModule({ ... imports: [ ... HammerModule ] }) Due to name changes made in some of the Enumerations we export, manual update is needed for their members. Here's a list of all changes made that require manual update: AvatarType.DEFAULT -> IgxAvatarType.CUSTOM Type.DEFAULT -> IgxBadgeType.PRIMARY IgxCardType.DEFAULT -> IgxCardType.ELEVATED IgxCardActionsLayout.DEFAULT -> IgxCardActionsLayout.START IgxDividerType.DEFAULT -> IgxDividerType.SOLID IgxProgressType.DANGER -> IgxProgressType.ERROR The ng update process will update all enumeration names, like AvatarType, Type, et al. to IgxAvatarType and IgxBadgeType, respectively. All other enumeration member names remain unchanged. From 8.1.x to 8.2.x IgxDrag Since hideBaseOnDrag and visible inputs are being deprecated, in order to achieve the same functionality in your application, you can use any way of hiding the base element that Angular provides. One example is setting the visibility style to hidden, since it will only make in invisible and keep its space that it takes in the DOM: <div igxDrag [ngStyle]=\"{ 'visibility': targetDragged ? 'hidden' : 'visible' }\" (dragStart)=\"onDragStarted($event)\" (dragEnd)=\"onDragEnded($event)\"> Drag me! </div> public targetDragged = false; public onDragStarted(event) { this.targetDragged = true; } public onDragEnded(event) { this.targetDragged = false; } Since animateOnRelease and dropFinished() are also being deprecated, any dropFinished() method usage should be replaced with transitionToOrigin(). Otherwise you would need to call transitionToOrigin() depending on when you would want the dragged element to transition back to its original location. Note that if the dragged element DOM position is changed, then its original location will also change based on that. IgxDrop Due to the default drop strategy provided with the IxgDrop directive is no longer applied by default, in order to continue having the same behavior, you need to set the new input dropStrategy to be the provided IgxAppendDropStrategy implementation. <div igxDrop [dropStrategy]=\"appendStrategy\"></div> import { IgxAppendDropStrategy } from 'igniteui-angular'; // import { IgxAppendDropStrategy } from '@infragistics/igniteui-angular'; for licensed package public appendStrategy = IgxAppendDropStrategy; Any use of interfaces IgxDropEnterEventArgs and IgxDropLeaveEventArgs should be replaced with IDragBaseEventArgs. Also any use of the IgxDropEventArgs interface should be replaced with IDropDroppedEventArgs. IgxRowDragDirective IRowDragStartEventArgs and IRowDragEndEventArgs have argument's name changed in order to be more clear to what it relates to. owner argument is renamed to dragDirective. The owner argument now provides a reference to the owner component. If your code was like: public dragStart(event) { const directive = event.owner; } From version 8.2.x it should be updated to: public dragStart(event) { const directive = event.dragDirective; const grid = event.owner; } IgxCombo The way that the igx-combo handles selection and data binding is changed. If the combo's [valueKey] input is defined, the control will look for that specific property in the passed array of data items when performing selection. All selection events are handled with the value of the data items' valueKey property. All combos that have valueKey specified should have their selection/two-way binding consist only of the values for the object property specified in the input: <igx-combo [data]=\"cities\" valueKey=\"id\" displayKey=\"name\"></igx-combo> export class MyExampleCombo { public data: { name: string, id: string }[] = [{ name: 'London', id: 'UK01' }, { name: 'Sofia', id: 'BG01' }, ...]; ... selectFavorites() { // Selection is handled with the data entries' id properties this.combo.selectItems(['UK01', 'BG01']); } } If the combo does not have a valueKey defined, all selection events are handled with equality (===). All combos that do not have a valueKey specified should have their selection/two-way binding handled with references to their data items: <igx-combo [data]=\"cities\" displayKey=\"name\"></igx-combo> export class MyExampleCombo { public data: { name: string, id: string }[] = [{ name: 'London', id: 'UK01' }, { name: 'Sofia', id: 'BG01' }, ...]; ... selectFavorites() { // Selection is handled with references to the data entries this.combo.selectItems([this.data[0], this.data[1]]); } } You can read more about setting up the combo in the readme and in the official documentation. From 8.0.x to 8.1.x The igx-paginator component is introduced as a standalone component and is also used in the Grid components. Keep in mind that if you have set the paginationTemplate, you may have to modify your CSS to display the pagination correctly. This is due to the fact that the template is no longer applied under a paging-specific container with CSS rules to center content, so you might need to add them manually. The style should be something similar to: <igx-grid #grid [data]=\"data\" [paging]=\"true\" [perPage]=\"10\" [paginationTemplate]=\"pager\"> </igx-grid> <ng-template #pager> <div class=\"pagination-container\"></div> </ng-template> .pagination-container { display: flex; justify-content: center; align-items: center; } From 7.3.x to 8.0.x While updating, if you face the following error Package \"@angular/compiler-cli\" has an incompatible peer dependency to \"typescript\" (requires \">=3.1.1 <3.3\", would install \"3.4.5\")., you should update @angular/core package first. This is related to this known Angular CLI issue While updating the igniteui-angular package, if you see the following error Package \"igniteui-angular\" has an incompatible peer dependency to \"web-animations-js\" (requires \"^2.3.1\", would install \"2.3.2-pr208\"), you should update using ng update igniteui-angular --force. This could happen if you update @angular/core and @angular/cli before updating igniteui-angular. From 7.2.x or 7.3.x to 7.3.4 If you use the filterGlobal method of IgxGrid, IgxTreeGrid or IgxHierarchicalGrid, you should know that the condition parameter is no longer optional. When the filterGlobal method is called with an invalid condition, it will not clear the existing filters for all columns. From 7.1.x to 7.2.x If you use an IgxCombo with combo.value, you should know that now combo.value is only a getter. If you use IgxTextHighlightDirective, you should know that the page input property is deprecated. rowIndex, columnIndex and page properties of the IActiveHighlightInfo interface are also deprecated. Instead, row and column optional properties are added. If you use the button-theme, you should know that the $button-roundness has been replaced for each button type with: $flat-border-radius, $raised-border-radius, $outline-border-radius, $fab-border-radius, $icon-border-radius. From 7.0.x to 7.1.x If you use an IgxGrid with summaries in your application, you should know that now the IgxSummaryOperand.operate() method is called with empty data in order to calculate the necessary height for the summary row. For custom summary operands, the method should always return an array of IgxSummaryResult with proper length. Before version 7.1: export class CustomSummary extends IgxNumberSummaryOperand { public operate(data?: any[]): IgxSummaryResult[] { return [{ key: 'average', label: 'average', summaryResult: IgxNumberSummaryOperand.average(data).toFixed(2) }]; } } Since version 7.1: export class CustomSummary extends IgxNumberSummaryOperand { public operate(data?: any[]): IgxSummaryResult[] { return [{ key: 'average', label: 'average', summaryResult: data.length ? IgxNumberSummaryOperand.average(data).toFixed(2) : null }]; } } From 6.0.x to 6.1.x If you use an IgxCombo control in your application and you have set the itemsMaxWidth option, you should change this option to itemsWidth View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/angular-events.html": {
    "href": "components/general/wpf-to-angular-guide/angular-events.html",
    "title": "Handling Angular Events | Event Binding | WPF to Angular Guide | Infragistics",
    "keywords": "Handling Angular Events The Angular events are emitted as a response to user interactions. When an Angular event is emitted, its event handling logic is executed. WPF provides routed events, CLR events, and commands. While in Angular, there are DOM events. Here is a simple example how you respond to a click event of a button in WPF: <Button Click=\"Button_Click\">Click Me</Button> private void Button_Click(object sender, RoutedEventArgs e) { Console.WriteLine(\"Hello World\"); } The same thing in Angular would look like this: <button (click)=\"onClicked()\">Click Me</button> onClicked() { console.log('Hello World'); } In WPF we are used to getting information about the event, such as the sender and the event arguments. In Angular we can use the $event variable. This variable will provide information about the event that was invoked. <button (click)=\"onClicked($event)\">Click Me</button> onClicked(event) { console.log(event.target); } Sometimes passing the event object might not be very useful. Instead, you may want to pass the value of an input on the page. <input #messageInput> <button (click)=\"onClicked(messageInput.value)\">Click Me</button> onClicked(message) { console.log(message); } Let's say that we want to print the value of an input on pressing Enter. You could do that in Angular like this: <input #messageInput (keyup)=\"onInputKeyup($event, messageInput.value)\"> onInputKeyup(event, message) { if (event.keyCode === 13) { console.log(message); } } Surprisingly, in Angular, there is an even easier way to do that. You could bind to the keyup.enter pseudo-event. Using this approach, the event handler will be called only when the user presses Enter. <input #messageInput (keyup.enter)=\"onInputKeyup(messageInput.value)\"> onInputKeyup(message) { console.log(message); } Responding to Events of a Component In WPF, when you create your own custom controls, often you need to extend or modify some base events like this: public class MyControl : Control { protected override void OnMouseDown(MouseButtonEventArgs e) { base.OnMouseDown(e); // Place your custom logic here } } In Angular, you achieve a similar result using the HostListener decorator. @Component({ selector: 'app-my-component', templateUrl: './my.component.html', styleUrls: ['./my.component.css'] }) export class MyComponent { @HostListener('mousedown', ['$event']) onMouseDown(event) { // place your custom logic here } } Create Your Own Events Sometimes you need to define your own events. In WPF you could define either CLR or routed events. Let's take a look at a simple example of a CLR event in WPF: public event EventHandler<TaskEventArgs> TaskCompleted; ... this.TaskCompleted(this, new TaskEventArgs()); In order to define a custom event in Angular, you have to define an EventEmitter property marked with the Output decorator. @Output() taskCompleted = new EventEmitter<TaskEventArgs>(); ... this.taskCompleted.emit(new TaskEventArgs()); Additional Resources Desktop to Web: Responding to Events with Angular Event Binding Angular User Input Component Interaction: Parent listens for child events Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/angular-pipes.html": {
    "href": "components/general/wpf-to-angular-guide/angular-pipes.html",
    "title": "Transform Data with Angular Pipes | WPF to Angular Guide | Infragistics",
    "keywords": "Transform Data with Angular Pipes You can use the Angular pipes to transform data from one value to another. This technic is similar to WPF converters. In WPF in order to transform data from one value to another, you are going to use an IValueConverter. To transform data in an Angular application, we are going to use a Pipe. The pipe is very similar to the WPF converter. It takes data as an input and then transforms that data into a desired output for display. Angular provides a number of predefined pipes for the most common data transformations. For example, if you want a header text to appear in upper case, you could use the UpperCasePipe. Using a pipe is very simple. After your expression, provide a pipe operator | followed by the pipe name. <h2>{{ header | uppercase }}</h2> What is really great about the pipes in Angular compared to a WPF converter is that you can actually use more than one pipe at a time. So, for example you can use a DatePipe and UpperCasePipe in order to format the date to a user-friendly format and make it uppercase: <h2>{{ birthday | date | uppercase }}</h2> Besides that, we also have the option to provide parameters to the pipe. For example, the DatePipe has parameters like format, time zone and locale. <h2>{{ birthday | date:\"MM/dd/yy\" }}</h2> Create Your Own Pipe Besides using the predefined pipes, Angular allows you to define your own pipes. Let's take a look at the implementation of a WPF converter that replaces a string with another one. public class ReplaceConverter : IValueConverter { public string OldValue { get; set; } public string NewValue { get; set; } public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { var strValue = value.ToString(); return strValue.Replace(this.OldValue, this.NewValue); } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotImplementedException(); } } <Window.Resources> <local:ReplaceConverter OldValue=\" \" NewValue=\"-\" x:Key=\"replaceConverter\"></local:ReplaceConverter> </Window.Resources> <Grid> <TextBlock Text=\"{Binding Path=Name, Mode=OneWay, Converter={StaticResource replaceConverter}}\"></TextBlock> </Grid> In order to do the same in Angular, we have to define a class that implements the PipeTransform interface and has the @Pipe decorator. import { Pipe, PipeTransform } from '@angular/core'; @Pipe({ name: 'replace' }) export class ReplacePipe implements PipeTransform { transform(value: string, oldValue: string, newValue: string): string { return value.replace(oldValue, newValue); } } <span>{{ name | replace:\" \":\"-\" }}</span> Note Note that in order to be able to use the pipe in the component's html template, you have to add it to the module declarations. Note An important difference between the Angular pipe and the WPF converter is that the Angular pipe works only for one-way binding unlike the WPF converter which has ConvertBack method. Additional Resources Desktop to Web: Transforming Data with Angular Pipes Angular Pipes List of Predefined Angular Pipes Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/create-first-angular-app.html": {
    "href": "components/general/wpf-to-angular-guide/create-first-angular-app.html",
    "title": "Create Your First Angular Application | WPF to Angular Guide | Infragistics",
    "keywords": "Create an Angular application Learn how to start creating an Angular application when you migrate from WPF to Angular. Prerequisites In order to start writing Angular applications, you need to install Node.js and the npm package manager. Node.js is a JavaScript runtime environment that executes JavaScript code outside of a browser. In order to get Node.js, go to nodejs.org. NPM is a package manager similar to the NuGet package manager for .NET. It is installed with Node.js by default. You will also need an IDE. One of the best environments for developing Angular applications is Visual Studio Code. It is free, open source, and runs on every platform. You can get it from code.visualstudio.com. Create new project If you are a WPF developer, creating new projects inside of Visual Studio is pretty straight forward. You would just click File -> New Project, select the project type, give it a name and press OK. Since you are going into the Angular world, you want to create a new project inside Visual Studio Code. However, there is no new project option here and that's because Visual Studio Code is file based and not project based. In order to create a new Angular application, we are going to use the command prompt. First you will need to install the Angular CLI. npm install -g @angular/cli Then navigate in the command prompt to the folder where you want your application to be created and execute the following command: ng new demo-app We are going to be prompted \"Would we like to add Angular routing?\". For this demo we will choose NO. Next, we are asked which stylesheet format would we like to use. We are going to stick with the basic CSS for now. It takes a few minutes, but eventually the process will complete and your new application will be created on the disk. Now we have to change directories to the demo-app folder that was just created and execute a command to open Visual Studio Code. cd demo-app code . This is going to launch a new instance of Visual Studio Code that contains your Angular application. Now this is the part that is probably the most overwhelming to desktop developers trying to learn Angular - the folder structure. Project structure Let's go ahead and take a look at each of these files and see how they relate to a WPF application. The best way to do that is to compare each project side by side. On the left we have our WPF app. On the right we have our Angular app. It is important to keep in mind that an Angular application is a single page application (SPA) which means there is only one page in the entire app, and that is your index.html. The index.html file could be compared to the App.xaml of the WPF application. They are both global and everything you put there will show up on every single page of your application. The index.html file contains a section <app-root></app-root> which is similar to the StartupUri of the App.xaml file and specifies the first page we want to show when the app launches. What happens technically is when you navigate to the index.html, the main.ts JavaScript file invokes which loads the AppModule. An Angular application is made up of modules and components. By default, you get a root module and a root component and those are going to be located under the app folder. when the main.ts file invokes, we're going to bootstrap the AppModule, which is in the app.module.ts file in the app folder. The app module then bootstraps its own AppComponent. The AppComponent is defined in the app.component.ts file and its selector is set to app-root. The AppComponent has its html template defined in the app.component.html file. Basically the <app-root></app-root> section in the index.html page will visualize the content of the app.component.html file. The main.ts file is similar to the App.xaml.cs file since it is something like a code behind. The app.component.html, which is the default component shown when the application runs, is very similar to the MainWindow.xaml in WPF. In WPF we have a packages.config file which defines all our dependencies to nuget packages while Angular has a package.json file which contains the dependencies that your application requires to run. The package.json file contains also a section for scripts that you can run in the console when you are testing, starting or building your application. Let's take a look at the References folder. In WPF we have a References node in our solution that shows all the references that are added to this project. In an Angular application that is actually going to be the nodes_module folder. Coming from WPF, you may be surprised how many dependencies an Angular project has. These are populated by using npm. Unfortunately, here the similarities end. Let us look at some of the other generated files and folders: e2e - stands for end-to-end testing and contains integration tests or tests with real-world scenarios like a login process. src - most of the application's code is located here. assets - contains your images or any other assets. environment - contains information about your build environments. favicon.ico - the icon that appears in the browser when you are at your site. karma.conf.js - contains configuration for the unit tests. style.css - stylesheet with styles that are global for your application, it is similar to a resource dictionary defined in App.xaml in WPF. Run the application Now we are ready to run the application, but in Visual Studio Code you cannot just press F5. We are going to open the Visual Studio Code Terminal by clicking in the menu on Terminal -> New Terminal or by pressing Ctrl + Shift + `. In order to run the application, you should execute the following command: ng serve After the application is started, you can open it in the browser on the following URL http://localhost:4200/. If you want your app to open automatically in the browser, you should use the following command: ng serve -o In this case -o stands for open. Another way to start the application is by using the npm commands: npm start You could find those scripts defined in the package.json file and modify the start command by adding the -o option: \"scripts\": { \"ng\": \"ng\", \"start\": \"ng serve -o\", Your first Angular application should look like this: Additional Resources Desktop to Web: Create your first Angular App Angular Application Shell Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/create-ui-with-components.html": {
    "href": "components/general/wpf-to-angular-guide/create-ui-with-components.html",
    "title": "Create a User Interface with Angular Components | WPF to Angular Guide | Infragistics",
    "keywords": "Create User Interface with an Angular component When it comes to creating user interface in an Angular application you can use an Angular component to facilitate the process. Creating a UI in Angular is very similar to how we would create one in WPF. We normally use user controls, represented by the UserControl class. A UserControl groups markup and code into a reusable container, allowing the same interface and functionality to be used in several different places. This user control will have a .xaml file for the UI markup and a C# file for the logic, and then it may even have a resource dictionary, which would contain any type of styling information for this user control. While in Angular, we use what's called a Component. A component has an html file, which is used for any UI markup. It has a typescript file, which is used for its properties and logic, and then it uses a CSS file for all its styling information. Let's go ahead and see just how similar these two are. On the left side, we have a WPF application, with a user control called Sample. It also has a resource dictionary called SampleResources that contains styling information. On the right side, we have an Angular application with an AppComponent. Let's go ahead and compare the Angular app component to that of the sample user control in the WPF application. Start by opening up the app component typescript file. We can think of this file as the code behind of the component, and the reason we think that way is because if we come over to the WPF and open up the Sample.xaml.cs, the code behind of the Sample user control, we can see a lot of similarities. First we can see that we have a class that we're exporting called AppComponent. Now, this AppComponent also has a property in it called title. So within this class we're going to define all the properties, methods and events required for our component to run. This is extremely similar if not the exact same of a user control. We can see that we have a class, in this case called Sample, and within this class, we're going to define all the properties, methods and events required for the user control to function. Next, let’s move up a few lines in the typescript file and look at this little weird syntax with the little @ symbol and then Component. This is actually called a decorator. This decorator is telling Angular how we're going to treat this class that we're exporting. In this case, we're going to treat it as a component and because we're treating it as a component, we have to provide some information in the decorator. Before we get to the information, let's first pay some attention to the very top line of the typescript file - import { Component } from '@angular/core'. You can think of this as a using statement. Essentially, we are importing the objects that are required for this component to function. In this case, we are importing the Component from the @angular/core module, so we can actually use the decorator for this component. That is extremely similar to a using statement inside of the code behind of our user control. We use using statements inside of C# to locate and use objects within our class that are required for the user control to function. Now, let's hop back inside of the component decorator. The line of code on line 4, is called a selector. The selector helps us determine how we're going to define these elements in html. This selector is called app-root, so if we go ahead and open up the index.html, we could see within the body an element called app-root. That element is using the selector defined in the component decorator to define an instance of this component. Next, on line 5, we have what's called a template URL. This is pointing to a file called app.component.html - the html file that represents the visual rendering of this component. This is extremely similar to the Sample.xaml file of the user control in WPF, where the xaml is the markup that represents how this control is going to render. On line 6, we see the style URLs. The style URL is pointing to a CSS file. This file represents the styling information of the component. So if we open up the app.component.css file, we can see that there's no styling information in here, but we can think of the CSS file as a direct mapping to a resource dictionary. The resource dictionary in XAML will contain all the styling information for the user control or elements within the user control, so that it renders according to our design. That is the exact same thing that you would do in CSS. Generate a component Now that we've seen just how similar an Angular component is to a WPF user control, let's create a new component and add it to our application. If you're a desktop developer, in WPF when you want to add a new user control, you simply right click in your project and say Add > User Control. Well, of course if you try to do the same thing in Visual Studio Code, you do not have that option. You only have new file, new folder. That means we have to hop into our terminal and use the Angular CLI to generate our component. So let's toggle a terminal by typing Control + Backtick. In the terminal we just type NG G for generate, C for component, and then provide a name for our component, e.g. sample. ng g c sample When the command completes, you'll notice a number of things have happened. First, we have a new folder with the same name we have given to our component. We also have four new files - an html file, a SPEC file, a typescript file, and a CSS file. We also made an update to the app.module.ts file. Look at the sample folder which contains our newly created component. We can see that all three files that are required for a component are there plus this extra SPEC file. This is actually a test file which we do not need for this article, so we're not going to bother with it now. We also made a modification to the app.module.ts, in which it added the sample component to the declarations section of our NgModule. Note This is important - whenever a new component is created, it must be declared in the declarations section of the NG module. This section essentially says what components belong to this module. Let's go back to our sample.component.ts file. It looks very similar to the app.component.ts file we covered above. In this case we have our import statement where we're importing our component. We have our component decorator where we are defining our selector as app-sample. We have our template URL as sample.component.html and we have our style URL sample.component.css. Let's go ahead and open up the html file where we can see a paragraph stating sample works!. We want to see this when we start the application so let's go to the app.component.html. We will delete most of the initial markup except for the title, and just add <app-sample></app-sample>. <div style=\"text-align:center\"> <h1> Welcome to {{ title }}! </h1> <app-sample></app-sample> </div> Run the application By typing npm start in the terminal, it will compile and build our application and launch it inside the browser. If all went well, our application should be running in the browser. We have welcome to app - the markup from the app component and then sample works!. This is the markup from our sample component that we just added. Let's now change our sample component a little by changing the text to 'This sample works very well!'. <p> This sample works very well! </p> Once we save and check the browser, we will see that we are indeed editing the html that is responsible for rendering the sample component. If we want to style our component, we need to look at our style URL. So let's open up our sample.component.css file and make the paragraph tag color red. p { color: red; } Once we save that and open up the browser, we should see that the styling in the CSS file has been applied to our sample component. Additional Resources Desktop to Web: Create your UI with Angular components Angular Introduction to Components Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/layout.html": {
    "href": "components/general/wpf-to-angular-guide/layout.html",
    "title": "Angular Page Layout Elements | WPF to Angular Guide | Infragistics",
    "keywords": "Page Layout In WPF, in order to layout the elements in your application, you need to put them inside a Panel. The panel is a container element that controls the arrangement of its child elements. In Angular, in order to customize the page layout and its child elements, you have to use CSS. Let us go through some of the most popular panels in WPF and see how we can achieve similar layout with CSS. StackPanel The StackPanel arranges its child elements into a single line that can be oriented horizontally or vertically. Let us add several buttons in a StackPanel and see how they look like in WPF: <StackPanel> <Button>1</Button> <Button>2</Button> <Button>3</Button> <Button>4</Button> <Button>5</Button> </StackPanel> If we want to achieve similar layout in Angular, we may use CSS Flexbox layout. The Flexible Box Layout Module is a powerful mechanism which allows designing a flexible responsive layout structure. In order to use the Flexbox layout, we have to define a container which has its display property set to flex. Also in order to stack the items vertically, we have to set the flex-direction property to column. <div class=\"flex-container\"> <button>1</button> <button>2</button> <button>3</button> <button>4</button> <button>5</button> </div> .flex-container { display: flex; flex-flow: column; } Here is the final result in the browser: The default value of the flex-direction property is row, which is equivalent to a StackPanel with Horizontal orientation in WPF. The flexbox also supports row-reverse and column-reverse directions which stack the items right to left and bottom to top respectively. WrapPanel The WrapPanel positions child elements in sequential position from left to right, breaking content to the next line at the edge of the containing box. Subsequent ordering happens sequentially from top to bottom or right to left, depending on the value of the Orientation property. Let us add several buttons in a WrapPanel and see how they look like in WPF: <WrapPanel> <WrapPanel.Resources> <Style TargetType=\"Button\"> <Setter Property=\"Width\" Value=\"150\"></Setter> </Style> </WrapPanel.Resources> <Button>1</Button> <Button>2</Button> <Button>3</Button> <Button>4</Button> <Button>5</Button> </WrapPanel> In order to achieve similar result in Angular, we will use the Flexbox layout again. As in the case with StackPanel, we have to set the display property to flex, but we also have to set the flex-wrap property to wrap. <div class=\"flex-container\"> <button>1</button> <button>2</button> <button>3</button> <button>4</button> <button>5</button> </div> .flex-container { display: flex; flex-wrap: wrap; } button { width: 150px; } Here is the final result in the browser: If you want to achieve a result similar to a WrapPanel with Orientation=\"Vertical\", you have to set the flex-direction property to column. The flex-flow property is a shorthand property for setting both the flex-direction and flex-wrap properties. .flex-container { display: flex; flex-flow: row wrap; } The flexbox supports some more CSS properties for aligning the items. You can learn more about them in this tutorial. Grid The Grid defines a flexible grid area consisting of columns and rows. Let us add several buttons in a Grid and see how they look like in WPF: <Grid> <Grid.ColumnDefinitions> <ColumnDefinition /> <ColumnDefinition /> <ColumnDefinition /> </Grid.ColumnDefinitions> <Grid.RowDefinitions> <RowDefinition Height=\"50\" /> <RowDefinition Height=\"50\" /> <RowDefinition Height=\"50\" /> <RowDefinition Height=\"50\" /> </Grid.RowDefinitions> <Button Grid.RowSpan=\"2\" Grid.ColumnSpan=\"2\">1</Button> <Button Grid.Column=\"2\">2</Button> <Button Grid.Row=\"1\" Grid.Column=\"2\">3</Button> <Button Grid.Row=\"2\">4</Button> <Button Grid.Row=\"2\" Grid.Column=\"1\">5</Button> <Button Grid.Row=\"2\" Grid.Column=\"2\">6</Button> <Button Grid.Row=\"3\" Grid.ColumnSpan=\"3\">7</Button> </Grid> In Angular, we could use the CSS Grid Layout Module, which offers a grid-based layout system, with rows and columns. In order to use the Grid layout, we have to define a container which has its display property set to grid or inline-grid. <div class=\"grid-container\"> <button class=\"button1\">1</button> <button>2</button> <button>3</button> <button>4</button> <button>5</button> <button>6</button> <button class=\"button7\">7</button> </div> .grid-container { display: grid; } Note The CSS Grid Layout is not supported in older browsers like Internet Explorer 11. Now let us define the columns of the grid using the grid-template-columns property. .grid-container { display: grid; grid-template-columns: auto auto auto; } We have defined three columns with width auto, which means they would have the same width. If you want to distribute the available space proportionally similar to the star sizing in WPF, you could use the flex sizing unit fr in CSS. The following code snippet defines two columns, the first one would receive one times the available space, while the second one would receive two times the available space: .grid-container { display: grid; grid-template-columns: 1fr 2fr; } Now we will add the rows with height of 50px each using the grid-template-rows property. .grid-container { display: grid; grid-template-columns: auto auto auto; grid-template-rows: 50px 50px 50px 50px; } If we open the application now it looks like this: You could see one important difference between the WPF and CSS grids. In WPF the default value of Grid.Row and Grid.Column is 0, while the CSS grid layout automatically assigns the next available row and column to its children. Now let us apply the column and row spans to the first and seventh buttons. We will use the grid-row and grid-column properties for that purpose. .button1 { grid-column: 1 / 3; grid-row: 1 / 3; } .button7 { grid-column: 1 / span 3; } First we specify the start row/column, then after the / symbol, we could specify either the end row/column or how many rows/columns the item should span. Unlike WPF, the CSS grid column numbering is not zero-based and the first row/column is 1. Here is the full CSS and the final result in the browser: .grid-container { display: grid; grid-template-columns: auto auto auto; grid-template-rows: 50px 50px 50px 50px; } .button1 { grid-column: 1 / 3; grid-row: 1 / 3; } .button7 { grid-column: 1 / span 3; } The grid-row and grid-column properties are shorthand properties for the grid-row-start, grid-row-end, grid-column-start and grid-column-end properties. You could learn more about the CSS Grid container and item properties in the tutorials in the Additional Resources section. Additional Resources CSS Flexbox CSS Grid Intro CSS Grid Container CSS Grid Item Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/one-way-binding.html": {
    "href": "components/general/wpf-to-angular-guide/one-way-binding.html",
    "title": "One-Way Data Binding in Angular | WPF to Angular Guide | Infragistics",
    "keywords": "What is one-way data binding in Angular One-way data binding in Angular (i.e. unidirectional binding) is a way to bind data from the component to the view (DOM) or vice versa - from view to the component. It is used to display information to the end-user which automatically stays synchronized with each change of the underlying data. This is similar to the one-way binding in WPF. What is Angular data binding? Data binding is widely used by programmers as this type of services significantly streamlines the process of updating any UI and also reduces the amount of boilerplate when building an app. Data binding in Angular is super easy, and unlike in WPF we don't have to worry about a data context, a view model, or INotifyPropertyChanged (INPC). All we have to worry about is an HTML file and a typescript file. With any data binding, the first thing you need are properties to bind to. So let's add a property called text into the component class, and set its value. In WPF, we need to set the DataContext and bind the property in XAML: public class IgniteUIClass { public string Text { get; set; } public IgniteUIClass() { this.Text = \"IgniteUI for Angular\"; } } ... public MainWindow() { InitializeComponent(); this.DataContext = new IgniteUIClass(); } <Label Content=\"{Binding Path=Text, Mode=OneWay}\"></Label> In Angular, we are directly binding a DOM property to a component's property: export class SampleComponent implements OnInit { text = 'IgniteUI for Angular'; constructor() { } ngOnInit() {} } <h2>{{ text }}</h2> Angular Data Binding Interpolation In the code from above, we simply display some text in the HTML by using a binding to the value of the text property. In this case, we are using interpolation to create a one-way binding. We do this by typing double curly braces, the name of the property - in our case text, and two closing curly braces. Another way to achieve the same result is to create h2 tag and bind the text property to its innerHTML property, by using the interpolation syntax again: <h2 innerHTML=\"{{ text }}\"></h2> There are two important things about interpolation. First, everything inside the curly braces is rendered as a string. Second, everything inside the curly braces is referred to as a template expression. This allows us to do more complex things, such as concatenation. For example, let's concatenate some text with the value of the text property: <h2>{{\"Welcome to \" + text }}</h2> The use of template expressions allows us to bind to javascript properties and methods as well. For example, we can bind to the text property's length which will result in the number 20: <h2>{{ text.length }}</h2> We can also bind to methods of that property, for example to toUpperCase(): <h2>{{ text.toUpperCase() }}</h2> This is a lot more powerful than the data binding in WPF and a lot easier to use too. We can even make mathematical calculations inside the template expression. For example, we can simply put 2 + 2 into the expression, and it will display the result, which is equal to 4: <h2>{{ 2 + 2 }}</h2> One more thing that we can do is to bind to actual methods from the typescript file. Here is a short example on how to achieve this: <h2>{{ getTitle() }}</h2> This getTitle() is a method defined in the typescript file. The result on the page is the returned value of that method: getTitle() { return 'Simple Title'; } Although the interpolation looks quite powerful, it has its limitations, for example - it only represents a string. So let's create a simple boolean property in the component class: export class SampleComponent implements OnInit { text = 'IgniteUI for Angular'; isDisabled = false; constructor() { } ... We will now create a simple input of type text and bind the isDisabled property to the input's disabled property: <input type=\"text\" disabled=\"{{ isDisabled }}\"> The expected result is that the input should be enabled, but it's disabled. This is because the interpolation returns a string, but the input's disabled property is of boolean type and it requires a boolean value. In order for this to work correctly, Angular provides property binding. Angular Property Binding Property binding in Angular is used to bind values for target properties of HTML elements or directives. The syntax here is a bit different than that of interpolation. With property binding, the property name is wrapped into square brackets, and its value does not contain curly braces - just the name of the property that it is bound to. <input type=\"text\" [disabled]=\"isDisabled\"> By using property binding, the input's disabled property is bound to a boolean result, not a string. The isDisabled value is false and running the app would display the input as enabled. Note It is very important to remember that when a binding relies on the data type result, then a property binding should be used! If the binding simply relies on a string value, then interpolation should be used. Additional Resources Desktop to Web: One-way data binding with Angular interpolation and property binding Two-way binding in Angular Angular Displaying Data Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/structural-directives.html": {
    "href": "components/general/wpf-to-angular-guide/structural-directives.html",
    "title": "Angular Structural Directives | ngIf, ngswitch | WPF to Angular Guide | Infragistics",
    "keywords": "Angular Structural Directives When it comes to control the appearance of the visual tree elements’ appearance in WPF, the most common way is to use binding and visibility converter, which requires some extra logic and static resources. Angular also has a similar technique, which changes the appearance or behavior of a DOM element - the Angular directives. One of the Angular directives type is the structural directives – they change the DOM layout by adding or removing DOM elements. In this topic, we are going to demonstrate the following three structural directives - ngIf, ngSwitch and ngFor. As one can tell from their names, each of these can be compared to a C# structure. The ngIf is the same thing as an \"if-else\" C# code block, the ngSwitch is the same thing as the C# switch-case statement and, lastly, the ngFor is the exact same thing as a C# \"for-loop\". ngIf Directive Let’s explore each of these directives, starting with the ngIf. This directive allows us to show or hide elements based on a boolean condition. We will start by creating a \"div\" element with an \"h2\" tag containing a name. <div> <h2>John</h2> </div> If we save this, our browser will render the name John. However, let’s say we have some type of boolean expression that we want to base the condition of the visibility of this \"h2\" tag on. For example, we are going to add a property called \"isFirstName\" and set it to false. In order to tell our div to be rendered when isFirstName equals true, we should use the following syntax *ngIf = \"isFirstName\". public isFirstName = false; <div *ngIf=\"isFirstName\"> <h2>John</h2> </div> Once we save the files, and because isFirstName is false, we will see that the name is no longer rendered in the browser. However, if we were to update isFirstName to be true, the \"John\" first name will be rendered in the browser. If we set isFirstName back to false, we'll notice that the first name is no longer rendered in our browser, instead it's empty. That's the default behavior of the ngif statement - if the expression is true we render the provided template otherwise it's empty. If we were to achieve the same behavior with WPF, we would need to use a visibility converter. The code would look similar to the following: public bool IsFirstName { get; set; } public Sample() { InitializeComponent(); this.DataContext = this; this.IsFirstName = true; } <UserControl.Resources> <BooleanToVisibilityConverter x:Key=\"VisibleIfTrueConverter\" /> </UserControl.Resources> <Grid> <Label Visibility=\"{Binding Path=IsFirstName, Converter={StaticResource VisibleIfTrueConverter}}\">John</Label> </Grid> In Angular, it is a lot easier and more straightforward. Let's create a requirement that states if the isFirstName property is false we want to provide a last name instead. To do that we're going to take advantage of the \"else\" clause of the ngIf directive. Let's start by creating an ng-template defining an \"h2\" tag which contains the last name. An ng-template is simply a placeholder that allows us to define content that is not part of the DOM, but can be added via code such as using the ngIf directive. But, in order to use this in the directive, we need to give it a template reference variable name such as \"lastname\". Now that we have named our ng-template, let's go into our ngIf directive, add \"; else lastname\" and save this. Because \"isFirstName\" is false, we are saying else use the lastname, which means are using the template with the last name. <div *ngIf=\"isFirstName; else lastname\"> <h2>John</h2> </div> <ng-template #lastname> <h2>Doe</h2> </ng-template> Now, another way we can write this is we can say \"isFirstName; then firstname; else lastname\". So in order to do that, we need to create another template called \"firstname\". <div *ngIf=\"isFirstName; then firstname; else lastname\"> </div> <ng-template #firstname> <h2>John</h2> </ng-template> <ng-template #lastname> <h2>Doe</h2> </ng-template> If we change \"isFirstName\" to true, the first name will be rendered in the browser. And one final tip on using the ngIf directive is that the expression is not limited to a single property - you can actually use multiple properties and/or functions as long as the expression as a whole returns a boolean result. For example we can even use logical operators such as \" && isValid || getIsValidName()\". ngSwitch Directive The next directive we will discuss is the ngSwitch directive. This allows us to compare one expression to multiple expressions to decide which templates to add or remove. Let’s say we have \"h2\" elements that represent makes of cars – Chevy, Ford and GMC. We would like to display only one of these items based on a value of a \"make\" property which we have defined in our typescript file with a default value of \"Chevy\". To achieve this we need to use the ngSwitch directive with the following syntax [ngSwitch] = expression where expression is our \"make\" property. Adding this to the \"div\" element wrapping the \"h2\" tags is not enough. Like in WPF, we need to add some \"case\" statements to each \"h2\" element. The syntax for that is *ngSwitchCase = expression. In this case, we are comparing directly against text, so we will add single quotes around the value which means that the final result would be *ngSwitchCase = \"'Chevy'\" /similar for the other two values/. make = \"Chevy\"; <div [ngSwitch]=\"make\"> <h2 *ngSwitchCase=\"'Chevy'\">Chevy</h2> <h2 *ngSwitchCase=\"'Ford'\">Ford</h2> <h2 *ngSwitchCase=\"'GMC'\">GMC</h2> </div> Once we save that, we are only going to see the Chevy option rendered in the browser because the value of our \"make\" property is set to \"Chevy\". If we change it, to say \"GMC\", and save that, only the GMC option will be rendered in the browser. Now, what happens if we add an option that is not available, say the \"Lambo\". Nothing would be rendered because that did not match any of our conditions. When we normally use a switch statement inside of C#, we have not only the case but also default value. The same is available in Angular – we can add another option with the \"Not Found\" text and mark it with the *ngSwitchDefault which will act as the default value if none of the other values are found. <h2 *ngSwitchDefault>Not Found</h2> In this case, if we are looking for Lambo, we don't have the Lambo option, so we switch to the default case which is “Not found”, and “Not found” is rendered in our browser. One thing we need to point out is that these are expressions so we can use even a function as long as it returns a result that matches the expression we are passing in. Pretty simple! ngFor Directive Next up is the ngFor directive. This directive allows us to iterate through a collection of objects and add a template for each item in that collection. Let's start by adding a collection of objects in our typescript file. We are going to call this an array of makes and add Chevy, Ford, GMC and Dodge. Next we will create a \"div\" and for each \"div\" we're going to create an \"h2\" tag that lists out the name of that make. To do that we are going to use the ngFor directive - the syntax for that *ngFor=\"let make of makes\". That provides us the ability to use interpolation to use the \"make\" property that is defined via the \"let make\" portion of the expression and print that out in the \"h2\" tag. makes = [\"Chevy\", \"Ford\", \"GMC\", \"Dodge\"]; <div *ngFor=\"let make of makes\"> <h2>{{ make }}</h2> </div> If all went well, we should see that for each item in that array we are using an h2 tag to represent that in the browser. In addition, the ngFor directive provides a few helper items that allow us to get more information about that collection such as: \"index as i\" - allows us to determine what the index of each item is <div *ngFor=\"let make of makes; index as i\"> <h2>{{ i }} - {{ make }}</h2> </div> \"first as f\" - allows us to get whether the item is the first one in the collection <div *ngFor=\"let make of makes; first as f\"> <h2>{{ f }} - {{ make }}</h2> </div> \"last as l\" - you can also get the last row or the last item in the collection <div *ngFor=\"let make of makes; last as l\"> <h2>{{ l }} - {{ make }}</h2> </div> \"odd as o\" or \"even as e\" - allow us to determine if the item in the collection is in an odd position or an even position <div *ngFor=\"let make of makes; odd as o\"> <h2>{{ o }} - {{ make }}</h2> </div> That's how easy it is to add and remove elements to your view in your angular application - just use a structural directive and you are done. Additional Resources Desktop to Web: Structural Directives in Angular Angular Structural Directives Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/two-way-binding.html": {
    "href": "components/general/wpf-to-angular-guide/two-way-binding.html",
    "title": "Two-Way Data Binding in Angular with ngModel | WPF to Angular Guide | Infragistics",
    "keywords": "What is two-way data binding in Angular The two-way data binding in Angular enables data to flow from the component to the view and the other way round. It is used to display information to the end-user and allows them to make changes to the underlying data using the UI. This makes a two-way connection between the view (the template) and the component class that we already mentioned. The process is similar to the two-way binding in WPF. How does data binding work in Angular? Angular data binding works by synchronizing the data in the angular components with the UI. This way it can always show the current value of the data. In terms of the two-way binding, the automatic data synchronization happens between the Model and the View, keeping both synced all the time. Because of this, any change made in the Model is immediately reflected in the View as well. And vice versa – changes made in the View are updated in the Model too. The two-way data binding in Angular is used to display information to the end user and allows the end user to make changes to the underlying data using the UI. This makes a two-way connection between the view (the template) and the component class. This is similar to the two-way binding in WPF. A one-way binding is taking the state from our component class and displaying it in our view. Let's look at this code: <input #myTitle (keyup)=\"keyup(myTitle.value)\"> <h2>{{ text }}</h2> export class SampleComponent implements OnInit { text = 'default value'; keyup(value) { this.text = value; } ... Here we are simply using interpolation to bind the text property to the HTML. This will display the value of the text property in the UI. The input element handles the user interaction and updates the underlying text property through the UI by using the event binding. Essentially, the input does the opposite of the one-way binding, it takes the information from the UI and updates the property in the component class. The method which is hooked up to the input's keyup event updates the text property each time the event occurs. Once the text property value is changed by the event method, that change is reflected in the UI by the one-way binding using interpolation of the h2 element. So if the user types something into the input element, that will immediately update the h2 text - this behavior is basically a simulation of a two-way binding. The same can also be achieved in WPF by using a one-way binding and a keyup event handler, but the two-way binding is way more convenient to use. How to implement two-way data binding in Angular Fortunately, we can implement the logic of the sample from above in a much easier way and this is where the two-way binding steps in! The direction of a two-way binding is not just component class to UI, but UI to component class as well. To achieve this, we are going to use a directive called ngModel. Let's update the sample from above with the ngModel directive. The syntax for that is - an open bracket followed by an open parenthesis, and of course the corresponding closing parenthesis and bracket. This is called a banana in the box, so let's see it in action! <input [(ngModel)]=\"text\"> <h2>{{ text }}</h2> And the equivalent bindings in WPF would be: <TextBox Text=\"{Binding Path=Text, Mode=TwoWay}\"></TextBox> <TextBlock Text=\"{Binding Path=Text, Mode=OneWay}\"></TextBlock> The Angular binding is a matter of syntax, and in WPF it is more like a setup - in particular the value of Binding.Mode. If we run this code, an error would occur in the console - saying that the ngModel is an unknown property of the input element. This is due to the fact, that in order to use the ngModel directive, it's necessary to import the FormsModule. It needs to be imported into the app.module.ts file: import { FormsModule } from '@angular/forms'; ... @NgModule({ imports: [ BrowserModule, FormsModule ] ... If we run the sample, the initial input's value would be equal to default value, which is the text property's value. Since the input is editable, changing its value will reflect over the h2 element immediately. So typing into the input updates the text property, and then the h2 element displays that value via the interpolation. Another equivalent way to achieve this is: <input [ngModel]=\"text\" (ngModelChange)=\"text = $event\"> This is actually similar to the first sample, which used a property binding and an event binding. Additional Resources Desktop to Web: Desktop to Web: Angular Two-Way Binding with ngModel One-way binding in Angular Angular NgModel Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general/wpf-to-angular-guide/wpf-to-angular-guide.html": {
    "href": "components/general/wpf-to-angular-guide/wpf-to-angular-guide.html",
    "title": "WPF to Angular Tutorial & Guide for Developers | Desktop to Web | Infragistics",
    "keywords": "Migrating from Desktop to Web: A WPF to Angular Tutorial WPF to Angular tutorial is the first step that you should take in order to make a smooth transition from a desktop to web framework transition. The tutorial targets WPF developers, who make their first steps to web development and it examines some differences and similarities of both frameworks - applications structure, data binding, events, components, etc. The guide is divided into the following topics and has included video tutorials: Create your first Angular application Before you begin on your path of learning Angular, you’ll need to install the prerequisites for modern web app dev with Angular. This section covers using the Node.js package manager, installing the Visual Studio Code IDE, and a few of the basic concepts that are necessary for modern web development. Check out the video tutorial for this topic. Create your UI with Angular components Creating a UI in Angular is very similar to how we would create one in WPF. We normally use user controls, represented by the UserControl class. A UserControl groups markup and code into a reusable container, allowing the same interface and functionality to be used in several different places. Understanding components in Angular is key to the rest of this series – so let’s get started by understanding how WPF components translate to components in Angular. Check out the video tutorial for this topic. One-way data binding in Angular One of the most powerful and widely used features in WPF is data binding. It makes a developers' life much easier, by synchronizing the business logic with the view and vice versa, without having to write a single extra line of code. Without the power of it, WPF would just be a better-looking Windows Forms. Luckily, Angular supports data binding! There are two types of data binding - one-way binding and two-way binding. This section shows you how to accomplish one-way data binding and how it compares to WPF. Check out the video tutorial for this topic. Angular Events Binding to user input events is core to every app. It’s hard to imagine writing a new app that doesn’t respond to some type of user interaction one way or another. The most common way to do that is with some type of event system. WPF provides routed events, CLR events, and commands. While in Angular, there are DOM events. This section you’ll learn about DOM events and how to handle user inputs. Check out the video tutorial for this topic. Two-way data binding in Angular In Angular, one-way binding updates the view with data coming from the component class. Like WPF, we can do the opposite operation - update the component class from the view. In that case we need to use a two-way binding. This section compares two-way binding in WPF and shows how easy it is to get started. Check out the video tutorial for this topic. Transforming Data with Angular Pipes In WPF we use a IValueConverter to transform data, in an Angular application, we use Angular Pipes. The pipe is very similar to the WPF converter. It takes data as an input and then transforms that data into a desired output for display. This section shows some of the pre-defined Angular Pipes, and how to use them in an app. Check out the video tutorial for this topic. Structural Directives in Angular As WPF developers, anytime we want to add or remove an element from the visual tree we have to jump into some code-behind and write some C# or we can use a combination of binding and a visibility converter, which again requires some custom logic and static resources. That's the way we have always done it in WPF, but Angular makes it so much easier. This section demonstrates how structural directives enable the manipulation of elements in an Angular app. Check out the video tutorial for this topic. Layout Elements In WPF, in order to layout the elements in your application, you need to put them inside a Panel. In Angular, we use CSS. This topic discusses Layout, and how to use CSS features like Flexbox and CSS Grid. Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/general-breaking-changes-dv.html": {
    "href": "components/general-breaking-changes-dv.html",
    "title": "Angular Breaking Changes | Ignite UI for Angular | Infragistics",
    "keywords": "Breaking Changes in Ignite UI for Angular This topic provides information about breaking changes in Ignite UI for Angular as well as how to update older code to latest API. Redesigned Chart Defaults Note These breaking changes were introduce in version 11.2.0 of these packages and components: All types of charts/series have new colors for brush/fill and outlines Old series brushes outlines New series outline brushes Color_001=#7446B9 Color_001=#8bdc5c Color_002=#9FB328 Color_002=#8b5bb1 Color_003=#F96232 Color_003=#6db1ff Color_004=#2E9CA6 Color_004=#f8a15f Color_005=#DC3F76 Color_005=#ee5879 Color_006=#FF9800 Color_006=#735656 Color_007=#3F51B5 Color_007=#f7d262 Color_008=#439C47 Color_008=#8ce7d9 Color_009=#795548 Color_009=#e051a9 Color_010=#9A9A9A Color_010=#a8a8b7 All types of charts/series have marker outlines with 2px thickness Bar/Column/Waterfall series have outlines with 1px thickness (other series have 2px thickness) Bar/Column/Waterfall series have square corners instead of rounded corners anymore Point/Bubble/ScatterSeries/PolarScatter series have markers with 70% transparent fill Point/Bubble/ScatterSeries/PolarScatter series have markers with fill that matches marker outline. To revert to the previous styling behavior for these series a new property has been added to the series, MarkerFillMode, which can be set to normal to mimic the prior behavior. Scatter High Density series has new colors for min/max heat properties Old heat min color New heat min color #FF7446B9 #ff8b5bb1 Old heat max color New heat max color #FFC62828 #ffee5879 Financial/Waterfall series have new colors for negative fill of their visuals Old negative brush new negative brush #FFC62828 #ffee5879 Changed Import Statements Import statements have been simplified to use just package names instead of full paths to API classes and enums. Note These breaking changes were introduce in version 8.2.12 of these packages and components: Affected Packages Affected Components igniteui-angular-excel Excel Library igniteui-angular-spreadsheet Spreadsheet igniteui-angular-maps Geo Map, Treemap igniteui-angular-gauges Bullet Graph, Linear Gauge, Radial Gauge igniteui-angular-charts Category Chart, Data Chart, Donut Chart, Financial Chart], Pie Chart, Zoom Slider igniteui-angular-core all classes and enums Code After Changes Now, you need to use just package names instead of full paths to API classes and enums. Please also note that the name of the Data Grid component and its corresponding modules have also changed. // gauges: import { IgxLinearGauge } from \"igniteui-angular-gauges\"; import { IgxLinearGaugeModule } from \"igniteui-angular-gauges\"; import { IgxLinearGraphRange } from \"igniteui-angular-gauges\"; import { IgxRadialGauge } from 'igniteui-angular-gauges}'; import { IgxRadialGaugeModule } from 'igniteui-angular-gauges'; import { IgxRadialGaugeRange } from 'igniteui-angular-gauges'; import { SweepDirection } from 'igniteui-angular-core'; // charts: import { IgxFinancialChartComponent } from \"igniteui-angular-charts\"; import { IgxFinancialChartModule } from \"igniteui-angular-charts\"; import { IgxDataChartComponent } from \"igniteui-angular-charts\"; import { IgxDataChartCoreModule } from \"igniteui-angular-charts\"; // maps: import { IgxGeographicMapComponent } from \"igniteui-angular-maps\"; import { IgxGeographicMapModule } from \"igniteui-angular-maps\"; Code Before Changes Before, you had to import using full paths to API classes and enums: // gauges: import { IgxLinearGaugeComponent } from 'igniteui-webcomponents-gauges/ES5/igx-linear-gauge-component'; import { IgxLinearGaugeModule } from 'igniteui-webcomponents-gauges/ES5/igx-linear-gauge-module'; import { IgxLinearGraphRange } from 'igniteui-webcomponents-gauges/ES5/igx-linear-graph-range'; import { IgxRadialGaugeComponent } from \"igniteui-webcomponents-gauges/ES5/igx-radial-gauge-component\"; import { IgxRadialGaugeModule } from \"igniteui-webcomponents-gauges/ES5/igx-radial-gauge-module\"; import { IgxRadialGaugeRange } from \"igniteui-webcomponents-gauges/ES5/igx-radial-gauge-range\"; import { SweepDirection } from \"igniteui-webcomponents-core/ES5/SweepDirection\"; // charts: import { IgxFinancialChartComponent } from \"igniteui-webcomponents-charts/ES5/igx-financial-chart-component\"; import { IgxFinancialChartModule } from \"igniteui-webcomponents-charts/ES5/igx-financial-chart-module\"; import { IgxDataChartComponent } from \"igniteui-webcomponents-charts/ES5/igx-data-chart-component\"; import { IgxDataChartCoreModule } from \"igniteui-webcomponents-charts/ES5/igx-data-chart-core-module\"; // maps: import { IgxGeographicMapComponent } from \"igniteui-webcomponents-maps/ES5/igx-geographic-map-component\"; import { IgxGeographicMapModule } from \"igniteui-webcomponents-maps/ES5/igx-geographic-map-module\"; View page on GitHub"
  },
  "components/general-changelog-dv.html": {
    "href": "components/general-changelog-dv.html",
    "title": "Angular What's New | Ignite UI for Angular | Infragistics",
    "keywords": "Ignite UI for Angular Changelog All notable changes for each version of Ignite UI for Angular are documented on this page. [!Note] This topic discusses changes only for components that are not included in the igniteui-angular package. For changes specific to igniteui-angular components, please see CHANGELOG.MD. Ignite UI for Angular Changelog at Github 17.3.0 (March 2024) igniteui-angular-charts XamRadialChart New Label Mode The IgxCategoryAngleAxisComponent for the now exposes a LabelMode property that allows you to further configure the location of the labels. This allows you to toggle between the default mode by selecting the Center enum, or use the new mode, ClosestPoint, which will bring the labels closer to the circular plot area. igniteui-angular-gauges IgxRadialGaugeComponent New title/subtitle properties. TitleText, SubtitleText will appear near the bottom the gauge. In addition, the various title/subtitle font properties were added such as TitleFontSize, TitleFontFamily, TitleFontStyle, TitleFontWeight and TitleExtent. Finally, the new TitleDisplaysValue will allow the value to correspond with the needle's position. New OpticalScalingEnabled and OpticalScalingSize properties for the IgxRadialGaugeComponent. This new feature will manage the size at which labels, titles, and subtitles of the gauge have 100% optical scaling. You can read more about this new feature here New highlight needle was added. HighlightValue and HighlightValueDisplayMode when both are provided a value and 'Overlay' setting, this will make the main needle to appear faded and a new needle will appear. IgxLinearGaugeComponent New highlight needle was added. HighlightValue and HighlightValueDisplayMode when both are provided a value and 'Overlay' setting, this will make the main needle to appear faded and a new needle will appear. IgxBulletGraphComponent The Performance bar will now reflect a difference between the value and new HighlightValue when the HighlightValueDisplayMode is applied to the 'Overlay' setting. The highlight value will show a filtered/subset completed measured percentage as a filled in color while the remaining bar's appearance will appear faded to the assigned value, illustrating the performance in real-time. 17.2.0 (January 2024) igniteui-angular-charts (Charts) Chart Highlight Filter - The IgxCategoryChartComponent and IgxDataChartComponent now expose a way to highlight and animate in and out of a subset of data. The display of this highlight depends on the series type. For column and area series, the subset will be shown on top of the total set of data where the subset will be colored by the actual brush of the series, and the total set will have a reduced opacity. For line series, the subset will be shown as a dotted line. 17.0.0 (November 2023) igniteui-angular-grids (Toolbar - Beta) Save tool action has been added to save the chart to an image via the clipboard. Vertical orientation has been added via the toolbar's orientation property. By default the toolbar is horizontal, now the toolbar can be shown in vertical orientation where the tools will popup to the left/right respectfully. Custom SVG icons support was added via the toolbar's renderImageFromText method, further enhancing custom tool creation. 16.1.0 (June 2023) New Components Toolbar - Beta. This component is a companion container for UI operations to be used primarily with our charting components. The toolbar will dynamically update with a preset of properties and tool items when linked to our IgxDataChartComponent or IgxCategoryChartComponent components. You'll be able to create custom tools for your project allowing end users to provide changes, offering an endless amount of customization. igniteui-angular-charts (Charts) ValueLayer - A new series type named the IgxValueLayerComponent is now exposed which can allow you to render an overlay for different focal points of the plotted data such as Maximum, Minimum, and Average. This is applied to the IgxCategoryChartComponent and IgxFinancialChartComponent by adding to the new valueLines collection. It is now possible to apply a dash array to the different parts of the series of the IgxDataChartComponent. You can apply this to the series plotted in the chart, the gridlines of the chart, and the trendlines of the series plotted in the chart. 16.0.0 (May 2023) Angular 16 support. 15.0.0 (December 2022) Angular 15 support. 14.2.0 (November 2022) Added significant improvements to default behaviors, and refined the Category Chart API to make it easier to use. These new chart improvements include: Responsive layouts for horizontal label rotation based on browser / screen size. Enhanced rendering for rounded labels on all platforms. Added marker properties to StackedFragmentSeries. Added shouldPanOnMaximumZoom property. New Category Axis Properties: ZoomMaximumCategoryRange ZoomMaximumItemSpan ZoomToCategoryRange ZoomToItemSpan New Chart Aggregation API for Grouping, Sorting and Summarizing Category string and numeric values, eliminating the need to pre-aggregate or calculate chart data: InitialSortDescriptions InitialSorts SortDescriptions InitialGroups InitialGroupDescriptions GroupDescriptions InitialSummaries InitialSummaryDescriptions SummaryDescriptions InitialGroupSortDescriptions GroupSorts GroupSortDescriptions [!Note] The Chart's Aggregation will not work when using includedProperties | excludedProperties because these properties are meant for non-aggregated data. Once you attempt to aggregate data these properties should no longer be used. The reason it does not work is because aggregation replaces the collection that is passed to the chart for render. The include/exclude properties are designed to filter in/out properties of that data and those properties no longer exist in the new aggregated collection. 13.2.0 (June 2022) igniteui-angular-charts (Charts) Added the highly-configurable DataLegend component, which works much like the IgxLegendComponent, but it shows values of series and provides many configuration properties for filtering series rows and values columns, styling and formatting values. Added the highly-configurable DataToolTip which displays values and titles of series as well as legend badges of series in a tooltip. This is now the default tooltip for all chart types. Added animation and transition-in support for Stacked Series. Animations can be enabled by setting the isTransitionInEnabled property to true. From there, you can set the transitionInDuration property to determine how long your animation should take to complete and the transitionInMode to determine the type of animation that takes place. Added AssigningCategoryStyle event, is now available to all series in IgxDataChartComponent. This event is handled when you want to conditionally configure aspects of the series items such as Fill background-color and highlighting. New allowedPositions enumeration for CalloutLayer. Used to limit where the callouts are to be placed within the chart. By default, the callouts are intelligently placed in the best place but this used to force for example TopLeft, TopRight, BottomLeft or BottomRight. New corner radius properties added for Annotation Layers; used to round-out the corners of each of the callouts. Note, a corner radius has now been added by default. calloutCornerRadius for CalloutLayer axisAnnotationBackgroundCornerRadius for FinalValueLayer xAxisAnnotationBackgroundCornerRadius and yAxisAnnotationBackgroundCornerRadius for CrosshairLayer New horizontalViewScrollbarMode and verticalViewScrollbarMode enumeration to enable scrollbars in various ways. When paired with isVerticalZoomEnabled or isHorizontalZoomEnabled, you'll be able to persist or fade-in and out the scrollbars along the axes to navigate the chart. New FavorLabellingScaleEnd, determines whether the axis should favor emitting a label at the end of the scale. Only compatible with numeric axes (e.g. IgxNumericXAxisComponent, IgxNumericYAxisComponent, PercentChangeAxis). New isSplineShapePartOfRange determines whether to include the spline shape in the axis range requested of the axis. New xAxisMaximumGap, determines the maximum allowed value for the plotted series when using xAxisGap. The gap determines the amount of space between columns or bars of plotted series. New xAxisMinimumGapSize, determines the minimum allowed pixel-based value for the plotted series when using xAxisGap to ensure there is always some spacing between each category. 13.1.0 (November 2021) [!Note] Please ensure package \"lit-html\": \"^2.0.0\" or newer is added to your project for optimal compatibility. igniteui-angular-charts (Charts) This release introduces a few improvements and simplifications to visual design and configuration options for the geographic map and all chart components. Changed yAxisLabelLocation property's type to YAxisLabelLocation from AxisLabelLocation in IgxFinancialChartComponent and IgxCategoryChartComponent Changed xAxisLabelLocation property's type to XAxisLabelLocation from AxisLabelLocation in IgxFinancialChartComponent Added xAxisLabelLocation property to IgxCategoryChartComponent Added support for representing geographic series of IgxGeographicMapComponent in a legend Added crosshair lines by default in IgxFinancialChartComponent and IgxCategoryChartComponent Added crosshair annotations by default in IgxFinancialChartComponent and IgxCategoryChartComponent Added final value annotation by default in IgxFinancialChartComponent Added new properties in Category Chart and Financial Chart: crosshairsLineThickness and other properties for customizing crosshairs lines crosshairsAnnotationXAxisBackground and other properties for customizing crosshairs annotations finalValueAnnotationsBackground and other properties for customizing final value annotations areaFillOpacity that allow changing opacity of series fill (e.g. Area chart) markerThickness that allows changing thickness of markers Added new properties in Category Chart, Financial Chart, Data Chart, and Geographic Map: markerAutomaticBehavior that allows which marker type is assigned to multiple series in the same chart legendItemBadgeShape for setting badge shape of all series represented in a legend legendItemBadgeMode for setting badge complexity on all series in a legend Added new properties in Series in Data Chart and Geographic Map: legendItemBadgeShape for setting badge shape on specific series represented in a legend legendItemBadgeMode for setting badge complexity on specific series in a legend Changed default vertical crosshair line stroke from #000000 to #BBBBBB in category chart and series Changed shape of markers to circle for all series plotted in the same chart. This can be reverted by setting chart's markerAutomaticBehavior property to SmartIndexed enum value Simplified shapes of series in chart's legend to display only circle, line, or square. This can be reverted by setting chart's legendItemBadgeMode property to MatchSeries enum value Changed color palette of series and markers displayed in all charts to improve accessibility Old brushes/outlines New outline/brushes #8BDC5C #8B5BB1 #6DB1FF #F8A15F #EE5879 #735656 #F7D262 #8CE7D9 #E051A9 #A8A8B7 #8BDC5C #8961A9 #6DB1FF #82E9D9 #EA3C63 #735656 #F8CE4F #A8A8B7 #E051A9 #FF903B 11.2.0 (April 2021) igniteui-angular-charts (Charts) This release introduces several new and improved visual design and configuration options for all of the chart components, e.g. IgxDataChartComponent, IgxCategoryChartComponent, and IgxFinancialChartComponent. Changed Bar/Column/Waterfall series to have square corners instead of rounded corners Changed Scatter High Density series’ colors for heat min property from #8a5bb1 to #000000 Changed Scatter High Density series’ colors for heat max property from #ee5879 to #ee5879 Changed Financial/Waterfall series’ NegativeBrush and NegativeOutline properties from #C62828 to #ee5879 Changed marker's thickness to 2px from 1px Changed marker's fill to match the marker's outline for IgxPointSeriesComponent, IgxBubbleSeriesComponent, IgxScatterSeriesComponent, IgxPolarScatterSeriesComponent. You can use set markerFillMode property to Normal to undo this change Compressed labelling for the IgxTimeXAxisComponent and IgxOrdinalTimeXAxisComponent New Marker Properties: series.markerFillMode - Can be set to MatchMarkerOutline so the marker depends on the outline series.markerFillOpacity - Can be set to a value 0 to 1 series.markerOutlineMode - Can be set to MatchMarkerBrush so the marker's outline depends on the fill brush color New Series Property: series.outlineMode - Can be set to toggle the series outline visibility. Note, for Data Chart, the property is on the series New chart properties that define bleed over area introduced into the viewport when the chart is at the default zoom level. A common use case is to provide space between the axes and first/last data points. Note, the computedPlotAreaMarginMode, listed below, will automatically set the margin when markers are enabled. The others are designed to specify a Double to represent the thickness, where PlotAreaMarginLeft etc. adjusts the space to all four sides of the chart: chart.plotAreaMarginLeft chart.plotAreaMarginTop chart.plotAreaMarginRight chart.plotAreaMarginBottom chart.computedPlotAreaMarginMode New Highlighting Properties chart.highlightingMode - Sets whether hovered or non-hovered series to fade, brighten chart.highlightingBehavior - Sets whether the series highlights depending on mouse position e.g. directly over or nearest item Note, in previous releases the highlighting was limited to fade on hover. Added Highlighting Stacked, Scatter, Polar, Radial, and Shape series: Added Annotation layers to Stacked, Scatter, Polar, Radial, and Shape series: Added support for overriding the data source of individual stack fragments within a stacked series Added custom style events to Stacked, Scatter, Range, Polar, Radial, and Shape series Added support to automatically sync the vertical zoom to the series content Added support to automatically expanding the horizontal margins of the chart based on the initial labels displayed Redesigned color palette of series and markers: Old brushes/outlines New outline/brushes #7446B9 #9FB328 #F96232 #2E9CA6 #DC3F76 #FF9800 #3F51B5 #439C47 #795548 #9A9A9A #8bdc5c #8b5bb1 #6db1ff #f8a15f #ee5879 #735656 #f7d262 #8ce7d9 #e051a9 #a8a8b7 for example: Chart Legend Added horizontal orientation property to ItemLegend that can be used with Bubble, Donut, and Pie Chart Added legendHighlightingMode property - Enables series highlighting when hovering over legend items igniteui-angular-maps (GeoMap) [!Note] These features are CTP Added support for wrap around display of the map (scroll infinitely horizontally) Added support for shifting display of some map series while wrapping around the coordinate origin Added support for highlighting of the shape series Added support for some annotation layers for the shape series 8.2.12 Changed Import Statements Import statements have been simplified to use just package names instead of full paths to API classes and enums. [!Note] These breaking changes were introduce in these packages and components only: Affected Packages Affected Components igniteui-angular-excel Excel Library igniteui-angular-spreadsheet Spreadsheet igniteui-angular-maps Geo Map, Treemap igniteui-angular-gauges Bullet Graph, Linear Gauge, Radial Gauge igniteui-angular-charts Category Chart, Data Chart, Donut Chart, Financial Chart], Pie Chart, Zoom Slider igniteui-angular-core all classes and enums Code After Changes Now, you need to use just package names instead of full paths to API classes and enums. Please also note that the name of the Data Grid component and its corresponding modules have also changed. // gauges: import { IgxLinearGauge } from \"igniteui-angular-gauges\"; import { IgxLinearGaugeModule } from \"igniteui-angular-gauges\"; import { IgxLinearGraphRange } from \"igniteui-angular-gauges\"; import { IgxRadialGauge } from 'igniteui-angular-gauges}'; import { IgxRadialGaugeModule } from 'igniteui-angular-gauges'; import { IgxRadialGaugeRange } from 'igniteui-angular-gauges'; import { SweepDirection } from 'igniteui-angular-core'; // charts: import { IgxFinancialChartComponent } from \"igniteui-angular-charts\"; import { IgxFinancialChartModule } from \"igniteui-angular-charts\"; import { IgxDataChartComponent } from \"igniteui-angular-charts\"; import { IgxDataChartCoreModule } from \"igniteui-angular-charts\"; // maps: import { IgxGeographicMapComponent } from \"igniteui-angular-maps\"; import { IgxGeographicMapModule } from \"igniteui-angular-maps\"; Code Before Changes Before, you had to import using full paths to API classes and enums: // gauges: import { IgxLinearGaugeComponent } from 'igniteui-angular-gauges/ES5/igx-linear-gauge-component'; import { IgxLinearGaugeModule } from 'igniteui-angular-gauges/ES5/igx-linear-gauge-module'; import { IgxLinearGraphRange } from 'igniteui-angular-gauges/ES5/igx-linear-graph-range'; import { IgxRadialGaugeComponent } from \"igniteui-angular-gauges/ES5/igx-radial-gauge-component\"; import { IgxRadialGaugeModule } from \"igniteui-angular-gauges/ES5/igx-radial-gauge-module\"; import { IgxRadialGaugeRange } from \"igniteui-angular-gauges/ES5/igx-radial-gauge-range\"; import { SweepDirection } from \"igniteui-angular-core/ES5/SweepDirection\"; // charts: import { IgxFinancialChartComponent } from \"igniteui-angular-charts/ES5/igx-financial-chart-component\"; import { IgxFinancialChartModule } from \"igniteui-angular-charts/ES5/igx-financial-chart-module\"; import { IgxDataChartComponent } from \"igniteui-angular-charts/ES5/igx-data-chart-component\"; import { IgxDataChartCoreModule } from \"igniteui-angular-charts/ES5/igx-data-chart-core-module\"; // maps: import { IgxGeographicMapComponent } from \"igniteui-angular-maps/ES5/igx-geographic-map-component\"; import { IgxGeographicMapModule } from \"igniteui-angular-maps/ES5/igx-geographic-map-module\"; View page on GitHub"
  },
  "components/general-cli-overview.html": {
    "href": "components/general-cli-overview.html",
    "title": "Angular CLI | Data Visualization Tools and Tables | Infragistics",
    "keywords": "Ignite UI CLI for Angular Our CLI tools provide project templates pre-configured for the Ignite UI for Angular toolset that help you get your next application off the ground in record time. The Ignite UI CLI is a stand-alone command-line tool for creating and scaffolding your applications for a variety of different frameworks and provides a substantial productivity boost for developers. Getting Started To get started, install the CLI: npm install -g igniteui-cli The above install command will make the Ignite UI CLI available for creation, scaffolding, and running of your Ignite UI for Angular application. Create a New Project To create an application that is configured to use the Ignite UI for Angular controls using the Ignite UI CLI, you can use the following template in your command line: Adding Components Once you have created a project, you can then add additional component templates using ig add at any point. Running this command without any parameters will guide you through the available templates by using a keyboard navigation CLI to add the control of your choosing. ig add Alternatively, you can simply run the ig list command to get a full list of supported templates in the current project you have created. ig list After running ig list and you find the component template you would like to add, you can do so quickly by following this template in your command line: ig add [component_template] [component_name] The \"component_template\" above will generally match an Ignite UI for Angular component (\"grid\", \"category-chart\", \"linear-gauge\", etc.). For example, if you wanted to add a data grid templated component named \"MyGridComponent\" to your application, you could run the following: ig add grid MyGridComponent Build and Run the Application In order to build and run the Ignite UI for Angular application, you can call the ig build and ig run commands: ig build ig run Ignite UI CLI Commands A full list of the available Ignite UI CLI commands and their usage (like passing flags, etc.), can be found at the Ignite UI CLI wiki pages: Command Alias Description ig start Builds the application, starts a web server and opens the application in the default browser. ig build Builds the application into an output directory ig generate g Generates a new custom template for supported frameworks and project types ig help -h Lists the available commands and provides a brief description of what they do. ig config Performs read and write operation on the Ignite UI CLI configuration settings. ig doc Searches the Infragistics knowledge base for information about a given search term ig list l Lists all templates for the specified framework and type. When you run the command within a project folder it will list all templates for the project's framework and type, even if you provide different ones. ig test Executes the tests for the current project. ig version -v Shows Ignite UI CLI version installed locally, or globally if local is missing View page on GitHub"
  },
  "components/general-getting-started.html": {
    "href": "components/general-getting-started.html",
    "title": "Getting Started | Ignite UI for Angular | Infragistics",
    "keywords": "Updating Existing App If you want to use Ignite UI for Angular in an existing Angular CLI project (one that you have from before). We have you covered! All you have to do is execute these commands: npm install --save igniteui-angular npm install --save igniteui-angular-charts igniteui-angular-core npm install --save igniteui-angular-excel igniteui-angular-core npm install --save igniteui-angular-gauges igniteui-angular-core npm install --save igniteui-angular-grids igniteui-angular-core npm install --save igniteui-angular-maps igniteui-angular-core npm install --save igniteui-angular-spreadsheet igniteui-angular-core Or yarn add igniteui-angular-charts igniteui-angular-core yarn add igniteui-angular-excel igniteui-angular-core yarn add igniteui-angular-gauges igniteui-angular-core yarn add igniteui-angular-grids igniteui-angular-core yarn add igniteui-angular-maps igniteui-angular-core yarn add igniteui-angular-spreadsheet igniteui-angular-core This will automatically install packages for Ignite UI for Angular, along with all of their dependencies, font imports and styles references to the existing project. Importing Component Modules First we have to import the required modules of the components we want to use. We will go ahead and do this for the GeographicMap component. Using Components We are now ready to use the Ignite UI for Angular map component in our markup! Let's go ahead and define it: Running Application Finally, we can run our new application by using one of the following commands: npm run-script start After executing this command, your project will be built and served locally on your computer. It will automatically open in your default browser and you will be able to use Ignite UI for Angular components in your project. The final result should show interactive map of the world: View page on GitHub"
  },
  "components/general-licensing.html": {
    "href": "components/general-licensing.html",
    "title": "Angular Licensing | Dock Manager | Ignite UI for Angular | Infragistics",
    "keywords": "License FAQ and Installation License Agreements in Ignite UI for Angular It is important to know all the legal terms and conditions regarding the Ignite UI for Angular that you purchase and use. We have updated our license terms and subscription model in second quarter of 2020. If your trial has ended or your subscription has expired, each developer on your team using Ignite UI will need to purchase a subscription. This will enable you to use our private npm feed hosted on https://packages.infragistics.com/npm/js-licensed/ for development. There you will find the latest versions of the Ignite UI for Angular packages. If you have a current subscription, you can use this private feed and you will have access to the full version of Ignite UI for Angular. For detailed explanation of the Ignite UI license agreement and terms of use, click here. Infragistics offers free, non-commercial, not-for-resale (NFR) licenses for the following: If you are part of a developer program like the Microsoft MVP, Microsoft Regional Director, Google Developer Expert, etc. If you are a primary, secondary or university student, or an academic institution, or a professor. If you qualify for a free, non-commercial, NFR license or if you have any license questions, please contact us. Currently only the igniteui-dockmanager package is available in our private npm feed, but in the future we will add the other Ignite UI for Angular packages as well. Ignite UI for Angular npm packages - Using the Private npm feed Npm is the most popular package manager and is also the default one for the runtime environment Node.js. It is highly adopted and is one of the fastest and easiest ways to manage the packages that you depend on in your project. For more information on how npm works, read the official npm documentation. Infragistics Ignite UI for Angular is available as npm packages and you can add them as dependencies to your project in a few easy steps. Choosing this approach will not require configuring npm. By installing this package you will start using the Ignite UI for Angular Trial version of the product. Currently only the igniteui-dockmanager npm package has a trial watermark, but in the future we will add it to the other Ignite UI for Angular packages as well. How to setup your environment to use the private npm feed First you need to setup the private registry and to associate this registry with the Infragistics scope. This will allow you to seamlessly use a mix of packages from the public npm registry and the Infragistics private registry. You will be asked to provide the username and the password that you use for logging into your Infragistics account. You should also provide the email that is registered to your Infragistics profile. If your account is not licensed (you are still using a Trial account) the private package feed won't be accessible to you e.g. it will return 404 or 403 error message. Only licensed accounts can access the packages.infragistics private feed. Now, to log in to our private feed using npm npm version 9+ Our private feed doesn't currently support login/adduser commands with npm v9, so we recommend the following steps instead to add the required auth fields to the config: npm config set @infragistics:registry https://packages.infragistics.com/npm/js-licensed/ npm config set //packages.infragistics.com/npm/js-licensed/:username=YOUR_USERNAME npm config set //packages.infragistics.com/npm/js-licensed/:email=YOUR_IG_EMAIL npm config set //packages.infragistics.com/npm/js-licensed/:_auth=YOUR_IG_AUTH_TOKEN You can generate Access Token through your Infragistics profile. This approach is applicable to all prior versions of npm. npm version up to v8 Run the adduser command and specify a user account and password: npm adduser --registry=https://packages.infragistics.com/npm/js-licensed/ --scope=@infragistics You will be asked to provide the username and the password that you use for logging into your Infragistics account. You should also provide the email that is registered to your Infragistics profile. npm is disallowing the use of the \"@\" symbol inside your username as it is considered as being \"not safe for the net\". Because your username is actually the email that you use for your Infragistics account it always contains the symbol \"@\". That's why you must escape this limitation by replacing the \"@\" symbol with \"!!\" (two exclamation marks). For example, if your username is \"username@example.com\" when asked about your username you should provide the following input: \"username!!example.com\". After this is done, you will be logged in and you will be able to install the latest versions of the Ignite UI packages into your project: npm uninstall igniteui-dockmanager npm install @infragistics/igniteui-dockmanager npm uninstall igniteui-dockmanager npm install @infragistics/igniteui-dockmanager Have in mind that we have set the Ignite UI for Angular package to be scoped, meaning that no changing the registries is needed if you want to install packages from our private feed and from npmjs.org simultaneously. Changes in your project source after license package update If you are upgrading from trial to licensed package the new packages will be scoped under @infragistics. As a result you can either: Do a global replace for all trial packages and change then to the licensed scoped version across all files in your project. For example, replace all igniteui-dockmanager references to @infragicstics/igniteui-dockmanager The change should affect all imports where such packages are used. Or Add a paths mapping in the project tsconfig.json. { /* ... */ \"compilerOptions\": { \"baseUrl\": \"./\", \"outDir\": \"./dist/out-tsc\", /* ... */ \"paths\": { \"igniteui-dockmanager\": [\"./node_modules/@infragistics/igniteui-dockmanager\"], \"igniteui-dockmanager/*\": [\"./node_modules/@infragistics/igniteui-dockmanager/*\"], } } } Change the themes imports like this: @import '~igniteui-dockmanager/dist/collection/styles/igc.themes'; // Should be changed to @import '~@infragistics/igniteui-dockmanager/dist/collection/styles/igc.themes'; So, if you've already adopted npm and you have an Ignite UI for Angular license, don't hesitate setting up the Infragistics private feed and boost your productivity, using the full potential of Ignite UI for Angular. Access Token Usage You can also authenticate to our private npm feed using an access token, which you can acquire through your infragistics.com user account. The access token authentication is the preferred alternative when you want to integrate a CI process in a publicly accessible repository, which uses the Ignite UI for Angular licensed packages. The following information is on how to setup authentication to our private npm registry using an access token in local configuration, Azure Pipelines build procedures and Travis CI build process: Generate a token from https://account.infragistics.com/access-tokens Each token is with Base64 encoding. Add the following into your .npmrc file @infragistics:registry=https://packages.infragistics.com/npm/js-licensed/ //packages.infragistics.com/npm/js-licensed/:_auth=YOUR_ACCESS_TOKEN //packages.infragistics.com/npm/js-licensed/:username=YOUR_USERNAME Azure Pipelines Configuration Update the azure-pipelines.yml with the following steps: steps: - script: npm config set @infragistics:registry $(npmRegistry) displayName: 'Npm add registry' - script: npm config set $(igScope):_auth=$(token) displayName: 'Npm config auth' Add npm registry and token variables. Travis CI Configuration We will follow almost the same approach here. The only difference would be that the configuration will be set on before_install before_install: - echo \"@infragistics:registry=https://packages.infragistics.com/npm/js-licensed/\" >> ~/.npmrc - echo \"//packages.infragistics.com/npm/js-licensed/:_auth=$TOKEN\" >> ~/.npmrc The best way to define an environment variable depends on what type of information it will contain. So you have two options: encrypt it and add it to your .travis.yml add it to your Repository Settings GitHub Actions Configuration Add the following scripts before the npm i(ci) step to your CI workflow configuration: - run: echo \"@infragistics:registry=https://packages.infragistics.com/npm/js-licensed/\" >> ~/.npmrc - run: echo \"//packages.infragistics.com/npm/js-licensed/:_auth=${{ secrets.NPM_TOKEN }}\" >> ~/.npmrc Define secrets (encrypted environment variables) and use them in the GitHub actions workflow for sensitive information like the access token. View page on GitHub"
  },
  "components/general-whats-new-dv.html": {
    "href": "components/general-whats-new-dv.html",
    "title": "Angular What's New | Ignite UI for Angular | Infragistics",
    "keywords": "What's New in Ignite UI for Angular This topic provides information about breaking changes in Ignite UI for Angular as well as how to update older code to latest API. Chart Features This release introduces several new and improved visual design and configuration options for all of the chart components. e.g. Data Chart, Category Chart, and Financial Chart. Redesigned Chart Defaults: New color palette for series/markers in all charts eg. Changed Bar/Column/Waterfall series to have square corners instead of rounded corners Changed Scatter High Density series’ colors for min/max heat properties Changed Financial/Waterfall series’ colors for negative fill of their visuals Changed marker's thickness to 2px from 1px Changed marker's fill to match the marker's outline for PointSeries, BubbleSeries, ScatterSeries, PolarScatterSeries Note, you can use set MarkerFillMode property to Normal to undo this change Compressed labelling for the TimeXAxis and OrdinalTimeXAxis New Marker Properties: MarkerFillMode - Can be set to 'MatchMarkerOutline' so the marker depends on the outline MarkerFillOpacity - Can be set to a value 0 to 1 MarkerOutlineMode - Can be set to 'MatchMarkerBrush' so the marker's outline depends on the fill brush color New Series OutlineMode Property: Can be set to toggle the series outline visibility. Note, for Data Chart, the property is on the series New Plot Area Margin Properties: PlotAreaMarginLeft PlotAreaMarginTop PlotAreaMarginRight PlotAreaMarginBottom ComputedPlotAreaMarginMode The plot area margin properties define the bleed over area introduced into the viewport when the chart is at the default zoom level. A common use case is to provide space between the axes and first/last data points. Note, the ComputedPlotAreaMarginMode, listed below, will automatically set the margin when markers are enabled. The others are designed to specify a Double to represent the thickness, where PlotAreaMarginLeft etc. adjusts the space to all four sides of the chart. New Highlighting Properties HighlightingMode - Sets whether hovered or non-hovered series to fade, brighten HighlightingBehavior - Sets whether the series highlights depending on mouse position eg. directly over or nearest item Note, in previous releases the highlighting was limited to fade on hover. Added Highlighting for the following series: Stacked Scatter Polar Radial Shape Added Annotation layers to the following series: Stacked Scatter Polar Radial Shape Added support for overriding the data source of individual stack fragments within a stacked series Added custom style events to Stacked, Scatter, Range, Polar, Radial, and Shape series Added support to automatically sync the vertical zoom to the series content Added support to automatically expanding the horizontal margins of the chart based on the initial labels displayed Chart Legend Features: Added Horizontal Orientation for ItemLegend The following chart types can use ItemLegend in horizontal orientation: Bubble Donut Pie LegendHighlightingMode - Enables series highlighting when hovering over legend items Geographic Map Features (CTP): Added support for wrap around display of the map (scroll infinitely horizontally) Added support for shifting display of some map series while wrapping around the coordinate origin Added support for highlighting of the shape series Added support for some annotation layers for the shape series View page on GitHub"
  },
  "components/geo-map.html": {
    "href": "components/geo-map.html",
    "title": "Angular Map | Data Visualization Tools | Map Overview | Infragistics",
    "keywords": "Angular Map Overview The Ignite UI for Angular map component allows you to display data that contains geographic locations from view models or geo-spatial data loaded from shape files on geographic imagery maps. Angular Map Example The following sample demonstrates how display data in IgxGeographicMapComponent using IgxGeographicProportionalSymbolSeriesComponent also known as Bubble Series. The map component allows you to render geographic imagery from Bing Maps™, and Open Street Maps. The map provides plotting of tens of thousands of data points, and updates them every few milliseconds so that the control can handle your real-time feeds. The map's Series property is used to support rendering an unlimited number of geographic series. This property is a collection of geographic series objects and any type of geographic series can be added to it. For example, IgxGeographicSymbolSeriesComponent can be added for plotting geographic locations such as cities and the IgxGeographicPolylineSeriesComponent for plotting connections (e.g. roads) between these geographic locations. The map provides customizable navigation behaviors for navigating map content using mouse, keyboard, or code-behind. Dependencies The Angular geographic map component, you need to first install these packages: npm install --save igniteui-angular-core npm install --save igniteui-angular-charts npm install --save igniteui-angular-maps Component Modules The IgxGeographicMapComponent requires the following modules, however the DataChartInteractivityModule is only required for mouse interactions, such as panning and zooming the map content. // app.module.ts import { IgxGeographicMapModule } from 'igniteui-angular-maps'; import { IgxDataChartInteractivityModule } from 'igniteui-angular-charts'; @NgModule({ imports: [ // ... IgxGeographicMapModule, IgxDataChartInteractivityModule // ... ] }) export class AppModule {} import { AfterViewInit, Component, ViewChild } from \"@angular/core\"; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-overview\", styleUrls: [\"./map-overview.component.scss\"], templateUrl: \"./map-overview.component.html\" }) export class MapOverviewComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; constructor() { } public ngAfterViewInit(): void { this.map.windowRect = { left: 0.2, top: 0.1, width: 0.7, height: 0.7 }; } } Usage Now that the map module is imported, next step is to create geographic map. The following code demonstrates how to do this and enable zooming in the map. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> Additional Resources You can find more information about related Angular map features in these topics: Geographic Map Navigation Using Scatter Symbol Series Using Scatter Proportional Series Using Scatter Contour Series Using Scatter Density Series Using Scatter Area Series Using Shape Polygon Series Using Shape Polyline Series API References The following is a list of API members mentioned in the above sections: IgxGeographicMapComponent IgxGeographicContourLineSeriesComponent IgxGeographicHighDensityScatterSeriesComponent IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent IgxGeographicProportionalSymbolSeriesComponent IgxGeographicSymbolSeriesComponent IgxGeographicScatterAreaSeriesComponent View page on GitHub"
  },
  "components/geo-map-binding-data-csv.html": {
    "href": "components/geo-map-binding-data-csv.html",
    "title": "Angular Map | Data Visualization Tools | Binding CSV Data | Infragistics",
    "keywords": "Angular Binding CSV Files with Geographic Locations With the Ignite UI for Angular map component, you can plot geographic data loaded from various file types. For example, you can load geographic locations from a comma separated values (CSV) file. Angular Binding CSV Files with Geographic Locations Example Data Example Here is an example of data from CSV file: City,Lat,Lon,State,Code,County,Density,Population New York,40.7856,-74.0093,New Jersey,NJ,Hudson,21057,54227 Dundee,42.5236,-76.9775,New York,NY,Yates,579,1650 Code Snippet The following code loads and binds IgxGeographicHighDensityScatterSeriesComponent in the map component to an array of objects created from loaded CSV file with geographic locations. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> County: {{item.county}} </span> <br/> <span> Population: {{item.density}} K </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxGeographicHighDensityScatterSeriesComponent } from \"igniteui-angular-maps\"; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-binding-geographic-csv_files\", styleUrls: [\"./map-binding-geographic-csv_files.component.scss\"], templateUrl: \"./map-binding-geographic-csv_files.component.html\" }) export class MapBindingDataCsvComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { this.componentDidMount(); } public componentDidMount() { // fetching JSON data with geographic locations from public folder fetch(\"assets/Data/UsaCities.csv\") .then((response) => response.text()) .then((data) => this.onDataLoaded(data)); } public onDataLoaded(csvData: string) { const csvLines = csvData.split(\"\\n\"); // parsing CSV data and creating geographic locations const geoLocations: any[] = []; for (let i = 1; i < csvLines.length; i++) { const columns = csvLines[i].split(\",\"); const location = { code: columns[4], county: columns[5], density: Number(columns[6]), latitude: Number(columns[1]), longitude: Number(columns[2]), name: columns[0], population: Number(columns[7]), state: columns[3] }; geoLocations.push(location); } // creating HD series with loaded data const geoSeries = new IgxGeographicHighDensityScatterSeriesComponent(); geoSeries.dataSource = geoLocations; geoSeries.latitudeMemberPath = \"latitude\"; geoSeries.longitudeMemberPath = \"longitude\"; geoSeries.heatMaximumColor = \"Red\"; geoSeries.heatMinimumColor = \"Black\"; geoSeries.heatMinimum = 0; geoSeries.heatMaximum = 5; geoSeries.pointExtent = 1; geoSeries.tooltipTemplate = this.tooltip; geoSeries.mouseOverEnabled = true; // adding symbol series to the geographic amp this.map.series.add(geoSeries); } } API References IgxGeographicHighDensityScatterSeriesComponent DataSource latitudeMemberPath longitudeMemberPath heatMaximumColor heatMinimumColor pointExtent View page on GitHub"
  },
  "components/geo-map-binding-data-json-points.html": {
    "href": "components/geo-map-binding-data-json-points.html",
    "title": "Angular Map | Data Visualization Tools | Binding JSON Files | Infragistics",
    "keywords": "Angular Binding JSON Files with Geographic Locations With the Ignite UI for Angular map, you can plot geographic data loaded from various file types. For example, you can load geographic locations from JavaScript Object Notation (JSON) file. Angular Binding JSON Files with Geographic Locations Example Data Example Here is an example of data from JSON file: [ { \"name\": \"Sydney Island\", \"lat\": -16.68972, \"lon\": 139.45917 }, { \"name\": \"Sydney Creek\", \"lat\": -16.3, \"lon\": 128.95 }, { \"name\": \"Mount Sydney\", \"lat\": -21.39864, \"lon\": 121.193 }, // ... ] Code Snippet The following code loads and binds IgxGeographicHighDensityScatterSeriesComponent in the map component to an array of objects created from loaded JSON file with geographic locations: <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span>{{item.city}}</span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { MarkerType } from 'igniteui-angular-charts'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicSymbolSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-binding-geographic-json-files\", styleUrls: [\"./map-binding-geographic-json-files.component.scss\"], templateUrl: \"./map-binding-geographic-json-files.component.html\" }) export class MapBindingDataJsonPointsComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { this.componentDidMount(); } public componentDidMount() { // fetching JSON data with geographic locations from public folder fetch(\"assets/Data/WorldCities.json\") .then((response) => response.json()) .then((data) => this.onDataLoaded(data)); } public onDataLoaded(jsonData: any[]) { const geoLocations: any[] = []; // parsing JSON data and using only cities that are capitals for (const jsonItem of jsonData) { if (jsonItem.cap) { const location = { city: jsonItem.name, country: jsonItem.country, latitude: jsonItem.lat, longitude: jsonItem.lon, population: jsonItem.pop }; geoLocations.push(location); } } // creating symbol series with loaded data const geoSeries = new IgxGeographicSymbolSeriesComponent(); geoSeries.dataSource = geoLocations; geoSeries.markerType = MarkerType.Circle; geoSeries.latitudeMemberPath = \"latitude\"; geoSeries.longitudeMemberPath = \"longitude\"; geoSeries.markerBrush = \"LightGray\"; geoSeries.markerOutline = \"Black\"; geoSeries.tooltipTemplate = this.tooltip; // adding symbol series to the geographic amp this.map.series.add(geoSeries); } } API References IgxGeographicHighDensityScatterSeriesComponent IgxGeographicSymbolSeriesComponent GeographicMap DataSource latitudeMemberPath longitudeMemberPath View page on GitHub"
  },
  "components/geo-map-binding-data-model.html": {
    "href": "components/geo-map-binding-data-model.html",
    "title": "Angular Map | Data Visualization Tools | Binding Geographic Data Models | Infragistics",
    "keywords": "Angular Binding Geographic Data Models The Ignite UI for Angular map component is designed to display geo-spatial data from shape files and/or geographic locations from data models on geographic imagery maps. The ItemsSource property of geographic series is used for the purpose of binding to data models. This property can be bound an array of custom objects. Angular Binding Geographic Data Models Example The following table summarized data structures required for each type of geographic series: Geographic Series Properties Description IgxGeographicSymbolSeriesComponent longitudeMemberPath, latitudeMemberPath Specifies names of 2 numeric longitude and latitude coordinates IgxGeographicHighDensityScatterSeriesComponent longitudeMemberPath, latitudeMemberPath Specifies names of 2 numeric longitude and latitude coordinates IgxGeographicProportionalSymbolSeriesComponent longitudeMemberPath, latitudeMemberPath, radiusMemberPath Specifies names of 2 numeric longitude and latitude coordinates and 1 numeric column for size/radius of symbols IgxGeographicScatterAreaSeriesComponent longitudeMemberPath, latitudeMemberPath, colorMemberPath Specifies names of 2 numeric longitude and latitude coordinates and 1 numeric column for triangulation of values IgxGeographicContourLineSeriesComponent longitudeMemberPath, latitudeMemberPath, valueMemberPath Specifies names of 2 numeric longitude and latitude coordinates and 1 numeric column for triangulation of values IgxGeographicShapeSeriesComponent shapeMemberPath Specifies the name of data column of ItemsSource items that contains the geographic points of shapes. This property must be mapped to an array of arrays of objects with x and y properties. IgxGeographicPolylineSeriesComponent shapeMemberPath Specifies the name of data column of ItemsSource items that contains the geographic coordinates of lines. This property must be mapped to an array of arrays of objects with x and y properties. Code Snippet The following code shows how to bind the IgxGeographicSymbolSeriesComponent to a custom data model that contains geographic locations of some cities of the world stored using longitude and latitude coordinates. Also, we use the IgxGeographicPolylineSeriesComponent to plot shortest geographic path between these locations using the WorldUtility <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #pointSeriesTemplate> <div> <span [style.color]=\"series.brush\"> {{item.country}} </span> </div> </ng-template> <ng-template let-series=\"series\" let-item=\"item\" #polylineSeriesTooltipTemplate> <div> <span [style.color]=\"series.brush\"> Departure: {{item.origin.country}} </span> <br/> <span [style.color]=\"series.brush\"> Arrival: {{item.dest.country}} </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { MarkerType } from 'igniteui-angular-charts'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from \"igniteui-angular-maps\"; import { IgxGeographicSymbolSeriesComponent } from 'igniteui-angular-maps'; import { WorldUtils } from \"../../utilities/WorldUtils\"; @Component({ selector: \"app-map-binding-geographic-data-models\", styleUrls: [\"./map-binding-geographic-data-models.component.scss\"], templateUrl: \"./map-binding-geographic-data-models.component.html\" }) export class MapBindingDataModelComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"pointSeriesTemplate\") public pointSeriesTemplate: TemplateRef<object>; @ViewChild(\"polylineSeriesTooltipTemplate\") public polylineSeriesTooltipTemplate: TemplateRef<object>; public flights: any[]; constructor() { } public ngAfterViewInit(): void { const cityDAL = { lat: 32.763, lon: -96.663, country: \"US\", name: \"Dallas\" }; const citySYD = { lat: -33.889, lon: 151.028, country: \"Australia\", name: \"Sydney\" }; const cityNZL = { lat: -36.848, lon: 174.763, country: \"New Zealand\", name: \"Auckland\" }; const cityQTR = { lat: 25.285, lon: 51.531, country: \"Qatar\", name: \"Doha\" }; const cityPAN = { lat: 8.949, lon: -79.400, country: \"Panama\", name: \"Panama\" }; const cityCHL = { lat: -33.475, lon: -70.647, country: \"Chile\", name: \"Santiago\" }; const cityJAP = { lat: 35.683, lon: 139.809, country: \"Japan\", name: \"Tokyo\" }; const cityALT = { lat: 33.795, lon: -84.349, country: \"US\", name: \"Atlanta\" }; const cityJOH = { lat: -26.178, lon: 28.004, country: \"South Africa\", name: \"Johannesburg\" }; const cityNYC = { lat: 40.750, lon: -74.0999, country: \"US\", name: \"New York\" }; const citySNG = { lat: 1.229, lon: 104.177, country: \"Singapore\", name: \"Singapore\" }; const cityMOS = { lat: 55.750, lon: 37.700, country: \"Russia\", name: \"Moscow\" }; const cityROM = { lat: 41.880, lon: 12.520, country: \"Italy\", name: \"Roma\" }; const cityLAX = { lat: 34.000, lon: -118.25, country: \"US\", name: \"Los Angeles\" }; this.flights = [ { origin: cityDAL, dest: citySNG, color: \"Green\" }, { origin: cityMOS, dest: cityNZL, color: \"Red\" }, { origin: cityCHL, dest: cityJAP, color: \"Blue\" }, { origin: cityPAN, dest: cityROM, color: \"Orange\" }, { origin: cityALT, dest: cityJOH, color: \"Black\" }, { origin: cityNYC, dest: cityQTR, color: \"Purple\" }, { origin: cityLAX, dest: citySYD, color: \"Gray\" } ]; for (const flight of this.flights) { this.createPolylineSeries(flight); this.createSymbolSeries(flight); } } public createSymbolSeries(flight: any) { const geoLocations = [flight.origin, flight.dest ]; const symbolSeries = new IgxGeographicSymbolSeriesComponent (); symbolSeries.dataSource = geoLocations; symbolSeries.markerType = MarkerType.Circle; symbolSeries.latitudeMemberPath = \"lat\"; symbolSeries.longitudeMemberPath = \"lon\"; symbolSeries.markerBrush = \"White\"; symbolSeries.markerOutline = flight.color; symbolSeries.thickness = 1; symbolSeries.tooltipTemplate = this.pointSeriesTemplate; this.map.series.add(symbolSeries); } public createPolylineSeries(flight: any) { const geoPath = WorldUtils.calcPaths(flight.origin, flight.dest); const geoDistance = WorldUtils.calcDistance(flight.origin, flight.dest); const geoRoutes = [ { dest: flight.dest, distance: geoDistance, origin: flight.origin, points: geoPath, time: geoDistance / 850 }]; const lineSeries = new IgxGeographicPolylineSeriesComponent (); lineSeries.dataSource = geoRoutes; lineSeries.shapeMemberPath = \"points\"; lineSeries.shapeStrokeThickness = 9; lineSeries.shapeOpacity = 0.5; lineSeries.shapeStroke = flight.color; lineSeries.tooltipTemplate = this.polylineSeriesTooltipTemplate; this.map.series.add(lineSeries); } } API References colorMemberPath IgxGeographicContourLineSeriesComponent IgxGeographicHighDensityScatterSeriesComponent IgxGeographicPolylineSeriesComponent IgxGeographicProportionalSymbolSeriesComponent IgxGeographicScatterAreaSeriesComponent IgxGeographicSymbolSeriesComponent ItemsSource latitudeMemberPath longitudeMemberPath radiusMemberPath ValueMemberPath View page on GitHub"
  },
  "components/geo-map-binding-data-overview.html": {
    "href": "components/geo-map-binding-data-overview.html",
    "title": "Angular Map | Data Visualization Tools | Data Binding | Infragistics",
    "keywords": "Angular Data Binding The Ignite UI for Angular map component is designed to display geo-spatial data from shape files and/or geographic locations from data models on geographic imagery maps. The DataSource property of geographic series is used for the purpose of binding to data models. Types of Data Sources The following section list some of data source that you can bind in the geographic map component Binding Shape Files Binding JSON Files Binding CSV Files Binding Data Models Binding Multiple Sources View page on GitHub"
  },
  "components/geo-map-binding-multiple-shapes.html": {
    "href": "components/geo-map-binding-multiple-shapes.html",
    "title": "Angular Map | Data Visualization Tools | Binding Multiple Data Shapes | Infragistics",
    "keywords": "Angular Binding and Overlaying Multiple Shape Files In the Ignite UI for Angular map, you can add multiple geographic series objects to overlay a few shapefiles with geo-spacial data. For example, IgxGeographicSymbolSeriesComponent for plotting geographic locations of ports, the IgxGeographicPolylineSeriesComponent for plotting routes between ports, and the IgxGeographicShapeSeriesComponent for plotting shapes of countries. Angular Binding and Overlaying Multiple Shape Files Example This topic takes you step-by-step towards displaying multiple geographic series in the map component. All geographic series plot following geo-spatial data loaded from shape files using the IgxShapeDataSource class. Refer to the Binding Shape Files topic for more information about IgxShapeDataSource object. IgxGeographicSymbolSeriesComponent – displays locations of major cities IgxGeographicPolylineSeriesComponent – displays routes between major ports IgxGeographicShapeSeriesComponent – displays shapes of countries of the world You can use geographic series in above or other combinations to plot desired data. Importing Components First, let's import required components and modules: import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from 'igniteui-angular-maps'; import { IgxGeographicShapeSeriesComponent } from 'igniteui-angular-maps'; import { IgxGeographicSymbolSeriesComponent } from 'igniteui-angular-maps'; import { IgxShapeDataSource } from 'igniteui-angular-core'; Creating Series Next, we need to create a map with a few Geographic Series that will later load different type of shapefile. <div className=\"sampleRoot\"> <div className=\"map\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > <igx-geographic-shape-series #shapeSeries name=\"polygonSeries\" shapeMemberPath=\"points\" shapeFill=\"rgb(150, 150, 150)\" shapeStroke=\"Black\" shapeStrokeThickness={1.0} > </igx-geographic-shape-series> <igx-geographic-polyline-series #polylineSeries [tooltipTemplate]=\"polylineTooltipTemplate\" name=\"polylineSeries\" shapeMemberPath=\"points\" shapeStroke=\"rgba(147, 15, 180, 0.5)\" thickness={3.0} > </igx-geographic-polyline-series> <igx-geographic-symbol-series #symbolSeries name=\"symbolSeries\" longitudeMemberPath=\"longitude\" latitudeMemberPath=\"latitude\" markerType=\"Circle\" markerOutline=\"rgb(2, 102, 196)\" markerBrush=\"White\" > </igx-geographic-symbol-series> </igx-geographic-map> </div> </div> <ng-template let-series=\"series\" let-item=\"item\" #polylineTooltipTemplate> <div> <span>{{item.capacity}}</span><br /> <span>Distance: {{item.distance}}</span> </div> </ng-template> <ng-template let-series=\"series\" let-item=\"item\" #shapeTooltipTemplate> <div> <span>{{item.name}}</span><br /> <span>Population: {{item.population}}</span> </div> </ng-template> <ng-template let-series=\"series\" let-item=\"item\" #pointTooltipTemplate> <div> <span [style.color]=\"series.brush\">City: {{item.city}}</span> </div> </ng-template> Loading Shapefiles Next, in constructor of your page, add a IgxShapeDataSource for each shapefile that you want to display in the geographic map component. const sdsPolygons = new IgxShapeDataSource(); sdsPolygons.importCompleted = this.onPolygonsLoaded; sdsPolygons.shapefileSource = url + \"/shapes/WorldCountries.shp\"; sdsPolygons.databaseSource = url + \"/shapes/WorldCountries.dbf\"; sdsPolygons.dataBind(); const sdsPolylines = new IgxShapeDataSource(); sdsPolylines.importCompleted = this.onPolylinesLoaded; sdsPolylines.shapefileSource = url + \"/shapes/WorldConnections.shp\"; sdsPolylines.databaseSource = url + \"/shapes/WorldConnections.dbf\"; sdsPolylines.dataBind(); const sdsLocations = new IgxShapeDataSource(); sdsLocations.importCompleted = this.onPointsLoaded; sdsLocations.shapefileSource = url + \"/Shapes/WorldCities.shp\"; sdsLocations.databaseSource = url + \"/Shapes/WorldCities.dbf\"; sdsLocations.dataBind(); Processing Polygons Process shapes data loaded in IgxShapeDataSource with of countries of the world and assign it to IgxGeographicShapeSeriesComponent object. import { IgxGeographicPolylineSeriesComponent } from 'igniteui-angular-maps'; import { IgxShapeDataSource } from 'igniteui-angular-core'; // ... public onPolygonsLoaded(sds: IgxShapeDataSource, e: any) { const geoPolygons: any[] = []; // parsing shapefile data and creating geo-polygons let pointData = sds.getPointData(); for ( let i = 0; i < pointData.length; i++ ) { let record = pointData[i]; // using field/column names from .DBF file const country = { points: record.points, name: record.fieldValues.NAME, gdp: record.fieldValues.GDP, population: record.fieldValues.POPULATION }; geoPolygons.push(country); }; const shapeSeries = this.geoMap.series[0] as IgxGeographicShapeSeries; shapeSeries.dataSource = geoPolygons; } Processing Polyline Process shapes data loaded in IgxShapeDataSource with communication routes between major cities and assign it to IgxGeographicPolylineSeriesComponent object. import { IgxGeographicPolylineSeriesComponent } from 'igniteui-angular-maps'; import { IgxShapeDataSource } from 'igniteui-angular-core'; // ... public onPolylinesLoaded(sds: IgxShapeDataSource, e: any) { const geoPolylines: any[] = []; // parsing shapefile data and creating geo-polygons let pointData = sds.getPointData(); for ( let i = 0; i < pointData.length; i++ ) { let record = pointData[i]; // using field/column names from .DBF file const route = { points: record.points, name: record.fieldValues.Name, capacity: record.fieldValues.CapacityG, distance: record.fieldValues.DistanceKM, isOverLand: record.fieldValues.OverLand === 0, isActive: record.fieldValues.NotLive !== 0, service: record.fieldValues.InService }; geoPolylines.push(route); } const lineSeries = this.geoMap.series[1] as IgxGeographicPolylineSeries; lineSeries.dataSource = geoPolylines; } Processing Points Process shapes data loaded in IgxShapeDataSource with locations of major cities and assign it to IgxGeographicSymbolSeriesComponent object. import { IgxGeographicSymbolSeriesComponent } from 'igniteui-angular-maps'; import { IgxShapeDataSource } from 'igniteui-angular-core'; // ... public onPointsLoaded(sds: IgxShapeDataSource, e: any) { const geoLocations: any[] = []; // parsing shapefile data and creating geo-locations let pointData = sds.getPointData(); for ( let i = 0; i < pointData.length; i++ ) { let record = pointData[i]; const pop = record.fieldValues.POPULATION; if (pop > 0) { // each shapefile record has just one point const location = { latitude: record.points[0][0].y, longitude: record.points[0][0].x, city: record.fieldValues.NAME, population: pop }; geoLocations.push(location); } } const symbolSeries = this.geoMap.series[2] as IgxGeographicSymbolSeries; symbolSeries.dataSource = geoLocations; } Map Background Also, you might want to hide geographic imagery from the map background content if your shape files provided sufficient geographic context (e.g. shape of countries) for your application. public geoMap: IgxGeographicMapComponent; // ... this.geoMap.backgroundContent = {}; Summary For your convenience, all above code snippets are combined into one code block below that you can easily copy to your project. import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from \"igniteui-angular-maps\"; import { IgxGeographicShapeSeriesComponent } from 'igniteui-angular-maps'; import { IgxGeographicSymbolSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-binding-multiple-shapes-files\", styleUrls: [\"./map-binding-multiple-shapes-files.component.scss\"], templateUrl: \"./map-binding-multiple-shapes-files.component.html\" }) export class MapBindingMultipleShapesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild (\"shapeSeries\") public shapeSeries: IgxGeographicShapeSeriesComponent; @ViewChild (\"polylineSeries\") public polylineSeries: IgxGeographicPolylineSeriesComponent; @ViewChild (\"symbolSeries\") public symbolSeries: IgxGeographicSymbolSeriesComponent; @ViewChild(\"polylineTooltipTemplate\") public polylineTooltipTemplate: TemplateRef<object>; @ViewChild(\"shapeTooltipTemplate\") public shapeTooltipTemplate: TemplateRef<object>; @ViewChild(\"pointTooltipTemplate\") public pointTooltipTemplate: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { this.map.windowRect = { left: 0.2, top: 0.1, width: 0.6, height: 0.6 }; // loading a shapefile with geographic polygons const sdsPolygons = new IgxShapeDataSource(); sdsPolygons.importCompleted.subscribe(() => this.onPolygonsLoaded(sdsPolygons, \"\")); sdsPolygons.shapefileSource = \"assets/Shapes/WorldCountries.shp\"; sdsPolygons.databaseSource = \"assets/Shapes/WorldCountries.dbf\"; sdsPolygons.dataBind(); // loading a shapefile with geographic polylines at runtime. const sdsPolylines = new IgxShapeDataSource(); sdsPolylines.shapefileSource = \"assets/Shapes/WorldCableRoutes.shp\"; sdsPolylines.databaseSource = \"assets/Shapes/WorldCableRoutes.dbf\"; sdsPolylines.dataBind(); sdsPolylines.importCompleted.subscribe(() => this.onPolylinesLoaded(sdsPolylines, \"\")); // loading a shapefile with geographic points const sdsPoints = new IgxShapeDataSource(); sdsPoints.importCompleted.subscribe(() => this.onPointsLoaded(sdsPoints, \"\")); sdsPoints.shapefileSource = \"assets/Shapes/WorldCities.shp\"; sdsPoints.databaseSource = \"assets/Shapes/WorldCities.dbf\"; sdsPoints.dataBind(); } public onPointsLoaded(sds: IgxShapeDataSource, e: any) { const geoLocations: any[] = []; // parsing shapefile data and creating geo-locations for (const record of sds.getPointData()) { const pop = record.fieldValues[\"POPULATION\"]; if (pop > 0) { // each shapefile record has just one point const location = { city: record.fieldValues[\"NAME\"], latitude: record.points[0][0].y, longitude: record.points[0][0].x, population: pop }; geoLocations.push(location); } } this.symbolSeries.dataSource = geoLocations; this.symbolSeries.tooltipTemplate = this.pointTooltipTemplate; } public onPolylinesLoaded(sds: IgxShapeDataSource, e: any) { const geoPolylines: any[] = []; // parsing shapefile data and creating geo-polygons for (const record of sds.getPointData()) { // using field/column names from .DBF file const route = { capacity: record.fieldValues[\"CapacityG\"], distance: record.fieldValues[\"DistanceKM\"], isActive: record.fieldValues[\"NotLive\"] !== 0, isOverLand: record.fieldValues[\"OverLand\"] === 0, name: record.fieldValues[\"Name\"], points: record.points, service: record.fieldValues[\"InService\"] }; geoPolylines.push(route); } this.polylineSeries.dataSource = geoPolylines; this.polylineSeries.shapeMemberPath = \"points\"; this.polylineSeries.shapeFilterResolution = 2.0; this.polylineSeries.shapeStrokeThickness = 2; this.polylineSeries.shapeStroke = \"rgba(252, 32, 32, 0.9)\"; this.polylineSeries.tooltipTemplate = this.polylineTooltipTemplate; } public onPolygonsLoaded(sds: IgxShapeDataSource, e: any) { const geoPolygons: any[] = []; // parsing shapefile data and creating geo-polygons sds.getPointData().forEach((record) => { // using field/column names from .DBF file const country = { gdp: record.fieldValues[\"GDP\"], name: record.fieldValues[\"NAME\"], points: record.points, population: record.fieldValues[\"POPULATION\"] }; geoPolygons.push(country); }); this.shapeSeries.dataSource = geoPolygons; this.shapeSeries.tooltipTemplate = this.shapeTooltipTemplate; } } API References IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent IgxGeographicSymbolSeriesComponent IgxShapeDataSource View page on GitHub"
  },
  "components/geo-map-binding-multiple-sources.html": {
    "href": "components/geo-map-binding-multiple-sources.html",
    "title": "Angular Map | Data Visualization Tools | Binding Multiple Data Source | Infragistics",
    "keywords": "Angular Binding Multiple Data Sources In the Ignite UI for Angular map, you can add multiple geographic series objects to overlay custom data sources with geo-spacial data. For example, IgxGeographicSymbolSeriesComponent for plotting geographic locations of airports, the IgxGeographicPolylineSeriesComponent for plotting flights between airports, and 2nd IgxGeographicPolylineSeriesComponent for plotting gridlines of major geographic coordinates. Angular Binding Multiple Data Sources Example This topic takes you step-by-step towards displaying multiple geographic series that will plot following geo-spatial data: IgxGeographicSymbolSeriesComponent – displays locations of major airports IgxGeographicPolylineSeriesComponent – displays flights between airports IgxGeographicPolylineSeriesComponent – displays gridlines of major coordinates You can use geographic series in this or other combinations to plot desired data. Creating Data Sources Create data sources for all geographic series that you want to display in the Ignite UI for Angular map. For example, you can the use WorldConnections script. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #polylineTooltipTemplate> <div> <span> Arrival: {{item.origin.country}} </span> <br/> <span> Destination: {{item.dest.country}} </span> <br/> <span> Distance: {{item.distance}} miles </span> </div> </ng-template> <ng-template let-series=\"series\" let-item=\"item\" #pointTooltipTemplate> <div> <span> {{item?.country}} </span> <br /> <span> {{item?.name}} </span> <br /> <span> Population: {{item.pop}} M </span> <br/> <span> Flights: {{item.flights}} </span> </div> </ng-template> Overlaying Flights Create first IgxGeographicPolylineSeriesComponent object with flight connections between major airports and add it to the Series collection of the Ignite UI for Angular map. <igx-geographic-polyline-series #polylineSeries [tooltipTemplate]=\"polylineTooltipTemplate\" name=\"polylineSeries\" shapeMemberPath=\"points\" shapeStroke=\"rgba(147, 15, 180, 0.5)\" thickness={3.0} > </igx-geographic-polyline-series> Overlaying Gridlines Create second IgxGeographicPolylineSeriesComponent object with geographic gridlines and add it to the Series collection of the Ignite UI for Angular map. <igx-geographic-polyline-series #polylineSeries [tooltipTemplate]=\"polylineTooltipTemplate\" datasource = worldFlights name=\"polylineSeries\" shapeMemberPath=\"points\" shapeStroke=\"rgba(196, 14, 14,0.05)\" thickness={3.0} > </igx-geographic-polyline-series> Overlaying Airports Create IgxGeographicSymbolSeriesComponent object with airport points and add it to the Series collection of the geographic Ignite UI for Angular map. <igx-geographic-symbol-series #symbolSeries name=\"symbolSeries\" longitudeMemberPath=\"longitude\" latitudeMemberPath=\"latitude\" markerType=\"Circle\" markerOutline=\"rgb(73, 73, 73)\" markerBrush=\"White\" > </igx-geographic-symbol-series> Summary For your convenience, all above code snippets are combined into one code block below that you can easily copy to your project. import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { MarkerType } from 'igniteui-angular-charts'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from \"igniteui-angular-maps\"; import { IgxGeographicSymbolSeriesComponent } from \"igniteui-angular-maps\"; import { WorldConnections } from \"../../utilities/WorldConnections\"; @Component({ selector: \"app-map-binding-multiple-data-sources\", styleUrls: [\"./map-binding-multiple-data-sources.component.scss\"], templateUrl: \"./map-binding-multiple--data-sources.component.html\" }) export class MapBindingMultipleSourcesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"polylineTooltipTemplate\") public polylineTooltipTemplate: TemplateRef<object>; @ViewChild(\"pointTooltipTemplate\") public pointTooltipTemplate: TemplateRef<object>; public data: any; constructor() { } public ngAfterViewInit(): void { this.map.windowRect = { left: 0.195, top: 0.1, width: 0.5, height: 0.5 }; const worldFlights = WorldConnections.getFlights(); const worldAirports = WorldConnections.getAirports(); const worldGridlines = WorldConnections.getGridlines(); this.addPolylineSeriesWith(worldFlights); this.addGridlineSeriesWith(worldGridlines); this.addSymbolSeriesWith(worldAirports); } public addGridlineSeriesWith(data: any[]) { const gridSeries = new IgxGeographicPolylineSeriesComponent(); gridSeries.dataSource = data; gridSeries.shapeMemberPath = \"points\"; gridSeries.shapeStroke = \"Gray\"; gridSeries.shapeStrokeThickness = 1; this.map.series.add(gridSeries); } public addPolylineSeriesWith(data: any[]) { const lineSeries = new IgxGeographicPolylineSeriesComponent (); lineSeries.dataSource = data; lineSeries.shapeMemberPath = \"points\"; lineSeries.shapeStroke = \"rgba(196, 14, 14,0.05)\"; lineSeries.shapeStrokeThickness = 4; lineSeries.tooltipTemplate = this.polylineTooltipTemplate; this.map.series.add(lineSeries); } public addSymbolSeriesWith(data: any[]) { const symbolSeries = new IgxGeographicSymbolSeriesComponent (); symbolSeries.dataSource = data; symbolSeries.markerType = MarkerType.Circle; symbolSeries.latitudeMemberPath = \"lat\"; symbolSeries.longitudeMemberPath = \"lon\"; symbolSeries.markerBrush = \"#aad3df\"; symbolSeries.markerOutline = \"rgb(73, 73, 73)\"; symbolSeries.thickness = 1; symbolSeries.tooltipTemplate = this.pointTooltipTemplate; this.map.series.add(symbolSeries); } } API References IgxGeographicPolylineSeriesComponent IgxGeographicSymbolSeriesComponent View page on GitHub"
  },
  "components/geo-map-binding-shp-file.html": {
    "href": "components/geo-map-binding-shp-file.html",
    "title": "Angular Map | Data Visualization Tools | Binding Geographic Shape Files | Infragistics",
    "keywords": "Angular Binding Shape Files with Geo-spatial Data The Ignite UI for Angular map component, the IgxShapeDataSource class loads geo-spatial data (points/locations, polylines, polygons) from shape files and converts it to a collection of IgxShapefileRecord objects. Angular Binding Shape Files with Geo-spatial Data Example The following table explains properties of the IgxShapeDataSource class for loading shape files. Property Type Description shapefileSource string Specifies the Uri to a shape file (.shp) that contains geo-spatial data items. databaseSource string Specifies the Uri to a shape database file (.dbf) that contains a data table for geo-spatial data items. When both source properties are set to non-null values, then the IgxShapeDataSource object’s ImportAsync method is invoked which in return performs fetching and reading the shape files and finally doing the conversion. After this operation is complete, the IgxShapeDataSource is populated with IgxShapefileRecord objects and the ImportCompleted event is raised in order to notify about completed process of loading and converting geo-spatial data from shape files. Loading Shapefiles The following code creates an instance of the IgxShapeDataSource object for loading a shape file that contains locations of major cities in the world. It also demonstrates how to handle the ImportCompleted event as a prerequisite for binding data to the map component. Binding Shapefiles In the map component, Geographic Series are used for displaying geo-spatial data that is loaded from shape files. All types of Geographic Series have an ItemsSource property which can be bound to an array of objects. The IgxShapeDataSource is an example such array because it contains a list of IgxShapefileRecord objects. The IgxShapefileRecord class provides properties for storing geo-spatial data, listed in the following table. Property Description Points Contains all the points in one geo-spatial shape loaded from a shape file (.shp). For example, the country of Japan in shape file would be represented as a list of a list of points object, where: The first list of points describes shape of Hokkaido island The second list of points describes shape of Honshu island The third list of points describes shape of Kyushu island The fourth list of points describes shape of Shikoku island | | `Fields` |Contains a row of data from the shape database file (.dbf) keyed by a column name. For example, a data about county of Japan which includes population, area, name of a capital, etc.| This data structure is suitable for use in most Geographic Series as long as appropriate data columns are mapped to them. Code Snippet This code example assumes that shape files were loaded using the IgxShapeDataSource. The following code binds IgxGeographicPolylineSeriesComponent in the map component to the IgxShapeDataSource and maps the Points property of all IgxShapefileRecord objects. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> Airline: {{item.name}} </span> <br /> <span> Length: {{item.distance}} miles </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-binding-shape-files\", styleUrls: [\"./map-binding-shape-files.component.scss\"], templateUrl: \"./map-binding-shape-files.component.html\" }) export class MapBindingShapefilePolylinesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltipTemplate: TemplateRef<object>; constructor() { } public ngAfterViewInit() { // loading a shapefile with geographic polygons const sds = new IgxShapeDataSource(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); sds.shapefileSource = \"assets/Shapes/WorldCableRoutes.shp\"; sds.databaseSource = \"assets/Shapes/WorldCableRoutes.dbf\"; sds.dataBind(); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); const geoPolylines: any[] = []; // parsing shapefile data and creating geo-polygons for (const record of shapeRecords) { // using field/column names from .DBF file const route = { capacity: record.fieldValues[\"CapacityG\"], distance: record.fieldValues[\"DistanceKM\"], isActive: record.fieldValues[\"NotLive\"] !== 0, isOverLand: record.fieldValues[\"OverLand\"] === 0, name: record.fieldValues[\"Name\"], points: record.points, service: record.fieldValues[\"InService\"] }; geoPolylines.push(route); } const geoSeries = new IgxGeographicPolylineSeriesComponent(); geoSeries.dataSource = geoPolylines; geoSeries.shapeMemberPath = \"points\"; geoSeries.shapeFilterResolution = 0.0; geoSeries.shapeStrokeThickness = 3; geoSeries.shapeStroke = \"rgb(82, 82, 82, 0.4)\"; geoSeries.tooltipTemplate = this.tooltipTemplate; this.map.series.add(geoSeries); } } API References Fields IgxGeographicPolylineSeriesComponent ImportCompleted ItemsSource Points IgxShapeDataSource View page on GitHub"
  },
  "components/geo-map-display-bing-imagery.html": {
    "href": "components/geo-map-display-bing-imagery.html",
    "title": "Angular Map | Data Visualization Tools | Displaying Bing Imagery | Infragistics",
    "keywords": "Angular Displaying Imagery from Bing Maps The Angular IgxBingMapsMapImagery is geographic imagery mapping service provided by Microsoft® company. It provides 3 styles of geographic imagery tiles of the world. This geographic imagery service is accessible directly on the www.bing.com/maps web site. The Ignite UI for Angular map component can display geographic imagery from Bing Maps in the map’s background content using the IgxBingMapsMapImagery class. Angular Displaying Imagery from Bing Maps Example Code Snippet The following code snippet shows how to display geographic imagery tiles from Bing Maps in Angular IgxGeographicMapComponent using IgxBingMapsMapImagery class. <igx-geographic-map #map width=\"100%\" height=\"100%\" zoomable=\"true\" > </igx-geographic-map> import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxBingMapsMapImagery } from 'igniteui-angular-maps'; // ... const tileSource = new IgxBingMapsMapImagery(); tileSource.apiKey = \"YOUR_BING_MAPS_API_KEY\"; tileSource.imageryStyle = BingMapsImageryStyle.AerialWithLabels; // or tileSource.imageryStyle = BingMapsImageryStyle.Aerial; // or tileSource.imageryStyle = BingMapsImageryStyle.Road; // resolving BingMaps uri based on HTTP protocol of hosting website let tileUri = tileSource.actualBingImageryRestUri; const isHttpSecured = window.location.toString().startsWith(\"https:\"); if (isHttpSecured) { tileUri = tileUri.replace(\"http:\", \"https:\"); } else { tileUri = tileUri.replace(\"https:\", \"http:\"); } tileSource.bingImageryRestUri = tileUri; this.map.backgroundContent = tileSource; Properties The following table summarized properties of the IgxBingMapsMapImagery class: Property Name Property Type Description apiKey string Represents the property for setting an API key required for the Bing Maps imagery service. You must obtain this key from the www.bingmapsportal.com website. imageryStyle BingMapsImageryStyle Represents the property for setting the Bing Maps imagery tiles map style. This property can be set to the following BingMapsImageryStyle enumeration values: Aerial - Specifies the Aerial map style without road or labels overlay AerialWithLabels - Specifies the Aerial map style with road and labels overlay Road - Specifies the Roads map style without Aerial overlay bingImageryRestUri string Represents the property for setting the Bing Imagery REST URI specifying where the TilePath and SubDomains will come from. This is an optional property, and if not specified it will use the default REST URI. cultureName string Represents a property for setting the culture name for the tile source. isDeferredLoad boolean Represents the property that specifies whether or not the Bing Maps service should auto-initialized upon the assignment of valid property values. isInitialized boolean Represents the property that is set to True occurs when geographic imagery tiles from Bing Maps service have been initialized and they are ready for rendering in the map component. subDomains SubDomainsCollection Represents an image collection of URI sub domains tilePath string Represents a property that sets the map tile image URI, this is the actual location of the Bing Maps API References BingMapsImageryStyle IgxBingMapsMapImagery IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-display-esri-imagery.html": {
    "href": "components/geo-map-display-esri-imagery.html",
    "title": "Angular Map | Data Visualization Tools | Displaying ESRI Imagery | Infragistics",
    "keywords": "Angular Displaying Imagery from Esri Maps The IgxArcGISOnlineMapImagery is a free geographic imagery mapping service created by Esri company. It provides over 40 styles of geographic imagery tiles of the world and some thematic tiles for the USA. This geographic imagery service can be accessed directly on www.arcgisonline.com web site. Angular Displaying Imagery from Esri Maps Example Code Snippet The following code snippet shows how to display Angular geographic imagery tiles from Esri imagery servers in IgxGeographicMapComponent using IgxArcGISOnlineMapImagery class. <igx-geographic-map #map width=\"100%\" height=\"100%\" zoomable=\"true\" > </igx-geographic-map> import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxArcGISOnlineMapImagery } from 'igniteui-angular-maps'; // ... public geoMap: IgxGeographicMapComponent; const tileSource = new IgxArcGISOnlineMapImagery(); tileSource.mapServerUri = \"https://services.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer\"; this.geoMap.backgroundContent = tileSource; Esri Utility Alternatively, you can use the EsriUtility which defines all styles provided by Esri imagery servers. import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxArcGISOnlineMapImagery } from 'igniteui-angular-maps'; import { EsriUtility, EsriStyle } from './EsriUtility'; // ... public geoMap: IgxGeographicMapComponent; const tileSource = new IgxArcGISOnlineMapImagery(); tileSource.mapServerUri = EsriUtility.getUri(EsriStyle.WorldOceansMap); this.geoMap.backgroundContent = tileSource; API References IgxArcGISOnlineMapImagery IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-display-heat-imagery.html": {
    "href": "components/geo-map-display-heat-imagery.html",
    "title": "Angular Map | Data Visualization Tools | Infragistics",
    "keywords": "Angular Displaying Heat Imagery The Ignite UI for Angular map control has the ability to show heat-map imagery through the use of the ShapeFileRecord that are generated by a IgxShapeDataSource by loading geo-spatial data by loading shape files to a tile series. It is highly recommended that you review the Binding Shape Files with Geo-Spatial Data topic as a pre-requisite to this topic. Angular Displaying Heat Imagery Example When a IgxShapeDataSource loads its shape files, it converts that data into IgxShapefileRecord objects. These objects can be retrieved from the GetPointData() method of the IgxShapeDataSource and can then be used to create a heat-map through usage of a IgxTileGeneratorMapImagery object with a IgxHeatTileGenerator assigned to its TileGenerator property. This IgxTileGeneratorMapImagery can then be used in a IgxGeographicTileSeriesComponent as its tileImagery source. The IgxHeatTileGenerator object works such that it has three value paths, xValues, yValues and values. As an example of how these could be used, in the case of a shape file that has information about population, you could consider the xValues to be longitude, yValues to be latitude, and values to be the population data. Each of these properties takes a number[]. The display of the geographic tile series when using the heat-map functionality can be customized by setting the minimumColor and maximumColor properties to \"rgba\" strings that describe colors that you wish to correspond to the minimum and maximum values of the collection that you assign to the values property of the HeatTileGenerator. You can further customize this by setting the ScaleColors property of the generator to contain a collection of strings that describe colors, as this will tell the IgxHeatTileGenerator what colors to use for the displayed values in the map. It is also possible to customize how colors in your ScaleColors collection blur together by using the blurRadius, maxBlurRadius, and useBlurRadiusAdjustedForZoom properties. The IgxHeatTileGenerator can also use a logarithmic scale. If you want to use this, you can set the useLogarithmicScale property to true. Web Worker The IgxHeatTileGenerator also has support for web workers to do the heavy lifting of the loading of the tile imagery from your shape file on a separate thread. This can greatly improve the performance of your geographic map when using the heat-map functionality. In order to use a web worker with the generator, you can set the useWebWorkers property to true and then set the webWorkerInstance property to an instance of your web worker. // heatworker.worker.ts import { HeatTileGeneratorWebWorker } from 'igniteui-angular-core'; const worker: Worker = self as any; worker.onmessage = HeatTileGeneratorWebWorker.onmessage; HeatTileGeneratorWebWorker.postmessage = heatWorkerPostMessage; function heatWorkerPostMessage() { (self as any).postMessage.apply(self, Array.prototype.slice.call(arguments)); } HeatTileGeneratorWebWorker.start(); export default {} as typeof Worker & (new () => Worker); Dependencies import { IgxHeatTileGenerator } from 'igniteui-angular-core'; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxTileGeneratorMapImagery } from 'igniteui-angular-maps'; Creating Heatmap The following code snippet shows how to display a population based heat-map in the Ignite UI for Angular map component: <igx-geographic-map #map width=\"100%\" height=\"calc(100% - 60px)\"> <igx-geographic-tile-series name=\"heatTiles\" [tileImagery]=\"tileImagery\"></igx-geographic-tile-series> </igx-geographic-map> @ViewChild(\"map\", { static: true }) public map: IgxGeographicMapComponent; public data: any[]; public tileImagery: IgxTileGeneratorMapImagery; // ... constructor() { this.data = this.initData(); this.tileImagery = new IgxTileGeneratorMapImagery(); const con: IgxShapeDataSource = new IgxShapeDataSource(); con.importCompleted.subscribe((s, e) => { const data = con.getPointData(); const lat: number[] = []; const lon: number[] = []; const val: number[] = []; for (let i = 0; i < data.length; i++) { const item = data[i]; for (let j = 0; j < item.points.length; j++) { const pointsList = item.points[j]; for (let k = 0; k < pointsList.length; k++) { lat.push(pointsList[k].y); lon.push(pointsList[k].x); } } const value = item.fieldValues[\"POP_2010\"]; if (value >= 0) { val.push(value); } else { val.push(0); } } const gen = new IgxHeatTileGenerator(); gen.xValues = lon; gen.yValues = lat; gen.values = val; gen.blurRadius = 6; gen.maxBlurRadius = 20; gen.useBlurRadiusAdjustedForZoom = true; gen.minimumColor = \"rgba(100,255, 0, 0.3922)\"; gen.maximumColor = \"rgba(255, 255, 0, 0.9412)\"; gen.useGlobalMinMax = true; gen.useGlobalMinMaxAdjustedForZoom = true; gen.useLogarithmicScale = true; gen.useWebWorkers = true; gen.webWorkerInstance = new Worker(\"../heatworker.worker\", { type: \"module\" }); gen.scaleColors = [ \"rgba(0, 0, 255, 64)\", \"rgba(0, 255, 255, 96)\", \"rgba(0, 255, 0, 160)\", \"rgba(255, 255, 0, 180)\", \"rgba(255, 0, 0, 200)\" ]; this.tileImagery.tileGenerator = gen; }); con.shapefileSource = \"assets/Shapes/AmericanCities.shp\"; con.databaseSource = \"assets/Shapes/AmericanCities.dbf\"; con.dataBind(); } API References IgxGeographicTileSeriesComponent IgxHeatTileGenerator maximumColor minimumColor IgxShapefileRecord IgxShapeDataSource IgxTileGeneratorMapImagery tileGenerator tileImagery useBlurRadiusAdjustedForZoom useLogarithmicScale View page on GitHub"
  },
  "components/geo-map-display-imagery-types.html": {
    "href": "components/geo-map-display-imagery-types.html",
    "title": "Angular Map | Data Visualization Tools | Geographic Imagery | Infragistics",
    "keywords": "Angular Geographic Imagery Angular Geographic imagery is a detailed representation of the world from a top view perspective. It can consist of an aerial-satellite map or road maps in a multi-scale imagery tiles structure. The geographic map component can display geographic imagery in order to provide end-users with rich and interactive world maps and geographic context for geo-spatial data. Types of geographic imagery The map component can display geographic imagery tiles from three supported mapping services or from other mapping services that can be easily implemented in an application. The following table summarizes supported and custom geographic imagery sources for the map component. Imagery Description Open Street Maps Provides geographic imagery from Open Street Maps service with an option to display a road map style only in one coloring theme. Bing Maps Provides geographic imagery from Bing Maps service with configurable options to display the following map styles: Satellite Map Style Satellite Map with Labels Style Road Map Style Map Background Content The map component's BackgroundContent property is used to display all supported types of geographic imagery sources. For each imagery source, there is an imagery class used for rendering corresponding geographic imagery tiles. The following table summarizes imagery classes provided by the map component. Imagery Class Description IgxGeographicMapImagery Represents the base control for all imagery classes that display all types of supported geographic imagery tiles. This class can be extended for the purpose of implementing support for geographic imagery tiles from other geographic imagery sources such as Map Quest mapping service. IgxOpenStreetMapImagery Represents the multi-scale imagery control for displaying geographic imagery tiles from the Open Street Maps service. By default, the BackgroundContent property is set to IgxOpenStreetMapImagery object and the map component displays geographic imagery tiles from the Open Street Maps service. In order to display different types of geographic imagery tiles, the map component must be re-configured. In addition, the BackgroundContent property can be set to any object that inherits the class. However, only objects that inherit the IgxGeographicMapImagery class will allow panning and zooming of the map background content. In the map component, map background content is always rendered behind all geographic series. In other words, geographic imagery tiles are always rendered first and any geographic series in the map component's Series property is rendered on top of the geographic imagery tiles. This is especially important when displaying multiple geographic series in the same plot area of the map component because geographic imagery tiles can quickly get buried in the map view. Code Snippet This code example explicitly sets BackgroundContent of the map component to the IgxOpenStreetMapImagery object which provides geographic imagery tile from the Open Street Maps. View page on GitHub"
  },
  "components/geo-map-display-osm-imagery.html": {
    "href": "components/geo-map-display-osm-imagery.html",
    "title": "Angular Map | Data Visualization Tools | Displaying Open Street Maps Imagery | Infragistics",
    "keywords": "Angular Displaying Imagery from Open Street Maps The Angular IgxOpenStreetMapImagery is a free geographic imagery mapping service created collaboratively by OpenStreetMap© contributors from around the world. It provides geographic imagery tiles of the world only in road map style without any configuration options. This geographic imagery service can be accessed directly on www.OpenStreetMap.org web site. By the default, the Ignite UI for Angular map component already displays geographic imagery from the Open Street Maps. Therefore, there is no need to configure the control to display geographic imagery from the Open Street Maps. Angular Displaying Imagery from Open Street Maps Example Code Snippet This code example explicitly sets BackgroundContent of the map component to the IgxOpenStreetMapImagery object which provides geographic imagery from OpenStreetMap© contributors. <igx-geographic-map #map width=\"100%\" height=\"100%\" zoomable=\"true\" > </igx-geographic-map> import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxOpenStreetMapImagery } from 'igniteui-angular-maps'; // ... public map: IgxGeographicMapComponent; const tileSource = new IgxOpenStreetMapImagery(); this.map.backgroundContent = tileSource; API References BackgroundContent IgxOpenStreetMapImagery View page on GitHub"
  },
  "components/geo-map-navigation.html": {
    "href": "components/geo-map-navigation.html",
    "title": "Angular Map | Data Visualization Tools | Map Navigation | Infragistics",
    "keywords": "Angular Navigating Map Content Navigation in the IgxGeographicMapComponent control is enabled by default and it allows zooming and panning of the map content. However, this behavior can be changed using the zoomable property. It is important to know that the map allows only synchronized zooming - scaling the map content with preserved aspect ratio. As result, it is not possible to scale the map content vertically without scaling it also horizontally and vice versa. Angular Navigating Map Content Example Geographic Coordinates You navigate map content within geographic region bound by these coordinates: horizontally from 180°E (negative) to 180°W (positive) longitudes vertically from 85°S (negative) to 85°N (positive) latitudes This code snippet shows how navigate the map using geographic coordinates: Window Coordinates Also, you can navigate map content within window rectangle bound by these relative coordinates: horizontally from 0.0 to 1.0 values vertically from 0.0 to 1.0 values This code snippet shows how navigate the map using relative window coordinates: Properties The following table summarizes properties that can be used in navigation of the IgxGeographicMapComponent control: Property Name Property Type Description windowRect Rect Sets new position and size of the navigation window in viewable area of the map content. Rect with 0, 0, 1, 1 values will zoom out the entire map content in the navigation window. windowScale number Sets new size of the navigation window in of the map control. It is equivalent smallest value of Width or Height stored in the windowRect property windowPositionHorizontal number Sets new horizontal position of the navigation window’s anchor point from the left edge of the map control. It is equivalent to value stored in the Left of the windowRect property. windowPositionVertical number Sets new vertical position of the navigation window’s anchor point from the top edge of the map control. It is equivalent to value stored in the Top of the windowRect property. actualWindowRect Rect Indicates current position and size of the navigation window in viewable area of the map content. Rect with 0, 0, 1, 1 values displays the entire map content in the navigation window. actualWindowScale number Indicates current size of the navigation window in of the map control. It is equivalent to smallest value of Width or Height stored in the actualWindowRect property actualWindowPositionHorizontal number Indicates current horizontal position of the navigation window’s anchor point from the left edge of the map control. It is equivalent to value stored in the Left of the actualWindowRect property. actualWindowPositionVertical number Indicates vertical position of the navigation window’s anchor point from the top edge of the map control. It is equivalent to value stored in the Top of the actualWindowRect property. API References actualWindowRect windowRect IgxGeographicMapComponent zoomable View page on GitHub"
  },
  "components/geo-map-resources-esri.html": {
    "href": "components/geo-map-resources-esri.html",
    "title": "Angular Map | Data Visualization Tools | ESRI Map Resources | Infragistics",
    "keywords": "Angular Esri Utility The resource topic provides implementation of an utility that helps with using IgxArcGISOnlineMapImagery provided by Esri Maps in IgxGeographicMapComponent. Code Snippet export class EsriUtility { public static getUri(style: EsriStyle): string { let isHttpSecured = window.location.toString().startsWith(\"https:\"); // resolving Esri Server uri based on hosting website let uri: string = style; if (!isHttpSecured) { uri = uri.replace(\"https:\", \"http:\"); } return uri; } } /** * Describes available links to imagery tile sources on public ArcGIS/Esri servers. * You can find up-to-date list on https://services.arcgisonline.com/arcgis/rest/services */ export enum EsriStyle { // these Esri maps show geographic tiles for the whole of world WorldStreetMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer\", WorldTopographicMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer\", WorldImageryMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer\", WorldOceansMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/Ocean_Basemap/MapServer\", WorldNationalGeoMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/NatGeo_World_Map/MapServer\", WorldTerrainMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer\", WorldDeLormesMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/Specialty/DeLorme_World_Base_Map/MapServer\", WorldLightGrayMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer\", WorldShadedReliefMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Shaded_Relief/MapServer\", WorldPhysicalMap = \"https://services.arcgisonline.com/ArcGIS/rest/services/World_Physical_Map/MapServer\", // these Esri maps show geographic tiles for the whole of world without contours of continents // therefore the Map should also load a shapefile of continents when using them WorldAdminOverlay = \"https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer\", WorldTransportationOverlay = \"https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer\", WorldBoundariesDarkOverlay =\"https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer\", WorldBoundariesLightOverlay = \"https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places_Alternate/MapServer\", WorldLabelsLightGrayOverlay = \"https://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Reference/MapServer\", // these Esri maps show only geographic tiles for the USA // therefore the Map should be zoomed in to geographic bounds of USA when using them UsaOwnerOccupiedHousing = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Owner_Occupied_Housing/MapServer\", UsaSoilSurvey = \"https://services.arcgisonline.com/ArcGIS/rest/services/Specialty/Soil_Survey_Map/MapServer\", UsaPopulationOlderThanAge64 = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Percent_Over_64/MapServer\", UsaPopulationYoungerThan18 = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Percent_Under_18/MapServer\", UsaPopulationGrowth2015 = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Projected_Population_Change/MapServer\", UsaUnemploymentRate = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Unemployment_Rate/MapServer\", UsaSocialVulnerability = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Social_Vulnerability_Index/MapServer\", UsaRetailSpendingPotential = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Retail_Spending_Potential/MapServer\", UsaPopulationChange2010 = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Recent_Population_Change/MapServer\", UsaPopulationChange2000 = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_1990-2000_Population_Change/MapServer\", UsaPopulationDensity = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Population_Density/MapServer\", UsaPopulationByGender = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Population_by_Sex/MapServer\", UsaMedianHouseholdIncome = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Median_Household_Income/MapServer\", UsaMedianNetWorth = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Median_Net_Worth/MapServer\", UsaMedianHomeValue = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Median_Home_Value/MapServer\", UsaMedianAge = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Median_Age/MapServer\", UsaLaborForceParticipation = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Labor_Force_Participation_Rate/MapServer\", UsaAverageHouseholdSize = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Average_Household_Size/MapServer\", UsaDiversityIndex = \"https://services.arcgisonline.com/ArcGIS/rest/services/Demographics/USA_Diversity_Index/MapServer\", UsaRailNetwork = \"https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer\", } API References IgxArcGISOnlineMapImagery IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-resources-shape-styling-utility.html": {
    "href": "components/geo-map-resources-shape-styling-utility.html",
    "title": "Angular Map | Shape Map Resources | Infragistics",
    "keywords": "Angular Shape Styling Utility The resource topic provides implementation of an utility that helps with styling UI elements of IgxGeographicShapeSeriesComponent in Angular IgxGeographicMapComponent component. Required Imports import { IgxGeographicShapeSeries } from 'igniteui-angular-maps'; import { Style } from 'igniteui-angular-core'; Utility Implementation export abstract class ShapeStyling { public defaultStroke = 'black'; public defaultFill = 'gray'; public defaultThickness = 0.5; public defaultOpacity = 1.0; public defaultStyle = new Style(); constructor() { this.defaultStyle = new Style(); this.defaultStyle.stroke = this.defaultStroke; this.defaultStyle.fill = this.defaultFill; this.defaultStyle.opacity = this.defaultOpacity; this.defaultStyle.strokeThickness = this.defaultThickness; } public abstract generate(record: any): Style; public getValue(itemMemberPath: string, item: any): any { let itemValue = null; if (item.fieldValues !== undefined) { // .hasOwnProperty(\"fieldValues\")) { if (item.fieldsNames.indexOf(itemMemberPath) >= 0) { itemValue = item.fieldValues[itemMemberPath]; } else { console.log('WARNING: ShapefileRecord does not have ' + itemMemberPath + ' in fieldValues property'); } } else if (item.hasOwnProperty(itemMemberPath)) { itemValue = item[itemMemberPath]; } else { console.log('WARNING: Shape data item does not have ' + itemMemberPath + ' property'); } return itemValue; } } export class ShapeRandomStyling extends ShapeStyling { public shapeThickness = 0.5; public shapeOpacity = 1.0; public shapeStrokeColors = ['black']; public shapeFillColors = ['red', 'orange', 'yellow']; public styleMappings = new Map<string, Style>(); public generate(record: any): Style { const id = record.fieldValues.Name || this.getRandomValue(0, 1000); if (this.styleMappings.has(id)) { return this.styleMappings.get(id); } else { const randStroke = this.getRandomItem(this.shapeStrokeColors); const randFill = this.getRandomItem(this.shapeFillColors); const shapeStyle = new Style(); shapeStyle.stroke = this.shapeStrokeColors[randStroke]; shapeStyle.fill = this.shapeFillColors[randFill]; shapeStyle.opacity = this.shapeOpacity; shapeStyle.strokeThickness = this.shapeThickness; this.styleMappings.set(id, shapeStyle); return shapeStyle; } } public getRandomValue(min: number, max: number): number { return Math.round(min + (Math.random() * (max - min))); } public getRandomItem(array: any[]): any { return this.getRandomValue(0, array.length - 1); } } export class ShapeRangeStyling extends ShapeStyling { public itemMemberPath = ''; public ranges: ShapeRange[] = []; constructor() { super(); this.ranges.push({ minimum: 0, maximum: 50, fill: 'yellow'} ); this.ranges.push({ minimum: 0, maximum: 100, fill: 'red'} ); } public generate(record: any): Style { let itemValue = this.getValue(this.itemMemberPath, record); if (itemValue === null) { return this.defaultStyle; } for (const range of this.ranges) { if (range.minimum <= itemValue && itemValue < range.maximum) { const shapeStyle = new Style(); shapeStyle.opacity = range.opacity || this.defaultOpacity; shapeStyle.fill = range.fill || this.defaultFill; shapeStyle.stroke = range.stroke || this.defaultStroke; shapeStyle.strokeThickness = range.strokeThickness || this.defaultThickness; return shapeStyle; } } return this.defaultStyle; } } export class ShapeRange { public minimum: number; public maximum: number; public opacity?: number; public fill: string; public stroke?: string; public strokeThickness?: number; } export class ShapeScaleStyling extends ShapeStyling { public shapeThickness = 0.5; public shapeOpacity = 1.0; public shapeStrokeColors = ['black']; public shapeFillColors = ['red', 'orange', 'yellow']; public itemMemberPath = ''; public itemMinimumValue = 0; public itemMaximumValue = 1000; public isLogarithmic = true; public generate(record: any): Style { let itemValue = this.getValue(this.itemMemberPath, record); if (itemValue === null) { return this.defaultStyle; } let fillColor = this.defaultFill; let strokeColor = this.defaultStroke; let scaleValue = this.getScaledValue(itemValue); if (!Number.isNaN(scaleValue)) { let fillIndex = Math.round(scaleValue * (this.shapeFillColors.length - 1)); let strokeIndex = Math.round(scaleValue * (this.shapeStrokeColors.length - 1)); fillColor = this.shapeFillColors[fillIndex]; strokeColor = this.shapeStrokeColors[strokeIndex]; } const shapeStyle = new Style(); shapeStyle.fill = fillColor; shapeStyle.stroke = strokeColor; shapeStyle.strokeThickness = this.shapeThickness; shapeStyle.opacity = this.shapeOpacity; return shapeStyle; } public getScaledValue(value: number): number { if (!Number.isFinite(value) || Number.isNaN(value)) { return Number.NaN; } let min = !Number.isFinite(this.itemMinimumValue) || Number.isNaN(this.itemMinimumValue) ? 0 : this.itemMinimumValue; let max = !Number.isFinite(this.itemMaximumValue) || Number.isNaN(this.itemMaximumValue) ? 1000 : this.itemMaximumValue; if (value < min || value > max) { return Number.NaN; } if (this.isLogarithmic) { return this.getLogarithmicValue(min, max, value); } else { return this.getLinearValue(min, max, value); } } public getLogarithmicValue(min: number, max: number, value: number) { if (!Number.isFinite(value)) { return Number.NaN; } let newMin = Math.log10(min); let newMax = Math.log10(max); let newVal = Math.log10(value); if (!Number.isFinite(newMin)) { newMin = 0.0; } if (!Number.isFinite(newMax)) { newMax = 1000; } if (newVal < 0) { newVal = 0.0; } return this.getLinearValue(newMin, newMax, newVal); } public getLinearValue(min: number, max: number, value: number) { if (!Number.isFinite(value)) { return Number.NaN; } // if the value is outside the range if (value < min || value > max) { return Number.NaN; } let scaledValue = (value - min) / (max - min); return scaledValue; } } export class ShapeComparisonStyling extends ShapeStyling { public itemMemberPath = ''; public itemMappings: ShapeComparison[] = []; public generate(record: any): Style { let itemValue = this.getValue(this.itemMemberPath, record); if (itemValue === null || itemValue === \"\") { return this.defaultStyle; } for (const mapping of this.itemMappings) { if (mapping.itemValue === itemValue) { const shapeStyle = new Style(); shapeStyle.opacity = mapping.opacity || this.defaultOpacity; shapeStyle.fill = mapping.fill || this.defaultFill; shapeStyle.stroke = mapping.stroke || this.defaultStroke; shapeStyle.strokeThickness = mapping.strokeThickness || this.defaultThickness; return shapeStyle; } } return this.defaultStyle; } } export class ShapeComparison { public itemValue: string; public opacity?: number; public fill: string; public stroke?: string; public strokeThickness?: number; } API References IgxGeographicShapeSeriesComponent IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-resources-world-connections.html": {
    "href": "components/geo-map-resources-world-connections.html",
    "title": "Angular Map | World Connections | Data Source | Infragistics",
    "keywords": "Angular World Connections The resource topic provides implementation of data utility for generating locations of airports, flight paths, and geographic gridlines. You can use these data sources as reference point for creating your own geographic data. Note that this utility depends on WorldUtil and WorldLocations scripts. Code Snippet import WorldLocations from \"./WorldLocations\"; import WorldUtils from \"./WorldUtils\" export default class WorldConnections { private static airports: any[] = []; private static airportsLookup = new Map<string, any>(); private static flights: any[] = []; private static flightsLookup: string[] = []; public static getFlights(): any[] { if (this.flights.length == 0) this.init(); return this.flights; } public static getAirports(): any[] { if (this.airports.length == 0) this.init(); return this.airports; } public static comparePopulation(a: any, b: any): number { if (a.pop < b.pop) { return 1; } if (a.pop > b.pop) { return -1; } return 0; } public static init() { const cities: any[] = WorldLocations.getAll(); cities.sort(this.comparePopulation); let count = cities.length; let minDistance = 200; let maxDistance = 9000; let flightsLimit = 1500; let flightsCount = 0; for (let i = 0; i < count; i++) { let origin = cities[i]; let connectionsCount = 0; let connectionsMax = Math.min(20, Math.round(origin.pop * 4)); for (let ii = 0; ii < count; ii++) { let dest = cities[ii]; if (origin.name != dest.name) { let route = [origin.name, dest.name].sort().join('-'); let routeIsValid = this.flightsLookup.indexOf(route) == -1; let distance = Math.round(WorldUtils.calcDistance(origin, dest)); let distanceIsValid = distance > minDistance && distance < maxDistance; let pass = Math.round((Math.random() * 200)) + 150; let time = distance / 800; let trafficIsValid = origin.pop > 3 && dest.pop > 1.0; if (routeIsValid && distanceIsValid && trafficIsValid) { this.flightsLookup.push(route); let paths = WorldUtils.calcPaths(origin, dest); flightsCount++; connectionsCount++; let id = origin.name.substring(0,3).toUpperCase() + \"-\" + flightsCount; let flight = { id: id, origin: origin, dest: dest, time: time, passengers: pass, distance: distance, points: paths }; this.flights.push(flight); } if (connectionsCount > connectionsMax) { break; } } } if (flightsCount > flightsLimit) { break; } } for (const flight of this.flights) { this.addAirport(flight.origin); this.addAirport(flight.dest); } this.airports = Array.from(this.airportsLookup.values()); } private static addAirport(city: any) { if (this.airportsLookup.has(city.name)) { this.airportsLookup.get(city.name).flights += 1; } else { let airport = Object.assign({flights: 1}, city ); this.airportsLookup.set(city.name, airport); } } public static getGridlines(): any[] { let gridlines = []; // longitude lines for (let lon = -180; lon <= 180; lon += 30) { let line: any[] = [{x: lon, y: -90}, {x: lon, y: 90}]; let points: any[] = [line]; let coordinateLine = {points: points, degree: lon, direction: lon > 0 ? \"E\" : \"W\" }; gridlines.push(coordinateLine); } // latitude lines for (let lat = -90; lat <= 90; lat += 30) { let line: any[] = [{x: -180, y: lat}, {x: 180, y: lat}]; let points: any[] = [line]; let coordinateLine = {points: points, degree: lat, direction: lat > 0 ? \"N\" : \"S\" }; gridlines.push(coordinateLine); } return gridlines; } } API References IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-resources-world-locations.html": {
    "href": "components/geo-map-resources-world-locations.html",
    "title": "Angular Map | World Locations | Data Source | Infragistics",
    "keywords": "Angular World Locations The resource topic provides implementation of data utility for generating geographic locations of cities and capitals of countries. Code Snippet export default class WorldLocations { private static locations: any[] = []; private static capitals: any[] = []; private static cities: any[] = []; // get location of cities and capitals public static getAll(): any[] { if (this.locations.length == 0) this.init(); return this.locations; } // get location of cities public static getCities(): any[] { if (this.cities.length == 0) this.init(); return this.cities; } // get location of capitals public static getCapitals(): any[] { if (this.capitals.length == 0) this.init(); return this.capitals; } public static init() { // console.log(\"WorldLocations init\"); this.locations = [ { cap: false, pop: 0.468, lat: 68.9635467529297, lon: 33.0860404968262, country: \"Russia\", name: \"Murmansk\" }, { cap: false, pop: 0.416, lat: 64.5206680297852, lon: 40.6461601257324, country: \"Russia\", name: \"Arkhangelsk\" }, { cap: false, pop: 5.825, lat: 59.9518890380859, lon: 30.4533271789551, country: \"Russia\", name: \"Saint Petersburg\" }, { cap: false, pop: 0.152, lat: 59.5709991455078, lon: 150.780014038086, country: \"Russia\", name: \"Magadan\" }, { cap: false, pop: 1.160, lat: 58.0002365112305, lon: 56.2324638366699, country: \"Russia\", name: \"Perm'\" }, { cap: false, pop: 1.620, lat: 56.8465423583984, lon: 60.6101303100586, country: \"Russia\", name: \"Yekaterinburg\" }, { cap: false, pop: 2.025, lat: 56.2896766662598, lon: 43.9406700134277, country: \"Russia\", name: \"Nizhniy Novgorod\" }, { cap: false, pop: 1.800, lat: 55.8628082275391, lon: -4.26994752883911, country: \"UK\", name: \"Glasgow\" }, { cap: false, pop: 1.140, lat: 55.7330055236816, lon: 49.1454658508301, country: \"Russia\", name: \"Kazan'\" }, { cap: false, pop: 1.325, lat: 55.1450004577637, lon: 61.3926124572754, country: \"Russia\", name: \"Chelyabinsk\" }, { cap: false, pop: 1.175, lat: 55.063304901123, lon: 73.2502899169922, country: \"Russia\", name: \"Omsk\" }, { cap: false, pop: 1.600, lat: 55.0321006774902, lon: 82.9428482055664, country: \"Russia\", name: \"Novosibirsk\" }, { cap: false, pop: 1.100, lat: 54.8217353820801, lon: 56.0961265563965, country: \"Russia\", name: \"Ufa\" }, { cap: true, pop: 0.582, lat: 54.6885681152344, lon: 25.2759666442871, country: \"Lithuania\", name: \"Vilnius\" }, { cap: false, pop: 0.685, lat: 54.5869255065918, lon: -5.90966033935547, country: \"UK\", name: \"Belfast\" }, { cap: false, pop: 0.909, lat: 54.3662033081055, lon: 18.624942779541, country: \"Poland\", name: \"Gdansk\" }, { cap: true, pop: 1.650, lat: 53.8999366760254, lon: 27.5755672454834, country: \"Byelarus\", name: \"Minsk\" }, { cap: false, pop: 1.540, lat: 53.8087120056152, lon: -1.49752748012543, country: \"UK\", name: \"Leeds\" }, { cap: false, pop: 2.225, lat: 53.5711212158203, lon: 10.027606010437, country: \"Germany\", name: \"Hamburg\" }, { cap: false, pop: 2.775, lat: 53.479663848877, lon: -2.26177859306335, country: \"UK\", name: \"Manchester\" }, { cap: false, pop: 0.710, lat: 53.3740425109863, lon: -1.46298921108246, country: \"UK\", name: \"Sheffield\" }, { cap: true, pop: 1.140, lat: 53.3415603637695, lon: -6.25734663009644, country: \"Ireland\", name: \"Dublin\" }, { cap: false, pop: 1.505, lat: 53.1385955810547, lon: 50.0961799621582, country: \"Russia\", name: \"Samara\" }, { cap: false, pop: 0.800, lat: 53.0801048278809, lon: 8.85762596130371, country: \"Germany\", name: \"Bremen\" }, { cap: true, pop: 5.061, lat: 52.5162734985352, lon: 13.3275728225708, country: \"Germany\", name: \"Berlin\" }, { cap: false, pop: 2.675, lat: 52.4927520751953, lon: -1.86334776878357, country: \"UK\", name: \"Birmingham\" }, { cap: true, pop: 1.860, lat: 52.3730430603027, lon: 4.89483308792114, country: \"Netherlands\", name: \"Amsterdam\" }, { cap: false, pop: 0.626, lat: 52.3174324035645, lon: 104.247833251953, country: \"Russia\", name: \"Irkutsk\" }, { cap: true, pop: 2.323, lat: 52.244945526123, lon: 21.0118789672852, country: \"Poland\", name: \"Warsaw\" }, { cap: false, pop: 1.110, lat: 51.925594329834, lon: 4.48515224456787, country: \"Netherlands\", name: \"Rotterdam\" }, { cap: false, pop: 1.061, lat: 51.7779083251953, lon: 19.4764404296875, country: \"Poland\", name: \"Lodz\" }, { cap: false, pop: 0.568, lat: 51.5138130187988, lon: 7.46641826629639, country: \"Germany\", name: \"Dortmund\" }, { cap: false, pop: 0.515, lat: 51.4893379211426, lon: 6.77530431747437, country: \"Germany\", name: \"Duisburg\" }, { cap: true, pop: 11.100, lat: 51.4879112243652, lon: -0.177998125553131, country: \"UK\", name: \"london\" }, { cap: false, pop: 3.867, lat: 51.3540420532227, lon: 7.12243509292603, country: \"Germany\", name: \"Essen\" }, { cap: false, pop: 0.700, lat: 51.3493309020996, lon: 12.3980741500854, country: \"Germany\", name: \"Leipzig\" }, { cap: false, pop: 1.100, lat: 51.207347869873, lon: 4.42605447769165, country: \"Belgium\", name: \"Antwerpen\" }, { cap: false, pop: 0.640, lat: 51.1218185424805, lon: 17.0381278991699, country: \"Poland\", name: \"Wroclaw\" }, { cap: false, pop: 0.465, lat: 51.0475540161133, lon: 3.73629117012024, country: \"Belgium\", name: \"Gent\" }, { cap: false, pop: 0.670, lat: 51.0456809997559, lon: 13.7053575515747, country: \"Germany\", name: \"Dresden\" }, { cap: false, pop: 0.671, lat: 51.0299987792969, lon: -114.050003051758, country: \"Canada\", name: \"Calgary\" }, { cap: false, pop: 1.760, lat: 50.9423446655273, lon: 6.93487167358398, country: \"Germany\", name: \"Koln\" }, { cap: true, pop: 2.385, lat: 50.8370475769043, lon: 4.36761236190796, country: \"Belgium\", name: \"Bruxelles\" }, { cap: false, pop: 0.570, lat: 50.7345581054688, lon: 7.09981870651245, country: \"Germany\", name: \"Bonn\" }, { cap: false, pop: 1.020, lat: 50.6320838928223, lon: 3.06290125846863, country: \"France\", name: \"Lille\" }, { cap: false, pop: 0.750, lat: 50.6225280761719, lon: 5.56943559646606, country: \"Belgium\", name: \"Liege\" }, { cap: true, pop: 2.900, lat: 50.4481582641602, lon: 30.5021114349365, country: \"Ukraine\", name: \"Kiev\" }, { cap: false, pop: 1.855, lat: 50.129997253418, lon: 8.66816711425781, country: \"Germany\", name: \"Frankfurt am Main\" }, { cap: true, pop: 1.325, lat: 50.1058959960938, lon: 14.4565200805664, country: \"Czech Repub\", name: \"Prague\" }, { cap: false, pop: 0.828, lat: 50.0622406005859, lon: 19.9450569152832, country: \"Poland\", name: \"Krakow\" }, { cap: false, pop: 0.625, lat: 49.9211692810059, lon: -97.1244430541992, country: \"Canada\", name: \"Winnipeg\" }, { cap: false, pop: 0.614, lat: 49.879207611084, lon: 73.20263671875, country: \"Kazakhstan\", name: \"Karaganda\" }, { cap: false, pop: 0.790, lat: 49.8373107910156, lon: 24.0345211029053, country: \"Ukraine\", name: \"Lvov\" }, { cap: false, pop: 0.450, lat: 49.2029800415039, lon: 16.6162452697754, country: \"Czech Repub\", name: \"Brno\" }, { cap: true, pop: 9.775, lat: 48.8815536499023, lon: 2.43283271789551, country: \"France\", name: \"Paris\" }, { cap: false, pop: 1.360, lat: 48.7102470397949, lon: 44.4836311340332, country: \"Russia\", name: \"Volgograd\" }, { cap: false, pop: 0.400, lat: 48.5834350585938, lon: 7.76799440383911, country: \"France\", name: \"Strasbourg\" }, { cap: false, pop: 0.335, lat: 48.2975959777832, lon: 14.2939014434814, country: \"Austria\", name: \"Linz\" }, { cap: true, pop: 1.875, lat: 48.2021179199219, lon: 16.3209857940674, country: \"Austria\", name: \"Vienna\" }, { cap: false, pop: 1.955, lat: 48.1409759521484, lon: 11.5429534912109, country: \"Germany\", name: \"Munchen\" }, { cap: false, pop: 2.200, lat: 48.0401458740234, lon: 37.7370529174805, country: \"Ukraine\", name: \"Donets'k\" }, { cap: true, pop: 0.548, lat: 47.928596496582, lon: 106.912353515625, country: \"Mongolia\", name: \"Ulaanbaatar\" }, { cap: true, pop: 2.565, lat: 47.5146255493164, lon: 19.0942497253418, country: \"Hungary\", name: \"Budapest\" }, { cap: false, pop: 1.150, lat: 47.3440055847168, lon: 123.964965820313, country: \"China\", name: \"Qiqihar\" }, { cap: false, pop: 0.185, lat: 47.2654609680176, lon: 11.3499822616577, country: \"Austria\", name: \"Innsbruck\" }, { cap: false, pop: 1.165, lat: 47.2320976257324, lon: 39.6880378723145, country: \"Russia\", name: \"Rostov-na-Donu\" }, { cap: false, pop: 0.465, lat: 47.2194328308105, lon: -1.56156122684479, country: \"France\", name: \"Nantes\" }, { cap: false, pop: 0.325, lat: 47.0649223327637, lon: 15.4311008453369, country: \"Austria\", name: \"Graz\" }, { cap: true, pop: 0.299, lat: 46.9482078552246, lon: 7.44573640823364, country: \"Switzerland\", name: \"Bern\" }, { cap: false, pop: 0.603, lat: 46.802074432373, lon: -71.2449340820313, country: \"Canada\", name: \"Quebec\" }, { cap: false, pop: 1.185, lat: 46.5722007751465, lon: 30.6839370727539, country: \"Ukraine\", name: \"Odessa\" }, { cap: false, pop: 2.670, lat: 45.7552185058594, lon: 126.622634887695, country: \"China\", name: \"Harbin\" }, { cap: false, pop: 1.275, lat: 45.7470817565918, lon: 4.85540056228638, country: \"France\", name: \"Lyon\" }, { cap: false, pop: 2.921, lat: 45.541015625, lon: -73.6535339355469, country: \"Canada\", name: \"Montreal\" }, { cap: false, pop: 3.750, lat: 45.4733810424805, lon: 9.19046401977539, country: \"Italy\", name: \"Milano\" }, { cap: false, pop: 0.420, lat: 45.4247741699219, lon: 12.370719909668, country: \"Italy\", name: \"Venezia\" }, { cap: true, pop: 0.819, lat: 45.3742179870605, lon: -75.650749206543, country: \"Canada\", name: \"Ottawa\" }, { cap: false, pop: 1.550, lat: 45.0748748779297, lon: 7.66642618179321, country: \"Italy\", name: \"Torino\" }, { cap: false, pop: 2.012, lat: 44.924186706543, lon: -93.3077926635742, country: \"US\", name: \"Minneapolis\" }, { cap: false, pop: 0.640, lat: 44.8414726257324, lon: -0.599498748779297, country: \"France\", name: \"Bordeaux\" }, { cap: true, pop: 1.400, lat: 44.7996826171875, lon: 20.4125556945801, country: \"Serbia\", name: \"Beograd\" }, { cap: true, pop: 2.250, lat: 44.4304847717285, lon: 26.1229763031006, country: \"Romania\", name: \"Bucuresti\" }, { cap: false, pop: 1.740, lat: 43.8813171386719, lon: 125.312652587891, country: \"China\", name: \"Changchung\" }, { cap: false, pop: 1.170, lat: 43.8502159118652, lon: 126.56706237793, country: \"China\", name: \"Jilin\" }, { cap: false, pop: 1.040, lat: 43.7826652526855, lon: 87.5865173339844, country: \"China\", name: \"Urumqi\" }, { cap: false, pop: 0.640, lat: 43.7815742492676, lon: 11.207745552063, country: \"Italy\", name: \"Firenze\" }, { cap: false, pop: 3.427, lat: 43.7207679748535, lon: -79.4126358032227, country: \"Canada\", name: \"Toronto\" }, { cap: false, pop: 0.541, lat: 43.5999603271484, lon: 1.43798303604126, country: \"France\", name: \"Toulouse\" }, { cap: false, pop: 0.985, lat: 43.2821578979492, lon: -2.97378325462341, country: \"Spain\", name: \"Bilbao\" }, { cap: true, pop: 1.190, lat: 43.2550621032715, lon: 76.9126281738281, country: \"Kazakhstan\", name: \"Almaty\" }, { cap: false, pop: 0.816, lat: 43.2104644775391, lon: -77.635612487793, country: \"US\", name: \"Rochester\" }, { cap: false, pop: 1.375, lat: 43.0679473876953, lon: -87.9907379150391, country: \"US\", name: \"Milwaukee\" }, { cap: false, pop: 1.900, lat: 43.0552520751953, lon: 141.345474243164, country: \"Japan\", name: \"Sapporo\" }, { cap: false, pop: 1.483, lat: 42.8986625671387, lon: -78.8484344482422, country: \"US\", name: \"Buffalo\" }, { cap: true, pop: 1.205, lat: 42.7072639465332, lon: 23.3318710327148, country: \"Bulgaria\", name: \"Sofia\" }, { cap: false, pop: 4.692, lat: 42.3943138122559, lon: -83.0789260864258, country: \"US\", name: \"Detroit\" }, { cap: false, pop: 3.972, lat: 42.3752975463867, lon: -71.1025848388672, country: \"US\", name: \"Boston\" }, { cap: false, pop: 1.270, lat: 41.8591575622559, lon: 123.905570983887, country: \"China\", name: \"Fushun\" }, { cap: false, pop: 7.717, lat: 41.826545715332, lon: -87.6413040161133, country: \"US\", name: \"Chicago\" }, { cap: false, pop: 3.840, lat: 41.8021621704102, lon: 123.383056640625, country: \"China\", name: \"Shenyang\" }, { cap: true, pop: 1.460, lat: 41.721809387207, lon: 44.7831268310547, country: \"Georgia\", name: \"Tbilisi\" }, { cap: false, pop: 0.575, lat: 41.6512641906738, lon: -0.878205060958862, country: \"Spain\", name: \"Zaragoza\" }, { cap: false, pop: 2.218, lat: 41.3907165527344, lon: -81.7275085449219, country: \"US\", name: \"Cleveland\" }, { cap: true, pop: 0.211, lat: 41.3316535949707, lon: 19.8318042755127, country: \"Albania\", name: \"Tirane\" }, { cap: false, pop: 1.300, lat: 41.1152458190918, lon: 122.977012634277, country: \"China\", name: \"Anshan\" }, { cap: false, pop: 5.750, lat: 41.0659561157227, lon: 29.0060691833496, country: \"Turkey\", name: \"Istanbul\" }, { cap: false, pop: 0.682, lat: 40.693920135498, lon: -111.89217376709, country: \"US\", name: \"Salt Lake City\" }, { cap: false, pop: 2.219, lat: 40.4972038269043, lon: -79.9970855712891, country: \"US\", name: \"Pittsburgh\" }, { cap: true, pop: 4.650, lat: 40.4422187805176, lon: -3.69096946716309, country: \"Spain\", name: \"Madrid\" }, { cap: true, pop: 2.020, lat: 40.3242988586426, lon: 49.8162384033203, country: \"Azerbaijan\", name: \"Baku\" }, { cap: true, pop: 1.315, lat: 40.2080230712891, lon: 44.5326690673828, country: \"Armenia\", name: \"Yerevan\" }, { cap: false, pop: 0.964, lat: 40.0446434020996, lon: -82.9927062988281, country: \"US\", name: \"Columbus\" }, { cap: true, pop: 2.400, lat: 39.929328918457, lon: 32.853271484375, country: \"Turkey\", name: \"Ankara\" }, { cap: false, pop: 5.209, lat: 39.9275512695313, lon: -75.2182235717773, country: \"US\", name: \"Philadelphia\" }, { cap: true, pop: 6.450, lat: 39.906192779541, lon: 116.388038635254, country: \"China\", name: \"Beijing\" }, { cap: false, pop: 0.246, lat: 39.9044532775879, lon: 41.2918243408203, country: \"Turkey\", name: \"Erzurum\" }, { cap: false, pop: 0.366, lat: 39.6575813293457, lon: 66.9476013183594, country: \"Uzbekistan\", name: \"Samarkand\" }, { cap: false, pop: 1.060, lat: 39.6154441833496, lon: 118.180213928223, country: \"China\", name: \"Tangshan\" }, { cap: false, pop: 1.270, lat: 39.4709167480469, lon: -0.367400944232941, country: \"Spain\", name: \"Valencia\" }, { cap: false, pop: 1.960, lat: 39.3218841552734, lon: -76.6183776855469, country: \"US\", name: \"Baltimore\" }, { cap: false, pop: 0.305, lat: 39.2251434326172, lon: 9.10890960693359, country: \"Italy\", name: \"Cagliari\" }, { cap: false, pop: 1.480, lat: 39.1480102539063, lon: -84.4770202636719, country: \"US\", name: \"Cincinnati\" }, { cap: false, pop: 4.880, lat: 39.1284141540527, lon: 117.18522644043, country: \"China\", name: \"Tianjin\" }, { cap: true, pop: 1.600, lat: 39.0285148620605, lon: 125.757514953613, country: \"Korea D P Rp\", name: \"Pyongyang\" }, { cap: false, pop: 1.272, lat: 38.9941177368164, lon: -94.6265640258789, country: \"US\", name: \"Kansas City\" }, { cap: true, pop: 3.221, lat: 38.8909111022949, lon: -76.9538345336914, country: \"US\", name: \"Washington D.C.\" }, { cap: false, pop: 2.203, lat: 38.6388854980469, lon: -90.3419799804688, country: \"US\", name: \"St. Louis\" }, { cap: false, pop: 0.866, lat: 38.5670166015625, lon: -121.422706604004, country: \"US\", name: \"Sacramento\" }, { cap: false, pop: 0.971, lat: 38.0809783935547, lon: 46.2901191711426, country: \"Iran\", name: \"Tabriz\" }, { cap: false, pop: 1.190, lat: 38.0770950317383, lon: 114.559707641602, country: \"China\", name: \"Shijiazhuang\" }, { cap: true, pop: 0.398, lat: 37.9504203796387, lon: 58.3901329040527, country: \"Turkmenistan\", name: \"Ashkhabad\" }, { cap: false, pop: 1.660, lat: 37.8930549621582, lon: 112.551704406738, country: \"China\", name: \"Taiyuan\" }, { cap: true, pop: 15.850, lat: 37.542350769043, lon: 126.935249328613, country: \"Korea Rep\", name: \"Seoul\" }, { cap: false, pop: 0.945, lat: 37.3726463317871, lon: -5.97083187103271, country: \"Spain\", name: \"Sevilla\" }, { cap: false, pop: 0.778, lat: 36.9999809265137, lon: 35.3243637084961, country: \"Turkey\", name: \"Adana\" }, { cap: false, pop: 0.796, lat: 36.8792915344238, lon: -76.2685699462891, country: \"US\", name: \"Norfolk\" }, { cap: true, pop: 1.225, lat: 36.8188133239746, lon: 10.1659603118896, country: \"Tunisia\", name: \"Tunis\" }, { cap: false, pop: 0.830, lat: 36.7914962768555, lon: 118.062042236328, country: \"China\", name: \"Zibo\" }, { cap: false, pop: 1.460, lat: 36.6555366516113, lon: 116.967056274414, country: \"China\", name: \"Jinan\" }, { cap: false, pop: 0.571, lat: 36.3355674743652, lon: 43.1371269226074, country: \"Iraq\", name: \"Mosul\" }, { cap: false, pop: 1.464, lat: 36.2900695800781, lon: 59.596851348877, country: \"Iran\", name: \"Mashhad\" }, { cap: false, pop: 1.216, lat: 36.2155456542969, lon: 37.1592826843262, country: \"Syria\", name: \"Aleppo\" }, { cap: false, pop: 1.270, lat: 36.1134300231934, lon: 103.599594116211, country: \"China\", name: \"Lanzhou\" }, { cap: false, pop: 2.206, lat: 35.8635368347168, lon: 128.591384887695, country: \"Korea Rep\", name: \"Taegu\" }, { cap: true, pop: 6.400, lat: 35.7744750976563, lon: 51.4476509094238, country: \"Iran\", name: \"Tehran\" }, { cap: true, pop: 23.620, lat: 35.6830558776855, lon: 139.809188842773, country: \"Japan\", name: \"Tokyo\" }, { cap: false, pop: 1.089, lat: 35.5045700073242, lon: 139.72721862793, country: \"Japan\", name: \"Kawasaki\" }, { cap: false, pop: 0.742, lat: 35.4895896911621, lon: -97.5302963256836, country: \"US\", name: \"Oklahoma City\" }, { cap: false, pop: 2.993, lat: 35.437385559082, lon: 139.619659423828, country: \"Japan\", name: \"Yokohama\" }, { cap: false, pop: 0.479, lat: 35.2058143615723, lon: -80.8356857299805, country: \"US\", name: \"Charlotte\" }, { cap: false, pop: 3.800, lat: 35.1578674316406, lon: 129.0546875, country: \"Korea Rep\", name: \"Pusan\" }, { cap: false, pop: 4.800, lat: 35.1549224853516, lon: 136.920593261719, country: \"Japan\", name: \"Nagoya\" }, { cap: false, pop: 0.853, lat: 35.1147270202637, lon: -90.0003280639648, country: \"US\", name: \"Memphis\" }, { cap: false, pop: 1.479, lat: 35.0091285705566, lon: 135.754821777344, country: \"Japan\", name: \"Kyoto\" }, { cap: false, pop: 1.170, lat: 34.757682800293, lon: 113.641777038574, country: \"China\", name: \"Zhengzhou\" }, { cap: false, pop: 0.431, lat: 34.7338752746582, lon: 36.7181739807129, country: \"Syria\", name: \"Homs\" }, { cap: false, pop: 0.740, lat: 34.6713485717773, lon: 112.361236572266, country: \"China\", name: \"Luoyang\" }, { cap: false, pop: 15.040, lat: 34.6355285644531, lon: 135.519119262695, country: \"Japan\", name: \"Osaka\" }, { cap: true, pop: 1.179, lat: 34.5309066772461, lon: 69.1367568969727, country: \"Afghanistan\", name: \"Kabul\" }, { cap: false, pop: 1.575, lat: 34.377555847168, lon: 132.444778442383, country: \"Japan\", name: \"Hiroshima\" }, { cap: false, pop: 2.050, lat: 34.265697479248, lon: 108.883361816406, country: \"China\", name: \"Xian\" }, { cap: false, pop: 0.535, lat: 34.0435676574707, lon: -4.99554777145386, country: \"Morocco\", name: \"Fes\" }, { cap: false, pop: 1.963, lat: 33.7957000732422, lon: -84.3492279052734, country: \"US\", name: \"Atlanta\" }, { cap: true, pop: 0.204, lat: 33.7181510925293, lon: 73.060546875, country: \"Pakistan\", name: \"Islamabad\" }, { cap: false, pop: 0.836, lat: 33.6058044433594, lon: 73.0437469482422, country: \"Pakistan\", name: \"Rawalpindi\" }, { cap: true, pop: 1.850, lat: 33.5193023681641, lon: 36.3134536743164, country: \"Syria\", name: \"Damascus\" }, { cap: false, pop: 1.482, lat: 33.5090217590332, lon: -112.110260009766, country: \"US\", name: \"Phoenix\" }, { cap: true, pop: 3.841, lat: 33.3340377807617, lon: 44.397834777832, country: \"Iraq\", name: \"Baghdad\" }, { cap: false, pop: 2.727, lat: 32.763729095459, lon: -96.663688659668, country: \"US\", name: \"Dallas\" }, { cap: false, pop: 0.987, lat: 32.6513900756836, lon: 51.6791877746582, country: \"Iran\", name: \"Esfahan\" }, { cap: false, pop: 2.290, lat: 32.0483665466309, lon: 118.768905639648, country: \"China\", name: \"Nanjing\" }, { cap: true, pop: 1.250, lat: 31.9493827819824, lon: 35.9329071044922, country: \"Jordan\", name: \"Amman\" }, { cap: false, pop: 0.595, lat: 31.6308898925781, lon: 74.8715515136719, country: \"India\", name: \"Amritsar\" }, { cap: false, pop: 3.025, lat: 31.5450534820557, lon: 74.3406753540039, country: \"Pakistan\", name: \"Lahore\" }, { cap: false, pop: 1.104, lat: 31.4089508056641, lon: 73.0834579467773, country: \"Pakistan\", name: \"Faisalabad\" }, { cap: false, pop: 9.300, lat: 31.2478694915771, lon: 121.47265625, country: \"China\", name: \"Shanghai\" }, { cap: false, pop: 1.810, lat: 30.6700687408447, lon: 104.071273803711, country: \"China\", name: \"Chengdu\" }, { cap: false, pop: 3.490, lat: 30.5724983215332, lon: 114.279220581055, country: \"China\", name: \"Wuhan\" }, { cap: false, pop: 0.617, lat: 30.503490447998, lon: 47.7608642578125, country: \"Iraq\", name: \"Al Basra\" }, { cap: false, pop: 1.270, lat: 30.2526245117188, lon: 120.165077209473, country: \"China\", name: \"Hangzhou\" }, { cap: true, pop: 9.300, lat: 30.0779113769531, lon: 31.2507972717285, country: \"Egypt\", name: \"Cairo\" }, { cap: false, pop: 1.185, lat: 29.9563789367676, lon: -90.0986862182617, country: \"US\", name: \"New Orleans\" }, { cap: false, pop: 2.755, lat: 29.7718296051025, lon: -95.407112121582, country: \"US\", name: \"Houston\" }, { cap: false, pop: 0.084, lat: 29.6507034301758, lon: 91.1320877075195, country: \"China\", name: \"Lhasa\" }, { cap: false, pop: 2.450, lat: 29.5441036224365, lon: 106.522689819336, country: \"China\", name: \"Chongqing\" }, { cap: false, pop: 0.968, lat: 29.4299221038818, lon: -98.5245742797852, country: \"US\", name: \"San Antonio\" }, { cap: false, pop: 1.030, lat: 28.6712398529053, lon: 115.88941192627, country: \"China\", name: \"Nanchang\" }, { cap: true, pop: 0.273, lat: 28.5687255859375, lon: 77.2167510986328, country: \"India\", name: \"New Delhi\" }, { cap: false, pop: 7.200, lat: 28.5264587402344, lon: 77.2243728637695, country: \"India\", name: \"Delhi\" }, { cap: false, pop: 1.190, lat: 28.1976413726807, lon: 112.968482971191, country: \"China\", name: \"Changsha\" }, { cap: true, pop: 0.320, lat: 27.7120170593262, lon: 85.3129501342773, country: \"Nepal\", name: \"Kathmandu\" }, { cap: true, pop: 0.012, lat: 27.44260597229, lon: 89.6673278808594, country: \"Bhutan\", name: \"Thimbu\" }, { cap: false, pop: 1.025, lat: 26.9051132202148, lon: 75.8012771606445, country: \"India\", name: \"Jaipur\" }, { cap: false, pop: 1.060, lat: 26.8494281768799, lon: 80.9197235107422, country: \"India\", name: \"Lucknow\" }, { cap: false, pop: 1.010, lat: 26.5719413757324, lon: 106.700302124023, country: \"China\", name: \"Guiyang\" }, { cap: false, pop: 1.875, lat: 26.4578304290771, lon: 80.3178634643555, country: \"India\", name: \"Kanpur\" }, { cap: false, pop: 0.890, lat: 26.0710163116455, lon: 119.303520202637, country: \"China\", name: \"Fuzhou\" }, { cap: false, pop: 2.827, lat: 25.8321304321289, lon: -80.2702178955078, country: \"US\", name: \"Miami\" }, { cap: false, pop: 2.015, lat: 25.6773529052734, lon: -100.317085266113, country: \"Mexico\", name: \"Monterrey\" }, { cap: false, pop: 1.025, lat: 25.6138973236084, lon: 85.1353454589844, country: \"India\", name: \"Patna\" }, { cap: false, pop: 0.800, lat: 25.3801860809326, lon: 68.3664703369141, country: \"Pakistan\", name: \"Hyderabad\" }, { cap: false, pop: 0.925, lat: 25.2820110321045, lon: 82.9563369750977, country: \"India\", name: \"Benares\" }, { cap: true, pop: 0.310, lat: 25.2036418914795, lon: 51.4972343444824, country: \"Qatar\", name: \"Doha\" }, { cap: false, pop: 1.280, lat: 25.0510330200195, lon: 102.702125549316, country: \"China\", name: \"Kunming\" }, { cap: true, pop: 6.130, lat: 25.0350914001465, lon: 121.506729125977, country: \"Taiwan\", name: \"Taipei\" }, { cap: false, pop: 0.715, lat: 24.1436424255371, lon: 120.670280456543, country: \"Taiwan\", name: \"T`ai-chung\" }, { cap: true, pop: 3.430, lat: 23.7099189758301, lon: 90.4071426391602, country: \"Bangladesh\", name: \"Dhaka\" }, { cap: false, pop: 3.050, lat: 23.0961952209473, lon: 113.293609619141, country: \"China\", name: \"Guangzhou\" }, { cap: false, pop: 2.400, lat: 23.0397911071777, lon: 72.5668640136719, country: \"India\", name: \"Ahmadabad\" }, { cap: false, pop: 0.648, lat: 22.8426475524902, lon: 89.5582427978516, country: \"Bangladesh\", name: \"Khulna\" }, { cap: false, pop: 11.100, lat: 22.5435371398926, lon: 88.3342208862305, country: \"India\", name: \"Calcutta\" }, { cap: false, pop: 0.435, lat: 22.2432346343994, lon: -97.8426284790039, country: \"Mexico\", name: \"Tampico\" }, { cap: false, pop: 0.533, lat: 21.975944519043, lon: 96.0841522216797, country: \"Burma\", name: \"Mandalay\" }, { cap: false, pop: 0.550, lat: 21.4273815155029, lon: 39.8148384094238, country: \"Saudi Arabia\", name: \"Mecca\" }, { cap: false, pop: 1.302, lat: 21.1557579040527, lon: 79.089111328125, country: \"India\", name: \"Nagpur\" }, { cap: true, pop: 1.500, lat: 21.0319480895996, lon: 105.81990814209, country: \"Vietnam\", name: \"Hanoi\" }, { cap: false, pop: 0.385, lat: 20.8613586425781, lon: 106.679794311523, country: \"Vietnam\", name: \"Haiphong\" }, { cap: false, pop: 0.400, lat: 20.8218688964844, lon: -89.552864074707, country: \"Mexico\", name: \"Merida\" }, { cap: false, pop: 2.325, lat: 20.6735916137695, lon: -103.343795776367, country: \"Mexico\", name: \"Guadalajara\" }, { cap: false, pop: 0.207, lat: 19.6157131195068, lon: 37.2196884155273, country: \"Sudan\", name: \"Bur Sudan\" }, { cap: true, pop: 14.100, lat: 19.4270458221436, lon: -99.127571105957, country: \"Mexico\", name: \"Mexico City\" }, { cap: false, pop: 1.055, lat: 19.0486316680908, lon: -98.1929473876953, country: \"Mexico\", name: \"Puebla de Zaragoza\" }, { cap: false, pop: 1.775, lat: 18.5357475280762, lon: 73.8522720336914, country: \"India\", name: \"Pune\" }, { cap: true, pop: 0.880, lat: 18.5266170501709, lon: -72.3431091308594, country: \"Haiti\", name: \"Port-au-Prince\" }, { cap: true, pop: 1.775, lat: 18.4006156921387, lon: -66.0817565917969, country: \"Puerto Rico\", name: \"San Juan\" }, { cap: true, pop: 0.770, lat: 18.0157127380371, lon: -76.7973022460938, country: \"Jamaica\", name: \"Kingston\" }, { cap: false, pop: 2.750, lat: 17.3945465087891, lon: 78.4850311279297, country: \"India\", name: \"Hyderabad\" }, { cap: true, pop: 2.800, lat: 16.8722229003906, lon: 96.1248931884766, country: \"Burma\", name: \"Rangoon\" }, { cap: true, pop: 0.427, lat: 15.3614444732666, lon: 44.2095031738281, country: \"Yemen\", name: \"Sanaa\" }, { cap: true, pop: 1.400, lat: 14.6180076599121, lon: -90.52490234375, country: \"Guatemala\", name: \"Guatemala\" }, { cap: true, pop: 0.552, lat: 14.0990505218506, lon: -87.2030944824219, country: \"Honduras\", name: \"Tegucigalpa\" }, { cap: true, pop: 6.450, lat: 13.7455711364746, lon: 100.552665710449, country: \"Thailand\", name: \"Bangkok\" }, { cap: true, pop: 0.920, lat: 13.7014122009277, lon: -89.2002334594727, country: \"El Salvador\", name: \"San Salvador\" }, { cap: true, pop: 0.398, lat: 13.6045436859131, lon: 2.08344984054565, country: \"Niger\", name: \"Niamey\" }, { cap: false, pop: 4.475, lat: 13.0615034103394, lon: 80.2478256225586, country: \"India\", name: \"Madras\" }, { cap: false, pop: 2.950, lat: 12.9747505187988, lon: 77.5877304077148, country: \"India\", name: \"Bangalore\" }, { cap: true, pop: 0.646, lat: 12.6529502868652, lon: -7.98648166656494, country: \"Mali\", name: \"Bamako\" }, { cap: true, pop: 0.682, lat: 12.1514730453491, lon: -86.2730331420898, country: \"Nicaragua\", name: \"Managua\" }, { cap: true, pop: 0.700, lat: 11.564736366272, lon: 104.913192749023, country: \"Cambodia\", name: \"Phnom Penh\" }, { cap: false, pop: 3.100, lat: 10.7591819763184, lon: 106.662452697754, country: \"Vietnam\", name: \"Ho Chi Minh City\" }, { cap: false, pop: 0.891, lat: 10.6450433731079, lon: -71.6371459960938, country: \"Venezuela\", name: \"Maracaibo\" }, { cap: true, pop: 3.600, lat: 10.4960489273071, lon: -66.8982849121094, country: \"Venezuela\", name: \"Caracas\" }, { cap: false, pop: 0.498, lat: 10.0656652450562, lon: -69.3391952514648, country: \"Venezuela\", name: \"Barquisimeto\" }, { cap: true, pop: 0.670, lat: 9.93047618865967, lon: -84.07861328125, country: \"Costa Rica\", name: \"San Jose\" }, { cap: false, pop: 0.960, lat: 9.91398620605469, lon: 78.1217269897461, country: \"India\", name: \"Madurai\" }, { cap: false, pop: 1.144, lat: 7.37884044647217, lon: 3.8952784538269, country: \"Nigeria\", name: \"Ibadan\" }, { cap: false, pop: 0.409, lat: 7.08008003234863, lon: 125.613677978516, country: \"Philippines\", name: \"Davao\" }, { cap: false, pop: 0.253, lat: 6.45053863525391, lon: 7.4920802116394, country: \"Nigeria\", name: \"Enugu\" }, { cap: false, pop: 2.095, lat: 6.24114656448364, lon: -75.5920333862305, country: \"Colombia\", name: \"Medellin\" }, { cap: true, pop: 1.250, lat: 5.55856275558472, lon: -0.200923636555672, country: \"Ghana\", name: \"Accra\" }, { cap: true, pop: 1.950, lat: 5.32485723495483, lon: -4.02188682556152, country: \"Ivory Coast\", name: \"Abidjan\" }, { cap: true, pop: 4.260, lat: 4.63021993637085, lon: -74.0805130004883, country: \"Colombia\", name: \"Bogota\" }, { cap: true, pop: 0.474, lat: 4.3658561706543, lon: 18.5623416900635, country: \"Cent Af Rep\", name: \"Bangui\" }, { cap: true, pop: 0.654, lat: 3.86512303352356, lon: 11.5136413574219, country: \"Cameroon\", name: \"Yaounde\" }, { cap: false, pop: 1.374, lat: 3.58524203300476, lon: 98.6755981445313, country: \"Indonesia\", name: \"Medan\" }, { cap: false, pop: 1.400, lat: 3.45685529708862, lon: -76.5224380493164, country: \"Colombia\", name: \"Cali\" }, { cap: true, pop: 1.475, lat: 3.1502103805542, lon: 101.707672119141, country: \"Malaysia\", name: \"Kuala Lumpur\" }, { cap: true, pop: 0.600, lat: 2.04117751121521, lon: 45.3441429138184, country: \"Somalia\", name: \"Muqdisho\" }, { cap: false, pop: 0.283, lat: 0.519284904003143, lon: 25.1961479187012, country: \"Zaire\", name: \"Kisangani\" }, { cap: true, pop: 1.050, lat: -0.229498133063316, lon: -78.524284362793, country: \"Ecuador\", name: \"Quito\" }, { cap: false, pop: 0.179, lat: -3.75289535522461, lon: -73.1914901733398, country: \"Peru\", name: \"Iquitos\" }, { cap: false, pop: 1.825, lat: -3.78332185745239, lon: -38.5889015197754, country: \"Brazil\", name: \"Fortaleza\" }, { cap: true, pop: 0.586, lat: -4.28518676757813, lon: 15.2851486206055, country: \"Congo\", name: \"Brazzaville\" }, { cap: false, pop: 0.291, lat: -5.89221096038818, lon: 22.4027786254883, country: \"Zaire\", name: \"Kananga\" }, { cap: true, pop: 1.300, lat: -6.81735897064209, lon: 39.2533493041992, country: \"Tanzania\", name: \"Dar es Salaam\" }, { cap: false, pop: 1.800, lat: -6.91243028640747, lon: 107.606903076172, country: \"Indonesia\", name: \"Bandung\" }, { cap: false, pop: 2.625, lat: -8.08516788482666, lon: -34.9146385192871, country: \"Brazil\", name: \"Recife\" }, { cap: false, pop: 0.155, lat: -12.7177352905273, lon: 13.464879989624, country: \"Angola\", name: \"Benguela\" }, { cap: true, pop: 1.568, lat: -15.7921094894409, lon: -47.8977470397949, country: \"Brazil\", name: \"Brasilia\" }, { cap: false, pop: 0.447, lat: -16.3975391387939, lon: -71.5227432250977, country: \"Peru\", name: \"Arequipa\" }, { cap: true, pop: 0.993, lat: -16.4990062713623, lon: -68.1462478637695, country: \"Bolivia\", name: \"La Paz\" }, { cap: false, pop: 0.990, lat: -16.7266998291016, lon: -49.254810333252, country: \"Brazil\", name: \"Goiania\" }, { cap: false, pop: 0.442, lat: -17.7887916564941, lon: -63.1974182128906, country: \"Bolivia\", name: \"Santa Cruz de La Sierra\" }, { cap: false, pop: 0.087, lat: -19.0421352386475, lon: -65.2558822631836, country: \"Bolivia\", name: \"Sucre\" }, { cap: false, pop: 2.950, lat: -19.8517208099365, lon: -43.9090690612793, country: \"Brazil\", name: \"Belo Horizonte\" }, { cap: false, pop: 10.150, lat: -22.7215728759766, lon: -43.4551773071289, country: \"Brazil\", name: \"Rio de Janeiro\" }, { cap: false, pop: 15.175, lat: -23.5813045501709, lon: -46.6228981018066, country: \"Brazil\", name: \"Sao Paulo\" }, { cap: false, pop: 1.065, lat: -23.9547004699707, lon: -46.3094940185547, country: \"Brazil\", name: \"Santos\" }, { cap: true, pop: 0.095, lat: -24.6614418029785, lon: 25.7948017120361, country: \"Botswana\", name: \"Gaborone\" }, { cap: false, pop: 1.700, lat: -25.4304790496826, lon: -49.2845077514648, country: \"Brazil\", name: \"Curitiba\" }, { cap: true, pop: 0.960, lat: -25.7313461303711, lon: 28.2183723449707, country: \"South Africa\", name: \"Pretoria\" }, { cap: true, pop: 1.070, lat: -25.9621543884277, lon: 32.5736923217773, country: \"Mozambique\", name: \"Maputo\" }, { cap: false, pop: 3.650, lat: -26.1789569854736, lon: 28.0043087005615, country: \"South Africa\", name: \"Johannesburg\" }, { cap: false, pop: 1.149, lat: -27.4539127349854, lon: 153.026489257813, country: \"Australia\", name: \"Brisbane\" }, { cap: false, pop: 1.550, lat: -29.8363723754883, lon: 30.9421882629395, country: \"South Africa\", name: \"Durban\" }, { cap: false, pop: 2.600, lat: -30.0395336151123, lon: -51.2079887390137, country: \"Brazil\", name: \"Porto Alegre\" }, { cap: false, pop: 1.070, lat: -31.3162784576416, lon: -64.1798553466797, country: \"Argentina\", name: \"Cordoba\" }, { cap: false, pop: 0.292, lat: -31.6168975830078, lon: -60.6978416442871, country: \"Argentina\", name: \"Santa Fe\" }, { cap: false, pop: 0.650, lat: -32.8974380493164, lon: -68.8297348022461, country: \"Argentina\", name: \"Mendoza\" }, { cap: false, pop: 1.045, lat: -32.9377365112305, lon: -60.6639404296875, country: \"Argentina\", name: \"Rosario\" }, { cap: true, pop: 4.100, lat: -33.475025177002, lon: -70.6475143432617, country: \"Chile\", name: \"Santiago\" }, { cap: false, pop: 0.690, lat: -33.8815765380859, lon: 25.4842987060547, country: \"South Africa\", name: \"Port Elizabeth\" }, { cap: false, pop: 3.365, lat: -33.8897743225098, lon: 151.028198242188, country: \"Australia\", name: \"Sydney\" }, { cap: true, pop: 10.750, lat: -34.6654014587402, lon: -58.4095916748047, country: \"Argentina\", name: \"Buenos Aires\" }, { cap: true, pop: 0.271, lat: -35.349925994873, lon: 149.041625976563, country: \"Australia\", name: \"Canberra\" }, { cap: false, pop: 0.850, lat: -36.893253326416, lon: 174.801055908203, country: \"New Zealand\", name: \"Auckland\" }, { cap: false, pop: 2.833, lat: -37.8529586791992, lon: 145.075103759766, country: \"Australia\", name: \"Melbourne\" }, { cap: false, pop: 0.224, lat: -38.7252731323242, lon: -62.2740669250488, country: \"Argentina\", name: \"Bahia Blanca\" }, { cap: false, pop: 0.320, lat: -43.5489158630371, lon: 172.683654785156, country: \"New Zealand\", name: \"Christchurch\" }, { cap: true, pop: 0.900, lat: 60.1964225769043, lon: 24.9766998291016, country: \"Finland\", name: \"Helsinki\" }, { cap: false, pop: 0.310, lat: 34.745231628418, lon: 10.7592582702637, country: \"Tunisia\", name: \"Sfax\" }, { cap: false, pop: 1.411, lat: 34.6638412475586, lon: 135.181838989258, country: \"Japan\", name: \"Kobe\" }, { cap: false, pop: 0.490, lat: 31.7737464904785, lon: 35.2252197265625, country: \"Israel\", name: \"Jerusalem\" }, { cap: false, pop: 0.616, lat: 10.1782207489014, lon: -68.0031127929688, country: \"Venezuela\", name: \"Valencia\" }, { cap: false, pop: 1.255, lat: -2.20381617546082, lon: -79.9093933105469, country: \"Ecuador\", name: \"Guayaquil\" }, { cap: false, pop: 4.054, lat: 37.7275123596191, lon: -122.308815002441, country: \"US\", name: \"San Francisco\" }, { cap: false, pop: 0.630, lat: 55.8752517700195, lon: -3.29878330230713, country: \"UK\", name: \"Edinburgh\" }, { cap: false, pop: 0.239, lat: 45.7002830505371, lon: 13.9328374862671, country: \"Italy\", name: \"Trieste\" }, { cap: false, pop: 1.750, lat: 33.3099060058594, lon: 130.317184448242, country: \"Japan\", name: \"Fukuoka\" }, { cap: false, pop: 1.525, lat: 33.6818656921387, lon: 130.797454833984, country: \"Japan\", name: \"Kita Kyushu\" }, { cap: true, pop: 0.303, lat: 12.1041393280029, lon: 15.2408237457275, country: \"Chad\", name: \"N'Djamena\" }, { cap: true, pop: 0.991, lat: 32.7516174316406, lon: 13.2118225097656, country: \"Libya\", name: \"Tripoli\" }, { cap: false, pop: 1.550, lat: 38.4389190673828, lon: 27.2057685852051, country: \"Turkey\", name: \"Izmir\" }, { cap: true, pop: 3.000, lat: -4.38867473602295, lon: 15.4692935943604, country: \"Zaire\", name: \"Kinshasa\" }, { cap: false, pop: 0.978, lat: -34.9185371398926, lon: 138.870681762695, country: \"Australia\", name: \"Adelaide\" }, { cap: true, pop: 8.600, lat: -6.29390430450439, lon: 106.762466430664, country: \"Indonesia\", name: \"Jakarta\" }, { cap: false, pop: 1.025, lat: -7.02784442901611, lon: 110.444259643555, country: \"Indonesia\", name: \"Semarang\" }, { cap: false, pop: 0.264, lat: -12.0435400009155, lon: -76.8356323242188, country: \"Peru\", name: \"Callao\" }, { cap: false, pop: 1.200, lat: -1.60532903671265, lon: -48.316276550293, country: \"Brazil\", name: \"Belem\" }, { cap: false, pop: 1.270, lat: 36.1483535766602, lon: 120.434127807617, country: \"China\", name: \"Qingdao\" }, { cap: true, pop: 0.377, lat: 18.0017318725586, lon: 102.680236816406, country: \"Laos\", name: \"Vientiane\" }, { cap: false, pop: 0.220, lat: 47.8011703491211, lon: 13.0908985137939, country: \"Austria\", name: \"Salzburg\" }, { cap: true, pop: 0.698, lat: 45.8070755004883, lon: 15.9643859863281, country: \"Croatia\", name: \"Zagreb\" }, { cap: true, pop: 0.273, lat: -3.26908373832703, lon: 29.5335865020752, country: \"Burundi\", name: \"Bujumbura\" }, { cap: true, pop: 0.185, lat: 35.1650695800781, lon: 33.3851623535156, country: \"Cyprus\", name: \"Nicosia\" }, { cap: true, pop: 0.182, lat: -2.11793518066406, lon: 29.9914855957031, country: \"Rwanda\", name: \"Kigali\" }, { cap: true, pop: 0.233, lat: 46.068302154541, lon: 14.639612197876, country: \"Slovenia\", name: \"Ljubljana\" }, { cap: true, pop: 0.109, lat: -29.2567100524902, lon: 27.8903884887695, country: \"Lesotho\", name: \"Maseru\" }, { cap: true, pop: 0.133, lat: 49.740406036377, lon: 6.27325582504272, country: \"Luxembourg\", name: \"Luxembourg\" }, { cap: false, pop: 0.770, lat: 51.903621673584, lon: 4.30062437057495, country: \"Netherlands\", name: \"The Hague\" }, { cap: true, pop: 0.435, lat: 48.2745094299316, lon: 17.2698059082031, country: \"Slovakia\", name: \"Bratislava\" }, { cap: false, pop: 0.201, lat: 52.1100006103516, lon: -106.629997253418, country: \"Canada\", name: \"Saskatoon\" }, { cap: false, pop: 0.187, lat: 50.4099998474121, lon: -104.650001525879, country: \"Canada\", name: \"Regina\" }, { cap: false, pop: 1.038, lat: 31.7800006866455, lon: -106.449996948242, country: \"US\", name: \"El Paso\" }, { cap: false, pop: 0.636, lat: 30.3299999237061, lon: -81.6600036621094, country: \"US\", name: \"Jacksonville\" }, { cap: false, pop: 0.002, lat: 51.3300018310547, lon: -80.7300033569336, country: \"Canada\", name: \"Moosonee\" }, { cap: false, pop: 0.002, lat: 54.8600006103516, lon: -67.0100021362305, country: \"Canada\", name: \"Schefferville\" }, { cap: false, pop: 0.008, lat: 53.310001373291, lon: -60.5499992370605, country: \"Canada\", name: \"Goose Bay\" }, { cap: false, pop: 0.202, lat: -8.75, lon: -63.9000015258789, country: \"Brazil\", name: \"Porto Velho\" }, { cap: false, pop: 0.185, lat: -13.6000003814697, lon: -71.8600006103516, country: \"Peru\", name: \"Cuzco\" }, { cap: false, pop: 0.280, lat: -15.5500001907349, lon: -56.0499992370605, country: \"Brazil\", name: \"Cuiaba\" }, { cap: false, pop: 0.220, lat: -27.3999996185303, lon: -58.9000015258789, country: \"Argentina\", name: \"Resistencia\" }, { cap: false, pop: 0.032, lat: 16.7600002288818, lon: -3.00999999046326, country: \"Mali\", name: \"Tombouctoo\" }, { cap: false, pop: 0.255, lat: 11.8800001144409, lon: 13.2600002288818, country: \"Niger\", name: \"Maiduguri\" }, { cap: false, pop: 0.145, lat: -5.80999994277954, lon: 13.4499998092651, country: \"Zaire\", name: \"Matadi\" }, { cap: false, pop: 0.203, lat: -12.7299995422363, lon: 15.7799997329712, country: \"Angola\", name: \"Huambo\" }, { cap: false, pop: 0.145, lat: -28.6599998474121, lon: 24.8299999237061, country: \"South Africa\", name: \"Kimberley\" }, { cap: false, pop: 0.320, lat: -33.0299987792969, lon: 27.8999996185303, country: \"South Africa\", name: \"East london\" }, { cap: false, pop: 0.247, lat: -7.32999992370605, lon: 19, country: \"Zaire\", name: \"Kahemba\" }, { cap: false, pop: 0.054, lat: -6.17999982833862, lon: 35.75, country: \"Tanzania\", name: \"Dodoma\" }, { cap: false, pop: 0.019, lat: 68.3499984741211, lon: 17.2999992370605, country: \"Norway\", name: \"Narvik\" }, { cap: false, pop: 0.160, lat: 34.4599990844727, lon: 62.2099990844727, country: \"Afghanistan\", name: \"Herat\" }, { cap: false, pop: 0.006, lat: 55.8800010681152, lon: 37.75, country: \"Russia\", name: \"Druzba\" }, { cap: false, pop: 0.146, lat: 39.4799995422363, lon: 76, country: \"China\", name: \"Kashi\" }, { cap: false, pop: 9.415, lat: 24.9799995422363, lon: 121.529998779297, country: \"Taiwan\", name: \"Chingmei\" }, { cap: false, pop: 0.166, lat: 16.4599990844727, lon: 107.699996948242, country: \"Vietnam\", name: \"Hue\" }, { cap: false, pop: 0.073, lat: 1.5, lon: 110.430000305176, country: \"Malaysia\", name: \"Kuching\" }, { cap: false, pop: 0.208, lat: -1.21000003814697, lon: 116.860000610352, country: \"Indonesia\", name: \"Balikpapan\" }, { cap: false, pop: 0.168, lat: 50.3300018310547, lon: 110.75, country: \"Russia\", name: \"Chatanga\" }, { cap: false, pop: 0.006, lat: 52.0499992370605, lon: 113.580001831055, country: \"Russia\", name: \"Chita\" }, { cap: false, pop: 0.001, lat: 67.5800018310547, lon: 133.410003662109, country: \"Russia\", name: \"Verkhoyansk\" }, { cap: false, pop: 0.187, lat: 62.0099983215332, lon: 129.830001831055, country: \"Russia\", name: \"Yakutsk\" }, { cap: false, pop: 0.006, lat: 59.3300018310547, lon: 143.25, country: \"Russia\", name: \"Okhotsk\" }, { cap: false, pop: 0.000, lat: 50.0800018310547, lon: 45.5299987792969, country: \"Russia\", name: \"Nikolayevsk\" }, { cap: false, pop: 0.000, lat: 46.9599990844727, lon: 142.75, country: \"Russia\", name: \"Yuzhno-Sakhalinsk\" }, { cap: false, pop: 0.000, lat: -23.6299991607666, lon: 133.929992675781, country: \"Australia\", name: \"Alice Springs\" }, { cap: false, pop: 0.039, lat: -16.8500003814697, lon: 145.710006713867, country: \"Australia\", name: \"Cairns\" }, { cap: false, pop: 0.106, lat: -19.2999992370605, lon: 146.830001831055, country: \"Australia\", name: \"Townsville\" }, { cap: false, pop: 0.059, lat: -23.4300003051758, lon: 150.479995727539, country: \"Australia\", name: \"Rockhampton\" }, { cap: false, pop: 0.405, lat: -33, lon: 151.910003662109, country: \"Australia\", name: \"Newcastle\" }, { cap: false, pop: 0.175, lat: -43, lon: 147.5, country: \"Australia\", name: \"Hobart\" }, { cap: false, pop: 0.109, lat: -45.8600006103516, lon: 170.5, country: \"New Zealand\", name: \"Dunedin\" }, { cap: false, pop: 0.256, lat: 48.6545677185059, lon: -123.569107055664, country: \"Canada\", name: \"Victoria\" }, { cap: true, pop: 0.164, lat: 6.60109615325928, lon: 2.63250279426575, country: \"Benin\", name: \"Porto Novo\" }, { cap: false, pop: 1.030, lat: 4.13665008544922, lon: 9.706374168396, country: \"Cameroon\", name: \"Douala\" }, { cap: false, pop: 0.708, lat: -5.19043016433716, lon: 119.722793579102, country: \"Indonesia\", name: \"Vjuag Padang\" }, { cap: false, pop: 0.112, lat: -3.3865532875061, lon: 129.312927246094, country: \"Indonesia\", name: \"Ambon\" }, { cap: false, pop: 1.604, lat: 37.5894508361816, lon: 126.767440795898, country: \"Korea Rep\", name: \"Inch`on\" }, { cap: false, pop: 1.680, lat: 39.0317153930664, lon: 121.598197937012, country: \"China\", name: \"Dalian\" }, { cap: false, pop: 1.227, lat: 45.4421310424805, lon: -122.641677856445, country: \"US\", name: \"Portland\" }, { cap: false, pop: 0.810, lat: -3.12230491638184, lon: -60.0146179199219, country: \"Brazil\", name: \"Manaus\" }, { cap: false, pop: 0.227, lat: -2.46000003814697, lon: -54.6100006103516, country: \"Brazil\", name: \"Santarem\" }, { cap: false, pop: 0.053, lat: -46.4099998474121, lon: 168.449996948242, country: \"New Zealand\", name: \"Invercargill\" }, { cap: false, pop: 0.049, lat: -10.2600002288818, lon: 40.1800003051758, country: \"Tanzania\", name: \"Mtwara\" }, { cap: false, pop: 0.100, lat: -18.2299995422363, lon: 49.4099998474121, country: \"Madagascar\", name: \"Toamasina\" }, { cap: false, pop: 0.235, lat: -29.1499996185303, lon: 26.2600002288818, country: \"South Africa\", name: \"Bloemfontein\" }, { cap: false, pop: 0.414, lat: -20.2000007629395, lon: 28.7099990844727, country: \"Zimbabwe\", name: \"Bulawayo\" }, { cap: false, pop: 0.061, lat: -17.8299999237061, lon: 25.8799991607666, country: \"Zambia\", name: \"Livingstone\" }, { cap: false, pop: 0.290, lat: 24.4300003051758, lon: 39.7000007629395, country: \"Saudi Arabia\", name: \"Al Madinah\" }, { cap: false, pop: 0.000, lat: 21.7600002288818, lon: 31.2800006866455, country: \"Sudan\", name: \"Wadi Halfa\" }, { cap: false, pop: 0.191, lat: 24.0799999237061, lon: 32.9500007629395, country: \"Egypt\", name: \"Aswan\" }, { cap: false, pop: 0.000, lat: 25.9099998474121, lon: 13.9099998474121, country: \"Libya\", name: \"Murzuq\" }, { cap: false, pop: 0.000, lat: 27.7000007629395, lon: -8.15999984741211, country: \"Algeria\", name: \"Tindouf\" }, { cap: false, pop: 0.050, lat: 16.9599990844727, lon: 7.98000001907349, country: \"Niger\", name: \"Agadez\" }, { cap: false, pop: 0.140, lat: 13.1800003051758, lon: 30.1599998474121, country: \"Sudan\", name: \"El Obeid\" }, { cap: false, pop: 0.125, lat: 0.0500000007450581, lon: 18.4599990844727, country: \"Zaire\", name: \"Mbandaka\" }, { cap: false, pop: 0.015, lat: 60.6500015258789, lon: -135.009994506836, country: \"Canada\", name: \"Whitehorse\" }, { cap: false, pop: 0.095, lat: -53.1500015258789, lon: -70.8000030517578, country: \"Chile\", name: \"Punte Arenas\" }, { cap: false, pop: 0.084, lat: -41.4799995422363, lon: -73, country: \"Chile\", name: \"Puerto Montt\" }, { cap: false, pop: 0.000, lat: -51.7099990844727, lon: -69.4100036621094, country: \"Argentina\", name: \"Rio Gallegos\" }, { cap: false, pop: 0.097, lat: -45.8300018310547, lon: -67.5, country: \"Argentina\", name: \"Comodoro Rivadavia\" }, { cap: false, pop: 0.327, lat: 29.9599990844727, lon: 32.560001373291, country: \"Egypt\", name: \"Suez\" }, { cap: false, pop: 3.350, lat: 31.0746040344238, lon: 29.9778099060059, country: \"Egypt\", name: \"Alexandria\" }, { cap: false, pop: 0.000, lat: -15.0500001907349, lon: 40.7000007629395, country: \"Mozambique\", name: \"Mocambique\" }, { cap: false, pop: 9.950, lat: 19.0453472137451, lon: 73.1723480224609, country: \"India\", name: \"Bombay\" }, { cap: true, pop: 2.548, lat: 36.596492767334, lon: 2.99369311332703, country: \"Algeria\", name: \"Algiers\" }, { cap: false, pop: 1.940, lat: 49.989673614502, lon: 36.2083129882813, country: \"Ukraine\", name: \"Kharkov\" }, { cap: false, pop: 1.600, lat: 48.4228897094727, lon: 35.1378936767578, country: \"Ukraine\", name: \"Dnepropetrovsk\" }, { cap: true, pop: 0.482, lat: 59.2775726318359, lon: 24.7520561218262, country: \"Estonia\", name: \"Tallinn\" }, { cap: false, pop: 0.000, lat: 47.810001373291, lon: 97, country: \"Mongolia\", name: \"Uliastay\" }, { cap: true, pop: 1.313, lat: 18.4997291564941, lon: -69.9104919433594, country: \"Dominican Rp\", name: \"Santo Domingo\" }, { cap: true, pop: 0.064, lat: 4.93300008773804, lon: 114.967002868652, country: \"Brunei\", name: \"Bandar Seri Begawan\" }, { cap: true, pop: 0.095, lat: 13.4452724456787, lon: -16.4946155548096, country: \"Gambia\", name: \"Banjul\" }, { cap: true, pop: 0.370, lat: 10.6397342681885, lon: -61.490062713623, country: \"Trinidad\", name: \"Port of Spain\" }, { cap: false, pop: 0.302, lat: 16.97438621521, lon: -99.9314956665039, country: \"Mexico\", name: \"Acapulco\" }, { cap: false, pop: 0.000, lat: 64.4001617431641, lon: 177.130187988281, country: \"Russia\", name: \"Anadyr\" }, { cap: false, pop: 0.003, lat: 65.6699981689453, lon: -37.3118667602539, country: \"Greenland\", name: \"Angmagssalik\" }, { cap: false, pop: 0.185, lat: -23.8325366973877, lon: -70.2254486083984, country: \"Chile\", name: \"Antofagasta\" }, { cap: false, pop: 0.294, lat: 40.75, lon: 140.669998168945, country: \"Japan\", name: \"Aomori\" }, { cap: false, pop: 0.436, lat: 32.0430526733398, lon: 20.3086757659912, country: \"Libya\", name: \"Banghazi\" }, { cap: false, pop: 0.000, lat: -15.75, lon: 133.220001220703, country: \"Australia\", name: \"Birdum\" }, { cap: false, pop: 0.000, lat: 2.75, lon: -60.5, country: \"Brazil\", name: \"Boa Vista\" }, { cap: false, pop: 0.280, lat: -6.61999988555908, lon: -79.8300018310547, country: \"Peru\", name: \"Chiclayo\" }, { cap: false, pop: 0.223, lat: -8.930100440979, lon: -78.4531478881836, country: \"Peru\", name: \"Chimbote\" }, { cap: false, pop: 0.001, lat: 58.710765838623, lon: -94.1800003051758, country: \"Canada\", name: \"Churchill\" }, { cap: false, pop: 0.686, lat: 9.98798847198486, lon: 76.5217819213867, country: \"India\", name: \"Cochin\" }, { cap: false, pop: 0.675, lat: -36.8832969665527, lon: -72.8516387939453, country: \"Chile\", name: \"Concepcion\" }, { cap: false, pop: 0.062, lat: -31, lon: -71.0199966430664, country: \"Chile\", name: \"Coquimbo\" }, { cap: false, pop: 0.073, lat: -12.7014999389648, lon: 130.994552612305, country: \"Australia\", name: \"Darwin\" }, { cap: true, pop: 0.120, lat: 11.5, lon: 43.0999984741211, country: \"Djibouti\", name: \"Djibouti\" }, { cap: false, pop: 0.022, lat: -32.0441665649414, lon: 115.9345703125, country: \"Australia\", name: \"Fremantle\" }, { cap: false, pop: 0.495, lat: 5.34999990463257, lon: 100.547142028809, country: \"Malaysia\", name: \"George Town\" }, { cap: false, pop: 0.001, lat: 69.3831405639648, lon: -53.6300010681152, country: \"Greenland\", name: \"Godhavn\" }, { cap: true, pop: 0.012, lat: 64.2711868286133, lon: -51.5800018310547, country: \"Greenland\", name: \"Godthab\" }, { cap: false, pop: 0.296, lat: 44.6300010681152, lon: -63.5800018310547, country: \"Canada\", name: \"Halifax\" }, { cap: false, pop: 0.007, lat: 70.3913269042969, lon: 23.9063415527344, country: \"Norway\", name: \"Hammerfest\" }, { cap: false, pop: 0.000, lat: 67.3499984741211, lon: 86.5500030517578, country: \"Russia\", name: \"Igarka\" }, { cap: false, pop: 0.019, lat: 27.2000007629395, lon: 2.52999997138977, country: \"Algeria\", name: \"In Salah\" }, { cap: false, pop: 0.003, lat: 68.2699966430664, lon: -133.669998168945, country: \"Canada\", name: \"Inuvik\" }, { cap: false, pop: 0.050, lat: -4.94999980926514, lon: 30, country: \"Tanzania\", name: \"Kigoma\" }, { cap: false, pop: 0.069, lat: 61.1500015258789, lon: 47, country: \"Russia\", name: \"Kotlas\" }, { cap: false, pop: 0.094, lat: 27, lon: -13.1800003051758, country: \"W Sahara\", name: \"Laayoune\" }, { cap: false, pop: 0.217, lat: 1.420086145401, lon: 124.884239196777, country: \"Indonesia\", name: \"Manado\" }, { cap: false, pop: 0.306, lat: 12.9499998092651, lon: 75.1608810424805, country: \"India\", name: \"Mangalore\" }, { cap: false, pop: 0.535, lat: 31.1499996185303, lon: -8, country: \"Morocco\", name: \"Marrakech\" }, { cap: true, pop: 0.038, lat: -26.3033809661865, lon: 31.1912975311279, country: \"Swaziland\", name: \"Mbabne\" }, { cap: false, pop: 0.449, lat: 32.8827476501465, lon: 129.857467651367, country: \"Japan\", name: \"Nagasaki\" }, { cap: false, pop: 0.510, lat: -5.78000020980835, lon: -35.25, country: \"Brazil\", name: \"Natal\" }, { cap: false, pop: 0.033, lat: -41.2999992370605, lon: 173.270004272461, country: \"New Zealand\", name: \"Nelson\" }, { cap: false, pop: 0.004, lat: 64.5862808227539, lon: -165.270004272461, country: \"US\", name: \"Nome\" }, { cap: false, pop: 0.174, lat: 69.3300018310547, lon: 88.0999984741211, country: \"Russia\", name: \"Noril`sk\" }, { cap: false, pop: 0.022, lat: 20.8999996185303, lon: -16.825647354126, country: \"Mauritania\", name: \"Nouadnibou\" }, { cap: false, pop: 0.600, lat: 53.7000007629395, lon: 87.1699981689453, country: \"Russia\", name: \"Novokuznetsk\" }, { cap: false, pop: 0.097, lat: 46.9199981689453, lon: -122.879997253418, country: \"US\", name: \"Olympia\" }, { cap: false, pop: 0.297, lat: -0.917578816413879, lon: 100.475059509277, country: \"Indonesia\", name: \"Padang\" }, { cap: false, pop: 0.787, lat: -3, lon: 104.830001831055, country: \"Indonesia\", name: \"Palembang\" }, { cap: false, pop: 0.155, lat: 38.1412391662598, lon: 21.8831691741943, country: \"Greece\", name: \"Patras\" }, { cap: false, pop: 0.269, lat: 53.2000007629395, lon: 158.720001220703, country: \"Russia\", name: \"Petropavloski-Kamchatskiy\" }, { cap: true, pop: 0.083, lat: 42.5, lon: 19.3999996185303, country: \"Montenegro\", name: \"Podgorica\" }, { cap: false, pop: 0.294, lat: -4.63870811462402, lon: 12.0580930709839, country: \"Congo\", name: \"Pointe Noire\" }, { cap: false, pop: 0.124, lat: -0.819999992847443, lon: 9.15334415435791, country: \"Gabon\", name: \"Port Gentil\" }, { cap: false, pop: 0.016, lat: 54.420280456543, lon: -130.048080444336, country: \"Canada\", name: \"Prince Rupert\" }, { cap: false, pop: 0.121, lat: 45.338134765625, lon: -65.6499481201172, country: \"Canada\", name: \"Saint John\" }, { cap: false, pop: 0.091, lat: 15.9512100219727, lon: -16.2978382110596, country: \"Senegal\", name: \"Saint Louis\" }, { cap: false, pop: 0.000, lat: 66.5699996948242, lon: 66.5800018310547, country: \"Russia\", name: \"Salekhard\" }, { cap: false, pop: 0.241, lat: 41.3199996948242, lon: 36.3699989318848, country: \"Turkey\", name: \"Samsun\" }, { cap: false, pop: 0.600, lat: -2.5, lon: -44.4300575256348, country: \"Brazil\", name: \"Sao Luis\" }, { cap: true, pop: 0.341, lat: 43.8699989318848, lon: 18.4300003051758, country: \"Bosnia/Herz\", name: \"Sarajevo\" }, { cap: false, pop: 0.000, lat: 70.5285720825195, lon: -22.9963226318359, country: \"Greenland\", name: \"Scoresbyund\" }, { cap: false, pop: 0.029, lat: 50.2825469970703, lon: -66.4025421142578, country: \"Canada\", name: \"Sept-Iles\" }, { cap: false, pop: 0.003, lat: 60.1199989318848, lon: -149.449996948242, country: \"US\", name: \"Seward\" }, { cap: true, pop: 0.445, lat: 42, lon: 21.5300006866455, country: \"Macedonia\", name: \"Skopje\" }, { cap: false, pop: 0.000, lat: 22.8299999237061, lon: 5.55000019073486, country: \"Algeria\", name: \"Tamanrasset\" }, { cap: false, pop: 0.000, lat: 77.6699981689453, lon: -69, country: \"Greenland\", name: \"Thule\" }, { cap: false, pop: 0.000, lat: 71.6999969482422, lon: 128.75, country: \"Russia\", name: \"Tiksi\" }, { cap: false, pop: 0.055, lat: -23.2901554107666, lon: 44.0190925598145, country: \"Madagascar\", name: \"Toliara\" }, { cap: false, pop: 0.354, lat: -7.92999982833862, lon: -79, country: \"Peru\", name: \"Trujillo\" }, { cap: false, pop: 0.604, lat: 17.75, lon: 83.3300018310547, country: \"India\", name: \"Vishakhapatnam\" }, { cap: false, pop: 0.116, lat: 67.8000030517578, lon: 64.3300018310547, country: \"Russia\", name: \"Vorkuta\" }, { cap: false, pop: 0.230, lat: 31.9699993133545, lon: 54.4500007629395, country: \"Iran\", name: \"Yazd\" }, { cap: false, pop: 0.282, lat: 29.6000003814697, lon: 60.8300018310547, country: \"Iran\", name: \"Zahedan\" }, { cap: false, pop: 0.318, lat: 12.861159324646, lon: 45.1800003051758, country: \"Yemen\", name: \"Aden\" }, { cap: true, pop: 1.500, lat: 9.02999973297119, lon: 38.7000007629395, country: \"Ethiopia\", name: \"Adis Abeba\" }, { cap: true, pop: 1.375, lat: 29.1949901580811, lon: 48.0027770996094, country: \"Kuwait\", name: \"Al Kuwayt\" }, { cap: true, pop: 0.663, lat: -18.8700008392334, lon: 47.5, country: \"Madagascar\", name: \"Antananarivo\" }, { cap: true, pop: 1.250, lat: 24.6499996185303, lon: 46.7700004577637, country: \"Saudi Arabia\", name: \"Ar Riyad\" }, { cap: true, pop: 0.275, lat: 15.3299999237061, lon: 38.9700012207031, country: \"Eritrea\", name: \"Asmara\" }, { cap: true, pop: 0.700, lat: -25.2199993133545, lon: -57.6699981689453, country: \"Paraguay\", name: \"Asuncion\" }, { cap: true, pop: 3.027, lat: 38.1216011047363, lon: 23.6548633575439, country: \"Greece\", name: \"Athens\" }, { cap: false, pop: 1.120, lat: 40.6500015258789, lon: 109.980003356934, country: \"China\", name: \"Baotou\" }, { cap: false, pop: 4.040, lat: 41.5299987792969, lon: 2.17000007629395, country: \"Spain\", name: \"Barcelona\" }, { cap: false, pop: 1.140, lat: 11.0142946243286, lon: -74.6800003051758, country: \"Colombia\", name: \"Barranquilla\" }, { cap: false, pop: 0.292, lat: -19.7692832946777, lon: 35.0231704711914, country: \"Mozambique\", name: \"Beira\" }, { cap: true, pop: 1.675, lat: 33.7799987792969, lon: 35.6579437255859, country: \"Lebanon\", name: \"Beirut\" }, { cap: true, pop: 0.005, lat: 17.1200008392334, lon: -88.8000030517578, country: \"Belize\", name: \"Belmopan\" }, { cap: false, pop: 0.239, lat: 60.3499984741211, lon: 5.49067831039429, country: \"Norway\", name: \"Bergen\" }, { cap: true, pop: 0.109, lat: 11.9109897613525, lon: -15.6499996185303, country: \"GuineaBissau\", name: \"Bissau\" }, { cap: false, pop: 1.790, lat: -33.8040084838867, lon: 18.6904315948486, country: \"South Africa\", name: \"cape Town\" }, { cap: false, pop: 0.625, lat: 51.5, lon: -3.15000009536743, country: \"UK\", name: \"Cardiff\" }, { cap: false, pop: 2.475, lat: 33.5444107055664, lon: -7.53409194946289, country: \"Morocco\", name: \"Casablanca\" }, { cap: true, pop: 0.038, lat: 4.92000007629395, lon: -52.4000015258789, country: \"Fr Guiana\", name: \"Cayenne\" }, { cap: false, pop: 1.392, lat: 22.4799995422363, lon: 91.8327941894531, country: \"Bangladesh\", name: \"Chittagong\" }, { cap: true, pop: 2.050, lat: 7.01999998092651, lon: 80.0883331298828, country: \"Sri Lanka\", name: \"Colombo\" }, { cap: true, pop: 0.800, lat: 9.52000045776367, lon: -12.8000001907349, country: \"Guinea\", name: \"Conakry\" }, { cap: true, pop: 1.428, lat: 14.6300001144409, lon: -16.8480949401855, country: \"Senegal\", name: \"Dakar\" }, { cap: false, pop: 1.405, lat: 39.75, lon: -105.069999694824, country: \"US\", name: \"Denver\" }, { cap: true, pop: 0.595, lat: 38.6300010681152, lon: 68.9000015258789, country: \"Tajikistan\", name: \"Dushanfe\" }, { cap: false, pop: 0.785, lat: 53.5699996948242, lon: -113.269996643066, country: \"Canada\", name: \"Edmonton\" }, { cap: false, pop: 1.871, lat: 30.4699993133545, lon: 30.8500003814697, country: \"Egypt\", name: \"Giza\" }, { cap: true, pop: 0.525, lat: 8.38277053833008, lon: -12.9102764129639, country: \"Sierra Leone\", name: \"Freetown\" }, { cap: true, pop: 0.616, lat: 42.8800010681152, lon: 74.7699966430664, country: \"Kyrgyzstan\", name: \"Frunze\" }, { cap: false, pop: 0.805, lat: 44.4550895690918, lon: 8.92229557037354, country: \"Italy\", name: \"Genova\" }, { cap: true, pop: 0.188, lat: 6.76999998092651, lon: -58.1699981689453, country: \"Guyana\", name: \"Georgetown\" }, { cap: false, pop: 0.711, lat: 57.75, lon: 12, country: \"Sweden\", name: \"Goteborg\" }, { cap: true, pop: 0.890, lat: -17.8299999237061, lon: 31.0200004577637, country: \"Zimbabwe\", name: \"Harare\" }, { cap: true, pop: 2.125, lat: 23.0489521026611, lon: -82.4164505004883, country: \"Cuba\", name: \"Havana\" }, { cap: false, pop: 1.300, lat: 21.6200008392334, lon: 39.3733062744141, country: \"Saudi Arabia\", name: \"Jiddah\" }, { cap: true, pop: 0.460, lat: 0.319999992847443, lon: 32.5800018310547, country: \"Uganda\", name: \"Kampala\" }, { cap: false, pop: 0.538, lat: 11.9200000762939, lon: 8.52000045776367, country: \"Nigeria\", name: \"Kano\" }, { cap: false, pop: 1.845, lat: 22.6734161376953, lon: 120.341484069824, country: \"Taiwan\", name: \"Kao-Hsiung\" }, { cap: false, pop: 5.300, lat: 24.8500003814697, lon: 67.0299987792969, country: \"Pakistan\", name: \"Karachi\" }, { cap: false, pop: 0.601, lat: 48.5299987792969, lon: 135.070007324219, country: \"Russia\", name: \"Khabarovsk\" }, { cap: true, pop: 0.924, lat: 15.5500001907349, lon: 32.5299987792969, country: \"Sudan\", name: \"Khartoum\" }, { cap: true, pop: 0.665, lat: 47, lon: 28.8299999237061, country: \"Moldova\", name: \"Kishinev\" }, { cap: true, pop: 1.685, lat: 55.7200012207031, lon: 12.5500001907349, country: \"Denmark\", name: \"Kobenhavn\" }, { cap: true, pop: 3.800, lat: 6.44999980926514, lon: 3.29999995231628, country: \"Nigeria\", name: \"Lagos\" }, { cap: false, pop: 0.255, lat: 49.3240203857422, lon: 0.219999998807907, country: \"France\", name: \"Le Havre\" }, { cap: true, pop: 0.236, lat: -0.504144549369812, lon: 9.49045658111572, country: \"Gabon\", name: \"Libreville\" }, { cap: true, pop: 0.234, lat: -13.9200000762939, lon: 33.8199996948242, country: \"Malawi\", name: \"Lilongwe\" }, { cap: true, pop: 4.344, lat: -12.0679960250854, lon: -76.8235549926758, country: \"Peru\", name: \"Lima\" }, { cap: true, pop: 2.250, lat: 38.7299995422363, lon: -9.13000011444092, country: \"Portugal\", name: \"Lisboa\" }, { cap: false, pop: 1.525, lat: 53.4226875305176, lon: -2.76683640480042, country: \"UK\", name: \"Liverpool\" }, { cap: true, pop: 0.400, lat: 6.28000020980835, lon: 1.35000002384186, country: \"Togo\", name: \"Lome\" }, { cap: false, pop: 9.764, lat: 34, lon: -118.25, country: \"US\", name: \"Los Angeles\" }, { cap: true, pop: 1.460, lat: -9, lon: 13.4617786407471, country: \"Angola\", name: \"Luanda\" }, { cap: false, pop: 0.543, lat: -11.6800003051758, lon: 27.5499992370605, country: \"Zaire\", name: \"Lumumbashi\" }, { cap: true, pop: 0.536, lat: -15.4300003051758, lon: 28.1700000762939, country: \"Zambia\", name: \"Lusaka\" }, { cap: true, pop: 0.031, lat: 3.64468479156494, lon: 8.81999969482422, country: \"Eq Guinea\", name: \"Malabo\" }, { cap: true, pop: 5.474, lat: 14.5500001907349, lon: 121.173408508301, country: \"Philippines\", name: \"Manila\" }, { cap: false, pop: 1.225, lat: 43.2999992370605, lon: 5.38000011444092, country: \"France\", name: \"Marseille\" }, { cap: true, pop: 0.050, lat: 23.5166397094727, lon: 58.6274795532227, country: \"Oman\", name: \"Masqat\" }, { cap: false, pop: 0.200, lat: 23.3615112304688, lon: -106.269996643066, country: \"Mexico\", name: \"Mazatlan\" }, { cap: false, pop: 0.442, lat: -4.01999998092651, lon: 39.6699981689453, country: \"Kenya\", name: \"Mombasa\" }, { cap: true, pop: 0.465, lat: 6.51743936538696, lon: -10.7700004577637, country: \"Liberia\", name: \"Monrovia\" }, { cap: true, pop: 1.550, lat: -34.9199981689453, lon: -56.1699981689453, country: \"Uruguay\", name: \"Montevideo\" }, { cap: true, pop: 13.100, lat: 55.75, lon: 37.7000007629395, country: \"Russia\", name: \"Moscow\" }, { cap: true, pop: 1.286, lat: -1.16999995708466, lon: 36.8300018310547, country: \"Kenya\", name: \"Nairobi\" }, { cap: false, pop: 2.875, lat: 40.8300018310547, lon: 14.2700004577637, country: \"Italy\", name: \"Napoli\" }, { cap: false, pop: 16.472, lat: 40.75, lon: -74.0999984741211, country: \"US\", name: \"New York\" }, { cap: false, pop: 0.329, lat: 40.7200012207031, lon: -74.1999969482422, country: \"US\", name: \"Newark\" }, { cap: true, pop: 0.285, lat: 18.0300006866455, lon: -15.7828607559204, country: \"Mauritania\", name: \"Nouakchott\" }, { cap: false, pop: 0.138, lat: 55.574535369873, lon: 9.90299892425537, country: \"Denmark\", name: \"Odense\" }, { cap: false, pop: 0.526, lat: 15.6199998855591, lon: 32.4799995422363, country: \"Sudan\", name: \"Omdurman\" }, { cap: false, pop: 0.629, lat: 35.75, lon: -0.519999980926514, country: \"Algeria\", name: \"Oran\" }, { cap: true, pop: 0.720, lat: 59.9300003051758, lon: 10.7200002670288, country: \"Norway\", name: \"Oslo\" }, { cap: true, pop: 0.442, lat: 12.4799995422363, lon: -1.66999995708466, country: \"Burkina Faso\", name: \"Ouagadouou\" }, { cap: false, pop: 0.724, lat: 38.1300010681152, lon: 13.3999996185303, country: \"Italy\", name: \"Palermo\" }, { cap: true, pop: 0.625, lat: 8.94999980926514, lon: -79.4000015258789, country: \"Panama\", name: \"Panama\" }, { cap: true, pop: 0.241, lat: 5.92999982833862, lon: -55.2299995422363, country: \"Suriname\", name: \"Paramaribo\" }, { cap: false, pop: 0.994, lat: -31.9758644104004, lon: 115.923370361328, country: \"Australia\", name: \"Perth\" }, { cap: true, pop: 0.152, lat: -9.55000019073486, lon: 147.414520263672, country: \"Papua N Guin\", name: \"Port Moresby\" }, { cap: false, pop: 1.225, lat: 41.1500015258789, lon: -8.48794841766357, country: \"Portugal\", name: \"Porto\" }, { cap: false, pop: 0.203, lat: 31.6000003814697, lon: 65.5, country: \"Afghanistan\", name: \"Qandahar\" }, { cap: false, pop: 1.326, lat: 14.6499996185303, lon: 121.029998779297, country: \"Philippines\", name: \"Quezon City\" }, { cap: true, pop: 0.980, lat: 33.9201965332031, lon: -6.74804067611694, country: \"Morocco\", name: \"Rabat\" }, { cap: true, pop: 0.138, lat: 64.3132629394531, lon: -21.336820602417, country: \"Iceland\", name: \"Reykjavik\" }, { cap: true, pop: 1.005, lat: 56.8800010681152, lon: 24.0499992370605, country: \"latvia\", name: \"Riga\" }, { cap: true, pop: 3.175, lat: 41.8800010681152, lon: 12.5200004577637, country: \"Italy\", name: \"Roma\" }, { cap: false, pop: 2.050, lat: -12.6002569198608, lon: -38.4799995422363, country: \"Brazil\", name: \"Salvador\" }, { cap: false, pop: 0.848, lat: 29.6299991607666, lon: 52.5699996948242, country: \"Iran\", name: \"Shiraz\" }, { cap: true, pop: 1.450, lat: 59.2446327209473, lon: 18.0842685699463, country: \"Sweden\", name: \"Stockholm\" }, { cap: false, pop: 2.028, lat: -7.40000009536743, lon: 112.684371948242, country: \"Indonesia\", name: \"Surabaja\" }, { cap: false, pop: 0.657, lat: 23.1700000762939, lon: 120.230003356934, country: \"Taiwan\", name: \"T`ai-nan\" }, { cap: false, pop: 0.595, lat: 27.9973583221436, lon: -82.5930252075195, country: \"US\", name: \"Tampa\" }, { cap: true, pop: 1.670, lat: 31.9171981811523, lon: 34.8568344116211, country: \"Israel\", name: \"Tel Aviv-Yafo\" }, { cap: false, pop: 0.706, lat: 40.6300010681152, lon: 22.7999992370605, country: \"Greece\", name: \"Thessaloniki\" }, { cap: true, pop: 2.325, lat: 41.247932434082, lon: 69.3498687744141, country: \"Uzbekistan\", name: \"Toshkent\" }, { cap: false, pop: 0.198, lat: 34.3437576293945, lon: 36.0070686340332, country: \"Lebanon\", name: \"Tripoli\" }, { cap: false, pop: 0.675, lat: -32.9000015258789, lon: -71.2993392944336, country: \"Chile\", name: \"Valparaiso\" }, { cap: false, pop: 1.381, lat: 49.274299621582, lon: -122.963066101074, country: \"Canada\", name: \"Vancouver\" }, { cap: false, pop: 0.648, lat: 43.1300010681152, lon: 131.960433959961, country: \"Russia\", name: \"Vladivostok\" }, { cap: false, pop: 0.017, lat: -23.1018676757813, lon: 14.6171045303345, country: \"Namibia\", name: \"Walvis Bay\" }, { cap: true, pop: 0.115, lat: -22.5699996948242, lon: 17.1000003814697, country: \"Namibia\", name: \"Windhoek\" }, { cap: true, pop: 0.350, lat: -41.2103958129883, lon: 175.144943237305, country: \"New Zealand\", name: \"Wellington\" }, { cap: false, pop: 2.077, lat: 47.5885543823242, lon: -122.316650390625, country: \"US\", name: \"Seattle\" }, { cap: false, pop: 2.099, lat: 32.7614593505859, lon: -117.125495910645, country: \"US\", name: \"San Diego\" }, { cap: false, pop: 0.110, lat: -20.2600002288818, lon: -69.9132614135742, country: \"Chile\", name: \"Iquique\" }, { cap: true, pop: 0.243, lat: 24.2360076904297, lon: 54.619270324707, country: \"Untd Arab Em\", name: \"Abu Zaby\" }, { cap: false, pop: 0.199, lat: 7.57660102844238, lon: -72.0054550170898, country: \"Venezuela\", name: \"San Cristobal\" }, { cap: false, pop: 0.509, lat: 46.25, lon: 48, country: \"Russia\", name: \"Astrakhan\" }, { cap: false, pop: 0.000, lat: 30.1386032104492, lon: 9.81835079193115, country: \"Libya\", name: \"Ghadamis\" }, { cap: false, pop: 0.077, lat: -31.3051528930664, lon: -57.7087745666504, country: \"Uruguay\", name: \"Salto\" }, { cap: false, pop: 0.012, lat: 62.5206146240234, lon: -114.061363220215, country: \"Canada\", name: \"Yellowknife\" }, { cap: false, pop: 0.043, lat: 19.7148151397705, lon: -155.067291259766, country: \"US\", name: \"Hilo\" }, { cap: false, pop: 0.763, lat: 21.3211765289307, lon: -157.806182861328, country: \"US\", name: \"Honolulu\" }, { cap: false, pop: 0.184, lat: 61.188648223877, lon: -149.172973632813, country: \"US\", name: \"Anchorage\" }, { cap: false, pop: 0.040, lat: 64.8387451171875, lon: -147.651184082031, country: \"US\", name: \"Fairbanks\" }, { cap: false, pop: 0.020, lat: 58.3910064697266, lon: -134.132476806641, country: \"US\", name: \"Juneau\" }, { cap: false, pop: 0.629, lat: 37.30810546875, lon: -121.847457885742, country: \"US\", name: \"San Jose\" }, { cap: false, pop: 0.386, lat: 28.5581398010254, lon: -105.966636657715, country: \"Mexico\", name: \"Chihuaha\" }, { cap: false, pop: 0.385, lat: 19.0096759796143, lon: -96.0840606689453, country: \"Mexico\", name: \"Veracruz\" }, { cap: false, pop: 0.154, lat: 16.9209060668945, lon: -96.9420394897461, country: \"Mexico\", name: \"Oaxaca\" }, { cap: false, pop: 0.000, lat: 78.1999969482422, lon: 15.6599998474121, country: \"Norway\", name: \"longyearbyen\" }, { cap: true, pop: 5.396, lat: 22.4284057617188, lon: 114.145706176758, country: \"UK\", name: \"Hong Kong\" }, { cap: false, pop: 0.775, lat: 22.3798961639404, lon: 114.230117797852, country: \"UK\", name: \"Kowloon\" }, { cap: false, pop: 3.025, lat: 1.22979354858398, lon: 104.177116394043, country: \"Singapore\", name: \"Singapore\" }, ]; this.capitals = this.locations.filter(city => city.cap); this.cities = this.locations.filter(city => !city.cap); return this.locations } } API References IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-resources-world-util.html": {
    "href": "components/geo-map-resources-world-util.html",
    "title": "Angular Map | World Utility | Data Source | Infragistics",
    "keywords": "Angular World Utility The resource topic provides implementation of utility that helps with generating Angular geographic data. Code Snippet export default class WorldUtils { // calculate geo-paths between two locations using great circle formula public static calcPaths(origin: any, dest: any): any[] { let interval = 200; let paths: any[] = [[]]; let pathID = 0; let distance = this.calcDistance(origin, dest); if (distance <= interval) { paths[pathID].push({ x: origin.lon, y: origin.lat }); paths[pathID].push({ x: dest.lon, y: dest.lat }); } else { let current = origin; let previous = origin; for (let dist = interval; dist <= distance; dist += interval) { previous = current paths[pathID].push({ x: current.lon, y: current.lat }); let bearing = this.calcBearing(current, dest); current = this.calcDestination(current, bearing, interval); // ensure geo-path wrap around the world through the new date-line if (previous.lon > 150 && current.lon < -150) { paths[pathID].push({ x: 180, y: current.lat }); paths.push([]); pathID++ current = { lon: -180, lat: current.lat } } else if (previous.lon < -150 && current.lon > 150) { paths[pathID].push({ x: -180, y: current.lat }); paths.push([]); pathID++ current = { lon: 180, lat: current.lat } } } paths[pathID].push({ x: dest.lon, y: dest.lat }); } return paths; } // calculate bearing angle between two locations public static calcBearing(origin: any, dest: any) : number { origin = this.toRadianLocation(origin); dest = this.toRadianLocation(dest); let range = (dest.lon - origin.lon); let y = Math.sin(range) * Math.cos(dest.lat); let x = Math.cos(origin.lat) * Math.sin(dest.lat) - Math.sin(origin.lat) * Math.cos(dest.lat) * Math.cos(range); let angle = Math.atan2(y, x); return this.toDegreesNormalized(angle); } // calculate destination for origin location and travel distance public static calcDestination(origin: any, bearing: number, distance: number): any { let radius = 6371.0; origin = this.toRadianLocation(origin); bearing = this.toRadians(bearing); distance = distance / radius; // angular distance in radians let lat = Math.asin(Math.sin(origin.lat) * Math.cos(distance) + Math.cos(origin.lat) * Math.sin(distance) * Math.cos(bearing)); let x = Math.sin(bearing) * Math.sin(distance) * Math.cos(origin.lat); let y = Math.cos(distance) - Math.sin(origin.lat) * Math.sin(origin.lat); let lon = origin.lon + Math.atan2(x, y); // normalize lon to coordinate between -180º and +180º lon = (lon + 3 * Math.PI) % (2 * Math.PI) - Math.PI; lon = this.toDegrees(lon); lat = this.toDegrees(lat); return { lon: lon, lat: lat }; } // calculate distance between two locations public static calcDistance(origin: any, dest: any) : number { origin = this.toRadianLocation(origin); dest = this.toRadianLocation(dest); let sinProd = Math.sin(origin.lat) * Math.sin(dest.lat); let cosProd = Math.cos(origin.lat) * Math.cos(dest.lat); let lonDelta = (dest.lon - origin.lon); let angle = Math.acos(sinProd + cosProd * Math.cos(lonDelta)); let distance = angle * 6371.0; return distance; // * 6371.0; // in km } public static toRadianLocation(geoPoint: any) : any { let x = this.toRadians(geoPoint.lon); let y = this.toRadians(geoPoint.lat); return { lon: x, lat: y }; } public static toRadians(degrees: number) : number { return degrees * Math.PI / 180; } public static toDegrees(radians: number) : number { return (radians * 180.0 / Math.PI); } public static toDegreesNormalized(radians: number) : number { let degrees = this.toDegrees(radians); degrees = (degrees + 360) % 360; return degrees; } // converts latitude coordinate to a string public static toStringLat(latitude: number) : string { let str = Math.abs(latitude).toFixed(1) + \"°\"; return latitude > 0 ? str + \"N\" : str + \"S\"; } // converts longitude coordinate to a string public static toStringLon(coordinate: number) : string { let val = Math.abs(coordinate); let str = val < 100 ? val.toFixed(1) : val.toFixed(0); return coordinate > 0 ? str + \"°E\" : str + \"°W\"; } public static toStringAbbr(value: number) : string { if (value > 1000000000000) { return (value / 1000000000000).toFixed(1) + \" T\" } else if (value > 1000000000) { return (value / 1000000000).toFixed(1) + \" B\" } else if (value > 1000000) { return (value / 1000000).toFixed(1) + \" M\" } else if (value > 1000) { return (value / 1000).toFixed(1) + \" K\" } return value.toFixed(0); } public static getLongitude(location: any) : number { if (location.x) return location.x; if (location.lon) return location.lon; if (location.longitude) return location.longitude; return Number.NaN; } public static getLatitude(location: any) : number { if (location.y) return location.y; if (location.lat) return location.lat; if (location.latitude) return location.latitude; return Number.NaN; } public static getBounds(locations: any[]) : any { let minLat = 90; let maxLat = -90; let minLon = 180; let maxLon = -180; for (const location of locations) { const crrLon = this.getLongitude(location); if (!Number.isNaN(crrLon)) { minLon = Math.min(minLon, crrLon); maxLon = Math.max(maxLon, crrLon); } const crrLat = this.getLatitude(location); if (!Number.isNaN(crrLat)) { minLat = Math.min(minLat, crrLat); maxLat = Math.max(maxLat, crrLat); } } const geoBounds = { left: minLon, top: minLat, width: Math.abs(maxLon - minLon), height: Math.abs(maxLat - minLat) }; return geoBounds; } } API References IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-shape-files-reference.html": {
    "href": "components/geo-map-shape-files-reference.html",
    "title": "Angular Map | Data Visualization Tools | Shape Files Reference | Shape Files Editing | Infragistics",
    "keywords": "Angular Shape Files Reference Purpose This topic provides resources about maps and geo-spatial related material as well as information about shape files. Use these resources to learn about and obtain shape files as well as tools for their editing before starting to bind geo-spatial data to the Ignite UI for Angular map component™ control. Resources Geo-spatial Overview Before plotting geo-spatial data in the control, one should get familiar with the following resources which provide general information about maps and geo-spatial data. Wikipedia – Cartography National Atlas of the United States – Geographic Locations National Atlas of the United States – Map Projections U.S. Geological Survey Wikipedia – Map Projections University of Colorado – Map Projections CSISS – Map Projections Shape Files Format The Angular IgxGeographicMapComponent control uses popular Shape Files format as one of the sources for geo-spatial data. Shape files are usually shipped with other file types, generally files with .shp, .shx, and .dbf extensions. The following table provides basic information and purpose for each type of shape files. File Extension Description .shp A shape file contains geo-spatial vector data items that describe points, polylines, and polygons. In this file, points may describe cities, polylines may describe roads, and polygons may describe shapes/borders of countries in geographic context. .shx A shape index file contains an index for a quick lookup of a geo-spatial vector data items. .dbf A shape database file contains a table in which a row corresponds to each geo-spatial data item from a shape (.shp) file. In the shape database file, string columns may describe attributes for geo-spatial data item such as strings (names of countries, regions, cities) and numeric columns (population of countries, location of cities). Refer to the following resources for detailed information and specifications on how geo-spatial data is stored in shape files. ESRI - Shape File Technical Description Wikipedia - Shape File Description Shape File Tools The following list provides resource tools for editing shape files. MapWindow – Shape (.shp) and Database (.dbf) File Editor Open Office – Database (.dbf) File Editor DBF Editor - Database (.dbf) File Editor DBF View - Database (.dbf) File Editor Satellite Signals – Geo-spatial Calculator RITA – NORTAD to Shape Files Converter Shape Files Data Sources The following list provides resources for obtaining shape files. Also, samples for the IgxGeographicMapComponent control are good source of shape files. These shape files are included in the installer for the Samples Browser. ESRI - World Map Data ESRI - Census 2010 Tiger/Line® - Shape Files National Atlas of the United States – Shape Files U.S. Census Bureau – Cartographic Boundary Files U.S. Census Bureau - 2007 Tiger/Line® - Shape Files U.S. Federal Executive Branch – Raw Data NOAA – Shape Files CDC - Shape Files Massachusetts Geographic Information System Geo Commons – Shape Files Geo Community – Shape Files RITA – NORTAD Files (Must-be converted to Shape Files) MapCruzin – Shape Files Additional Resources The following topics provide additional information related to this topic. Binding Shape Files API References IgxGeographicMapComponent IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent ItemsSource shapeMemberPath IgxShapeDataSource View page on GitHub"
  },
  "components/geo-map-shape-styling.html": {
    "href": "components/geo-map-shape-styling.html",
    "title": "Angular Map | Data Visualization Tools | Shape Styling | Conditional Formatting | Infragistics",
    "keywords": "Angular Shape Styling on Geographic Shape Series This topic explains how to apply custom styling to the IgxGeographicShapeSeriesComponent in the Angular IgxGeographicMapComponent. Angular Shape Styling on Geographic Shape Series Example Required Imports Shape styling requires that you import the following classes: import { IgxGeographicShapeSeries } from 'igniteui-angular-maps'; import { IgxStyleShapeEventArgs } from 'igniteui-angular-charts'; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxShapefileRecord } from 'igniteui-angular-core'; Note that the following code examples are using the Shape Styling Utility file that provides four different ways of styling shapes: Shape Comparison Styling Shape Random Styling Shape Range Styling Shape Scale Styling Shape Random Styling This code snippet creates instances of ShapeRandomStyling that will randomly assign fill colors to the countries of the world. import { ShapeRandomStyling } from './ShapeStylingUtility'; // ... this.shapeRandomStyling = new ShapeRandomStyling(); this.shapeRandomStyling.shapeStrokeColors = ['Black']; this.shapeRandomStyling.shapeFillColors = ['#8C23D1', '#0E9759', '#B4D336', '#F2A464', '#D74545', 'DodgerBlue']; this.geoSeries = new IgxGeographicShapeSeries(); this.geoSeries.styleShape = this.onStylingShape; // ... public onStylingShape(s: IgxGeographicShapeSeries, args: IgxStyleShapeEventArgs) { const itemRecord = args.item as IgxShapefileRecord; const shapeStyle = this.ShapeRandomStyling.getStyle(itemRecord); args.shapeOpacity = shapeStyle.opacity; args.shapeFill = shapeStyle.fill; args.shapeStroke = shapeStyle.stroke; args.shapeStrokeThickness = shapeStyle.strokeThickness; } Shape Scale Styling This code snippet creates instances of ShapeScaleStyling that will assign fill colors to shape of countries based on population scaled on logarithmic scale. import { ShapeScaleStyling } from './ShapeStylingUtility'; // ... this.shapeScaleStyling = new ShapeScaleStyling(); this.shapeScaleStyling.itemMinimumValue = 5000; this.shapeScaleStyling.itemMaximumValue = 2000000000; // 2 Billions this.shapeScaleStyling.itemMemberPath = 'Population'; this.shapeScaleStyling.isLogarithmic = true; this.shapeScaleStyling.defaultFill = 'Gray'; this.shapeScaleStyling.shapeStrokeColors = ['Black']; this.shapeScaleStyling.shapeFillColors = ['DodgerBlue', 'yellow', '#c2f542', '#e8c902', '#e8b602', '#e87902', 'brown']; this.geoSeries = new IgxGeographicShapeSeries(); this.geoSeries.styleShape = this.onStylingShape; // ... public onStylingShape(s: IgxGeographicShapeSeries, args: IgxStyleShapeEventArgs) { const itemRecord = args.item as IgxShapefileRecord; const shapeStyle = this.shapeScaleStyling.getStyle(itemRecord); args.shapeOpacity = shapeStyle.opacity; args.shapeFill = shapeStyle.fill; args.shapeStroke = shapeStyle.stroke; args.shapeStrokeThickness = shapeStyle.strokeThickness; } Shape Range Styling This code snippet creates instances of ShapeRangeStyling that will assign colors to shape of countries based on ranges of population. import { ShapeRangeStyling } from './ShapeStylingUtility'; // ... this.shapeRangeStyling = new ShapeRangeStyling(); this.shapeRangeStyling.defaultFill = 'Gray'; this.shapeRangeStyling.itemMemberPath = 'Population'; this.shapeRangeStyling.ranges = [ { fill: 'yellow', minimum: 5000, maximum: 10000000, }, // 5 K - 10 M { fill: 'orange', minimum: 10000000, maximum: 100000000, }, // 10 M - 100 M { fill: 'red', minimum: 100000000, maximum: 500000000, }, // 100 M - 500 M { fill: 'brown', minimum: 500000000, maximum: 2000000000, }, // 500 M - 2 B ]; this.geoSeries = new IgxGeographicShapeSeries(); this.geoSeries.styleShape = this.onStylingShape; // ... public onStylingShape(s: IgxGeographicShapeSeries, args: IgxStyleShapeEventArgs) { const itemRecord = args.item as IgxShapefileRecord; const shapeStyle = this.shapeRangeStyling.getStyle(itemRecord); args.shapeOpacity = shapeStyle.opacity; args.shapeFill = shapeStyle.fill; args.shapeStroke = shapeStyle.stroke; args.shapeStrokeThickness = shapeStyle.strokeThickness; } Shape Comparison Styling This code snippet creates instances of ShapeComparisonStyling that will assign colors to countries based on their region name in the world. import { ShapeComparisonStyling } from './ShapeStylingUtility'; this.shapeComparisonStyling = new ShapeComparisonStyling(); this.shapeComparisonStyling.defaultFill = 'Gray'; this.shapeComparisonStyling.itemMemberPath = 'Region'; this.shapeComparisonStyling.itemMappings = [ { fill: 'Red', itemValue: 'Eastern Europe' }, { fill: 'Red', itemValue: 'Central Asia' }, { fill: 'Red', itemValue: 'Eastern Asia' }, { fill: 'Orange', itemValue: 'Southern Asia' }, { fill: 'Orange', itemValue: 'Middle East' }, { fill: 'Orange', itemValue: 'Northern Africa' }, { fill: 'Yellow', itemValue: 'Eastern Africa' }, { fill: 'Yellow', itemValue: 'Western Africa' }, { fill: 'Yellow', itemValue: 'Middle Africa' }, { fill: 'Yellow', itemValue: 'Southern Africa' }, { fill: 'DodgerBlue', itemValue: 'Central America' }, { fill: 'DodgerBlue', itemValue: 'Northern America' }, { fill: 'DodgerBlue', itemValue: 'Western Europe' }, { fill: 'DodgerBlue', itemValue: 'Southern Europe' }, { fill: 'DodgerBlue', itemValue: 'Northern Europe' }, { fill: '#22c928', itemValue: 'South America' }, { fill: '#b64fff', itemValue: 'Melanesia' }, { fill: '#b64fff', itemValue: 'Micronesia' }, { fill: '#b64fff', itemValue: 'Polynesia' }, { fill: '#b64fff', itemValue: 'Australia' }, ]; this.geoSeries = new IgxGeographicShapeSeries(); this.geoSeries.styleShape = this.onStylingShape; // ... public onStylingShape(s: IgxGeographicShapeSeries, args: IgxStyleShapeEventArgs) { const itemRecord = args.item as IgxShapefileRecord; const shapeStyle = this.shapeComparisonStyling.getStyle(itemRecord); args.shapeOpacity = shapeStyle.opacity; args.shapeFill = shapeStyle.fill; args.shapeStroke = shapeStyle.stroke; args.shapeStrokeThickness = shapeStyle.strokeThickness; } API References IgxGeographicShapeSeriesComponent IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-type-scatter-area-series.html": {
    "href": "components/geo-map-type-scatter-area-series.html",
    "title": "Angular Map | Data Visualization Tools | Scatter Area Series | Data Binding | Infragistics",
    "keywords": "Angular Geographic Area Map In Angular map component, you can use the IgxGeographicScatterAreaSeriesComponent to draw a colored surface, in a geographic context, based on a triangulation of longitude and latitude data with a numeric value assigned to each point. This type of geographic series is useful for rendering scattered data, defined by geographic locations such as weather temperature, precipitation, population distribution, air pollution, etc. Angular Geographic Area Map Example The IgxGeographicScatterAreaSeriesComponent works a lot like the IgxGeographicContourLineSeriesComponent except that it represents data as interpolated and colored surface instead of contour lines connecting data points with the same values. Data Requirements Similar to other types of geographic series in the map component, the IgxGeographicScatterAreaSeriesComponent has the ItemsSource property which can be bound to an array of objects. In addition, each item in the items source must have three data columns, two that store a geographic longitude and latitude coordinates and one data column that stores a value associated with the geographic location. The longitudeMemberPath, latitudeMemberPath, and colorMemberPath properties of the geographic series identify these data column. The IgxGeographicScatterAreaSeriesComponent automatically performs built-in data triangulation on items in the ItemsSource if no triangulation is set to the trianglesSource property. However, computing triangulation can be a very time-consuming process, so the runtime performance will be better when specifying a TriangulationSource for this property, especially when a large number of data items are present. Data Binding The following table summarizes properties of GeographicScatterAreaSeries used for data binding. Property Name Property Type Description ItemsSource any The source of data items to perform triangulation on if the trianglesSource property provides no triangulation data. longitudeMemberPath string The name of the property containing the Longitude for all items bound to the ItemsSource. latitudeMemberPath string The name of the property containing the Latitude for all items bound to the ItemsSource. colorMemberPath string The name of the property containing a value at Latitude and Longitude coordinates of each data item. This numeric value will be be converted to a color when the colorScale property is set. trianglesSource any The source of triangulation data. Setting Triangles of the TriangulationSource object to this property improves both runtime performance and geographic series rendering. triangleVertexMemberPath1 string The name of the property of the trianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. triangleVertexMemberPath2 string The name of the property of the trianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. triangleVertexMemberPath3 string The name of the property of the trianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. Color Scale Use the ColorScale property of the IgxGeographicScatterAreaSeriesComponent to resolve colors values of points and thus fill surface of the geographic series. The colors are smoothly interpolated around the shape of the surface by applying a pixel-wise triangle rasterizer to a triangulation data. Because rendering of the surface is pixel-wise, the color scale uses colors instead of brushes. The provided IgxCustomPaletteColorScaleComponent class should satisfy most coloring needs, but the ColorScale base class can be inherited by the application for custom coloring logic. The following table list properties of the IgxCustomPaletteColorScaleComponent affecting surface coloring of the GeographicScatterAreaSeries. Property Name Property Type Description palette ObservableCollection Gets or sets the collection of colors to select from or to interpolate between. interpolationMode ColorScaleInterpolationMode Gets or sets the method getting a color from the Palette. maximumValue double The highest value to assign a color. Any given value greater than this value will be Transparent. minimumValue double The lowest value to assign a color. Any given value less than this value will be Transparent. Code Snippet The following code shows how to bind the IgxGeographicScatterAreaSeriesComponent to triangulation data representing surface temperatures in the world. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> Degrees: {{item.value}} \"°F\" </span> <br/> <span> Longitude: {{item.lon}} </span> <br/> <span> Latitude: {{item.lat}} </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxCustomPaletteColorScaleComponent } from 'igniteui-angular-charts'; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicScatterAreaSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-geographic-scatter-area-series\", styleUrls: [\"./map-geographic-scatter-area-series.component.scss\"], templateUrl: \"./map-geographic-scatter-area-series.component.html\" }) export class MapTypeScatterAreaSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild (\"template\") public tooltipTemplate: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { const sds = new IgxShapeDataSource(); sds.shapefileSource = \"assets/Shapes/WorldTemperatures.shp\"; sds.databaseSource = \"assets/Shapes/WorldTemperatures.dbf\"; sds.dataBind(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); const contourPoints: any[] = []; for (const record of shapeRecords) { const temp = record.fieldValues.Contour; // using only major contours (every 10th degrees Celsius) if (temp % 10 === 0 && temp >= 0) { for (const shapes of record.points) { for (let i = 0; i < shapes.length; i++) { if (i % 5 === 0) { const p = shapes[i]; const item = { lon: p.x, lat: p.y, value: temp}; contourPoints.push(item); } } } } } this.createContourSeries(contourPoints); } public createContourSeries(data: any[]) { const brushes = [ \"rgba(32, 146, 252, 0.5)\", // semi-transparent blue \"rgba(14, 194, 14, 0.5)\", // semi-transparent green \"rgba(252, 120, 32, 0.5)\", // semi-transparent orange \"rgba(252, 32, 32, 0.5)\" // semi-transparent red ]; const colorScale = new IgxCustomPaletteColorScaleComponent(); colorScale.palette = brushes; colorScale.minimumValue = 0; colorScale.maximumValue = 30; const areaSeries = new IgxGeographicScatterAreaSeriesComponent(); areaSeries.dataSource = data; areaSeries.longitudeMemberPath = \"lon\"; areaSeries.latitudeMemberPath = \"lat\"; areaSeries.colorMemberPath = \"value\"; areaSeries.colorScale = colorScale; areaSeries.tooltipTemplate = this.tooltipTemplate; areaSeries.thickness = 4; this.map.series.add(areaSeries); } } API References colorMemberPath colorScale IgxCustomPaletteColorScaleComponent IgxGeographicContourLineSeriesComponent IgxGeographicScatterAreaSeriesComponent ItemsSource latitudeMemberPath longitudeMemberPath trianglesSource TriangulationSource View page on GitHub"
  },
  "components/geo-map-type-scatter-bubble-series.html": {
    "href": "components/geo-map-type-scatter-bubble-series.html",
    "title": "Angular Map | Data Visualization Tools | Scatter Proportional Series | Data Binding | Infragistics",
    "keywords": "Angular Geographic Bubble Map In Angular map component, you can use the IgxGeographicProportionalSymbolSeriesComponent to plot bubbles or proportional markers at the geographic locations specified by the data in your application. This map series can be useful for highlighting points of interest in your particular business case like department stores, warehouses, or offices. Also you can use this map series in a fleet management system or a GPS system for dynamic vehicle tracking. Angular Geographic Bubble Map Example The demo above shows the IgxGeographicProportionalSymbolSeriesComponent series and how to specify data binding options of the series. Automatic marker selection is configured along with marker collision avoidance logic, and marker outline and fill colors are specified too. Configuration Summary Similar to other types of scatter series in the map control, the IgxGeographicProportionalSymbolSeriesComponent series has the ItemsSource property which can be bound to an array of objects. In addition, each data item in the items source must have two data columns that store geographic longitude and latitude coordinates and uses the longitudeMemberPath and latitudeMemberPath properties to map these data columns. The radiusScale and radiusMemberPath will settings configures the radius for the bubbles. The following table summarizes the GeographicHighDensityScatterSeries series properties used for data binding. Property Type Description ItemsSource any Gets or sets the items source longitudeMemberPath string Uses the ItemsSource property to determine the location of the longitude values on the assigned items latitudeMemberPath string Uses the ItemsSource property to determine the location of the latitude values on the assigned items radiusMemberPath string Sets the path to use to get the radius values for the series. radiusScale IgxSizeScaleComponent Gets or sets the radius scale property for the current bubble series. minimumValue any Configure the minimum value for calculating value sub ranges. maximumValue any Configure the maximum value for calculating value sub ranges. Code Snippet <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> {{item.name}} </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxSizeScaleComponent } from 'igniteui-angular-charts'; import { IgxValueBrushScaleComponent } from 'igniteui-angular-charts'; import { IgxDataContext } from 'igniteui-angular-core'; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicProportionalSymbolSeriesComponent } from 'igniteui-angular-maps'; import { MarkerType } from 'igniteui-angular-charts'; import { WorldLocations } from \"../../utilities/WorldLocations\"; @Component({ selector: \"app-map-geographic-scatter-proportional-series\", styleUrls: [\"./map-geographic-scatter-proportional-series.component.scss\"], templateUrl: \"./map-geographic-scatter-proportional-series.component.html\" }) export class MapTypeScatterBubbleSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild (\"template\") public tooltipTemplate: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { const sds = new IgxShapeDataSource(); sds.shapefileSource = \"assets/Shapes/WorldTemperatures.shp\"; sds.databaseSource = \"assets/Shapes/WorldTemperatures.dbf\"; sds.dataBind(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); console.log(\"loaded contour shapes: \" + shapeRecords.length + \" from /Shapes/WorldTemperatures.shp\"); const contourPoints: any[] = []; for (const record of shapeRecords) { const temp = record.fieldValues.Contour; // using only major contours (every 10th degrees Celsius) if (temp % 10 === 0 && temp >= 0) { for (const shapes of record.points) { for (let i = 0; i < shapes.length; i++) { if (i % 5 === 0) { const p = shapes[i]; const item = { lon: p.x, lat: p.y, value: temp}; contourPoints.push(item); } } } } } console.log(\"loaded contour points: \" + contourPoints.length); this.addSeriesWith(WorldLocations.getAll()); } public addSeriesWith(locations: any[]) { const sizeScale = new IgxSizeScaleComponent(); sizeScale.minimumValue = 4; sizeScale.maximumValue = 60; const brushes = [ \"rgba(14, 194, 14, 0.4)\", // semi-transparent green \"rgba(252, 170, 32, 0.4)\", // semi-transparent orange \"rgba(252, 32, 32, 0.4)\" // semi-transparent red ]; const brushScale = new IgxValueBrushScaleComponent(); brushScale.brushes = brushes; brushScale.minimumValue = 0; brushScale.maximumValue = 30; const symbolSeries = new IgxGeographicProportionalSymbolSeriesComponent(); symbolSeries.dataSource = locations; symbolSeries.markerType = MarkerType.Circle; symbolSeries.radiusScale = sizeScale; symbolSeries.fillScale = brushScale; symbolSeries.fillMemberPath = \"pop\"; symbolSeries.radiusMemberPath = \"pop\"; symbolSeries.latitudeMemberPath = \"lat\"; symbolSeries.longitudeMemberPath = \"lon\"; symbolSeries.markerOutline = \"rgba(0,0,0,0.3)\"; symbolSeries.tooltipTemplate = this.tooltipTemplate; this.map.series.add(symbolSeries); } } API References IgxGeographicProportionalSymbolSeriesComponent ItemsSource latitudeMemberPath longitudeMemberPath radiusMemberPath radiusScale View page on GitHub"
  },
  "components/geo-map-type-scatter-contour-series.html": {
    "href": "components/geo-map-type-scatter-contour-series.html",
    "title": "Angular Map | Data Visualization Tools | Scatter Contour Series | Data Binding | Infragistics",
    "keywords": "Angular Geographic Contour Map In Angular map component, you can use the IgxGeographicContourLineSeriesComponent to draw colored contour lines, in a geographic context, based on a triangulation of longitude and latitude data with a numeric value assigned to each point. This type of geographic series is useful for rendering scattered data defined by geographic locations such as weather temperature, atmospheric pressure, precipitation, population distribution, topographic data, etc. Angular Geographic Contour Map Example The IgxGeographicContourLineSeriesComponent works a lot like the IgxGeographicScatterAreaSeriesComponent except that it represents data as contour lines, colored using a fill scale and the geographic scatter area series, represents data as a surface interpolated using a color scale. Data Requirements Similar to other types of geographic series in the map component, the IgxGeographicContourLineSeriesComponent has the ItemsSource property which can be bound to an array of objects. In addition, each item in the items source must have three data columns, two that store geographic location (longitude and latitude coordinates) and one data column that stores a value associated with the geographic location. These data column, are identified by longitudeMemberPath, latitudeMemberPath, and valueMemberPath properties of the geographic series. The IgxGeographicContourLineSeriesComponent automatically performs built-in data triangulation on items in the ItemsSource if no triangulation is set to the trianglesSource property. However, computing triangulation can be a very time-consuming process, so the runtime performance will be better when specifying a TriangulationSource for this property, especially when a large number of data items are present. Data Binding The following table summarizes properties of IgxGeographicContourLineSeriesComponent used for data binding. Property Name Property Type Description ItemsSource any The source of data items to perform triangulation on if the trianglesSource property provides no triangulation data. longitudeMemberPath string The name of the property containing the Longitude for all items bound to the ItemsSource. latitudeMemberPath string The name of the property containing the Latitude for all items bound to to the ItemsSource. valueMemberPath string The name of the property containing a value at Latitude and Longitude coordinates of each data item. This numeric value will be be converted to a color when the fillScale property is set. trianglesSource any Gets or sets the source of triangulation data. Setting Triangles of the TriangulationSource object to this property improves both runtime performance and geographic series rendering. triangleVertexMemberPath1 string The name of the property of the TrianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. triangleVertexMemberPath2 string The name of the property of the TrianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. triangleVertexMemberPath3 string The name of the property of the TrianglesSource items which, for each triangle, contains the index of the first vertex point in the ItemsSource. It is not mandatory to set this property. It is taken by default unless custom triangulation logic is provided. Contour Fill Scale Use the fillScale property of the IgxGeographicContourLineSeriesComponent to resolve fill brushes of the contour lines of the geographic series. The provided `ValueBrushScale class should satisfy most of your coloring needs, but the application for custom coloring logic can inherit the ValueBrushScale class. The following table list properties of the CustomPaletteColorScale affecting the surface coloring of the GeographicContourLineSeries. Property Name Property Type Description brushes BrushCollection Gets or sets the collection of brushes for filling contours of the IgxGeographicContourLineSeriesComponent maximumValue double The highest value to assign a brush in a fill scale. minimumValue double The lowest value to assign a brush in a fill scale. Code Snippet The following code shows how to bind the IgxGeographicContourLineSeriesComponent to triangulation data representing surface temperatures in the world. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <span [style.color]=\"series.brush\"> {{item | number: 2}} \"°C\" </span> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxValueBrushScaleComponent } from 'igniteui-angular-charts'; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicContourLineSeriesComponent } from 'igniteui-angular-maps'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-geographic-scatter-contour-series\", styleUrls: [\"./map-geographic-scatter-contour-series.component.scss\"], templateUrl: \"./map-geographic-scatter-contour-series.component.html\" }) export class MapTypeScatterContourSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild (\"template\") public tooltip: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { const sds = new IgxShapeDataSource(); sds.shapefileSource = \"assets/Shapes/WorldTemperatures.shp\"; sds.databaseSource = \"assets/Shapes/WorldTemperatures.dbf\"; sds.dataBind(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); const contourPoints: any[] = []; for (const record of shapeRecords) { const temp = record.fieldValues.Contour; // using only major contours (every 10th degrees Celsius) if (temp % 10 === 0 && temp >= 0) { for (const shapes of record.points) { for (let i = 0; i < shapes.length; i++) { if (i % 5 === 0) { const p = shapes[i]; const item = { lon: p.x, lat: p.y, value: temp}; contourPoints.push(item); } } } } } this.createContourSeries(contourPoints); } public createContourSeries(data: any[]) { const brushes = [ \"rgba(32, 146, 252, 0.5)\", // semi-transparent blue \"rgba(14, 194, 14, 0.5)\", // semi-transparent green \"rgba(252, 120, 32, 0.5)\", // semi-transparent orange \"rgba(252, 32, 32, 0.5)\" // semi-transparent red ]; const brushScale = new IgxValueBrushScaleComponent(); brushScale.brushes = brushes; brushScale.minimumValue = 0; brushScale.maximumValue = 30; const contourSeries = new IgxGeographicContourLineSeriesComponent(); contourSeries.dataSource = data; contourSeries.longitudeMemberPath = \"lon\"; contourSeries.latitudeMemberPath = \"lat\"; contourSeries.valueMemberPath = \"value\"; contourSeries.fillScale = brushScale; contourSeries.tooltipTemplate = this.tooltip; contourSeries.thickness = 4; this.map.series.add(contourSeries); } } API References fillScale IgxGeographicContourLineSeriesComponent IgxGeographicScatterAreaSeriesComponent ItemsSource latitudeMemberPath longitudeMemberPath trianglesSource TriangulationSource IgxValueBrushScaleComponent valueMemberPath View page on GitHub"
  },
  "components/geo-map-type-scatter-density-series.html": {
    "href": "components/geo-map-type-scatter-density-series.html",
    "title": "Angular Map | Data Visualization Tools | Scatter High Density Series | Data Binding | Infragistics",
    "keywords": "Angular Geographic High Density Map In Angular map component, you can use the IgxGeographicHighDensityScatterSeriesComponent to bind and show scatter data ranging from hundreds to millions of data points requiring exceedingly little loading time. Angular Geographic High Density Map Example The demo above shows the IgxGeographicHighDensityScatterSeriesComponent series in the map component bound to hundreds or even thousands of data points representing Australia’s population density. The map plot area with more densely populated data points represented as coalescences of red pixels and loosely distributed data points by discrete blue pixels. Because there are so many data points, the series displays the scatter data as tiny dots as opposed to full size markers, and displays areas with the most data using a higher color density representing a cluster of data points. Data Requirements Similar to other types of scatter series in the map control, the IgxGeographicHighDensityScatterSeriesComponent series has the ItemsSource property which can be bound to an array of objects. In addition, each data item in the items source must have two data columns that store geographic longitude and latitude coordinates and uses the longitudeMemberPath and latitudeMemberPath properties to map these data columns. Data Binding The following table summarizes the GeographicHighDensityScatterSeries series properties used for data binding. Property Type Description ItemsSource any Gets or sets the items source longitudeMemberPath string Uses the ItemsSource property to determine the location of the longitude values on the assigned items latitudeMemberPath string Uses the ItemsSource property to determine the location of the latitude values on the assigned items Heat Color Scale The Heat Color Scale, an optional feature, determines the color pattern within the series. The following table summarizes the properties used for determining the color scale. Property Type Description heatMinimum Double Defines the double value representing the minimum end of the color scale heatMaximum Double Defines the double value representing the maximum end of the color scale heatMinimumColor Color Defines the point density color used at the bottom end of the color scale heatMaximumColor Color Defines the point density color used at the top end of the color scale Code Example The following code demonstrates how set the heatMinimumColor and heatMaximumColor properties of the IgxGeographicHighDensityScatterSeriesComponent <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> {{item.n}} </span> </div> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicHighDensityScatterSeriesComponent } from 'igniteui-angular-maps'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { WorldUtils } from \"../../utilities/WorldUtils\"; @Component({ selector: \"app-map-geographic-scatter-density-series\", styleUrls: [\"./map-geographic-scatter-density-series.component.scss\"], templateUrl: \".map-geographic-scatter-density-series.component.html\" }) export class MapTypeScatterDensitySeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; public geoLocations; constructor() { } public ngAfterViewInit(): void { // fetching geographic locations from public JSON folder fetch(\"assets/Data/AusPlaces.json\") .then((response) => response.json()) .then((data) => this.onDataLoaded(data, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { this.geoLocations = sds; // creating HD series with loaded data const geoSeries = new IgxGeographicHighDensityScatterSeriesComponent(); geoSeries.dataSource = sds; geoSeries.longitudeMemberPath = \"x\"; geoSeries.latitudeMemberPath = \"y\"; geoSeries.heatMaximumColor = \"Red\"; geoSeries.heatMinimumColor = \"Black\"; geoSeries.heatMinimum = 0; geoSeries.heatMaximum = 5; geoSeries.pointExtent = 1; geoSeries.tooltipTemplate = this.tooltip; geoSeries.mouseOverEnabled = true; // adding HD series to the geographic amp this.map.series.add(geoSeries); // zooming to bound of all geographic locations const geoBounds = WorldUtils.getBounds(this.geoLocations); geoBounds.top = 0; geoBounds.height = -50; this.map.zoomToGeographic(geoBounds); } } API References IgxGeographicHighDensityScatterSeriesComponent IgxGeographicHighDensityScatterSeriesComponent heatMaximumColor heatMinimumColor ItemsSource latitudeMemberPath longitudeMemberPath View page on GitHub"
  },
  "components/geo-map-type-scatter-symbol-series.html": {
    "href": "components/geo-map-type-scatter-symbol-series.html",
    "title": "Angular Map | Data Visualization Tools | Scatter Symbol Series | Data Binding | Infragistics",
    "keywords": "Angular Geographic Symbol Map In Angular map component, you can use the IgxGeographicSymbolSeriesComponent to display geo-spatial data using points or markers in a geographic context. This type of geographic series is often used to render a collection of geographic locations such as cities, airports, earthquakes, or points of interests. Angular Geographic Symbol Map Example Data Requirements Similarly to other types of geographic series in the map component, the IgxGeographicSymbolSeriesComponent has the ItemsSource property which can be bound to an array of objects. In addition, each data item in this object must have two numeric data columns that store a geographic location (longitude and latitude). These data columns are then mapped to the latitudeMemberPath and longitudeMemberPath properties. The IgxGeographicSymbolSeriesComponent uses values of these mapped data columns to plot symbol elements in the geographic map component. Code Snippet The following code shows how to bind the IgxGeographicSymbolSeriesComponent to locations of cities loaded from a shape file using the IgxShapeDataSource. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <div *ngIf=\"item.org;then hasOrg; else notOrg\" ></div> <span [style.color]=\"series.brush\"> {{item.name}} </span> <br/> <span> Population {{item.pop}} M </span> </div> <ng-template #hasOrg> <span> Population {{item.pop}} M </span> <br /> </ng-template> <ng-template #notOrg> <span> </span> </ng-template> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { MarkerType } from 'igniteui-angular-charts'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicSymbolSeriesComponent } from \"igniteui-angular-maps\"; import { WorldLocations } from \"../../utilities/WorldLocations\"; @Component({ selector: \"app-map-geographic-scatter-symbol-series\", styleUrls: [\"./map-geographic-scatter-symbol-series.component.scss\"], templateUrl: \"./map-geographic-scatter-symbol-series.component.html\" }) export class MapTypeScatterSymbolSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { this.addSeriesWith(WorldLocations.getCities(), \"Gray\"); this.addSeriesWith(WorldLocations.getCapitals(), \"rgb(32, 146, 252)\"); } public addSeriesWith(locations: any[], brush: string) { const symbolSeries = new IgxGeographicSymbolSeriesComponent (); symbolSeries.dataSource = locations; symbolSeries.markerType = MarkerType.Circle; symbolSeries.latitudeMemberPath = \"lat\"; symbolSeries.longitudeMemberPath = \"lon\"; symbolSeries.markerBrush = \"White\"; symbolSeries.markerOutline = brush; symbolSeries.tooltipTemplate = this.tooltip; this.map.series.add(symbolSeries); } } API References IgxGeographicSymbolSeriesComponent ItemsSource latitudeMemberPath longitudeMemberPath IgxShapeDataSource View page on GitHub"
  },
  "components/geo-map-type-series.html": {
    "href": "components/geo-map-type-series.html",
    "title": "Angular Map | Data Visualization Tools | Geographic Series Types | Infragistics",
    "keywords": "Angular Geographic Series Overview In the Ignite UI for Angular Map component, geographic series are visual elements of the map that display geo-spatial data as points (e.g. locations of cities), polylines (e.g. road connections), or polygons (shape of countries) in a geographic context. The map component's Series property is a collection of geographic series objects. This property is used to support rendering an unlimited number of geographic series in the same plot area. When multiple geographic series objects are added to the Series property, each successive series will be layered on top of the previous series starting from the first to the last series. Therefore, geographic series can be better understood as map layers that can be stacked on top of each other and/or on top of geographic imagery. All types of geographic series are always rendered on top of the geographic imagery tiles. However, sometimes geographic series (e.g. with detailed shape files of the world) might provide enough geographic contexts for an application and geographic imagery is not desired in the map control. Type of Geographic Series The Angular Geographic Map component supports the following types of geographic series: Using Scatter Symbol Series Using Scatter Proportional Series Using Scatter Contour Series Using Scatter Density Series Using Scatter Area Series Using Shape Polygon Series Using Shape Polyline Series API Members IgxGeographicMapComponent View page on GitHub"
  },
  "components/geo-map-type-shape-polygon-series.html": {
    "href": "components/geo-map-type-shape-polygon-series.html",
    "title": "Angular Map | Data Visualization Tools | Shape Polygon Series | Infragistics",
    "keywords": "Angular Geographic Polygon Map In Angular map component, you can use the IgxGeographicShapeSeriesComponent to display geo-spatial data using shape polygons in a geographic context. This type of geographic series is often used to render shapes of countries or regions defined by geographic locations. Angular Geographic Polygon Map Example The IgxGeographicShapeSeriesComponent works a lot like the IgxGeographicPolylineSeriesComponent except that geo-spatial data is rendered with polygons instead of polylines. Data Requirements Similar to other types of geographic series in the map control, the IgxGeographicShapeSeriesComponent has the ItemsSource property which can be bound to an array of objects. In addition, each data item in this object must have one data column that stores single/multiple shapes using an array of arrays of objects with x and y values representing geographic locations. This data column is then mapped to the shapeMemberPath property. The IgxGeographicShapeSeriesComponent uses points of this mapped data column to plot polygons in the map control. Code Snippet The following code demonstrates how to bind the IgxGeographicShapeSeriesComponent to shapes of countries in the world loaded from a shape file using the IgxShapeDataSource. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <div *ngIf=\"item.org;then hasOrg; else notOrg\" ></div> <span [style.color]=\"series.brush\"> {{item.name}} </span> <br/> <span> Population {{item.pop}} M </span> </div> <ng-template #hasOrg> <span> Population {{item.pop}} M </span> <br /> </ng-template> <ng-template #notOrg> <span> </span> </ng-template> </ng-template> import { AfterViewInit, Component, TemplateRef, ViewChild } from \"@angular/core\"; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicShapeSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-geographic-shape-polygon-series\", styleUrls: [\"./map-geographic-shape-polygon-series.component.scss\"], templateUrl: \"./map-geographic-shape-polygon-series.component.html\" }) export class MapTypeShapePolygonSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; public data: any; constructor() { } public ngAfterViewInit(): void { const sds = new IgxShapeDataSource(); sds.shapefileSource = \"assets/Shapes/WorldCountries.shp\"; sds.databaseSource = \"assets/Shapes/WorldCountries.dbf\"; sds.dataBind(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); console.log(\"loaded /Shapes/WorldCountries.shp \" + shapeRecords.length); const countriesNATO: any[] = []; const countriesSCO: any[] = []; const countriesARAB: any[] = []; const countriesOther: any[] = []; for (const record of shapeRecords) { // using field/column names from .DBF file const country = { name: record.fieldValues.NAME, org: record.fieldValues.ALLIANCE, points: record.points, pop: record.fieldValues.POPULATION }; const group = record.fieldValues.ALLIANCE; if (group === \"NATO\") { countriesNATO.push(country); } else if (group === \"SCO\") { countriesSCO.push(country); } else if (group === \"ARAB LEAGUE\") { countriesARAB.push(country); } else { countriesOther.push(country); } } this.addSeriesWith(countriesNATO, \"rgb(32, 146, 252)\", \"NATO\"); this.addSeriesWith(countriesSCO, \"rgb(252, 32, 32)\", \"SCO\"); this.addSeriesWith(countriesARAB, \"rgb(14, 194, 14)\", \"AL\"); this.addSeriesWith(countriesOther, \"rgb(146, 146, 146)\", \"Other\"); } public addSeriesWith(shapeData: any[], shapeBrush: string, shapeTitle: string) { const seriesName = shapeTitle + \"series\"; const geoSeries = new IgxGeographicShapeSeriesComponent(); geoSeries.dataSource = shapeData; geoSeries.shapeMemberPath = \"points\"; geoSeries.brush = shapeBrush; geoSeries.outline = \"Black\"; geoSeries.tooltipTemplate = this.tooltip; geoSeries.thickness = 1; geoSeries.title = shapeTitle; this.map.series.add(geoSeries); } } API References IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent ItemsSource shapeMemberPath IgxShapeDataSource View page on GitHub"
  },
  "components/geo-map-type-shape-polyline-series.html": {
    "href": "components/geo-map-type-shape-polyline-series.html",
    "title": "Angular Map | Data Visualization Tools | Shape Polyline Series | Infragistics",
    "keywords": "Angular Geographic Polyline Map In Angular map component, you can use the IgxGeographicPolylineSeriesComponent to display geo-spatial data using polylines in a geographic context. This type of geographic series is often used to render roads or connections between geographic locations such as cities or airports. Angular Geographic Polyline Map Example The IgxGeographicPolylineSeriesComponent works a lot like the IgxGeographicShapeSeriesComponent except that geo-spatial data is rendered with polylines instead of polygons. Data Requirements Similarly to other types of geographic series in the control, the IgxGeographicPolylineSeriesComponent has the ItemsSource property which can be bound to an array of objects. In addition, each data item in this object must have one data column that stores single/multiple shapes using an array of arrays of objects with x and y values representing geographic locations. This data column is then mapped to the shapeMemberPath property. The IgxGeographicPolylineSeriesComponent uses points of this mapped data column to plot polygons in the control. Code Snippet The following code shows how to bind the IgxGeographicPolylineSeriesComponent to locations of cities loaded from a shape file using the IgxShapeDataSource. <div className=\"sampleRoot\" > <igx-geographic-map #map width=\"700px\" height=\"500px\" zoomable=\"true\" > </igx-geographic-map> </div> <ng-template let-series=\"series\" let-item=\"item\" #template> <div> <span> {{item.country}} {{item.type}} </span> <br /> <span> Length: {{item.length}} miles </span> </div> </ng-template> import { AfterViewInit, Component, EmbeddedViewRef, TemplateRef, ViewChild} from \"@angular/core\"; import { IgxShapeDataSource } from 'igniteui-angular-core'; import { IgxIgxGeographicMapComponent } from 'igniteui-angular-maps'; import { IgxGeographicPolylineSeriesComponent } from 'igniteui-angular-maps'; @Component({ selector: \"app-map-geographic-shape-polyline-series\", styleUrls: [\"./map-geographic-shape-polyline-series.component.scss\"], templateUrl: \"./map-geographic-shape-polyline-series.component.html\" }) export class MapTypeShapePolylineSeriesComponent implements AfterViewInit { @ViewChild (\"map\") public map: IgxGeographicMapComponent; @ViewChild(\"template\") public tooltip: TemplateRef<object>; constructor() { } public ngAfterViewInit(): void { this.map.windowRect = { left: 0.195, top: 0.325, width: 0.2, height: 0.1 }; const sds = new IgxShapeDataSource(); sds.shapefileSource = \"/assets/Shapes/AmericanRoads.shp\"; sds.databaseSource = \"/assets/Shapes/AmericanRoads.dbf\"; sds.dataBind(); sds.importCompleted.subscribe(() => this.onDataLoaded(sds, \"\")); } public onDataLoaded(sds: IgxShapeDataSource, e: any) { const shapeRecords = sds.getPointData(); console.log(\"loaded /Shapes/AmericanRoads.shp \" + shapeRecords.length); const roadsUSA: any[] = []; const roadsMEX: any[] = []; const roadsCAN: any[] = []; // filtering records of loaded shapefile for (const record of shapeRecords) { // reading field values loaded from DBF file const type = record.fieldValues.RoadType; const road = { country: record.fieldValues.Country, length: record.fieldValues.RoadLength / 10, points: record.points, type: type === 1 ? \"Highway\" : \"Road\" }; // grouping road items by country names if (type === 1 || type === 2) { if (road.country === \"USA\") { roadsUSA.push(road); } else if (road.country === \"MEX\") { roadsMEX.push(road); } else if (road.country === \"CAN\") { roadsCAN.push(road); } } } // creating polyline series for roads of each country this.addSeriesWith(roadsCAN, \"rgba(252, 32, 32, 0.9)\"); this.addSeriesWith(roadsUSA, \"rgba(3, 121, 231, 0.9)\"); this.addSeriesWith(roadsMEX, \"rgba(14, 194, 14, 0.9)\"); } public addSeriesWith(shapeData: any[], shapeBrush: string) { const lineSeries = new IgxGeographicPolylineSeriesComponent (); lineSeries.dataSource = shapeData; lineSeries.shapeMemberPath = \"points\"; lineSeries.shapeFilterResolution = 2.0; lineSeries.shapeStrokeThickness = 2; lineSeries.shapeStroke = shapeBrush; lineSeries.tooltipTemplate = this.tooltip; this.map.series.add(lineSeries); } } API References IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent ItemsSource IgxShapeDataSource View page on GitHub"
  },
  "components/grid/advanced-filtering.html": {
    "href": "components/grid/advanced-filtering.html",
    "title": "Advanced Filtering in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Advanced Filtering The Advanced filtering provides a dialog which allows the creation of groups with filtering conditions across all columns for any Angular table like the Grid. Angular Grid Advanced Filtering Example Interaction In order to open the advanced filtering dialog, the Advanced Filtering button in the grid toolbar should be clicked. The dialog is using the IgxQueryBuilder component to generate,display and edit the filtering logic. You can have a look at the Query Builder topic for details on the interaction process. In order to filter the data once you are ready with creating the filtering conditions and groups, you should click the Apply button. If you have modified the advanced filter, but you don't want to preserve the changes, you should click the Cancel button. You could also clear the advanced filter by clicking the Clear Filter button. Usage To enable the advanced filtering, the allowAdvancedFiltering input property should be set to true. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> <igx-grid-toolbar></igx-grid-toolbar> </igx-grid> The advanced filtering generates a FilteringExpressionsTree which is stored in the advancedFilteringExpressionsTree input property. You could use the advancedFilteringExpressionsTree property to set an initial state of the advanced filtering. ngAfterViewInit(): void { const tree = new FilteringExpressionsTree(FilteringLogic.And); tree.filteringOperands.push({ fieldName: 'ID', condition: IgxStringFilteringOperand.instance().condition('contains'), searchVal: 'a', ignoreCase: true }); const subTree = new FilteringExpressionsTree(FilteringLogic.Or); subTree.filteringOperands.push({ fieldName: 'ContactTitle', condition: IgxStringFilteringOperand.instance().condition('doesNotContain'), searchVal: 'b', ignoreCase: true }); subTree.filteringOperands.push({ fieldName: 'CompanyName', condition: IgxStringFilteringOperand.instance().condition('startsWith'), searchVal: 'c', ignoreCase: true }); tree.filteringOperands.push(subTree); this.grid.advancedFilteringExpressionsTree = tree; } In case you don't want to show the Grid toolbar, you could use the openAdvancedFilteringDialog and closeAdvancedFilteringDialog methods to open and close the advanced filtering dialog programmatically. Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Grid is the intersection between the results of the two filters. External Advanced filtering As you see the demo above the Advanced filtering dialog is hosted in an overlay on top of the Grid. When the setup in the dialog is ready, the apply or close actions would hide that dialog. There is a way to make that dialog stay always visible - be used as a standalone component. In the demo below, the advanced filtering dialog is declared separately of the Grid. Demo Usage It's super easy to configure the advanced filtering to work outside of the Grid. All you need to do is to create the dialog and set its grid property: <igx-advanced-filtering-dialog [grid]=\"grid1\"> </igx-advanced-filtering-dialog> You can also see how our drag and drop App Builder™ can streamline the entire design-to-Angular-code story. Styling To get started with styling the Advanced Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The advanced filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); Since we have other components inside the advanced filtering dialog, such as buttons, chips, dropdowns and inputs, we need to create a separate theme for each one: $custom-button: button-theme( $disabled-color: gray, ... ); $custom-button-group: button-group-theme( $item-background: #292826, ... ); $custom-input-group: input-group-theme( $box-background: #4a4a4a, ... ); $custom-chip: chip-theme( $background: #FFCD0F, ... ); $custom-drop-down: drop-down-theme( $background-color: #292826, ... ); In this example we only changed some of the parameters for the listed components, but the button-theme, button-group-theme, chip-theme, drop-down-theme, input-group-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also add some styles for other elements inside the advanced filtering dialog. @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); @include drop-down($custom-drop-down); .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } .igx-input-group__input::placeholder { color: gray; } } Note We scope most of the components' mixins within igx-advanced-filtering-dialog, so that these custom themes will affect only components nested in the advanced filtering dialog. Otherwise, other buttons, chips, inputs and dropdowns in the application would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); .igx-input-group__input::placeholder { color: gray; } .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: color($dark-palette, \"secondary\", 400) ); $custom-button: button-theme( $disabled-color: color($dark-palette, \"secondary\", 100), ... ); $custom-button-group: button-group-theme( $item-background: color($dark-palette, \"secondary\", 400), ... ); $custom-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 200), ... ); $custom-chip: chip-theme( $background: color($dark-palette, \"primary\", 400), ... ); $custom-drop-down: drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), ... ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-button, light-button-group, light-chip, light-input-group and light-drop-down schemas: $grid-dark-palette: palette($primary: #11bd7b, $secondary: #e32057, $info: $black-color); $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"info\") ) ) ); $custom-button-schema: extend($_light-button, ( disabled-color:( color: (\"secondary\", 100) ), ... ) ); $custom-button-group-schema: extend($_light-button-group, ( item-background:( color: (\"secondary\", 400) ), ... ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 200) ), ... ) ); $custom-chip-schema: extend($_light-chip, ( background:( color: (\"primary\", 400) ), ... ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), ... ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-button: $custom-button-schema, igx-button-group: $custom-button-group-schema, igx-input-group: $custom-input-group-schema, igx-chip: $custom-chip-schema, igx-drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $grid-dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button-group: button-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-chip: chip-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxGridComponent API IgxGridComponent Styles Additional Resources Grid overview Filtering Excel Style Filtering Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/batch-editing.html": {
    "href": "components/grid/batch-editing.html",
    "title": "Batch Editing and Transactions in Angular Grid Grid - Infragistics",
    "keywords": "Angular Grid Batch Editing and Transactions The Batch Editing feature of the IgxGrid is based on the TransactionService. Follow the Transaction Service class hierarchy topic to see an overview of the igxTransactionService and details how it is implemented. Below is a detailed example of how is Batch Editing enabled for the Grid component. Angular Grid Batch Editing and Transactions Example The following sample demonstrates a scenario, where the grid has batchEditing enabled and has row editing enabled. The latter will ensure that transaction will be added after the entire row edit is confirmed. Note Transaction state consists of all the updated, added and deleted rows, and their last states. Usage To get started import the IgxGridModule in the app.module.ts file: // app.module.ts ... import { IgxGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxGridModule], ... }) export class AppModule {} Then, all you need to do is enable batchEditing from your Grid: <igx-grid [data]=\"data\" [batchEditing]=\"true\"> ... </igx-grid> This will ensure a proper instance of Transaction service is provided for the igx-grid. The proper TransactionService is provided through a TransactionFactory. You can learn more about this internal implementation in the transactions topic. After batch editing is enabled, define a IgxGrid with bound data source and rowEditable set to true and bind: <igx-grid #grid [batchEditing]=\"true\" [data]=\"data\" [primaryKey]=\"'ProductID'\" width=\"100%\" height=\"500px\" [rowEditable]=\"true\"> ... </igx-grid> ... <button igxButton [disabled]=\"!grid.transactions.canUndo\" (click)=\"undo()\">Undo</button> <button igxButton [disabled]=\"!grid.transactions.canRedo\" (click)=\"redo()\">Redo</button> <button igxButton [disabled]=\"grid.transactions.getAggregatedChanges(false).length < 1\" (click)=\"openCommitDialog(dialogGrid)\">Commit</button> ... The following code demonstrates the usage of the transactions API - undo, redo, commit. export class GridBatchEditingSampleComponent { @ViewChild('grid', { read: IgxGridComponent }) public gridRowEditTransaction: IgxGridComponent; public undo() { /* exit edit mode and commit changes */ this.grid.endEdit(true); this.grid.transactions.undo(); } public redo() { /* exit edit mode and commit changes */ this.grid.endEdit(true); this.grid.transactions.redo() } public commit() { this.grid.transactions.commit(this.data); this.toggle.close(); } } Note The transactions API won't handle end of edit and you'd need to do it by yourself. Otherwise, Grid would stay in edit mode. One way to do that is by calling endEdit in the respective method. Note Disabling rowEditable property will modify Grid to create transactions on cell change and will not expose row editing overlay in the UI. Remote Paging with Batch Editing Demo Check out the full demo configuration API References transactions igxTransactionService Additional Resources Build CRUD operations with igxGrid Grid Overview Grid Editing Grid Row Editing Grid Row Adding Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/cascading-combos.html": {
    "href": "components/grid/cascading-combos.html",
    "title": "Cascading combos in Angular Grid Grid - Infragistics",
    "keywords": "Angular Grid with Cascading Combos The Grid's Editing functionality provides with the opportunity to use Cascading Combos. By selecting the value in any preceding Combos, the users will receive only the data that is relevant to their selection within the next Combo. Angular Grid with Cascading Combos Sample Overview The sample below demonstrates how Grid works with nested Cascading Combos. Setup In order enable column editing, make sure editable property is set to true. Once the column editig is enabled, you can start by adding your Single Select ComboBox. Please note that here in order to have only one single selection available, you will need to use igxSimpleCombo instead of modifying the igxCombo. To get started with the Simple ComboBox component, first you need to import the IgxSimpleComboModule in your app.module.ts file: import { IgxSimpleComboModule } from 'igniteui-angular'; @NgModule({ imports: [ ... IgxSimpleComboModule, ... ] }) export class AppModule {} Then, in the template, you should bind the combos igx-simple-combo to some data. displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the simple combobox will use the specified valueKey (if any). export class MySimpleComboComponent implements OnInit { public countriesData: Country[]; public selectedCountry: Country; public selectedCity: City; public ngOnInit() { this.countriesData = getCountries([ 'United States', 'Japan', 'United Kingdom' ]); } } In order to handle the selection change, we need selectionChanging(). The emitted event arguments, IComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the items that were added or removed. Therefore, it will filter the values based on the selection of the previous combo. <igx-combo [data]=\"countriesData\" (selectionChanging)=\"countryChanging($event)\"></igx-combo> public countryChanging(event: IComboSelectionChangeEventArgs) { if (event.added.length) { event.newSelection = event.added; } } And lastly, adding the Linear Progress, which is required while loading the list of data. The id is necessary to set the value of id attribute. <igx-linear-bar [id]=\"'region-progress-' + cell.row.data.ID\" [style.visibility]=\"'hidden'\" type=\"info\" [indeterminate]=\"true\"> </igx-linear-bar> API Summary IgxSimpleComboComponent IgxComboComponent Styles IgxLinearProgressBarComponent IgxLinearProgressBarComponent Styles Additional Resources Grid Editing Single Select ComboBox Cascading Combos Linear Progress View page on GitHub"
  },
  "components/grid/cell-editing.html": {
    "href": "components/grid/cell-editing.html",
    "title": "Cell Editing in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Cell Editing Ignite UI for Angular Grid component provides a great data manipulation capabilities and powerful API for Angular CRUD operations. By default the Grid is using in cell editing and different editors will be shown based on the column data type, thanks to the default cell editing template. In addition, you can define your own custom templates for update-data actions and to override the default behavior for committing and discarding any changes. Angular Grid cell editing and edit templates Example Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. Cell Editing Editing through UI You can enter edit mode for specific cell, when an editable cell is focused in one of the following ways: on double click; on single click - Single click will enter edit mode only if the previously selected cell was in edit mode and currently selected cell is editable. If the previously selected cell was not in edit mode, single click will select the cell without entering edit mode; on key press Enter; on key press F2; You can exit edit mode without committing the changes in one of the following ways: on key press Escape; when you perform sorting, filtering, searching and hiding operations; You can exit edit mode and commit the changes in one of the following ways: on key press Enter; on key press F2; on key press Tab; on single click to another cell - when you click on another cell in the Grid, your changes will be submitted. operations like paging, resize, pin or move will exit edit mode and changes will be submitted. Note The cell remains in edit mode when you scroll vertically or horizontally or click outside the Grid. This is valid for both cell editing and row editing. Editing through API You can also modify the cell value through the IgxGrid API but only if primary key is defined: public updateCell() { this.grid1.updateCell(newValue, rowID, 'ReorderLevel'); } Another way to update cell is directly through update method of IgxGridCell: public updateCell() { const cell = this.grid1.getCellByColumn(rowIndex, 'ReorderLevel'); // You can also get cell by rowID if primary key is defined // cell = this.grid1.getCellByKey(rowID, 'ReorderLevel'); cell.update(70); } Cell Editing Templates You can see and learn more for default cell editing templates in the general editing topic. If you want to provide a custom template which will be applied when a cell is in edit mode, you can make use of the igxCellEditor directive. To do this, you need to pass an ng-template marked with the igxCellEditor directive and properly bind your custom control to the cell.editValue: <igx-column field=\"class\" header=\"Class\" [editable]=\"true\"> <ng-template igxCellEditor let-cell=\"cell\" let-value> <igx-select class=\"cell-select\" [(ngModel)]=\"cell.editValue\" [igxFocus]=\"true\"> <igx-select-item *ngFor=\"let class of classes\" [value]=\"class\"> {{ class }} </igx-select-item> </igx-select> </ng-template> </igx-column> This code is used in the sample below which implements an IgxSelectComponent in the cells of the Race, Class and Alignment columns. Note Any changes made to the cell's editValue in edit mode, will trigger the appropriate editing event on exit and apply to the transaction state (if transactions are enabled). Note The cell template igxCell controls how a column's cells are shown when outside of edit mode. The cell editing template directive igxCellEditor, handles how a column's cells in edit mode are displayed and controls the edited cell's edit value. Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. For more information on how to configure columns and their templates, you can see the documentation for Grid Columns configuration. Grid Excel Style Editing Using Excel Style Editing allows the user to navigate trough the cells just as he would using the Excel, and ever so quickly edit them. Implementing this custom functionality can be done by utilizing the events of the grid. First we hook up to the grid's keydown events, and from there we can implement two functionalities: Constant edit mode public keydownHandler(event) { const key = event.keyCode; const grid = this.grid; const activeElem = grid.navigation.activeNode; if( (key >= 48 && key <= 57) || (key >= 65 && key <= 90) || (key >= 97 && key <= 122)){ // Number or Alphabet upper case or Alphabet lower case const columnName = grid.getColumnByVisibleIndex(activeElem.column).field; const cell = grid.getCellByColumn(activeElem.row, columnName); if (cell && !cell.editMode) { cell.editMode = true; cell.editValue = event.key; this.shouldAppendValue = true; } else if (cell && cell.editMode && this.shouldAppendValue) { event.preventDefault(); cell.editValue = cell.editValue + event.key; this.shouldAppendValue = false; } } } Enter/ Shift+Enter navigation if (key == 13) { let thisRow = activeElem.row; const column = activeElem.column; const rowInfo = grid.dataView; // to find the next eiligible cell, we will use a custom method that will check the next suitable index let nextRow = this.getNextEditableRowIndex(thisRow, rowInfo, event.shiftKey); // and then we will navigate to it using the grid's built in method navigateTo this.grid.navigateTo(nextRow, column, (obj) => { obj.target.activate(); this.grid.clearCellSelection(); this.cdr.detectChanges(); }); } Key parts of finding the next eligible index would be: //first we check if the currently selected cell is the first or the last if (currentRowIndex < 0 || (currentRowIndex === 0 && previous) || (currentRowIndex >= dataView.length - 1 && !previous)) { return currentRowIndex; } // in case using shift + enter combination, we look for the first suitable cell going up the field if(previous){ return dataView.findLastIndex((rec, index) => index < currentRowIndex && this.isEditableDataRecordAtIndex(index, dataView)); } // or for the next one down the field return dataView.findIndex((rec, index) => index > currentRowIndex && this.isEditableDataRecordAtIndex(index, dataView)); Please check the full sample for further reference: Angular Grid Excel Style Editing Sample Main benefits of the above approach include: Constant edit mode: typing while a cell is selected will immediately enter edit mode with the value typed, replacing the existing one Any non-data rows are skipped when navigating with Enter/Shift+Enter. This allows users to quickly cycle through their values. CRUD operations Note Please keep in mind that when you perform some CRUD operation all of the applied pipes like filtering, sorting and grouping will be re-applied and your view will be automatically updated. The IgxGridComponent provides a straightforward API for basic CRUD operations. Adding a new record The Grid component exposes the addRow method which will add the provided data to the data source itself. // Adding a new record // Assuming we have a `getNewRecord` method returning the new row data. const record = this.getNewRecord(); this.grid.addRow(record); Updating data in the Grid Updating data in the Grid is achieved through updateRow and updateCell methods but only if primary key for the grid is defined. You can also directly update a cell and/or a row value through their respective update methods. // Updating the whole row this.grid.updateRow(newData, this.selectedCell.cellID.rowID); // Just a particular cell through the Grid API this.grid.updateCell(newData, this.selectedCell.cellID.rowID, this.selectedCell.column.field); // Directly using the cell `update` method this.selectedCell.update(newData); // Directly using the row `update` method const row = this.grid.getRowByKey(rowID); row.update(newData); Deleting data from the Grid Please keep in mind that deleteRow() method will remove the specified row only if primary key is defined. // Delete row through Grid API this.grid.deleteRow(this.selectedCell.cellID.rowID); // Delete row through row object const row = this.grid.getRowByIndex(rowIndex); row.delete(); These can be wired to user interactions, not necessarily related to the igx-grid; for example, a button click: <button igxButton igxRipple (click)=\"deleteRow($event)\">Delete Row</button> Cell validation on edit event Using the grid's editing events we can alter how the user interacts with the grid. In this example, we'll validate a cell based on the data entered in it by binding to the cellEdit event. If the new value of the cell does not meet our predefined criteria, we'll prevent it from reaching the data source by cancelling the event (event.cancel = true). We'll also display a custom error message using IgxToast. The first thing we need to is bind to the grid's event: <igx-grid (cellEdit)=\"handleCellEdit($event)\" ...> ... </igx-grid> The cellEdit emits whenever any cell's value is about to be committed. In our handleCellEdit definition, we need to make sure that we check for our specific column before taking any action: export class MyGridEventsComponent { public handleCellEdit(event: IGridEditEventArgs): void { const column = event.column; if (column.field === 'Ordered') { const rowData = event.rowData; if (!rowData) { return; } if (event.newValue > rowData.UnitsInStock) { event.cancel = true; this.toast.open(); } } } } If the value entered in a cell under the Ordered column is larger than the available amount (the value under Units in Stock), the editing will be cancelled and a toast with an error message will be displayed. The result of the above validation being applied to our igx-grid can be seen in the below demo: Styling The IgxGrid allows for its cells to be styled through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide range of properties, which allow users to style many different aspects of the grid. In the below steps, we are going to go over how you can style the grid's cell in edit mode and how you can scope those styles. In order to use the Ignite UI Theming Library, we must first import the theme index file in our global styles: Importing style library @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Now we can make use of all of the functions exposed by the Ignite UI for Angular theme engine. Defining a palette After we've properly imported the index file, we create a custom palette that we can use. Let's define two colors that we like and use them to build a palette with igx-palette: $white: #fff; $blue: #4567bb; $color-palette: palette($primary: $white, $secondary: $blue); Defining themes We can now define the theme using our palette. The cells are styled by the grid-theme, so we can use that to generate a theme for our IgxGrid: $custom-grid-theme: grid-theme( $cell-editing-background: $blue, $cell-edited-value-color: $white, $cell-active-border-color: $white, $edit-mode-color: color($color-palette, \"secondary\", 200) ); Applying the theme The easiest way to apply our theme is with a sass @include statement in the global styles file: @include grid($custom-grid-theme); This way, the theme will apply to all grids in our application. If we wish to apply this custom styling only to a specific component, we need to scope the theme. Scoped component theme In order for the custom theme to affect only our specific component, we can move all of the styles we just defined from the global styles file to our custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, our styles will be applied only to our custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-grid-theme); } } } Styling Demo In addition to the steps above, we can also style the controls that are used for the cells' editing templates: igx-input-group, igx-datepicker & igx-checkbox Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridCell IgxGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Build CRUD operations with igxGrid Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/grid/cell-selection.html": {
    "href": "components/grid/cell-selection.html",
    "title": "Angular Grid Cell Selection - Ignite UI for Angular",
    "keywords": "Angular Cell Selection The selection feature enables rich data select capabilities in the Material UI based Grid. Variety of events and single select actions are available thanks to the powerful API and easy to use methods. The Grid now supports three modes for cell selection, and you can easily switch between them by changing cellSelection property. You can disable cell selection, you can select only one cell within the grid or to select multiple cells in the grid, which is provided as default option. But let's dive deeper in each of these options. Angular Cell Selection Example The sample below demonstrates the three types of Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Selection types Grid Multiple-cell Selection How to select cells: By Mouse drag - Rectangular data selection of cells would be performed. By Ctrl key press + Mouse drag - Multiple range selections would be performed. Any other existing cell selection will be persisted. Instant multi-cell selection by using Shift key. Select single cell and select another single cell by holding the Shift key. Cell range between the two cells will be selected. Keep in mind that if another second cell is selected while holding Shift key the cell selection range will be updated based on the first selected cell position (starting point). Keyboard multi-cell selection by using the Arrow keys while holding Shift key. Multi-cell selection range will be created based on the focused cell. Keyboard multi-cell selection by using the Ctrl + Arrow keys and Ctrl + Home/End while holding Shift key. Multi-cell selection range will be created based on the focused cell. Clicking with the Left Mouse key while holding Ctrl key will add single cell ranges into the selected cells collection. Continuous multiple cell selection is available, by clicking with the mouse and dragging. Demo Grid Single Selection When you set the [cellSelection]=\"'single'\", this allows you to have only one selected cell in the grid at a time. Also the mode mouse drag will not work and instead of selecting a cell, this will make default text selection. Note When single cell is selected selected event is emitted, no matter if the selection mode is single or multiple. In multi-cell selection mode when you select a range of cells rangeSelected event is emitted. Grid None selection If you want to disable cell selection you can just set [cellSelection]=\"'none'\" property. In this mode when you click over the cell or try to navigate with keyboard, the cell is not selected, only the activation style is applied and it is going to be lost when you scroll or click over other element on the page. The only way for you to define selection is by using the API methods that are described below. Keyboard navigation interactions While Shift key is pressed Shift + Arrow Up to add above cell to the current selection. Shift + Arrow Down to add below cell to the current selection. Shift + Arrow Left to add left cell to the current selection. Shift + Arrow Right to add right cell to the current selection. While Ctrl + Shift keys are pressed Ctrl + Shift + Arrow Up to select all cells above the focused cell in the column. Ctrl + Shift + Arrow Down to select all cells below the focused cell in the column. Ctrl + Shift + Arrow Left to select all cells till the start of the row. Ctrl + Shift + Arrow Right to select all cells till the end of the row. Ctrl + Shift + Home to select all cells from the focused cell till the first-most cell in the grid Ctrl + Shift + End to select all cells from the focused cell till the last-most cell in the grid Note Continuous scroll is possible only within Grid's body. Api usage Below are the methods that you can use in order to select ranges, clear selection or get selected cells data. Select range selectRange(range) - Select a range of cells with the API. rowStart and rowEnd should use row indexes and columnStart and columnEnd could use column index or column data field value. const range = { rowStart: 2, rowEnd: 2, columnStart: 1, columnEnd: 1 }; this.grid1.selectRange(range); ... const range = { rowStart: 0, rowEnd: 2, columnStart: 'Name', columnEnd: 'ParentID' }; this.grid1.selectRange(range); Note Select range is additive operation. It will not clear your previous selection. Clear cell selection clearCellSelection() will clear the current cell selection. Get selected data getSelectedData() will return array of the selected data in format depending on the selection. Examples below: If three different single cells are selected: expectedData = [ { CompanyName: 'Infragistics' }, { Name: 'Michael Langdon' }, { ParentID: 147 } ]; If three cells from one column are selected: expectedData = [ { Address: 'Obere Str. 57'}, { Address: 'Avda. de la Constitución 2222'}, { Address: 'Mataderos 2312'} ]; If three cells are selected with mouse drag from one row and three columns: expectedData = [ { Address: 'Avda. de la Constitución 2222', City: 'México D.F.', ContactTitle: 'Owner' } ]; If three cells are selected with mouse drag from two rows and three columns: expectedData = [ { ContactTitle: 'Sales Agent', Address: 'Cerrito 333', City: 'Buenos Aires'}, { ContactTitle: 'Marketing Manager', Address: 'Sierras de Granada 9993', City: 'México D.F.'} ]; If two different ranges are selected: expectedData = [ { ContactName: 'Martín Sommer', ContactTitle: 'Owner'}, { ContactName: 'Laurence Lebihan', ContactTitle: 'Owner'}, { Address: '23 Tsawassen Blvd.', City: 'Tsawassen'}, { Address: 'Fauntleroy Circus', City: 'London'} ]; If two overlapping ranges are selected, the format would be: expectedData = [ { ContactName: 'Diego Roel', ContactTitle: 'Accounting Manager', Address: 'C/ Moralzarzal, 86'}, { ContactName: 'Martine Rancé', ContactTitle: 'Assistant Sales Agent', Address: '184, chaussée de Tournai', City: 'Lille'}, { ContactName: 'Maria Larsson', ContactTitle: 'Owner', Address: 'Åkergatan 24', City: 'Bräcke'}, { ContactTitle: 'Marketing Manager', Address: 'Berliner Platz 43', City: 'München'} ]; Note selectedCells() will return cells from all visible rows (rows in the grid's view port) and from all columns, including columns that are out of view. getSelectedData() will also return the selected cell data. getSelectedRanges(): GridSelectionRange[] will return the current selected ranges in the grid from both keyboard and pointer interactions. The type is GridSelectionRange[]. Features integration The multi-cell selection is index based (DOM elements selection). Sorting - When sorting is performed selection will not be cleared. It will leave currently selected cells the same while sorting ascending or descending. Paging - On paging selected cells will be cleared. Selection wont be persisted across pages. Filtering - When filtering is performed selection will not be cleared. If filtering is cleared it will return - the initially selected cells. Resizing - On column resizing selected cells will not be cleared. Hiding - It will not clear the selected cells. If column is hidden, the cells from the next visible column will be selected. Pinning - Selected cell will not be cleared. Same as hiding Group by - On column grouping selected cells will not be cleared. Styling Guidelines The theme engine exposes properties that allows us to style the range of selected cells. Import theme To get started with styling the selection, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Define colors Once done, we can make use of the igx-contrast-color and igx-color functions. With them, we define the colors we would like to use for our selection range: $text-color:contrast-color($default-palette, 'primary', 900); $background-color: color($default-palette, \"primary\", 900); $border-yellow: #f2c43c; Create custom theme Next we create a new theme that extends the grid-theme passing our text-color, background-color and border-yellow variables as $cell-selected-text-color, $cell-selected-background and $cell-active-border-color, respectively: $custom-grid-theme: grid-theme( $cell-selected-text-color: $text-color, $cell-active-border-color: $border-yellow, $cell-selected-background: $background-color ); Apply theme Afterwards, all we need to do is include the mixin in our component's style (could also be in the app styles), so that our igx-grid uses the newly created theme instead of the default one: @include grid($custom-grid-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. We scope the style under :host selector so as not to affect any other grids we might have in our application. :host { ::ng-deep { @include grid($custom-grid-theme); } } With the custom theme applied, the selected grid cells are highlighted with our selected colors: Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridComponent API IgxGridRow API IgxGridCell API IgxGridComponent Styles Additional Resources Grid overview Selection Row selection Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/clipboard-interactions.html": {
    "href": "components/grid/clipboard-interactions.html",
    "title": "Angular Grid Clipboard Interactions - Ignite UI for Angular",
    "keywords": "Angular Grid Clipboard Interactions Copy to clipboard operations are now available in the Grid. This functionality provides a fast, easy and customizable way to copy data of the Angular Data Grid through the current multi cell data select. System Clipboard behavior gives the user ability to copy data from the Grid into Excel or other external programs. Angular Grid Clipboard Interactions Example Functionality Copy behavior is working with the default interaction defined by the browser and operating system. Thus for the copy and paste behaviors, these are: Windows/Unix based Ctrl + C / Ctrl + Ins as a keyboard shortcut Ctrl + V / Shift + Ins as a keyboard shortcut Copy action through the browser menu macOS ⌘ Cmd + C as a keyboard shortcut ⌘ Cmd + V as a keyboard shortcut Copy action through the browser menu Limitations Both the cut and copy events are not natively supported in Internet Explorer. The exception is the paste event (IE 11) which is emitted but does not expose the clipboardData property in the event. Note In order to copy cells in IE 11, you can use the keyboard selection. Hold the shift key in order to make a multi-cell selection, press Ctrl + C in order to copy. The copy behavior is disabled while the grid is in edit mode. The current version of this feature covers only the copy from grid behavior. Later on we plan to expose paste within grid behavior. You can use a custom paste handler in order to configure paste behavior, have a look at our Paste from Excel topic. API Usage We expose clipboardOptions @Input property, which handles the following options: enabled Enables/disables copying of selected cells. copyHeaders Include the associated headers when copying. copyFormatters Apply any existing column formatters to the copied data. separator The string separator to use the for formatting the data in the clipboard. Default is /t Note Excel can automatically detect text that is separated by tabs (tab-delimited /t) and properly paste the data into separate columns. When the paste format doesn't work, and everything you paste appears in a single column, then Excel's delimiter is set to another character, or your text is using spaces instead of tabs. gridCopy Emitted when a copy operation is executed. Fired only if copy behavior is enabled through the clipboardOptions Additional Resources Grid overview Paging Filtering Sorting Summaries Column Pinning Selection Virtualization and Performance Multi-column headers Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/collapsible-column-groups.html": {
    "href": "components/grid/collapsible-column-groups.html",
    "title": "Collapsible Column Groups in Angular Data Grid - Infragistics",
    "keywords": "Collapsible Column Groups in Angular Data Grid Multi-column headers allow you to have multiple levels of nested columns and column groups. They also provide the ability to mark each column group as collapsible. Collapsible multi-column headers make it possible to collapse/expand, i.e. to show and hide the nested headers under the current one, which will give you a shortened/summarized information for example. Angular Grid Collapsible Column Groups Overview Example Setup To get started with the IgxGrid and the Collapsible multi-column headers , first you need to install Ignite UI for Angular by typing the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxGridModule in the app.module.ts file. Also, we strongly suggest that you take a brief look at multi-column groups topic, to see more detailed information on how to setup the column groups in your grid. Usage Collapsible Column Groups is a part of the multi-column headers feature which provides a way to collapse/expand a column group to a smaller set of data. When a column group is collapsed, a subset of the columns will be shown to the end-user and the other child columns of the group will hide. Each collapsed/expanded column can be bound to the grid data source, or it may be unbound, thus calculated. In order to define a column group as collapsible, you need to set the property to [collapsible]=\"true\" and also keep in mind that you need to define the property visibleWhenCollapsed to at least two child columns: at least one column must be visible when the group is collapsed ([visibleWhenCollapsed]=\"true\") and at least one column must be hidden when the group is expanded ([visibleWhenCollapsed]=\"false\"), otherwise the collapsible functionality will be disabled. If visibleWhenCollapsed is not specified for some of the child columns, then this column will be always visible no matter whether the parent state is expanded or collapsed. So let's see the markup below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <!-- Initially the column groups will be expanded---> <!--The column below will be visible when its parent is collapsed--> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <!--The three columns below will be visible when its parent is expanded--> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column field=\"FirstName\" header=\"First Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column field=\"LastName\" header=\"Last Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column-group header=\"Customer Address\"> <!--This column visibility will not be changed based on parent expand/collapsed state--> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> </igx-column-group> </igx-column-group> And now let's sum up: every child column has three states: Can be always visible, no matter the expanded state of its parent; Can be visible, when its parent is collapsed; Can be hidden, when its parent is collapsed; The initial state of the column group which is specified as collapsible is [expanded]=\"true\". But you can easily change this behavour by setting the property [expanded]=\"false\". Expand/Collapse indicator template Default expand indicator for the igxGrid is the following: Default collapse indicator for the igxGrid is the following: Also, if you need to change the default expand/collapse indicator, we provide two easy ways to do so - via an input property or through a directive. Using an input property You can define custom expand/collapse template and provide it to each of the collapsible column groups using collapsibleIndicatorTemplate input property. Check the markup below: <ng-template #indTemplate let-column=\"column\"> <igx-icon [attr.draggable]=\"false\" >{{column.expanded ? 'remove' : 'add'}} </igx-icon> </ng-template> <igx-column-group header=\"Customer Information\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Using igxCollapsibleIndicator directive Another way to achieve this behavior is to use the igxCollapsibleIndicator directive as shown in the example below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <ng-template igxCollapsibleIndicator let-column=\"column\"> <igx-icon [attr.draggable]=\"false\">{{column.expanded ? 'remove' : 'add'}} </<igx-icon> </ng-template> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Note Please keep in mind that initially collapse group option takes precedence over column hidden - If you declared your column to be hidden using the property hidden and you have a group defined where the same column should be shown, the column will be shown. API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-hiding.html": {
    "href": "components/grid/column-hiding.html",
    "title": "Column Hiding in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Column Hiding The Ignite UI for Angular Grid provides an IgxColumnActionsComponent with an IgxColumnHidingDirective which allows users to perform column hiding directly through the user interface or by using the Angular component. The Material UI Grid has a built-in column hiding UI, which can be used through the Grid's toolbar to change the visible state of the columns. In addition, developers can always define the column hiding UI as a separate component and place it anywhere they want on the page. Angular Grid Column Hiding Example Grid Setup Let's start by creating our Grid and binding it to our data. We will also enable both filtering and sorting for the columns. <!--columnHiding.component.html--> <igx-grid #grid id=\"grid\" [data]=\"data\" [autoGenerate]=\"false\" width=\"100%\" height=\"560px\" columnWidth=\"200px\" [allowFiltering]=\"true\"> <igx-column [field]=\"'ID'\" dataType=\"string\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column [field]=\"'ContactName'\" dataType=\"string\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column [field]=\"'ContactTitle'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'City'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'CompanyName'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Fax'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Address'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'PostalCode'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Country'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Phone'\" dataType=\"string\" [sortable]=\"true\"></igx-column> </igx-grid> Toolbar's Column Hiding UI The built-in Column Hiding UI is placed inside an IgxDropDownComponent in the Grid's toolbar. We can show/hide the Column Hiding UI by using this exact dropdown. For this purpose all we have to do is set both the IgxGridToolbarActionsComponent and the IgxGridToolbarHidingComponent inside of the Grid. We will also add a title to our toolbar by using the IgxGridToolbarTitleComponent and a custom style for our Grid's wrapper. <!--columnHiding.component.html--> <div class=\"grid__wrapper\"> <igx-grid ...> <igx-grid-toolbar> <igx-grid-toolbar-title>Employees</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> ... </igx-grid> </div> /* columnHiding.component.css */ .grid__wrapper { margin: 10px; } The Grid provides us with some useful properties when it comes to using the toolbar's column hiding UI. By using the igx-grid-toolbar-hiding title property, we will set the title that is displayed inside the dropdown button in the toolbar. <!--columnHiding.component.html--> <div class=\"grid__wrapper\"> <igx-grid> <igx-grid-toolbar> <igx-grid-toolbar-title>Employees</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding #hidingActionRef title=\"Column Hiding\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-grid> </div> By using the columnsAreaMaxHeight property of the IgxGridToolbarHidingComponent, we can set the maximum height of the area that contains the column actions. This way if we have a lot of actions and not all of them can fit in the container, a scrollbar will appear, which will allow us to scroll to any action we want. // columnHiding.component.ts public ngAfterViewInit() { this.hidingActionRef.columnsAreaMaxHeight = \"200px\"; } In order to use the expanded set of functionalities for the column hiding UI, we can use the IgxColumnActionsComponent's columnsAreaMaxHeight property. This way we can use it according to our application's requirements. You can see the result of the code from above at the beginning of this article in the Angular Column Hiding Example section. Custom Column Hiding UI Let's say we want to manually define our IgxColumnActionsComponent, add the IgxColumnHidingDirective so that it knows what its purpose would be and put it anywhere on the page. First, however, we need to import the IgxColumnActionsModule. // app.module.ts ... import { ... IgxColumnActionsModule } from 'igniteui-angular'; // import { ..., IgxColumnActionsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxColumnActionsModule], }) export class AppModule {} Now let's create our IgxColumnActionsComponent. In our application, we will place it next to the grid (which is not the case with the toolbar's column hiding UI, where the component is inside a dropdown by design). We will also set the columns property of the component to the columns of our Grid and include some custom styles to make our application look even better! <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> <igx-column-actions igxColumnHiding #columnHidingUI [columns]=\"grid.columns\"> </igx-column-actions> </div> <div class=\"gridContainer\"> <igx-grid #grid [data]=\"data\" [autoGenerate]=\"false\" width=\"100%\" height=\"500px\" columnWidth=\"200px\"> ... </igx-grid> </div> /* columnHiding.component.css */ .grid__wrapper { margin: 15px; display: flex; flex-direction: row; } .columnHidingContainer { min-width: 250px; height: 560px; display: flex; flex-direction: column; padding-left: 20px; padding-right: 20px; border: 1px gray; border-radius: 10px; box-shadow: 1px 1px 2px 2px rgba(50, 50, 50, 0.25); igx-column-actions { height: 460px; } } .columnsOrderOptionsContainer { margin-top: 20px; margin-bottom: 20px; } .gridContainer { width: 100%; min-width: 200px; display: flex; flex-direction: column; margin-left: 30px; } Add title and filter prompt A couple more things we can do in order to enrich the user experience of our column hiding component is to set the title and the filterColumnsPrompt properties. The title is displayed on the top and the filterColumnsPrompt is the prompt text that is displayed in the filter input of our column hiding UI. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> <igx-column-actions igxColumnHiding #columnHidingUI [columns]=\"grid.columns\" title=\"Column Hiding\" filterColumnsPrompt=\"Type here to search\"> </igx-column-actions> </div> Add column display order options We can also allow the user to choose the display order of the columns in the column hiding UI. For this purpose we will use the columnDisplayOrder property, which is an enumeration type property and has the following options: Alphabetical (order the columns alphabetically) DisplayOrder (order the columns according to the way they are displayed in the Grid) Let's create a couple of nicely designed radio buttons for our options! We just have to go ahead and get the IgxRadio module. // app.module.ts ... import { ... IgxRadioModule } from 'igniteui-angular'; // import { ..., IgxRadioModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxRadioModule], }) export class AppModule {} Now all we have to do is bind the checked property of both radio buttons respectively with different conditions and handle their click events. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> ... <div class=\"columnsOrderOptionsContainer\"> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'Alphabetical'\" (click)=\"columnHidingUI.columnDisplayOrder = 'Alphabetical'\"> Alphabetical order </igx-radio> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'DisplayOrder'\" (click)=\"columnHidingUI.columnDisplayOrder = 'DisplayOrder'\"> Display order </igx-radio> </div> </div> Disable hiding of a column We can easily prevent the user from being able to hide columns through the column hiding UI by simply setting their disableHiding property to true. <!--columnHiding.component.html--> <div class=\"gridContainer\"> <igx-grid ... > ... <igx-column [field]=\"'ContactName'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column [field]=\"'ContactTitle'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> ... </igx-grid> </div> If all went well, this is how our column hiding UI component should look like: Styling To get started with styling the column actions component, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; By using the simplest approach, we create a new theme that extends the column-actions-theme and accepts the $title-color and the $background-color parameters. $custom-column-actions-theme: column-actions-theme( $background-color: steelblue, $title-color: gold ); As seen, the column-actions-theme only controls colors for the column actions container, but does not affect the buttons, checkboxes and the input-group inside of it. Let's say we want to style the buttons as well, so we will create a new button theme: $custom-button: button-theme($flat-text-color: gold, $disabled-color: black); In this example we only changed the text-color of the flat buttons and the button disabled color, but the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } Note We scope the igx-button mixin within .igx-column-actions, so that only the column hiding buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: gold; $blue-color: steelblue; $custom-palette: palette($primary: $blue-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $title-color: color($custom-palette, \"secondary\", 400), $background-color: color($custom-palette, \"primary\", 200) ); $custom-button: button-theme( $palette: $custom-palette, $flat-text-color: color($custom-palette, \"secondary\", 400), $disabled-color: black ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. // Extending the dark column actions schema $custom-column-actions-schema: extend($_dark-column-actions, ( title-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ) ) ); // Extending the dark button schema $custom-button-schema: extend($_dark-button, ( flat-text-color:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-column-actions: $custom-column-actions-schema, igx-button: $custom-button-schema )); // Defining column-actions-theme with the global dark schema $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $custom-button: button-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References In this article we learned how to use the built-in column hiding UI in the Grid's toolbar and we defined it as a separate component as well. We introduced a UI that allows the user to choose between different column orders and we set our own custom title and filter prompt texts. We also used an additional Ignite UI for Angular component - the IgxRadio button. The column hiding UI has a few more APIs to explore, which are listed below. IgxColumnActionsComponent IgxColumnActionsComponent Styles Additional components and/or directives with relative APIs that were used: IgxGridComponent properties: hiddenColumnsCount IgxColumnComponent properties: disableHiding IgxGridToolbarComponent properties: showProgress IgxGridToolbarComponent components: IgxGridToolbarTitleComponent IgxGridToolbarActionsComponent IgxGridToolbarComponent methods: IgxGridComponent events: columnVisibilityChanged IgxRadioComponent Styles: IgxGridComponent Styles IgxRadioComponent Styles Additional Resources Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-moving.html": {
    "href": "components/grid/column-moving.html",
    "title": "Column Reordering & Moving in Angular Data Grid - Infragistics",
    "keywords": "Grid Column Reordering & Moving The Grid component in Ignite UI for Angular provides the Column Moving feature to allow columns reordering via standard drag/drop mouse or touch gestures, or by using the Column Moving API. Column moving works both with pinned and unpinned columns and with Multi-column Headers. Moving a column into the pinned area pins the column and vice versa, moving a column outside of the pinned area unpins the column. Note Reordering between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. Moving is allowed between columns/column-groups, if they are top level columns. Note If a column header is templated and the Column Moving is enabled or the corresponding column is groupable, then the templated elements need to have the draggable attribute set to false! This allows to attach handlers for any event emitted by the element, otherwise the event is consumed by the igxDrag directive. Note If the pinned area exceeds its maximum allowed width (80% of the total Grid width), a visual clue notifies the end user that the drop operation is forbidden and pinning is not possible. This means you won't be allowed to drop a column in the pinned area. <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> Angular Grid Column Moving Overview Example Overview Column moving feature is enabled on a per-grid level, meaning that the igx-grid could have either movable or immovable columns. This is done via the moving input of the igx-grid. <igx-grid [moving]=\"true\"></igx-grid> API In addition to the drag and drop functionality, the Column Moving feature also provides two API methods to allow moving a column/reordering columns programmatically: moveColumn - Moves a column before or after another column (a target). The first parameter is the column to be moved, and the second parameter is the target column. Also accepts an optional third parameter position (representing a DropPosition value), which determines whether to place the column before or after the target column. // Move the ID column after the Name column const idColumn = grid.getColumnByName(\"ID\"); const nameColumn = grid.getColumnByName(\"Name\"); grid.moveColumn(idColumn, nameColumn, DropPosition.AfterDropTarget); move - Moves a column to a specified visible index. If the passed index parameter is invalid (is negative, or exceeds the number of columns), or if the column is not allowed to move to this index (if inside another group), no operation is performed. // Move the ID column at 3rd position. const idColumn = grid.getColumnByName(\"ID\"); idColumn.move(3); Note that when using the API, only the columnMovingEnd event will be emitted, if the operation was successful. Also note that in comparison to the drag and drop functionality, using the API does not require setting the moving property to true. Events There are several events related to the column moving to provide a means for tapping into the columns' drag and drop operations. These are columnMovingStart, columnMoving and columnMovingEnd. You can subscribe to the columnMovingEnd event of the igx-grid to implement some custom logic when a column is dropped to a new position. For example, you can cancel dropping the Category after the Change On Year(%) column. <igx-grid #dataGrid [data]=\"data\" [autoGenerate]=\"false\" [moving]=\"true\" (columnMovingEnd)=\"onColumnMovingEnd($event)\"> <igx-column [field]=\"'Category'\"></igx-column> <igx-column [field]=\"'Change On Year(%)'\" [dataType]=\"'number'\" ></igx-column> </igx-grid> public onColumnMovingEnd(event) { if (event.source.field === \"Category\" && event.target.field === \"Change On Year(%)\") { event.cancel = true; } } Styling To get started with styling the Grid column moving headers, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $ghost-header-background, $ghost-header-text-color and the $ghost-header-icon-color parameters. // Define dark theme for the column moving $dark-grid-column-moving-theme: grid-theme( $ghost-header-text-color: #F4D45C, $ghost-header-background: #575757, $ghost-header-icon-color: #f4bb5c ); The last step is to include the component mixins with its respective theme: @include grid($dark-grid-column-moving-theme); Note Depending on the component View Encapsulation strategy, it may be necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include grid($dark-grid-column-moving-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #575757; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the pallete. $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $ghost-header-text-color: color($dark-palette, \"primary\", 400), $ghost-header-background: color($dark-palette, \"secondary\", 200), $ghost-header-icon-color: color($dark-palette, \"primary\", 500) ); Note The color and palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid. // Extending the dark grid schema $dark-grid-column-moving-schema: extend($_light-grid, ( ghost-header-text-color:( color: (\"primary\", 400) ), ghost-header-background:( color: (\"secondary\", 200) ), ghost-header-icon-color:( color:( \"primary\", 500) ) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global dark-schema $custom-light-schema: extend($light-schema,( igx-grid: $dark-grid-column-moving-schema, )); // Defining dark-grid-theme with the global dark schema $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References ColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-pinning.html": {
    "href": "components/grid/column-pinning.html",
    "title": "Angular Grid Column Pinning - Ignite UI for Angular",
    "keywords": "Angular Grid Column Pinning A column or multiple columns can be pinned to the left or right side of the Angular UI Grid. Column Pinning in Ignite UI for Angular allows the end users to lock column in a particular column order, this will allow them to see it while horizontally scrolling the Grid. The Material UI Grid has a built-in column pinning UI, which can be used through the Grid's toolbar to change the pin state of the columns. In addition, you can define a custom UI and change the pin state of the columns via the Column Pinning API. Angular Grid Column Pinning Example Column Pinning API Column pinning is controlled through the pinned input of the igx-column. Pinned columns are rendered on the left side of the Grid by default and stay fixed through horizontal scrolling of the unpinned columns in the Grid body. <igx-grid #grid1 [data]=\"data | async\" [width]=\"700px\" [autoGenerate]=\"false\" (columnInit)=\"initColumns($event)\" (selected)=\"selectCell($event)\"> <igx-column [field]=\"Name\" [pinned]=\"true\"></igx-column> <igx-column [field]=\"AthleteNumber\"></igx-column> <igx-column [field]=\"TrackProgress\"></igx-column> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-grid> You may also use the Grid's pinColumn or unpinColumn methods of the IgxGridComponent to pin or unpin columns by their field name: this.grid.pinColumn('AthleteNumber'); this.grid.unpinColumn('Name'); Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the column is already in the desired state. A column is pinned to the right of the rightmost pinned column. Changing the order of the pinned columns can be done by subscribing to the columnPin event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"true\" (columnPin)=\"columnPinning($event)\"></igx-grid> public columnPinning(event) { if (event.column.field === 'Name') { event.insertAtIndex = 0; } } Pinning Position You can change the column pinning position via the pinning configuration option. It allows you to set the columns position to either Start or End. When set to End the columns are rendered at the end of the grid, after the unpinned columns. Unpinned columns can be scrolled horizontally, while the pinned columns remain fixed on the right. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-grid> public pinningConfig: IPinningConfig = { columns: ColumnPinningPosition.End }; Demo Custom Column Pinning UI You can define your custom UI and change the pin state of the columns via the related API. Let's say that instead of a toolbar you would like to define pin icons in the column headers that the end user can click to change the particular column's pin state. This can be done by creating a header template for the column with a custom icon. <igx-grid #grid1 [data]=\"data\" [width]=\"'100%'\" [height]=\"'500px'\"> <igx-column #col *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.header\" [width]=\"c.width\" [pinned]='c.pinned' [hidden]='c.hidden' [headerClasses]=\"'customHeaderSyle'\"> <ng-template igxHeader> <div class=\"title-inner\"> <span style=\"float:left\">{{col.header}}</span> <igx-icon class=\"pin-icon\" fontSet=\"fas\" name=\"fa-thumbtack\" (click)=\"toggleColumn(col)\"></igx-icon> </div> </ng-template> </igx-column> </igx-grid> On click of the custom icon the pin state of the related column can be changed using the column's API methods. public toggleColumn(col: ColumnType) { col.pinned ? col.unpin() : col.pin(); } Demo Pinning Limitations Setting column widths in percentage (%) explicitly makes the Grid body and header content to be misaligned when there are pinned columns. For column pinning to function correctly the column widths should be in pixels (px) or auto-assigned by the Grid. Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Pinning styling. Importing global theme To begin the customization of the Pinning feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the Pinning feature as desired. $custom-theme: grid-theme( /* Pinning properties that affect styling */ $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: #FFCD0F, $cell-active-border-color: #FFCD0F /* add other features properties here... */ ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $primary-color: #292826; $secondary-color: #ffcd0f; $custom-palette: palette( $primary: $primary-color, $secondary: $secondary-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: color($custom-palette, \"secondary\", 500), $cell-active-border-color: color($custom-palette, \"secondary\", 500) ); The $custom-theme contains the same properties as the one in the previous section, but this time the colors are not hardcoded. Instead, the custom igx-palette was used and the colors were obtained through its primary and secondary colors, with a given color variant. Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( pinned-border-width: 5px, pinned-border-style: double, pinned-border-color: color:(\"secondary\", 500), cell-active-border-color: color:(\"secondary\", 500) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme to affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridComponent IgxColumnComponent Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-resizing.html": {
    "href": "components/grid/column-resizing.html",
    "title": "Angular Grid Column Resizing - Ignite UI for Angular",
    "keywords": "Angular Grid Column Resizing With deferred grid column resizing, the user will see a temporary resize indicator while the Angular drag resizing operation is in effect. The new grid column width is applied once the drag operation has ended. Angular Grid Column Resizing Example Column resizing is also enabled per-column level, meaning that the igx-grid can have a mix of resizable and non-resizable columns. This is done via the resizable input of the igx-column. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\"></igx-column> You can subscribe to the columnResized event of the igx-grid to implement some custom logic when a column is resized. Both, previous and new column widths, as well as the IgxColumnComponent object, are exposed through the event arguments. <igx-grid [data]=\"data\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\"> <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\"></igx-column> <igx-column [field]=\"'CompanyName'\" width=\"100px\" [resizable]=\"true\"></igx-column> </igx-grid> public onResize(event) { this.col = event.column; this.pWidth = event.prevWidth; this.nWidth = event.newWidth; } Resizing columns in pixels/percentages Depending on the user scenario, the column width may be defined in pixels, percentages or a mix of both. All these scenarios are supported by the Column Resizing feature. By default if a column does not have width set, it fits the available space with width set in pixels. This means that the following configuration is possible: <igx-grid [data]=\"data\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\"> <igx-column [field]=\"'ID'\" width=\"10%\" [resizable]=\"true\"></igx-column> <igx-column [field]=\"'CompanyName'\" width=\"100px\" [resizable]=\"true\"></igx-column> <igx-column [field]=\"'ContactTitle'\" [resizable]=\"true\"></igx-column> </igx-grid> Note There is a slight difference in the way resizing works for columns set in pixels and percentages. Pixels Resizing columns with width in pixels works by directly adding or subtracting the horizontal amount of the mouse movement from the size of the column. Percentages When resizing columns with width in percentages, the horizontal amount of the mouse movement in pixels translates roughly to its percentage amount relative to the grid width. The columns remain responsive and any future grid resizing will still reflect on the columns as well. Restrict column resizing You can also configure the minimum and maximum allowable column widths. This is done via the minWidth and maxWidth inputs of the igx-column. In this case the resize indicator drag operation is restricted to notify the user that the column cannot be resized outside the boundaries defined by minWidth and maxWidth. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> Mixing the minimum and maximum column width value types (pixels or percentages) is allowed. If the values set for minimum and maximum are set to percentages, the respective column size will be limited to those exact sizes similar to pixels. This means the following configurations are possible: <igx-column [field]=\"'ID'\" width=\"10%\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> or <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'5%'\" [maxWidth]=\"'15%'\"></igx-column> Auto-size columns on double click Each column can be auto sized by double clicking the right side of the header - the column will be sized to the longest currently visible cell value, including the header itself. This behavior is enabled by default, no additional configuration is needed. However, the column will not be auto-sized in case maxWidth is set on that column and the new width exceeds that maxWidth value. In this case the column will be sized according to preset maxWidth value. You can also auto-size a column dynamically using the exposed autosize() method on IgxColumnComponent. @ViewChild('grid') grid: IgxGridComponent; let column = this.grid.columnList.filter(c => c.field === 'ID')[0]; column.autosize(); Auto-size columns on initialization Each column can be set to auto-size on initialization by setting width to 'auto': <igx-column width='auto'>... When the column is first initialized in the view it resolves its width to the size of the longest visible cell or header. Note that cells that are outside of the visible rows are not included. This approach is more performance optimized than auto-sizing post initialization and is recommended especially in cases where you need to auto-size a large number of columns. Styling To get started with the styling of the Grid column resize line, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The simplest approach to achieve this is to create a new theme that extends the grid-theme and accepts many parameters as well as the $resize-line-color parameter. $custom-grid-theme: grid-theme( $resize-line-color: #0288D1 ); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. :host { ::ng-deep { @include grid($custom-grid-theme); } } Defining a color palette Instead of hard-coding the color values, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the specified primary and secondary color: $primary-color: #0288D1; $secondary-color: #BDBDBD; $custom-theme-palette: palette($primary: $primary-color, $secondary: $secondary-color); And then, with igx-color, we can easily retrieve the color from the palette. $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $resize-line-color: color($custom-theme-palette, 'secondary', 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please, refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend the predefined schema provided for every component, in this case - light-grid schema: // Extending the light grid schema $light-grid-schema: extend($_light-grid, ( resize-line-color: ( color: ('secondary', 500) ), header-background: ( color: (\"primary\", 100) ), header-text-color: ( color: (\"primary\", 600) ) ) ); In order to apply our custom schema, we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global light-schema $custom-light-grid-schema: extend($light-schema,( igx-grid: $light-grid-schema )); // Specifying the palette and schema of the custom grid theme $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $schema: $custom-light-grid-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-selection.html": {
    "href": "components/grid/column-selection.html",
    "title": "Angular Grid Column Selection - Ignite UI for Angular",
    "keywords": "Angular Grid Column Selection The Column selection feature provides an easy way to select an entire column with a single click. It emphasizes the importance of a particular column by focusing the header cell(s) and everything below. The feature comes with a rich API that allows for manipulation of the selection state, data extraction from the selected fractions and data analysis operations and visualizations. Angular Column Selection Example The sample below demonstrates the three types of Grid's column selection behavior. Use the column selection dropdown below to enable each of the available selection modes. *Contact Title, City and Address columns are with disabled column selection. Basic usage The column selection feature can be enabled through the columnSelection input, which takes GridSelectionMode values. Interactions The default selection mode is none. If set to single or multiple all of the presented columns will be selectable. With that being said, in order to select a column, we just need to click on one, which will mark it as selected. If the column is not selectable, no selection style will be applied on the header, while hovering. Note Multi-column Headers don't reflect on the selectable input. The IgxColumnGroupComponent is selectable, if at least one of its children has the selection behaviour enabled. In addition, the component is marked as selected if all of its selectable descendents are selected. *Under Country Information Column Group only column City and Postal code are selectable. Keyboard combinations Note The keyboard combinations are available only when the grid columnSelection input is set to multiple. There are two scenarios for keyboard navigation of the Column Selection feature: Multi-column selection - holding ctrl + click on every selectable header cell. Range column selection - holding shift + click selects all selectable columns in between. API manipulations The API provides some additional capabilities when it comes to the non-visible columns such that, every hidden column could be marked as selected by setting the corresponding setter. Note The above statement also applies to the IgxColumnGroupComponent, except that when the selected property is changed it changes the state of its descendants. More information regarding the API manipulations could be found in the API References section. Styling Before diving into the styling options, the core module and all component mixins need to be imported. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Note Please note that row selection and column selection can't be manipulated independently. They depend on the same variables. With that being said, let's move on and change the selection and hover styles. Following the simplest approach, let's define our custom theme. $custom-grid-theme: grid-theme( $row-selected-background: #011627, $row-selected-text-color: #ECAA53, $row-selected-hover-background: #011627, $header-selected-text-color: #ECAA53, $header-selected-background: #011627 ); grid-theme accepts several parameters but those are the five responsible for changing the appearance of all selected columns: $row-selected-background - sets the background of the selected fraction. $row-selected-text-color - sets the text color of the selected fraction $row-selected-hover-background - sets the color of the hovered cell or bunch of cells. $header-selected-text-color - sets the text color of the selected column header $header-selected-background - sets the background color of the selected column header. Using CSS Variables The last step is to include the custom igx-grid theme. @include css-vars($custom-grid-theme) Overriding the Base Theme In order to style components for Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. Note If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. In order to prevent the custom theme from leaking into other components, be sure that you have included the :host selector before ::ng-deep. :host { ::ng-deep { @include grid($custom-column-selection-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References The column selection UI has a few more APIs to explore, which are listed below. IgxGridComponent IgxColumnComponent IgxColumnGrpupComponent IgxGridComponent Styles IgxGridComponent properties: columnSelection selectedColumns selectColumns deselectColumns selectAllColumns deselectAllColumns IgxColumnComponent properties: selectable selected IgxColumnGrpupComponent properties: selectable selected IgxGridComponent events: onColumnsSelectionChange Additional Resources Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/column-types.html": {
    "href": "components/grid/column-types.html",
    "title": "Column Data Types in Angular - Ignite UI for Angular",
    "keywords": "Angular Grid Column Types Ignite UI for Angular Grid provides a default handling of number, string, date, boolean, currency and percent column data types, based on which the appearance of the default and editing templates will be present. Angular Column Types Example Default template If you want to enable a data type-specific template, you should set the column dataType input otherwise the column will be treated as a string column since that is the default value for column dataType. Let's see what are the default templates for each type. String This column dataType is not changing the appearance or format of the cell value. Number If the dataType is set to number, the cell value will be formatted based on application or grid's locale settings, as well as when pipeArgs property is specified. Then the number format will be changed based on them, for example it might change the: Number of digits after the decimal point Decimal separator with , or . public options = { digitsInfo: '1.4-4', }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatOptions\" [dataType]=\"'number'\"> </igx-column> DateTime, Date and Time The appearance of the date portions will be set (e.g. day, month, year) based on locale format or pipeArgs input. The pipe arguments can be used to specify a custom date format or timezone: format - The default value for formatting the date is 'mediumDate'. Other available options are 'short', 'long', 'shortDate', 'fullDate', 'longTime', 'fulLTime' and etc. This is a full list of all available pre-defined format options. timezone - The user's local system timezone is the default value. The timezone offset or standard GMT/UTC or continental US timezone abbreviation can also be passed. Different timezone examples which will display the corresponding time of the location anywhere in the world: public formatDateOptions = { /** The date/time components that a date column will display, using predefined options or a custom format string. */ /** e.g 'dd/mm/yyyy' or 'shortDate' **/ format: 'longDate', /** A timezone offset (such as '+0430'), or a standard UTC/GMT or continental US timezone abbreviation. */ timezone: 'GMT' }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatDateOptions\" [dataType]=\"'date'\"> </igx-column> Available timezones: Timezone Value Alpha Time Zone ‘UTC+1’ Australian Central Time ‘UTC+9:30/ +10:30’ Arabia Standard Time ‘UTC+3’ Central Standard Time ‘UTC-6’ China Standard Time ‘UTC+8’ Delta Time Zone ‘UTC+4’ Greenwich Mean Time ‘UTC+0’ Gulf Standard Time ‘UTC+4’ Hawaii Standard Time ‘UTC-10’ India Standard Time ‘UTC+4’ The Grid accepts date values of type Date object, Number (milliseconds), An ISO date-time string. This section shows how to configure a custom display format. As you can see in the sample, we specify a different format options in order to showcase the available formats for the specific column type. For example, below you can find the format options for the time portion of the date object: // Time format with equivalent example public timeFormats = [ { format: 'shortTime', eq: 'h:mm a' }, { format: 'mediumTime', eq: 'h:mm:ss a' }, { format: 'longTime', eq: 'h:mm:ss a z' }, { format: 'fullTime', eq: 'h:mm:ss a zzzz' }, ]; Cell editing When it comes to cell editing based on the column type a different editor will appear: dateTime - IgxDateTimeEditor directive will be used. This editor will give you a mask directions for the input elements part of the DateTime object. date - IgxDatePicker component will be used. time - IgxTimePicker component will be used. Filtering The same editors listed above will be used when it comes to Quick Filtering/Excel-style Filtering. These are the following filtering operands that each type exposes: dateTime and date - Equals, Does Not Equal, Before, After, Today, Yesterday, This Month, Last Month, Next Month, This Year, Last Year, Next Year, Empty, Not Empty, Null, Not Null; time - At, Not At, Before, After, At or Before, At or After, Empty, Not Empty, Null, Not Null; Summaries The available Summary operands will be Count, Earliest (date/time) and Latest (date/time). Sorting Time type column sorts based on the time portion of the object, ms will be disregarded. Date type column sorts based on the date portion, disregards the time portion. DateTime column sorts based on the full date Boolean The default template is using material icons for visualization of boolean values - 'clear' icon for false values and 'check' icon for true values. As for the editing template, it is using igx-checkbox component. <igx-column [dataType]=\"'boolean'\"> </igx-column> Currency Default template The default template will show a numeric value with currency symbol that would be either prefixed or suffixed. Both currency symbol location and number value formatting is based on the provided Application LOCALE_ID or Grid locale. By using LOCALE_ID import { LOCALE_ID } from '@angular/core'; ... @Component({ selector: 'app-component.sample', templateUrl: 'grid-component.sample.html', providers: [{provide: LOCALE_ID, useValue: 'fr-FR' }] }) By using Grid's locale <igx-grid [locale]=\"'fr-FR'\" [data]=\"data\"> </igx-grid> By using the pipeArgs input the end-user can customize the number format by decimal point, currencyCode and display. public options = { digitsInfo: '3.4-4', currencyCode: 'USD', display: 'symbol-narrow' }; public formatOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatOptions\" [dataType]=\"'currency'\"> </igx-column> Parameter Description digitsInfo Represents Decimal representation of currency value currencyCode ISO 4217 currency code display* Displays the value by narrow or wide symbol *display - for the default en-US locale, the code USD can be represented by the narrow symbol $ or the wide symbol US$. Upon editing of cell's value the currency symbol will be visible as suffix or prefix. More about that could be found in the official Cell editing topic. Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Percent Default template is showing the percent equivalent of the underlying numeric value. The displayed cell value is a multiplied result by display factor of '100' - for example, as the default factor is 100 and the \"value\" passed to the cell is 0.123, then the displayed cell value will be \"12.3%\". When it comes to cell editing, the value will be the same as the data source value - the display factor is '1'. Upon editing of the cell a preview of the percent value will be shown as a suffix element.For example, while editing '0.0547' the preview element will show '5.47%'. public options = { /** * Decimal representation options, specified by a string in the following format: * `{minIntegerDigits}`.`{minFractionDigits}`-`{maxFractionDigits}`. * `minIntegerDigits`: The minimum number of integer digits before the decimal point. Default is 1. * `minFractionDigits`: The minimum number of digits after the decimal point. Default is 0. * `maxFractionDigits`: The maximum number of digits after the decimal point. Default is 3. */ digitsInfo: '2.2-3' }; public formatPercentOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatPercentOptions\" [dataType]=\"'percent'\"> </igx-column> Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Image Default template is using the value coming from the data as an image source to a default image template. The default image template will extract the name of the image file and set it as alt attribute of the image to meet the accessibility requirement. The displayed cell size is adjusted to the sizes of the images rendered, so keep in mind that large images will still be rendered and the grid rows will become as large as the images in the image column. Filtering, sorting and grouping will be turned off by default for image type columns. If you want to enable them, you need to provide custom strategies which perform the data operations. <igx-column [dataType]=\"'image'\"> </igx-column> When auto-generating columns, the grid analyses the values in the first data record. If a value is of type string and matches the pattern of a url ending in an image extension (gif, jpg, jpeg, tiff, png, webp, bmp) then the column will automatically be marked as dataType === GridColumnDataType.Image and a default image template will be rendered. Default editing template See the editing templates part of Grid Editing topic Custom editing template and formatter Custom template and column formatter definition will always take precedence over the column data type set: Custom template <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"false\"> <igx-column [field]=\"'UnitsInStock'\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [editable]=\"true\"> <ng-template igxCellEditor let-value> {{ value | currency:'USD':'symbol':'1.0-0'}} </ng-template> </igx-column> </igx-grid> Column formatter // Through column formatter property public formatCurrency(value: number) { return `Dollar sign ${value.toFixed(0)}`; } public init(column: IgxColumnComponent) { switch (column.field) { case 'UnitsInStock': column.formatter = this.formatCurrency; break; default: return; } API References IgxGridCell Column pipeArgs Grid locale Column dataType Additional Resources For custom templates you can see cell editing topic Grid overview topic Editing topic Summaries topic View page on GitHub"
  },
  "components/grid/conditional-cell-styling.html": {
    "href": "components/grid/conditional-cell-styling.html",
    "title": "Conditional Cell Styling in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Conditional Styling If you need to provide any custom styling in the IgxGrid component, you can do it on either row or cell level. Grid Conditional Row Styling The IgxGrid component in Ignite UI for Angular provides two ways to conditional styling of rows based on custom rules. By setting rowClasses input on the IgxGrid component; By setting rowStyles input on the IgxGrid component; Further in this topic wi will cover both of them in more details. Using rowClasses You can conditionally style the IgxGrid rows by setting the rowClasses input and define custom rules. <!-- sample.component.html --> <igx-grid #grid [data]=\"data\" [height]=\"'600px'\" [width]=\"'100%'\" [rowClasses]=\"rowClasses\"> ... </igx-grid> The rowClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. // sample.component.ts public rowClasses = { activeRow: this.activeRowCondition }; public activeRowCondition = (row: RowType) => this.grid?.navigation.activeNode?.row === row.index; // sample.component.scss ::ng-deep { .activeRow { border: 2px solid #fc81b8; border-left: 3px solid #e41c77; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo Using rowStyles Columns now expose the rowStyles property which allows conditional styling of the data rows. Similar to rowClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling (without any conditions). The callback signature for both rowStyles and rowClasses is: (row: RowType) => boolean Let's define our styles: // component.ts public rowStyles = { background: (row: RowType) => (+row.data['Change'] < 0 && +row.data['Change On Year(%)'] < 0) ? '#FF000088' : '#00000000', border: (row: RowType) => (+row.data['Change'] < 0 && +row.data['Change On Year(%)'] < 0) ? '2px solid' : '1px solid', 'border-color': (row: RowType) => (+row.data['Change'] < 0 && +row.data['Change On Year(%)'] < 0) ? '#FF000099' : '#E9E9E9' }; <!-- sample.component.html --> <igx-grid #grid1 [data]=\"data | async\" [height]=\"'500px'\" width=\"100%\" [autoGenerate]=\"false\" [allowFiltering]=\"true\" [rowStyles]=\"rowStyles\"> ... </igx-grid> Demo Grid Conditional Cell Styling Overview The IgxGrid component in Ignite UI for Angular provides two ways to conditional styling of cells based on custom rules. By setting the IgxColumnComponent input cellClasses to an object literal containing key-value pairs. The key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. The result is a convenient material styling of the cell. // component.ts file public beatsPerMinuteClasses = { downFont: this.downFontCondition, upFont: this.upFontCondition }; ... private downFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 95; } // component.scss file .upFont { color: red; } .downFont { color: green; } Using cellClasses You can conditionally style the IgxGrid cells by setting the IgxColumnComponent cellClasses input and define custom rules. <!-- sample.component.html --> <igx-column field=\"BeatsPerMinute\" dataType=\"number\" [cellClasses]=\"beatsPerMinuteClasses\"></igx-column> The cellClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. // sample.component.ts private upFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] > 95; } private downFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 95; } public beatsPerMinuteClasses = { downFont: this.downFontCondition, upFont: this.upFontCondition }; // sample.component.scss ::ng-deep { .upFont { color: green; } .downFont { color: red; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo By using the IgxColumnComponent input cellStyles which accepts an object literal where the keys are style properties and the values are expressions for evaluation. public styles = { 'background': 'linear-gradient(180deg, #dd4c4c 0%, firebrick 100%)', 'text-shadow': '1px 1px 2px rgba(25,25,25,.25)', 'animation': '0.25s ease-in-out forwards alternate popin' }; The callback signature for both cellStyles and cellClasses is now changed to: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Using cellStyles Columns now expose the cellStyles property which allows conditional styling of the column cells. Similar to cellClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling with ease (without any conditions). In the sample above we've created: Two different styles that will be applied based on the column index. You will also change the text color based on even/odd rows. The callback signature for both cellStyles is: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Let's define our styles: // component.ts public oddColStyles = { background: 'linear-gradient(to right, #b993d6, #8ca6db)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'white' : 'gray', animation: '0.75s popin' }; public evenColStyles = { background: 'linear-gradient(to right, #8ca6db, #b993d6)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'gray' : 'white', animation: '0.75s popin' }; On ngOnInit we will add the cellStyles configuration for each column of the predefined columns collection, which is used to create the IgxGrid columns dynamically. // component.ts public ngOnInit() { this.data = athletesData; this.columns = [ { field: 'Id' }, { field: 'Position' }, { field: 'Name' }, { field: 'AthleteNumber' }, { field: 'CountryName' } ]; this.applyCSS(); } public applyCSS() { this.columns.forEach((column, index) => { column.cellStyles = (index % 2 === 0 ? this.evenColStyles : this.oddColStyles); }); } public updateCSS(css: string) { this.oddColStyles = {...this.oddColStyles, ...JSON.parse(css)}; this.evenColStyles = {...this.evenColStyles, ...JSON.parse(css)}; this.applyCSS(); } // component.html <igx-grid #grid1 [data]=\"data\" primaryKey=\"ID\" width=\"80%\" height=\"300px\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\" [cellStyles]=\"c.cellStyles\"> </igx-column> </igx-grid> Define a popin animation // component.scss @keyframes popin { 0% { opacity: 0.1; transform: scale(.75, .75); filter: blur(3px) invert(1); } 50% { opacity: .5; filter: blur(1px); } 100% { transform: scale(1, 1); opacity: 1; filter: none; } } Demo Known issues and limitations If there are cells bind to the same condition (from different columns) and one cell is updated, the other cells won't be updated based on the new value, if the condition is met. A pipe check should be performed in order to apply the changes to the rest of the cells. The example below shows how to do that with a spread operator ... on onCellEdit event. This will copy the original object with a new instance, and lead pure pipe to be fired. public backgroundClasses = { myBackground: (rowData: any, columnKey: string) => { return rowData.Col2 < 10; } }; ... editDone(evt) { this.backgroundClasses = {...this.backgroundClasses}; } <igx-grid #grid1 [data]=\"data\" height=\"500px\" width=\"100%\" (onCellEdit)=\"editDone($event)\"> <igx-column field=\"Col1\" dataType=\"number\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col2\" dataType=\"number\" [editable]=\"true\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col3\" header=\"Col3\" dataType=\"string\" [cellClasses]=\"backgroundClasses\"></igx-column> </igx-grid> API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Column Hiding Selection Searching Toolbar Multi-column Headers Size (Display Density) Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/display-density.html": {
    "href": "components/grid/display-density.html",
    "title": "Angular Grid Size - Ignite UI for Angular",
    "keywords": "Angular Grid Size IgxGrid design is based on Material Design Guidelines. We currently provide an option to choose between predefined set of size options that will bring a small, medium, or large view respectively. By selecting the right size for your Material UI table / Material UI grid you can significantly improve the user experience when interacting with large amounts of content. Angular Grid Size Example Usage As you can see in the demo above, the IgxGrid provides three size options: small, medium and large. The code snippet below shows how to set size: <igx-grid #grid [data]=\"data\" style=\"--ig-size: var(--ig-size-small)\"> </igx-grid> And now let's see in details how each option reflects on the Grid component. When you switch between different sizes the height of each Grid element and the corresponding paddings will be changed. Also if you want to apply custom column width, please consider the fact that it must be bigger than the sum of left and right padding. --ig-size-large - this is the default Grid size with the lowest intense and row height equal to 50px. Left and Right paddings are 24px; Minimal column width is 80px; --ig-size-medium - this is the middle size with 40px row height. Left and Right paddings are 16px; Minimal column width is 64px; --ig-size-small - this is the smallest size with 32px row height. Left and Right paddings are 12px; Minimal column width is 56px; Note Please keep in mind that currently you can not override any of the sizes. Let's now continue with our sample and see in action how each size is applied. Let's first add a button which will help us to switch between each size: <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\"></igx-buttongroup> </div> @ViewChild(IgxButtonGroupComponent) public buttonGroup: IgxButtonGroupComponent; public size = 'small'; public sizes; public ngOnInit() { this.sizes = [ { label: 'small', selected: this.size === 'small', togglable: true }, { label: 'medium', selected: this.sie === 'medium', togglable: true }, { label: 'large', selected: this.size === 'large', togglable: true } ]; } Now we can add the markup. <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\" (selected)=\"selectSize($event)\"></igx-buttongroup> </div> <igx-grid #grid [data]=\"data\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> <igx-column-group header=\"Customer Information\"> <igx-column field=\"CustomerName\" header=\"Customer Name\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column-group header=\"Customer Address\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"Address\" header=\"Address\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"PostalCode\" header=\"Postal Code\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> </igx-column-group> </igx-column-group> <igx-column field=\"Salesperson\" header=\"Sales Person\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"ShipperName\" header=\"Shipper Name\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"OrderDate\" header=\"Order Date\" [dataType]=\"'date'\" [sortable]=\"true\" [hasSummary]=\"true\"> <ng-template igxCell let-cell=\"cell\" let-val> {{val | date:'dd/MM/yyyy'}} </ng-template> </igx-column> <igx-column-group header=\"Product Details\"> <igx-column field=\"ProductID\" header=\"ID\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" [filterable]=\"false\"> </igx-column> <igx-column field=\"ProductName\" header=\"Name\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" [filterable]=\"false\"> </igx-column> <igx-column field=\"UnitPrice\" header=\"Unit Price\" [dataType]=\"'number'\" [sortable]=\"true\" [hasSummary]=\"true\" [filterable]=\"false\"> </igx-column> <igx-column field=\"Quantity\" header=\"Quantity\" [dataType]=\"'number'\" [sortable]=\"true\" [hasSummary]=\"true\" [filterable]=\"false\"> </igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" [dataType]=\"'boolean'\" [sortable]=\"true\" [hasSummary]=\"true\" > </igx-column> </igx-column-group> <igx-column-group header=\"Shipping Information\"> <igx-column field=\"ShipName\" header=\"Name\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" > </igx-column> <igx-column-group header=\"Shipping Address\"> <igx-column field=\"ShipCountry\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" > </igx-column> <igx-column field=\"ShipCity\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" > </igx-column> <igx-column field=\"ShipPostalCode\" header=\"Postal Code\" [dataType]=\"'string'\" [sortable]=\"true\" [hasSummary]=\"true\" > </igx-column> </igx-column-group> </igx-column-group> </igx-grid> Finally, let's provide the necessary logic in order to actually apply the size: @ViewChild('grid', { read: IgxGridComponent }) public grid: IgxGridComponent; public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } Another option that IgxGrid provides for you, in order to be able to change the height of the rows in the Grid, is the property rowHeight. So let's see in action how this property affects the Grid layout along with the --ig-size CSS variable. Please keep in mind the following: --ig-size CSS variable will have NO impact on row height if there is rowHeight specified; --ig-size will affect all of the rest elements in the Grid, as it has been described above; And now we can extend our sample and add rowHeight property to the Grid: <igx-grid #grid [data]=\"data\" [rowHeight]=\"'80px'\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> .............. </igx-grid> API References IgxGridComponent IgxGridComponent Styles IgxColumnComponent Additional Resources Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/editing.html": {
    "href": "components/grid/editing.html",
    "title": "Angular Grid Editing - Ignite UI for Angular",
    "keywords": "/* Fix for the overlapping right side-affix when the screen is shrinked */ .table-responsive { width:63vw; } Angular Grid Editing Ignite UI for Angular Grid component provides an easy way to perform data manipulation operations like creating, updating, and deleting records. The data manipulation phases are: Cell Editing, Row Editing, and Batch Editing. The Grid gives you a powerful public API which allows you to customize the way these operations are performed. Additionally, Cell editing exposes several default editors based on the column data type, that could be easily customized via igxCellEditor directive or igxRow directives. Setup In order to specify which edit mode should be enabled, the Grid exposes the following boolean properties - editable and rowEditable. Property editable enables you to specify the following options: false - the editing for the corresponding column will be disabled; /default value/ true - the editing for the corresponding column will be enabled; Keep in mind that if the column is not editable, you can still modify its value through the public API exposed by the Grid. Property rowEditable enables you to specify the following options: false - the row editing in the corresponding grid will be disabled; /default value/ true - the row editing in the corresponding grid will be enabled; In the Grid if you set rowEditable property to true, and editable property is not explicitly defined for any column, the editing will be enabled for all the columns except the primary key. Batch editing in the grid can be enabled for both cell editing and row editing modes. In order to set up batch editing it is necessary to provide to the grid a TransactionService. Cell and Batch Editing - in this scenario every singe modification of each cell is preserved separately and undo/ redo operations are available on cell level; Row and Batch Editing - in this scenario the modifications are preserved on row level so undo/ redo operations will not be working for each cell that is modified but for the bunch of cell from each row. Editing Templates If you want to use a data type specific edit templates, you should specify the column dataType property. So let's now see what are the default templates for each type: For string data type, default template is using igxInput For number data type, default template is using igxInput type=\"number\", so if you try to update cell to a value which can not be parsed to a number your change is going to be discarded, and the value in the cell will be set to 0. For date data type, default template is using igxDatePicker For dateTime data type, default template is using IgxDateTimeEditor directive. This editor will give you a mask directions for the input elements part of the DateTime object. For date data type, default template is using IgxDatePicker component. For time - data type, default template is using IgxTimePicker component. For boolean data type, default template is using igxCheckbox For currency data type, default template is using IgxInputGroup with prefix/suffix configuration based on application or grid locale settings. For percent data type, default template is using IgxInputGroup with suffix element that shows a preview of the edited value in percents. For custom templates you can see Cell Editing topic All available column data types could be found in the official Column types topic. Event arguments and sequence The grid exposes a wide array of events that provide greater control over the editing experience. These events are fired during the Row Editing and Cell Editing lifecycle - when starting, committing or canceling the editing action. Event Description Arguments Cancellable rowEditEnter If rowEditing is enabled, fires when a row enters edit mode IGridEditEventArgs true cellEditEnter Fires when a cell enters edit mode (after rowEditEnter) IGridEditEventArgs true cellEdit If value is changed, fires just before a cell's value is committed (e.g. by pressing Enter) IGridEditEventArgs true cellEditDone If value is changed, fires after a cell has been edited and cell's value is committed IGridEditDoneEventArgs false cellEditExit Fires when a cell exits edit mode IGridEditDoneEventArgs false rowEdit If rowEditing is enabled, fires just before a row in edit mode's value is committed (e.g. by clicking the Done button on the Row Editing Overlay) IGridEditEventArgs true rowEditDone If rowEditing is enabled, fires after a row has been edited and new row's value has been committed. IGridEditDoneEventArgs false rowEditExit If rowEditing is enabled, fires when a row exits edit mode IGridEditDoneEventArgs false Event cancelation RowEditEnter - Neither Row nor Cell will enter edit mode. CellEditEnter - Prevents entering cell edit. If rowEditable is enabled, row edit will be triggered, although cell edit will remain forbidden. CellEdit - Allowed Cell/Row edit, hitting Done button or Enter won't commit the value or row transaction. Cell editing and Row editing won't be closed until Cancel button is clicked. RowEdit - Committing cell is possible, but not the whole row. The row will stay in edit mode and the row transaction will be considered open. Hitting Done does not commit or close the row. Cancel button closes the editing process and the transaction without committing the changes. The following sample demonstrates the editing execution sequence in action: Features integration While a cell/row is in edit mode, a user may interact with the grid in many ways. The following table specifies how a certain interaction affects the current editing: Grid Filtering Sorting Paging Moving Pinning Hiding GroupBy Resizing Escape Enter F2 Tab Cell Click Add new row/Delete/Edit Keep edit mode ✔ Exit edit mode ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ Commit ✔ ✔ ✔ ✔ ✔ Discard ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ As seen from the table, all interactions, except resizing a column, will end the editing and will discard the new values. Should the new value be committed, this can be done by the developer in the corresponding feature \"-ing\" event. Example how to commit new values, if user tries to sort the column while a cell/row is in edit mode: <igx-grid #grid [data]=\"localData\" [primaryKey]=\"'ProductID'\" (sorting)=\"onSorting($event)\"> ... </igx-grid> public onSorting(event: ISortingEventArgs) { this.grid.endEdit(true); // (event.owner as IgxGridComponent).endEdit(true); } API References IgxGridCell IgxGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Grid overview Build CRUD operations with igxGrid Column Data Types Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/grid/excel-style-filtering.html": {
    "href": "components/grid/excel-style-filtering.html",
    "title": "Excel Style Filtering in Angular Data Grid- Ignite UI for Angular",
    "keywords": "Excel Filtering in Angular Grid The grid Excel filtering provides an Excel like filtering UI for any Angular table like the Grid. Angular Grid Excel Style Filtering Example Usage To turn on the grid excel filtering, two inputs should be set. The allowFiltering should be set to true and the filterMode should be set to excelStyleFilter. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\"> </igx-grid> Interactions In order to open the filter menu for a particular column, the Angular filter icon in the header should be clicked. Additionally, you can use the Ctrl + Shift + L combination on a selected header. If the column can be sorted, pinned, moved, selected or hidden along with the filtering functionality, there will be buttons available for the features that are turned on. If no filter is applied, all the items in the list will be selected. They can be filtered from the input above the list. In order to filter the data, you can select/deselect the items in the list and either click the Apply button, or press Enter. The filtering applied through the list items creates filter expressions with equals operator and the logic operator between the expressions is OR. If you type something in the search box and apply the filter, only the items that match the search criteria will be selected. If you want to add items to the currently filtered ones, however, you should select the option Add current selection to filter. If you want to clear the filter, you can check the Select All option and then click the Apply button. To apply a filter with different expressions, you can click the Text filter, which will open a sub menu with all available filter operators for the particular column. Selecting one of them will open the custom filter dialog, where you can add as many expressions as you want with different filter and logic operators. There is also a clear button, which can clear the filter. Configure Menu Features Sorting, pinning and hiding features can be removed from the filter menu using the corresponding inputs: sortable, selected, disablePinning, disableHiding. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"650px\" width=\"100%\" [moving]=\"true\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\"> <igx-column field=\"ProductName\" header=\"Product Name\" [sortable]=\"true\" [dataType]=\"'string'\"> </igx-column> <igx-column field=\"QuantityPerUnit\" header=\"Quantity Per Unit\" [sortable]=\"false\" [disablePinning]=\"true\" [disableHiding]=\"true\" [dataType]=\"'string'\"> </igx-column> <igx-column field=\"UnitPrice\" header=\"Unit Price\" [disablePinning]=\"true\" [disableHiding]=\"true\" [sortable]=\"true\" [dataType]=\"'number'\"> </igx-column> <igx-column field=\"OrderDate\" header=\"Order Date\" [sortable]=\"false\" [dataType]=\"'date'\" [formatter]=\"formatDate\"> </igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" [sortable]=\"true\" [dataType]=\"'boolean'\"> </igx-column> </igx-grid> In the sample below Product Name and Discontinued columns have all four features enabled, Quantity Per Unit have all three disabled, Unit Price has only sorting and Order Date has only pinning and hiding and all are selectable. Templates If you want to further customize the Excel style filter menu without disabling the column features you could use custom templates. The Excel Style filter menu provides two directives for templating: IgxExcelStyleColumnOperationsTemplateDirective - re-templates the area with all column operations like sorting, pinning, etc. IgxExcelStyleFilterOperationsTemplateDirective - re-templates the area with all filter specific operations. You could either re-template only one of those areas or both of them. You could put any custom content inside those directives or you could use any of our built-in Excel style filtering components. The following code demonstrates how to define a custom Excel style filter menu using the igx-excel-style-header, igx-excel-style-sorting and igx-excel-style-search components. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"650px\" width=\"100%\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\"> <igx-grid-excel-style-filtering [minHeight]=\"'380px'\" [maxHeight]=\"'500px'\"> <igx-excel-style-column-operations> <igx-excel-style-header [showPinning]=\"true\" [showHiding]=\"true\" > </igx-excel-style-header> <igx-excel-style-sorting></igx-excel-style-sorting> </igx-excel-style-column-operations> <igx-excel-style-filter-operations> <igx-excel-style-search></igx-excel-style-search> </igx-excel-style-filter-operations> </igx-grid-excel-style-filtering> ... </igx-grid> You could also re-template the Excel style filtering icon in the column header using the igxExcelStyleHeaderIcon directive: <igx-grid ...> <ng-template igxExcelStyleHeaderIcon> <igx-icon>filter_alt</igx-icon> </ng-template> </igx-grid> Here is the full list of Excel style filtering components that you could use: igx-excel-style-header igx-excel-style-sorting igx-excel-style-moving igx-excel-style-pinning igx-excel-style-hiding igx-excel-style-selecting igx-excel-style-clear-filters igx-excel-style-conditional-filter igx-excel-style-search Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. These values can be provided manually and loaded on demand, which is demonstrated in the Grid Remote Data Operations topic. Formatted Values Filtering Strategy By default, the Grid component filters the data based on the original cell values, however in some cases you may want to filter the data based on the formatted values. In order to do that you can use the FormattedValuesFilteringStrategy. The following sample demonstrates how to format the numeric values of a column as strings and filter the Grid based on the string values: Note The formatted values filtering strategy won't work correctly if you have more than one column bound to the same field from your data and one of the columns has a formatter. External Excel Style filtering As you see at the demos above the default appearance of the Excel Style filtering dialog is inside the Grid. So this dialog is only visible when configuring the filters. There is a way to make that dialog stay always visible - it can be used outside of the grid as a standalone component. In the demo below, the Excel style filtering is declared separately of the Grid. Demo Usage In order to configure the Excel style filtering component, you should set its column property to one of the Grid's columns. In the sample above, we have bound the column property to the value of an IgxSelectComponent that displays the Grid's columns. <igx-select #gridColums value=\"ProductID\"> <label igxLabel>Columns:</label> <igx-select-item *ngFor=\"let c of grid1.columns\" [value]=\"c.field\"> {{ c.field }} </igx-select-item> </igx-select> <igx-grid-excel-style-filtering [column]=\"grid1.getColumnByName(gridColums.value)\"> </igx-grid-excel-style-filtering> External Outlet The Grid's z-index creates separate stacking context for each grid in the DOM. This ensures that all descendant elements of the grid will render as intended, without overlapping one another. However, elements that go outside of the grid (e.g. Excel Style filter) will conflict with outside elements with the same z-index (e.g. having two grids one under another) resulting in false rendering. The solution for this issue is to set the outlet property to an external outlet directive which allows the overlay elements to always appear on top. Demo Styling To get started with styling the Excel Style Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The excel style filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); We obviously have a lot more components inside the excel like filtering dialog, such as buttons, checkboxes, a list and even a drop-down. In order to style them, we need to create a separate theme for each one: $dark-button: button-theme( $background: #FFCD0F, $foreground: #292826, $hover-background: #292826, $hover-foreground: #FFCD0F ); $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $custom-list: list-theme( $background: #FFCD0F ); $custom-checkbox: checkbox-theme( $empty-color: #292826, $fill-color: #292826, $tick-color: #FFCD0F, $label-color: #292826 ); $custom-drop-down: drop-down-theme( $background-color: #FFCD0F, $item-text-color: #292826, $hover-item-background: #292826, $hover-item-text-color: #FFCD0F ); In this example we only changed some of the parameters for the listed components, but the button-theme, checkbox-theme, drop-down-theme, input-group-theme, list-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope most of the components' mixins within .igx-excel-filter and .igx-excel-filter__secondary, so that these custom themes will affect only components nested in the excel style filtering dialog and all of its sub-dialogs. Otherwise other buttons, checkboxes, input-groups and lists would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); $dark-button: button-theme( $background: color($dark-palette, \"secondary\", 400), $foreground: color($dark-palette, \"primary\", 400), $hover-background: color($dark-palette, \"primary\", 400), $hover-foreground: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $custom-list: list-theme( $background: color($dark-palette, \"secondary\", 400) ); $custom-checkbox: checkbox-theme( $empty-color: color($dark-palette, \"primary\", 400), $fill-color: color($dark-palette, \"primary\", 400), $tick-color: color($dark-palette, \"secondary\", 400), $label-color: color($dark-palette, \"primary\", 400) ); $custom-drop-down:drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), $item-text-color: color($dark-palette, \"primary\", 400), $hover-item-background: color($dark-palette, \"primary\", 400), $hover-item-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group, light-button, light-list, light-checkbox and light-drop-down schemas: $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"secondary\", 400) ) ) ); $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ), contained-background:( color: (\"secondary\", 400) ), contained-text-color:( color: (\"primary\", 400) ), contained-hover-background:( color: (\"primary\", 400) ), contained-hover-text-color:( color: (\"secondary\", 400) ) ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); $custom-list-schema: extend($_light-list, ( background:( color: (\"secondary\", 400) ) ) ); $custom-checkbox-schema: extend($_light-checkbox, ( empty-color:( color: (\"primary\", 400) ), fill-color:( color: (\"primary\", 400) ), tick-color:( color: (\"secondary\", 400) ), label-color:( color: (\"primary\", 400) ) ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), item-text-color:( color: (\"primary\", 400) ), hover-item-background:( color: (\"primary\", 400) ), hover-item-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( grid: $custom-grid-schema, button: $custom-button-schema, input-group: $custom-input-group-schema, list: $custom-list-schema, checkbox: $custom-checkbox-schema, drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-list: list-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-checkbox: checkbox-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxGridComponent API IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/export-excel.html": {
    "href": "components/grid/export-excel.html",
    "title": "Angular Grid Export to Excel - Ignite UI for Angular",
    "keywords": "Angular Grid Export to Excel Service The Excel Exporter service can export data to excel from the IgxGrid. The data export functionality is encapsulated in the IgxExcelExporterService class and the data is exported in MS Excel table format. This format allows features like filtering, sorting, etc. To do this you need to invoke the IgxExcelExporterService's export method and pass the IgxGrid component as first argument to export grid easily. Angular Excel Exporter Example Exporting Grid's Data To start using the IgniteUI Excel Exporter first import the IgxExcelExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts import { IgxExcelExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxExcelExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <igx-grid #grid [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid> <button (click)=\"exportButtonHandler()\">Export IgxGrid to Excel</button> You may access the exporter service by defining an argument of type IgxExcelExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in MS Excel format you need to invoke the exporter service's export method and pass the IgxGrid component as first argument. Here is the code which will execute the export process in the component's typescript file: // component.ts import { IgxExcelExporterService, IgxExcelExporterOptions } from 'igniteui-angular'; import { IgxGridComponent } from 'igniteui-angular'; @ViewChild('grid') public grid: IgxGridComponent; constructor(private excelExportService: IgxExcelExporterService) { } public exportButtonHandler() { this.excelExportService.export(this.grid, new IgxExcelExporterOptions('ExportedDataFile')); } If all went well, you should see the IgxGrid component and a button under it. When pressing the button, it will trigger the export process and the browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the Grid component in MS Excel format. Export All Data There are some cases when you might be using remote operations like Paging and the Grid won't have access to all of its data. In these cases, we recommend using the Excel Export Service and pass the whole data collection, if available. Example: public exportButtonHandler() { this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions('ExportedDataFile')); } Export Grouped Data To export grouped data you just need to group the Grid by one or more columns. The browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the Grid component in MS Excel format grouped by the selected column. Example: Export Multi Column Headers Grid It is now possible to export Grid with defined multi-column headers. All headers will be reflected in the exported excel file as they are displayed in the Grid. If you want to exclude the defined multi-column headers from the exported data you can set the exporter option ignoreMultiColumnHeaders to true. Note The exported Grid will not be formatted as a table, since Excel tables do not support multiple row headers. Export Grid with Frozen Column Headers By default Excel Exporter service exports the grid with scrollable (unfrozen) column headers. There are scenarios in which you may want to freeze all headers on top of the exported excel file so they always stay in view as the user scrolls through the records. To achieve this you could set the exporter option freezeHeaders to true. public exportButtonHandler() { const exporterOptions = new IgxExcelExporterOptions('ExportedDataFile'); exporterOptions.freezeHeaders = true; this.excelExportService.export(this.grid, exporterOptions); } Customizing the Exported Content In the above examples the Excel Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude a column from the export if its header is \"Age\" and if its index is 1: // component.ts this.excelExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Age' && args.columnIndex == 1) { args.cancel = true; } }); this.excelExportService.export(this.grid, new IgxExcelExporterOptions('ExportedDataFile')); When you are exporting data from the Grid component, the export process takes in account features like row filtering and column hiding and exports only the data visible in the Grid. You can configure the exporter service to include filtered rows or hidden columns by setting properties on the IgxExcelExporterOptions object. Known Limitations Limitation Description Max worksheet size The maximum worksheet size supported by Excel is 1,048,576 rows by 16,384 columns. Cell Styling The excel exporter service does not support exporting a custom style applied to a cell component. In such scenarios we recommend using the Excel Library. API References The Excel Exporter service has a few more APIs to explore, which are listed below. IgxExcelExporterService API IgxExcelExporterOptions API Additional components that were used: IgxGridComponent API IgxGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/filtering.html": {
    "href": "components/grid/filtering.html",
    "title": "Angular Grid Filter - Ignite UI for Angular",
    "keywords": "Angular Grid Filtering IgniteUI for Angular Grid component provides three different filtering types - Quick filtering, Excel style filtering and Advanced filtering which enable you to display only the records that meet specified criteria. The Material UI grid component in Ignite UI provides angular filter capabilities and extensive filtering API through the Data Container to which the Grid is bound. Angular Grid Filtering Example The sample below demonstrates Grid's Quick filtering user experience. API filter() method is used to apply contains condition on the ProductName column through external igxInputGroup component. Setup In order to specify if filtering is enabled and which filtering mode should be used, the Grid exposes the following boolean properties - allowFiltering, allowAdvancedFiltering, filterMode and filterable. Property allowFiltering enables you to specify the following options: false - the filtering for the corresponding grid will be disabled; /default value/ true - the filtering for the corresponding grid will be enabled; Property allowAdvancedFiltering enables you to specify the following options: false - the advanced filtering for the corresponding grid will be disabled; /default value/ true - the advanced filtering for the corresponding grid will be enabled; Property filterMode enables you to specify the following options: quickFilter - a simplistic filtering UI; /default value/ excelStyleFilter - an Excel-like filtering UI; Property filterable enables you to specify the following options: true - the filtering for the corresponding column will be enabled; /default value/ false - the filtering for the corresponding column will be disabled; <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"ProductName\"></igx-column> <igx-column field=\"Price\" [dataType]=\"'number'\" [filterable]=\"false\"> </igx-grid> To enable the Advanced filtering however, you need to set the allowAdvancedFiltering input properties to true. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> </igx-grid> Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Grid is the intersection between the results of the two filters. Interaction In order to open the filter row for a particular column, the 'Filter' chip below its header should be clicked. To add conditions you should choose filter operand using the dropdown on the left of the input and enter value. For number and date columns 'Equals' is selected by default, for string - 'Contains' and for boolean - 'All'. Pressing 'Enter' confirms the condition and you are now able to add another one. There is a dropdown, between 'condition' chips, which determines the logical operator between them, 'AND' is selected by default. To remove a condition you can click the 'X' button of the chip, and to edit it you should select the chip and the input will be populated with the chip's data. While filter row is opened you can click on any filterable column's header in order to select it and to be able to add filter conditions for it. While some filtering conditions have been applied to a column, and the filter row is closed, you can either remove the conditions by clicking the chip's close button, or you can open the filter row by selecting any of the chips. When there is not enough space to show all the conditions, a filter icon is shown with a badge that indicates how many more conditions there are. It can also be clicked in order to open the filter row. Usage There's a default filtering strategy provided out of the box, as well as all the standard filtering conditions, which the developer can replace with their own implementation. In addition, we've provided a way to easily plug in your own custom filtering conditions. The Grid currently provides not only a simplistic filtering UI, but also more complex filtering options. Depending on the set dataType of the column, the correct set of filtering operations is loaded inside the filter UI dropdown. Additionally, you can set the ignoreCase and the initial condition properties. Filtering feature is enabled for the Grid component by setting the allowFiltering input to true. The default filterMode is quickFilter and it cannot be changed run time. To disable this feature for a certain column – set the filterable input to false. <igx-grid [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"ProductName\"></igx-column> <igx-column field=\"Price\" dataType=\"number\"></igx-column> <igx-column field=\"Discontinued\" [dataType]=\"'boolean'\" [filterable]=\"false\"> </igx-grid> Note If values of type string are used by a column of dataType Date, the Grid won't parse them to Date objects and using filtering conditions won't be possible. If you want to use string objects, additional logic should be implemented on the application level, in order to parse the values to Date objects. You can filter any column or a combination of columns through the Grid API. The Grid exposes several methods for this task - filter, filterGlobal and clearFilter. filter - filter a single column or a combination of columns. There are five filtering operand classes exposed: IgxFilteringOperand: this is a base filtering operand, which can be inherited when defining custom filtering conditions. IgxBooleanFilteringOperand defines all default filtering conditions for boolean type. IgxNumberFilteringOperand defines all default filtering conditions for numeric type. IgxStringFilteringOperand defines all default filtering conditions for string type. IgxDateFilteringOperand defines all default filtering conditions for Date type. // Single column filtering // Filter the `ProductName` column for values which `contains` the `myproduct` substring, ignoring case this.grid.filter('ProductName', 'myproduct', IgxStringFilteringOperand.instance().condition('contains'), true); The only required parameters are the column field key and the filtering term. Both the condition and the case sensitivity will be inferred from the column properties if not provided. In the case of multiple filtering, the method accepts an array of filtering expressions. Note The filtering operation DOES NOT change the underlying data source of the Grid. // Multi column filtering const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'ch' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); const priceFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'Price'); const priceExpression = { condition: IgxNumberFilteringOperand.instance().condition('greaterThan'), fieldName: 'UnitPrice', ignoreCase: true, searchVal: 20 }; priceFilteringExpressionsTree.filteringOperands.push(priceExpression); gridFilteringExpressionsTree.filteringOperands.push(priceFilteringExpressionsTree); this.grid.filteringExpressionsTree = gridFilteringExpressionsTree; filterGlobal - clears all existing filters and applies the new filtering condition to all Grid's columns. // Filter all cells for a value which contains `myproduct` this.grid.filteringLogic = FilteringLogic.Or; this.grid.filterGlobal('myproduct', IgxStringFilteringOperand.instance().condition('contains'), false); clearFilter - removes any applied filtering from the target column. If called with no arguments it will clear the filtering of all columns. // Remove the filtering state from the ProductName column this.grid.clearFilter('ProductName'); // Clears the filtering state from all columns this.grid.clearFilter(); Initial filtered state To set the initial filtering state of the Grid, set the IgxGridComponent filteringExpressionsTree property to an array of IFilteringExpressionsTree for each column to be filtered. constructor(private cdr: ChangeDetectorRef) { } public ngAfterViewInit() { const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'c' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); this.grid.filteringExpressionsTree = gridFilteringExpressionsTree; this.cdr.detectChanges(); } Filtering logic The filteringLogic property of the Grid controls how filtering multiple columns will resolve in the Grid. You can change it at any time through the Grid API, or through the Grid input property. import { FilteringLogic } from 'igniteui-angular'; // import { FilteringLogic } from '@infragistics/igniteui-angular'; for licensed package ... this.grid.filteringLogic = FilteringLogic.OR; The default value of AND returns only the rows that match all the currently applied filtering expressions. Following the example above, a row will be returned when both the 'ProductName' cell value contains 'myproduct' and the 'Price' cell value is greater than 55. When set to OR, a row will be returned when either the 'ProductName' cell value contains 'myproduct' or the 'Price' cell value is greater than 55. Remote Filtering The Grid supports remote filtering, which is demonstrated in the Grid Remote Data Operations topic. Custom Filtering Operands You can customize the filtering menu by adding, removing or modifying the filtering operands. By default, the filtering menu contains certain operands based on the column’s data type (IgxBooleanFilteringOperand, IgxDateFilteringOperand, IgxNumberFilteringOperand and IgxStringFilteringOperand). You can extend these classes or their base class IgxFilteringOperand to change the filtering menu items’ behavior. In the sample below, inspect the \"Product Name\" and \"Discontinued\" columns filters menus. For the \"Discontinued\" column filter, we have limited the number of operands to All, True and False. For the \"Product Name\" column filter – we have modified the Contains and Does Not Contain operands logic to perform case sensitive search and added also Empty and Not Empty operands. To do that, extend the IgxStringFilteringOperand and IgxBooleanFilteringOperand, modify the operations and their logic, and set the column filters input to the new operands. // grid-custom-filtering.component.ts export class GridCustomFilteringComponent { public caseSensitiveFilteringOperand = CaseSensitiveFilteringOperand.instance(); public booleanFilteringOperand = BooleanFilteringOperand.instance(); } export class CaseSensitiveFilteringOperand extends IgxStringFilteringOperand { private constructor() { super(); const customOperations = [ { iconName: 'contains', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) !== -1; }, name: 'Contains (case sensitive)' }, { iconName: 'does_not_contain', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) === -1; }, name: 'Does Not Contain (case sensitive)' } ]; const emptyOperators = [ // 'Empty' this.operations[6], // 'Not Empty' this.operations[7] ]; this.operations = customOperations.concat(emptyOperators); } } export class BooleanFilteringOperand extends IgxBooleanFilteringOperand { private constructor() { super(); this.operations = [ // 'All' this.operations[0], // 'TRUE' this.operations[1], // 'FALSE' this.operations[2] ]; } } <!-- grid-custom-filtering.component.html --> <igx-grid [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"ProductName\" header=\"Product Name\" [filters]=\"caseSensitiveFilteringOperand\"></igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" [dataType]=\"'boolean'\" [filters]=\"booleanFilteringOperand\"> <ng-template igxCell let-cell=\"cell\" let-val> <img *ngIf=\"val\" src=\"assets/images/grid/active.png\" title=\"Delivered\" alt=\"Delivered\" /> <img *ngIf=\"!val\" src=\"assets/images/grid/expired.png\" title=\"Undelivered\" alt=\"Undelivered\" /> </ng-template> </igx-column> </igx-grid> Re-templating filter cell You can add a template marked with igxFilterCellTemplate in order to retemplate the filter cell. In the sample below, an input is added for the string columns and IgxDatePicker for the date column. When the user types or selects a value, a filter with contains operator for string columns and equals operator for date columns, is applied using grid's public API. Styling To get started with styling the filtering row, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $filtering-row-text-color, $filtering-row-background, $filtering-header-text-color and the $filtering-header-background parameters. $custom-grid: grid-theme( $filtering-row-text-color: #292826, $filtering-row-background: #FFCD0F, $filtering-header-text-color: #292826, $filtering-header-background: #FFCD0F ); As seen, the grid-theme only controls colors for the filtering row and the respective column header that is being filtered. We obviously have a lot more components inside the filtering row, such as an input group, chips, buttons and others. In order to style them, we need to create a separate theme for each one, so let's create a new input group theme and a new button theme: $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $dark-button: button-theme( $flat-background: #FFCD0F, $flat-text-color: #292826, $flat-hover-background: #292826, $flat-hover-text-color: #FFCD0F ); In this example we only changed some of the parameters for the input group and the button, but the input-group-theme and the button-theme provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope the igx-button and the igx-input-group mixins within .igx-grid__filtering-row, so that only the filtering row buttons and its input group would be styled. Otherwise other buttons and input groups in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-text-color: color($dark-palette, \"primary\", 400), $filtering-row-background: color($dark-palette, \"secondary\", 400), $filtering-header-text-color: color($dark-palette, \"primary\", 400), $filtering-header-background: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $dark-button: button-theme( $flat-background: color($dark-palette, \"secondary\", 400), $flat-text-color: color($dark-palette, \"primary\", 400), $flat-hover-background: color($dark-palette, \"primary\", 400), $flat-hover-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group and light-button schemas: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( filtering-row-text-color:( color: (\"primary\", 400) ), filtering-row-background:( color: (\"secondary\", 400) ), filtering-header-text-color:( color: (\"primary\", 400) ), filtering-header-background:( color: (\"secondary\", 400) ) ) ); // Extending the light input group schema $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); // Extending the light button schema $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-input-group: $custom-input-group-schema, igx-button: $custom-button-schema )); // Defining grid-theme with the global light schema $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining button-theme with the global light schema $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining input-group-theme with the global light schema $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Limitations Note Some browsers such as Firefox fail to parse regional specific decimal separators by considering them grouping separators, thus resulting in them being invalid. When inputting such values for a numeric column filter value, only the valid part of the number will be applied to the filtering expression. For further information, refer to the Firefox issue. Breaking Changes in 6.1.0 IgxGrid filteringExpressions property is removed. Use filteringExpressionsTree instead. filter_multiple method is removed. Use filter method and filteringExpressionsTree property instead. The filter method has new signature. It now accepts the following parameters: name - the name of the column to be filtered. value - the value to be used for filtering. conditionOrExpressionTree (optional) - this parameter accepts object of type IFilteringOperation or IFilteringExpressionsTree. If only simple filtering is needed, a filtering operation could be passed as an argument. In case of advanced filtering, an expressions tree containing complex filtering logic could be passed as an argument. ignoreCase (optional) - whether the filtering is case sensitive or not. filteringDone event now have only one parameter of type IFilteringExpressionsTree which contains the filtering state of the filtered column. filtering operands: IFilteringExpression condition property is no longer a direct reference to a filtering condition method, instead it's a reference to an IFilteringOperation. IgxColumnComponent now exposes a filters property, which takes an IgxFilteringOperand class reference. Custom filters can be provided to the Grid columns by populating the operations property of the IgxFilteringOperand with operations of IFilteringOperation type. API References IgxColumnComponent IgxGridComponent API IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/grid.html": {
    "href": "components/grid/grid.html",
    "title": "Angular Data Grid | Build Fast Angular Tables | Infragistics",
    "keywords": ".sample-content { display: flex; flex-flow: row wrap; justify-content: center; } .sample-column { display: flex; flex-flow: column nowrap; flex: 1 0 25%; align-content: flex-start; min-width: 280px; } .tabbar-wrapper { width: inherit; position: relative; height: 100%; margin: 0 auto; } .tabbar-wrapper > p { padding-right: 20px } Angular Data Grid Component Overview The Angular Data Grid is a component for displaying data in a tabular format. Modern grids are complex and are usually packed with a large set of features like data selection, excel style filtering, sorting, paging, grouping, templating, column moving, column pinning, exporting to Excel, CSV formats and more. Angular Data Grid Example Boston Marathon 2021 – In this angular grid example, you can see how users can do both basic and excel-style filtering, live-data sorting, as well as using of grid summaries and cell templating that includes our Sparkline component, Circular Progress Indicator component, and Icons. The demo also includes custom paging and per page usage part of the Angular Pagination. Getting Started with Ignite UI for Angular Data Grid Note This component requires HammerModule to be imported in the root module of the application in order for touch interactions to work as expected.. To get started with the Ignite UI for Angular Data Grid component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxGridModule in your app.module.ts file. // app.module.ts import { IgxGridModule } from 'igniteui-angular'; // import { IgxGridModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxGridModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxGridComponent as a standalone dependency, or use the IGX_GRID_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_GRID_DIRECTIVES } from 'igniteui-angular'; // import { IGX_GRID_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-grid [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_GRID_DIRECTIVES] /* or imports: [IgxGridComponent] */ }) export class HomeComponent { public data: Product []; } Now that you have the Ignite UI for Angular Grid module or directives imported, you can start using the igx-grid component. Using the Angular Data Grid <igx-grid #grid1 id=\"grid1\" [data]=\"localData\" [autoGenerate]=\"true\"></igx-grid> The data property binds the grid, in this case to local array of objects. The autoGenerate property tells the igx-grid to auto generate the grid's IgxColumnComponents based on the data source fields. It will also try to deduce the appropriate data type for the column if possible. Developers can also explicitly define the columns and the mapping to the data source fields. Angular Bootstrap Grid Definition Ignite UI for Angular includes a powerful bootstrap grid like flex-based layout system. Any modern application today is expected to follow a responsive web design approach, meaning it can gracefully adjust layout of HTML elements based on the device size, or from simply resizing the browser. An Angular bootstrap grid layout was the most used approach in the past, but a flex-based layout system like CSS grid has become more popular, as it works in any browser. The Ignite UI for Angular Layout Directive allows vertical and horizontal flow, including content / text wrapping, justification, and alignment. The Ignite UI for Angular grid supports a responsive layout using CSS, giving you the ultimate flexibility in how the grid behaves on resize. Angular Grid Styling Configuration Note The IgxGridComponent uses css grid layout, which is not supported in IE without prefixing, consequently it will not render properly. In Angular most of the styles are prefixed implicitly thanks to the Autoprefixer plugin. For prefixing grid layouts however, you need to enable the Autoprefixer grid property with the comment /* autoprefixer grid:on */. To facilitate your work, apply the comment in the src/styles.scss file. // src/styles.scss @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); /* autoprefixer grid:on */ @include theme($default-palette); Editable Grid Angular Each operation for Angular grid editing includes Batch operations, meaning the API gives you the option to group edits into a single server call, or you can perform grid edit / update operations as they occur with grid interactions. Along with a great developer experience as an editable Angular grid with CRUD operations, the Angular grid includes Excel-like keyboard navigation. Common default grid navigation is included, plus the option to override any navigation option to meet the needs of your customers. An editable grid in Angular with a great navigation scheme is critical to any modern line of business application, with the Ignite UI grid we make it easy. Following this topic you will learn more about cell template and cell editing template and editing. Angular Grid Column Configuration IgxColumnComponent is used to define the grid's columns collection and to enable features per column like sorting and filtering. Cell, header, and footer templates are also available. Defining Columns Let's turn the autoGenerate property off and define the columns collection in the markup: <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"false\" (columnInit)=\"initColumns($event)\" (selected)=\"selectCell($event)\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" [sortable]=\"true\" header=\" \"></igx-column> <igx-column field=\"AthleteNumber\" [sortable]=\"true\" header=\"Athlete number\" [filterable]=\"false\"></igx-column> <igx-column field=\"TrackProgress\" header=\"Track progress\" [filterable]=\"false\"> <ng-template igxCell let-value> <igx-linear-bar [stripped]=\"false\" [value]=\"value\" [max]=\"100\"></igx-linear-bar> </ng-template> </igx-column> <igx-paginator [perPage]=\"6\"> </igx-paginator> </igx-grid> Each of the columns of the grid can be templated separately. The column expects ng-template Angular grid module directives. It also expose additionalTemplateContext input that can be used for custom properties and any type of data context that you want to pass to the column itself: <igx-column [additionalTemplateContext]=\"contextObject\"> <ng-template igxCell let-cell=\"cell\" let-props=\"additionalTemplateContext\"> {{ props.firstProperty }} </ng-template> </igx-column> public contextObject = { firstProperty: 'testValue', secondProperty: 'testValue1'}; Header Template igxHeader targets the column header providing as a context the column object itself. ... <igx-column field=\"Name\"> <ng-template igxHeader let-column> {{ column.field | uppercase }} </ng-template> </igx-column> ... Note Whenever a header template is used along with grouping/moving functionality the column header area becomes draggable and you cannot access the custom elements part of the header template until you mark them as not draggable. Example below. <igx-column #col field=\"ProductName\" header=\"Product Name\" [groupable]=\"true\" [hasSummary]=\"true\"> <ng-template igxHeader let-col> <div class=\"text\">{{col.field}}</div> <igx-icon (click)=\"toggleSummary(col)\" [attr.draggable]=\"false\">functions </igx-icon> </ng-template> </igx-column> As you can see, we are adding draggable attribute set to false. Cell Template igxCell applies the provided template to all cells in the column. The context object provided in the template consists of the cell value provided implicitly and the cell object itself. It can be used to define a template where the cells can grow according to their content, as in the below example. ... <igx-column field=\"Name\"> <ng-template igxCell let-value> {{ value | titlecase }} </ng-template> </igx-column> ... In the snippet above we \"take\" a reference to the implicitly provided cell value. This is sufficient if you just want to present some data and maybe apply some custom styling or pipe transforms over the value of the cell. However even more useful is to take the CellType instance itself as shown below: <igx-grid #grid [data]=\"data\"> <igx-column dataType=\"string\" field=\"Name\"> <ng-template igxCell let-cell=\"cell\"> <!-- Implement row deleting inside the cell template itself --> <span tabindex=\"0\" (keydown.delete)=\"grid.deleteRow(cell.row.index)\">{{ cell.value | titlecase }}</span> </ng-template> </igx-column> <igx-column dataType=\"boolean\" field=\"Subscribtion\"> <ng-template igxCell let-cell=\"cell\"> <!-- Bind the cell value through the ngModel directive and update the data source when the value is changed in the template --> <input type=\"checkbox\" [ngModel]=\"cell.value\" (ngModelChange)=\"cell.update($event)\" /> </ng-template> </igx-column> <igx-grid> When changing data through the cell template using ngModel, you need to call the appropriate API methods to make sure the value is correctly updated in the Angular grid's underlying data collection. In the snippet above, the ngModelChange call passes through the grid's editing API and goes through the grid's editing pipeline, properly triggering transactions(if applicable) and handling of summaries, selection, etc. However, this ngModelChange will fire every time the value of the cell changes, not just when the user is done editing, resulting in a lot more API calls. Note The grid exposes a default handling for number, string, date and boolean column types. For example, the column will display check or close icon, instead of true/false by default, for boolean column type. If the data in a cell is bound with [(ngModel)] and the value change is not handled, the new value will not be properly updated in the Angular grid's underlying data source. When dealing with cell editing with a custom template, it is strongly advised to use the cell's cell editing template. When properly implemented, the cell editing template also ensures that the cell's editValue will correctly pass through the grid editing event cycle. Cell Editing Template The column also accepts one last template that will be used when a cell is in edit mode. As with the other column templates, the provided context object is again the cell value and the cell object itself. Of course in order to make the edit-mode template accessible to end users, you need to set the editable property of the IgxColumnComponent to true. <igx-column dataType=\"number\" editable=\"true\" field=\"Price\"> <ng-template igxCellEditor let-cell=\"cell\"> <label for=\"price\"> Enter the new price tag </label> <input name=\"price\" type=\"number\" [(ngModel)]=\"cell.editValue\" /> </ng-template> </igx-column> Make sure to check the API for the CellType in order to get accustomed with the provided properties you can use in your templates. Column Template API Each of the column templates can be changed programmatically at any point through the IgxColumnComponent object itself. For example in the code below, we have declared two templates for our user data. In our TypeScript code we'll get references to the templates themselves and then based on some condition we will render the appropriate template for the column in our application. <igx-grid> <!-- Column declarations --> </igx-grid> <ng-template #normalView let-value> <div class=\"user-details\">{{ val }}</div> <user-details-component></user-details-component> </ng-template> <ng-template #smallView let-value> <div class=\"user-details-small\">{{ val }}</div> </ng-template> @ViewChild(\"normalView\", { read: TemplateRef }) public normalView: TemplateRef<any>; @ViewChild(\"smallView\", { read: TemplateRef }) public smallView: TemplateRef<any>; .... const column = this.grid.getColumnByName(\"User\"); // Return the appropriate template based on some conditiion. // For example saved user settings, viewport size, etc. column.bodyTemplate = this.smallView; Column properties can also be set in code in the columnInit event which is emitted when the columns are initialized in the grid. public initColumns(column: IgxGridColumn) { const column: IgxColumnComponent = column; if (column.field === 'ProductName') { column.sortable = true; column.editable = true; } } The code above will make the ProductName column sortable and editable and will instantiate the corresponding features UI (like inputs for editing, etc.). Custom Display Format All values for a date, numeric, currency and percent column are transformed through the Angular DatePipe, DecimalPipe, CurrencyPipe and PercentPipe accordingly. This does not modify the original value, just the value that is displayed in the column. So please keep in mind that all data operations and manipulations are done based on the values in your data source. By default, values will be displayed according to the grid locale (if not specified, it fallbacks to the application locale, which defaults to 'en-US'). See Setting up the locale of your app for more details. Also, there are optional parameters for formatting: format - determines what date/time parts are displayed, defaults to 'mediumDate', equivalent to 'MMM d, y' timezone - the timezone offset for dates. By default uses the end-user's local system timezone digitsInfo - decimal representation objects. Default to '1.0-3' To allow customizing the display format by these parameters, the pipeArgs input is exposed. A column will respect only the corresponding properties for its data type, if pipeArgs is set. Example: const pipeArgs: IColumnPipeArgs = { format: 'longDate', timezone: 'UTC', digitsInfo: '1.1-2' } <igx-column field=\"OrderDate\" dataType=\"date\" [pipeArgs]=\"pipeArgs\"></igx-column> <igx-column field=\"UnitPrice\" dataType=\"number\" [pipeArgs]=\"pipeArgs\"></igx-column> The OrderDate column will respect only the format and timezone properties, while the UnitPrice will only respect the digitsInfo. For further details, please check the official Angular documentation at Localizing your app. All available column data types could be found in the official Column types topic. Angular Grid Data Structure The IgxGridComponent handles flat data and nested POJOs(Plain old Java objects). The data structure specific for rendering is in the form: const OBJECT_ARRAY = [{ ObjectKey1: value1, ObjectKey2: value2, . . . ObjectKeyN: valueN }, . . . }]; const POJO = [{ ObjectKey1: value1, ObjectKey2: value2, . . . ObjectKeyN: { ObjectKeyN1: value1, ObjectKeyN2: value2, . . . ObjectKeyNM: valueNM, } }, . . . }]; Warning The key values must not contain arrays. If you use autoGenerate columns the data keys must be identical. Angular Grid Data Binding Before going any further with the grid we want to change the Angular grid to bind to remote data service, which is the common scenario in large-scale applications. A good practice is to separate all data fetching related logic in a separate data service, so we are going to create a service which will handle the fetching of data from the server. Let's implement our service in a separate file // northwind.service.ts import { Injectable } from '@angular/core'; import { HttpClient } from '@angular/common/http'; import { Observable } from 'rxjs/Observable'; import { of } from 'rxjs/observable/of'; import { catchError, map } from 'rxjs/operators'; We're importing the Injectable decorator which is an essential ingredient in every Angular service definition. The HttpClient will provide us with the functionality to communicate with backend services. It returns an Observable of some result to which we will subscribe in our grid component. Note: Before Angular 5 the HttpClient was located in @angular/http and was named Http. Since we will receive a JSON response containing an array of records, we may as well help ourselves by specifing what kind of data we're expecting to be returned in the observable by defining an interface with the correct shape. Type checking is always recommended and can save you some headaches down the road. // northwind.service.ts export interface NorthwindRecord { ProductID: number; ProductName: string; SupplierID: number; CategoryID: number; QuantityPerUnit: string; UnitPrice: number; UnitsInStock: number; UnitsOnOrder: number; ReorderLevel: number; Discontinued: boolean; CategoryName: string; } The service itself is pretty simple consisting of one method: fetchData that will return an Observable<NorthwindRecord[]>. In cases when the request fails for any reason (server unavailable, network error, etc), the HttpClient will return an error. We'll leverage the catchError operator which intercepts an Observable that failed and passes the error to an error handler. Our error handler will log the error and return a safe value. // northwind.service.ts @Injectable() export class NorthwindService { private url = 'http://services.odata.org/V4/Northwind/Northwind.svc/Alphabetical_list_of_products'; constructor(private http: HttpClient) {} public fetchData(): Observable<NorthwindRecord[]> { return this.http .get(this.url) .pipe( map(response => response['value']), catchError( this.errorHandler('Error loading northwind data', []) ) ); } private errorHandler<T>(message: string, result: T) { return (error: any): Observable<any> => { console.error(`${message}: ${error.message}`); return of(result as T); }; } } Make sure to import both the HttpClientModule and our service in the application module and register the service as a provider. // app.module.ts import { HttpClientModule } from '@angular/common/http'; ... import { NorthwindService } from './northwind.service'; @NgModule({ imports: [ ... HttpClientModule ... ], providers: [ NorthwindService ] }) export class AppModule {} After implementing the service we will inject it in our component's constructor and use it to retrieve the data. The ngOnInit lifecycle hook is a good place to dispatch the initial request. Note: In the code below, you may wonder why are we setting the records property to an empty array before subscribing to the service. The Http request is asynchronous, and until it completes, the records property will be undefined which will result in an error when the grid tries to bind to it. You should either initialize it with a default value or use a BehaviorSubject. // my.component.ts @Component({...}) export class MyComponent implements OnInit { public records: NorthwindRecord[]; constructor(private northwindService: NorthwindService) {} ngOnInit() { this.records = []; this.northwindService.fetchData().subscribe((records) => this.records = records); } } and in the template of the component: <igx-grid [data]=\"records\"> <igx-column field=\"ProductId\"></igx-column> <!-- rest of the column definitions --> ... </igx-grid> Note: The grid autoGenerate property is best to be avoided when binding to remote data for now. It assumes that the data is available in order to inspect it and generate the appropriate columns. This is usually not the case until the remote service responds, and the grid will throw an error. Making autoGenerate available, when binding to remote service, is on our roadmap for future versions. Complex Data Binding The IgxGridComponent supports binding to complex objects (inluding nesting deeper than one level) through a \"path\" of properties in the data record. Take a look at the following data model: interface AminoAcid { name: string; abbreviation: { short: string; long: string; } weight: { molecular: number; residue: number; }, formula: { molecular: string; residue: string; } ... } For example, in order to display the weights of a given amino acid in the grid the following snippet will suffice <igx-column field=\"weight.molecular\"></igx-column> <igx-column field=\"weight.residue\"></igx-column> Refer to the sample below for additional information. This type of binding supports all the default functionality that you would expect from the grid. That is all sorting and filtering operations work out of the box without any additional configuration. Same goes for grouping and editing operations with or without transactions as well as the ability to template the cells of the bound column. Warning The grids do not support this kind of binding for primary key, foreign key and child key properties where applicable. An alternative way to bind complex data, or to visualize composite data (from more than one column) in the IgxGrid is to use a custom body template for the column. Generally, one can: - use the value of the cell, that contains the nested data - use the cell object in the template, from which to access the row.data, therefore retrieve any value from it, i.e cell.row.data[field] and cell.row.data[field][nestedField] and interpolate it those in the template. <igx-column field=\"abbreviation.long\" header=\"Long\"> <ng-template igxCell let-cell=\"cell\"> <div> <div> {{ cell.value }} {{ cell.row.data['name'] }} {{ cell.row.data['weight']['molecular'] }} </div> </div> </ng-template> </igx-column> Below is the data that we are going to use: export const EMPLOYEE_DATA = [ { Age: 55, Employees: [ { Age: 43, HireDate: new Date(2011, 6, 3), ID: 3, Name: \"Michael Burke\", Title: \"Senior Software Developer\" }, { Age: 29, HireDate: new Date(2009, 6, 19), ID: 2, Name: \"Thomas Anderson\", Title: \"Senior Software Developer\" }, { Age: 31, HireDate: new Date(2014, 8, 18), ID: 11, Name: \"Monica Reyes\", Title: \"Software Development Team Lead\" }, { Age: 35, HireDate: new Date(2015, 9, 17), ID: 6, Name: \"Roland Mendel\", Title: \"Senior Software Developer\" }], HireDate: new Date(2008, 3, 20), ID: 1, Name: \"John Winchester\", Title: \"Development Manager\" }, ... The custom template for the column, that will render the nested data: ... <igx-column field=\"Employees\" header=\"Employees\" [cellClasses]=\"{ expand: true }\" width=\"40%\"> <ng-template #nestedDataTemp igxCell let-people let-cell=\"cell\"> <div class=\"employees-container\"> <igx-expansion-panel *ngFor=\"let person of people\"> <igx-expansion-panel-header iconPosition=\"right\"> <igx-expansion-panel-description> {{ person.Name }} </igx-expansion-panel-description> </igx-expansion-panel-header> <igx-expansion-panel-body> <div class=\"description\"> <igx-input-group (keydown)=\"stop($event)\" style=\"--ig-size: var(--ig-size-small)\"> <label igxLabel for=\"title\">Title</label> <input type=\"text\" name=\"title\" igxInput [(ngModel)]=\"person.Title\" style=\"text-overflow: ellipsis;\" /> </igx-input-group> <igx-input-group (keydown)=\"stop($event)\" style=\"--ig-size: var(--ig-size-small); width: 15%;\"> <label igxLabel for=\"age\">Age</label> <input type=\"number\" name=\"age\" igxInput [(ngModel)]=\"person.Age\" /> </igx-input-group> </div> </igx-expansion-panel-body> </igx-expansion-panel> </div> </ng-template> </igx-column> ... And the result from this configuration is: Working with Flat data The flat data binding approach is similar to the one that we already described above, but instead of cell value we are going to use the data property of the IgxGridRow. Since the Angular grid is a component for rendering, manipulating and preserving data records, having access to every data record gives you the opportunity to customize the approach of handling it. The data property provides you this opportunity. Below is the data that we are going to use: export const DATA: any[] = [ { Address: \"Obere Str. 57\", City: \"Berlin\", CompanyName: \"Alfreds Futterkiste\", ContactName: \"Maria Anders\", ContactTitle: \"Sales Representative\", Country: \"Germany\", Fax: \"030-0076545\", ID: \"ALFKI\", Phone: \"030-0074321\", PostalCode: \"12209\", Region: null }, ... ] The custom template: ... <igx-column field=\"Address\" header=\"Address\" width=\"25%\" editable=\"true\"> <ng-template #compositeTemp igxCell let-cell=\"cell\"> <div class=\"address-container\"> // In the Address column combine the Country, City and PostCode values of the corresponding data record <span><strong>Country:</strong> {{cell.row.data.Country}}</span> <br/> <span><strong>City:</strong> {{cell.row.data.City}}</span> <br/> <span><strong>Postal Code:</strong> {{cell.row.data.PostalCode}}</span> </div> </ng-template> </igx-column> Keep in mind that with the above defined template you will not be able to make editing operations, so we need an editor template. <igx-column field=\"Address\" header=\"Address\" width=\"25%\" editable=\"true\"> <ng-template igxCellEditor let-cell=\"cell\"> <div class=\"address-container\"> <span> <strong>Country:</strong> {{cell.row.data.Country}} <igx-input-group width=\"100%\"> <input igxInput [(ngModel)]=\"cell.row.data.Country\" /> </igx-input-group> </span> <br/> <span><strong>City:</strong> {{cell.row.data.City}}</span> <igx-input-group width=\"100%\"> <input igxInput [(ngModel)]=\"cell.row.data.City\" /> </igx-input-group> <br/> <span><strong>Postal Code:</strong> {{cell.row.data.PostalCode}}</span> <igx-input-group width=\"100%\"> <input igxInput [(ngModel)]=\"cell.row.data.PostalCode\" /> </igx-input-group> </div> </ng-template> </igx-column> ... And the result is: Keyboard Navigation Grid's keyboard navigation provides a rich variety of keyboard interactions for the user. It enhances accessibility and allows intuitive navigation through any type of elements inside (cell, row, column header, toolbar, footer, etc.). Check out these resources for more information: Grid Keyboard Navigation TreeGrid Keyboard Navigation Hierarchical Grid Keyboard Navigation Blog post - Improving Usability, Accessibility and ARIA Compliance with Grid keyboard navigation State Persistence Achieving a state persistence framework is easier than ever by using the new built-in IgxGridState directive. Sizing See the Grid Sizing topic. Performance (Experimental) The IgxGridComponent's design allows it to take advantage of the Event Coalescing feature that has Angular introduced. This feature allows for improved performance with roughly around 20% in terms of interactions and responsiveness. This feature can be enabled on application level by simply setting the ngZoneEventCoalescing and ngZoneRunCoalescing properties to true in the bootstrapModule method: platformBrowserDynamic() .bootstrapModule(AppModule, { ngZoneEventCoalescing: true, ngZoneRunCoalescing: true }) .catch(err => console.error(err)); Note This is still in experimental feature for the IgxGridComponent. This means that there might be some unexpected behaviors in the Grid. In case of encountering any such behavior, please contact us on our Github page. Note Enabling it can affects other parts of an Angular application that the IgxGridComponent is not related to. Known Limitations Limitation Description Column widths set in percentage and px Currently we do not support mixing of column widths with % and px. When trying to filter a column of type number If a value different than number is entered into the filtering input, NaN is returned due to an incorrect cast. Grid width does not depend on the column widths The width of all columns does not determine the spanning of the grid itself. It is determined by the parent container dimensions or the defined grid's width. Grid nested in parent container When grid's width is not set and it is placed in a parent container with defined dimensions, the grid spans to this container. Grid OnPush ChangeDetectionStrategy The grid operates with ChangeDetectionStrategy.OnPush so whenever some customization appears make sure that the grid is notified about the changes that happens. Columns have a minimum allowed column width. Depending on the value of [--ig-size] CSS variable, they are as follows: \"small\": 56px \"medium\": 64px \"large \": 80px If width less than the minimum allowed is set it will not affect the rendered elements. They will render with the minimum allowed width for the corresponding [--ig-size]. This may lead to an unexpected behavior with horizontal virtualization and is therefore not supported. Row height is not affected by the height of cells that are not currently rendered in view. Because of virtualization a column with a custom template (that changes the cell height) that is not in the view will not affect the row height. The row height will be affected only while the related column is scrolled in the view. Note igxGrid uses igxForOf directive internally hence all igxForOf limitations are valid for igxGrid. For more details see igxForOf Known Issues section. API References IgxGridComponent IgxGridComponent Styles IgxColumnComponent IgxGridRow IgxGridCell Theming Dependencies IgxIcon Theme IgxInputGroup Theme IgxChip Theme IgxRipple Theme IgxButton Theme IgxOverlay Theme IgxDropDown Theme IgxCalendar Theme IgxSnackBar Theme IgxBadge Theme Tutorial video Learn more about creating an Angular data grid in our short tutorial video: Additional Resources Grid Sizing Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Column Data Types Build CRUD operations with igxGrid Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub The Angular Data Grid is a component for displaying data in a tabular format. Modern grids are complex and are usually packed with a large set of features like data selection, excel style filtering, sorting, paging, grouping, templating, column moving, column pinning, exporting to Excel, CSV formats and more."
  },
  "components/grid/groupby.html": {
    "href": "components/grid/groupby.html",
    "title": "Angular Grid Group By | Group by multiple fields | Infragistics",
    "keywords": "Angular Grid Group By A Group By behavior in an Ignite UI for Angular Table or UI Grid creates grouped data rows based on the column values. The Group By in igxGrid allows for visualizing the groups in a hierarchical structure. The grouped data rows can be expanded or collapsed and the order of grouping may be changed through the UI or API. When Row Selection is enabled, a Group By row selector is rendered in the left-most area of the group row. In case the rowSelection property is set to single, checkboxes are disabled and only serve as an indication for the group where selection is placed. If the rowSelection property is set to multiple, clicking over the Group By row selector selects all records belonging to this group. Angular Grid Group By Example This example presents the grouping capabilities of a large amount of data. Dragging the column headers to the top (grouping area) allows users to see the data for the selected column in a hierarchical structure. They can do group by in multiple fields by dragging more column headers to the top. These grouping options come in handy when you have tables with numerous rows and columns where users want to present the data in a much faster and visually acceptable way. Initial Grouping State It is possible to define initial grouping of the grid by assigning an array of expressions to the groupingExpressions property of the grid. public ngOnInit() { grid.groupingExpressions = [ { fieldName: 'ProductName', dir: SortingDirection.Desc }, { fieldName: 'Released', dir: SortingDirection.Desc } ]; } Grouping expressions implement the ISortingExpression interface. Group By API Grouping API Grouping is available through the UI and through a robust API exposed by the grid component. Developers can allow end-users to group the grid data by certain columns, by setting each column's groupable property to true. <igx-grid [data]=\"data\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [groupable]=\"true\"> </igx-column> </igx-grid> public ngOnInit() { grid.columns.forEach((column) => { column.groupable = true; }); } During runtime the expressions are gettable and settable from the groupingExpressions property. If you need to add or change an existing expression you may also use the groupBy method with either a single or an array of ISortingExpression. grid.groupBy({ fieldName: 'ProductName', dir: SortingDirection.Desc, ignoreCase: true }); Note Up until now, grouping/sorting worked in conjuction with each other. In 13.2 version, a new behavior which decouples gropuing from sorting is introduced. For example - clearing the grouping will not clear sorting expressions in the grid or vice versa. Still, if a column is both sorted and grouped, grouped expressions take precedence. Expand/Collapse API In addition to grouping expressions you can also control the expansion states for group rows. They are stored in a separate property of the igxGrid component groupingExpansionState. A group row is uniquely identified based on the field name it is created for and the value it represents for each level of grouping. This means that the signature of an expansion state interface is the following: export interface IGroupByKey { fieldName: string; value: any; } export interface IGroupByExpandState { hierarchy: Array<IGroupByKey>; expanded: boolean; } As with groupingExpressions, setting a list of IGroupByExpandState directly to the groupingExpansionState will change the expansion accordingly. Additionally igxGrid exposes a method that toggles a group by the group record instance. const groupRow = this.grid.groupsRecords.find(r => r.value === \"France\"); const groupRow = this.grid.getRowByIndex(0).groupRow; grid.toggleGroup(groupRow); groupRow.expanded = false; Groups can be created expanded (default) or collapsed and the expansion states would generally only contain the state opposite to the default behavior. You can control whether groups should be created expanded or not through the groupsExpanded property. Select/Deselect all rows in a group API Selecting/Deselecting all rows in a group is available through the selectRowsInGroup and deselectRowsInGroup API methods. The code snippet below can be used to select all rows within a group using the group record instance selectRowsInGroup method. Additionally, the second parameter of this method is a boolean property through which you may choose whether the previous row selection will be cleared or not. The previous selection is preserved by default. const groupRow = this.grid.groupsRecords.find(r => r.value === \"France\"); const groupRow = this.grid.getRowByIndex(0).groupRow; grid.selectRowsInGroup(groupRow); If you need to deselect all rows within a group programmatically, you can use the deselectRowsInGroup method. const groupRow = this.grid.groupsRecords.find(r => r.value === \"France\"); const groupRow = this.grid.getRowByIndex(0).groupRow; grid.deselectRowsInGroup(groupRow); Templating Group Row Templates The group row except for the expand/collapse UI is fully templatable. By default it renders a grouping icon and displays the field name and value it represents. The grouping record template is rendered against has the following signature: export interface IGroupByRecord { expression: ISortingExpression; level: number; records: GroupedRecords; value: any; groupParent: IGroupByRecord; groups?: IGroupByRecord[]; } As an example, the following template would make the group rows summary more verbose: <ng-template igxGroupByRow let-groupRow> <span>Total items with value: {{ groupRow.value }} are {{ groupRow.records.length }}</span> </ng-template> Group Row Selector Templates As mentioned above the group row except for the expand/collapse UI is fully templatable. To create a custom Group By row selector template within the Grid, declare an <ng-template> with igxGroupByRowSelector directive. From the template, you can access the implicitly provided context variable, with properties that give you information about the Group By row's state. The selectedCount property shows how many of the group records are currently selected while totalCount shows how many records belong to the group. <ng-template igxGroupByRowSelector let-groupByRowContext> {{ groupByRowContext.selectedCount }} / {{ groupByRowContext.totalCount }} </ng-template> The groupRow property returns a reference to the group row. <ng-template igxGroupByRowSelector let-groupByRowContext> <div (click)=\"handleGroupByRowSelectorClick($event, groupByRowContext.groupRow)\">Handle groupRow</div> </ng-template> The selectedCount and totalCount properties can be used to determine if the Group By row selector should be checked or indeterminate (partially selected). <igx-grid #grid [data]=\"gridData\" primaryKey=\"ProductID\" rowSelection=\"multiple\"> <!-- ... --> <ng-template igxGroupByRowSelector let-context> <igx-checkbox [checked]=\" context.selectedCount > 0 && context.selectedCount === context.totalCount\" [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"> </igx-checkbox> </ng-template> </igx-grid> Angular Grid Group By with Paging Group rows participate in the paging process along with data rows. They count towards the page size for each page. Collapsed rows are not included in the paging process. Any expand or collapse operation forces Paging to recalculate the page count and adjust the page index if necessary. Groups that span multiple pages are split between them. The group row is visible only on the page it starts on and is not repeated on subsequent pages. Summary information for group rows is calculated based on the whole group and is unaffected by Paging. Angular group by with paging example Group By with Summaries Integration between Group By and Summaries is described in the Summaries topic. Keyboard Navigation The grouping UI supports the following keyboard interactions: For group rows (focus should be on the row or the expand/collapse cell) ALT + RIGHT - Expands the group ALT + LEFT - Collapses the group SPACE - selects all rows in the group, if rowSelection property is set to multiple For group igxChip components in the group by area (focus should be on the chip) SHIFT + LEFT - moves the focused chip left, changing the grouping order, if possible SHIFT + RIGHT - moves the focused chip right, changing the grouping order, if possible SPACE - changes the sorting direction DELETE - ungroups the field The seperate elements of the chip are also focusable and can be interacted with using the ENTER key. Angular Grid Custom Group By igxGrid allows defining custom grouping per column or per grouping expression, which provides grouping based on a custom condition. This is useful when you need to group by complex objects or for other application specific scenarios. Note In order to implement custom grouping the data first needs to be sorted appropriately. Due to this you may also need to apply a custom sorting strategy that extends the base DefaultSortingStrategy. After the data is sorted the custom groups can be determined by specifying a groupingComparer for the column or for the specific grouping expression. The sample below demonstrates custom grouping by Date, where the date values are sorted and grouped by Day, Week, Month or Year based on user-selected grouping mode. Angular custom group by example The sample defines custom sorting strategies for the different date conditions. Each custom strategy extends the base DefaultSortingStrategy and defines the compareValues method, which is the custom compare function used when sorting the values. Additionally it extracts the values from the date needed for the comparison. class BaseSortingStrategy extends DefaultSortingStrategy { public getParsedDate(date: any) { return { day: date.getDay(), month: date.getMonth() + 1, year: date.getFullYear() }; } compareValues(a: any, b: any) { const dateA = this.getParsedDate(a); const dateB = this.getParsedDate(b); return dateA.year < dateB.year ? -1 : dateA.year > dateB.year ? 1 : dateA.month < dateB.month ? -1 : dateA.month > dateB.month ? 1 : 0; } } class DaySortingStrategy extends BaseSortingStrategy { compareValues(a: any, b: any) { const dateA = this.getParsedDate(a); const dateB = this.getParsedDate(b); return dateA.year < dateB.year ? -1 : dateA.year > dateB.year ? 1 : dateA.month < dateB.month ? -1 : dateA.month > dateB.month ? 1 : dateA.day < dateB.day ? -1 : dateA.day > dateB.day ? 1 : 0; } } class WeekSortingStrategy extends BaseSortingStrategy { public getWeekOfDate(a: any) { return parseInt(new DatePipe(\"en-US\").transform(a, 'w'), 10); } compareValues(a: any, b: any) { const dateA = this.getParsedDate(a); const dateB = this.getParsedDate(b); const weekA = this.getWeekOfDate(a); const weekB = this.getWeekOfDate(b); return dateA.year < dateB.year ? -1 : dateA.year > dateB.year ? 1 : weekA < weekB ? -1 : weekA > weekB ? 1 : 0; } } A groupingComparer function is defined for the grouping expressions, which determines the items belonging to the same group based on the selected grouping mode. Values in the sorted data for which this function returns 0 are marked as part of the same group. groupingComparer: (a, b) => { const dateA = this.sortingStrategy.getParsedDate(a); const dateB = this.sortingStrategy.getParsedDate(b); if (this.groupByMode === 'Month') { return dateA.month === dateB.month ? 0 : -1; } else if (this.groupByMode === \"Year\") { return dateA.year === dateB.year ? 0 : -1; } else if (this.groupByMode === \"Week\") { return this.sortingStrategy.getWeekOfDate(a) === this.sortingStrategy.getWeekOfDate(b) ? 0 : -1; } return dateA.day === dateB.day && dateA.month === dateB.month ? 0 : -1; } From version 15.1.0, you can also use the built-in sorting strategy GroupMemberCountSortingStrategy to sort items based on members count. public sortByGroup() { const expressions = this.grid1.groupingExpressions; if (expressions.length) { const fieldName = expressions[0].fieldName; const dir = expressions[0].dir === SortingDirection.Asc ? SortingDirection.Desc : SortingDirection.Asc; this.grid1.groupBy({ fieldName, dir, ignoreCase: false, strategy: GroupMemberCountSortingStrategy.instance() }); } } Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Group By styling. Importing global theme To begin the customization of the Group By feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the Group By as desired. You also need to extend the chip-theme, because it's used in the Group By feature. $custom-theme: grid-theme( /* Group By properties that affect styling */ $group-row-background: #494949, $group-row-selected-background: #383838, $group-label-column-name-text: #f8f8f8, $group-label-icon: #FFCD0F, $group-label-text: #f8f8f8, $group-count-background: #FFCD0F, $group-count-text-color: #000, $expand-icon-color: #FFCD0F, $expand-icon-hover-color: rgb(223, 181, 13), $cell-active-border-color: #FFCD0F, $row-selected-background: #fff6d3, $row-selected-text-color: #000, $drop-indicator-color: #FFCD0F /* add other features properties here... */ ); /* Chip theme will style the chips in the Group By area */ $custom-chips-theme: chip-theme( $background: #494949, $text-color: #f8f8f8, $hover-text-color: #e7e7e7 ); Defining a custom color palette In the approach that we described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #292826; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $group-row-background: color($custom-palette, \"primary\", 300), $group-row-selected-background: color($custom-palette, \"primary\", 400), $group-label-column-name-text:contrast-color($custom-palette, \"primary\", 500), $group-label-icon: color($custom-palette, \"secondary\", 600), $group-label-text:contrast-color($custom-palette, \"primary\", 500), $group-count-background: color($custom-palette, \"secondary\", 600), $group-count-text-color: color($custom-palette, \"primary\", 400), $expand-icon-color: color($custom-palette, \"secondary\", 600), $expand-icon-hover-color: color($custom-palette, \"secondary\", 300), $cell-active-border-color: color($custom-palette, \"secondary\", 600) ); $custom-chips-theme: chip-theme( $background: color($custom-palette, \"primary\", 300), $text-color:contrast-color($custom-palette, \"primary\", 500), $hover-text-color:contrast-color($custom-palette, \"primary\", 600) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( group-row-background: (igx-color:('secondary', 100)), group-row-selected-background: (igx-color:('primary', 400)), group-label-column-name-text: (igx-color:('primary', 600)), group-label-icon: (igx-color:('primary', 600)), group-label-text: (igx-color:('secondary', 700)), group-count-background: (igx-color:('primary', 600)), group-count-text-color: (igx-color:('secondary', 400)), expand-icon-color: (igx-color:('primary', 600)), expand-icon-hover-color: (igx-color:('primary', 400)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); @include chip($custom-chips-theme); Scoped component theme In order for the custom theme to affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); @include chip($custom-chips-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Limitations Limitation Description Maximum amount of grouped columns is 10. If more than 10 columns are grouped an error is thrown. API References IgxGridComponent IgxGroupByRow IgxGridComponent Styles ISortingExpression IgxColumnComponent IGroupByExpandState IgxChipComponent IgxChipComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Column Moving Summaries Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/keyboard-navigation.html": {
    "href": "components/grid/keyboard-navigation.html",
    "title": "Angular Grid Keyboard Navigation - Ignite UI for Angular",
    "keywords": "Angular Grid Keyboard Navigation Keyboard navigation in the IgxGrid provides a rich variety of keyboard interactions for the user. It enhances the accessibility of the IgxGrid and allows to navigate through any type of elements inside (cell, row, column header, toolbar, footer, etc.). This functionality is enabled by default, and the developer has the option to override any of the default behaviors in an easy way. The tabulations of the IgxGrid has been reduced so that the navigation is compliant with W3C accesibility standards and convenient to use. Currently, the IgxGrid introduces the following tab stops: GroupBy or Toolbar area (if enabled); IgxGrid header; IgxGrid body; Column summaries (if enabled); IgxGrid paginator (if enabled); Note Due to this change, navigating between the cells with tab and Shift + Tab is no longer supported in the IgxGrid. Pressing the Tab key now goes through the tab stops in the following order: GroupBy / Toolbar -> Headers -> Body -> Summaries -> Footer / Paginator. Note Exposing any focusable element into the IgxGrid body via template may introduce side effects in the keyboard navigation, since the default browser behavior is not prevented. It is the developer's responsibility to prevent or modify it appropriately. Header Navigation A full keyboard navigation support in the IgxGrid header is now introduced. Column headers can be easily traversed with the arrow keys. Additionally, there are a number of key combinations that trigger actions on the columns like filtering, sorting, grouping and etc. When the IgxGrid header container is focused, the following key combinations are available: Key Combinations Arrow Up navigates one cell up in the headers (no looping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Down navigates one cell down in the headers (no wrapping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Left navigates one cell left (no looping) Arrow Right navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Home navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Ctrl + Arrow Right navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level End navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level Alt + L opens Advanced Filtering dialog if Advanced Filtering is enabled Ctrl + Shift + L opens the Excel Style Filter dialog or the default (row) filter if the column is filterable Ctrl + Arrow Up sorts the active column header in ASC order. If the column is already sorted in ASC, sorting state is cleared Ctrl + Arrow Down sorts the active column header in DSC order. If the column is already sorted in DSC, sorting state is cleared Space selects the column; If the column is already selected, selection is cleared Shift + Alt + Arrow Left groups the column, if the column is marked as groupable Shift + Alt + Arrow Right ungroups the column, if the column is marked as groupable Alt + Arrow Left or Alt + Arrow Up collapses the column group header, if the header is not already collapsed Alt + Arrow Right or `Alt + Arrow Down expands the column group header, if the header is not already expanded Body navigation When the IgxGrid body is focused, the following key combinations are available: Key Combination Arrow Up- navigates one cell up (no wrapping) Arrow Down navigates one cell down (no wrapping) Arrow Left navigates one cell left (no wrapping between lines) Arrow Right - navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row Ctrl + Arrow Right navigates to the rightmost cell in the row Ctrl + Arrow Up navigates to the first cell in the column Ctrl + Arrow Down navigates to the last cell in the column Home navigates to the leftmost cell in the row End navigates to the rightmost cell in the row Ctrl + Home navigates to the top leftmost data cell in the grid Ctrl + End navigates to the bottom rightmost data cell in the grid Page Up scrolls one page (view port) up Page Down scrolls one page (view port) down Enter enters edit mode F2 enters edit mode Esc exits edit mode Tab available only if there is a cell in edit mode; moves the focus to the next editable cell in the row; after reaching the last cell in the row, moves te focus to the first editable cell in the next row. When Row Editing is enabled, moves the focus from the right-most editable cell to the CANCEL and DONE buttons, and from DONE button to the left-most editable cell in the row Shift + Tab - available only if there is a cell in edit mode; moves the focus to the previous editable cell in the row; after reaching the first cell in the row, moves the focus to the last editable cell in the previous row. When Row Editing is enabled, moves the focus from the right-most editable cell to CANCEL and DONE buttons, and from DONE button to the right-most editable cell in the row Space - selects the row, if Row Selection is enabled Alt + Arrow Left or Alt + Arrow Up - over Group Row - collapses the group Alt + Arrow Right or Alt + Arrow Down - over Group Row - expands the group Alt + Arrow Left or Alt + Arrow Up - over Master Detail Row - collapses the details view Alt + Arrow Right or Alt + Arrow Down - over Master Detail Row - expands the details view Space - over Group Row - selects all rows in the group, if rowSelection property is set to multiple Practice all of the above mentioned actions in the demo sample below. Focus any navigable grid element and a list with some of the available actions for the element will be shown to guide you through. Demo Custom keyboard navigation Overriding the default behavior for a certain key or keys combination is one of the benefits that the Keyboard Navigation feature provides. For example: press the Enter or Tab key to navigate to the next cell or the cell below. This or any other navigation scenario is easily achieved by the Keyboard Navigation API: API Description Arguments gridKeydown An event that is emitted when any of key press/combinations described above is performed. Can be canceled. For any other key press/combination, use the default onkeydown event. IGridKeydownEventArgs activeNodeChange An event that is emitted when the active node is changed. You can use it to determine the Active focus position (header, tbody etc.), column index, row index or nested level. IActiveNodeChangeEventArgs navigateTo Navigates to a position in the grid, based on provided rowindex and visibleColumnIndex. It can also execute a custom logic over the target element, through a callback function that accepts param of type { targetType: GridKeydownTargetType, target: Object } . Usage: grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); }); rowindex: number, visibleColumnIndex: number, callback: ({ targetType: GridKeydownTargetType, target: Object }) => {} getNextCell returns ICellPosition object, which defines the next cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getNextCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const nextEditableCell = grid.getNextCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean getPreviousCell returns ICellPosition object, which defines the previous cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getPreviousCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const prevEditableCell = grid.getPreviousCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean Let's try the API to demonstrate how to achieve common scenarios like user input validation and custom navigation. First we need to register an event handler for the gridKeydown event: <igx-grid #grid1 [data]=\"data\" [primaryKey]=\"'ProductID'\" (gridKeydown)=\"customKeydown($event)\"> public customKeydown(args: IGridKeydownEventArgs) { const target: IgxGridCell = args.target as IgxGridCell; const evt: KeyboardEvent = args.event as KeyboardEvent; const type = args.targetType; if (type === 'dataCell' && target.inEditMode && evt.key.toLowerCase() === 'tab') { // 1. USER INPUT VALIDATON ON TAB } if (type === 'dataCell' && evt.key.toLowerCase() === 'enter') { // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS } } Based on the IGridKeydownEventArgs values we identified two cases, where to provide our own logic (see above). Now, using the methods from the API, let's perform the desired - if the user is pressing Tab key over a cell in edit mode, we will perform validation on the input. If the user is pressing Enter key over a cell, we will move focus to cell in the next row: // 1. USER INPUT VALIDATON ON TAB if (target.column.dataType === 'number' && target.editValue < 10) { // alert the user that the input is invalid return; } // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS this.grid1.navigateTo(target.row.index + 1, target.column.visibleIndex, (obj) => { obj.target.activate(); }); Note Please refer to the sample code for full implementation details. Use the demo below to try out the custom scenarios that we just implemented: Double click or press F2 key on a cell in the Order column, change the value to 7 and press Tab key. Prompt message will be shown. Select a cell and press Enter key a couple of times. Every key press will move the focus to a cell in the next row, under the same column. Demo Known Limitations Limitation Description Navigating inside а grid with scrollable parent container. If the grid is positioned inside a scrollable parent container and the user navigates to a grid cell that is out of view, parent container will not be scrolled. API References IgxGridComponent API IgxGridComponent Styles Additional Resources Hierarchical Grid Keyboard Navigation Tree Grid Keyboard Navigation Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/live-data.html": {
    "href": "components/grid/live-data.html",
    "title": "Live Data Updates in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Live Data Updates The Grid component is able to handle thousands of updates per second, while staying responsive for user interactions. Angular Live-data Update Example The sample below demonstrates the Grid performance when all records are updated multiple times per second. Use the UI controls to choose the number of records loaded and the frequency of updates. Feed the same data into the Line Chart to experience the powerful charting capabilities of Ignite UI for Angular. The Chart button will show Category Prices per Region data for the selected rows and the Chart column button will show the same for the current row. Data binding and updates A service provides data to the component when the page loads, and when the slider controller is used to fetch a certain number of records. While in a real scenario updated data would be consumed from the service, here data is updated in code. This is done to keep the demo simple and focus on its main goal - demonstrate the grid performance. <igx-grid #grid [data]=\"data\"></igx-grid> public ngOnInit() { this.localService.getData(this.volume); this.volumeSlider.onValueChange.subscribe(x => this.localService.getData(this.volume); this.localService.records.subscribe(x => { this.data = x; }); } Angular pipes are used internally to update the grid view. A change in the data field value or a change in the data object/data collection reference will trigger the corresponding pipes. However, this is not the case for columns, which are bound to complex data objects, because the Angular pure pipe will not detect a change in a nested property. To resolve the situation, provide a new object reference for the data object containing the property. Example: <igx-grid #grid [data]=\"data\"> <igx-column field=\"price.usd\"></igx-column> </igx-grid> private updateData(data: IRecord[]) { const newData = [] for (const rowData of data) { rowData.price = { usd: getUSD(), eur: getEUR() }; newData.push({...rowData}); } this.grid.data = newData; } Templates Updating the view works the same way for columns with a default template and for columns with a custom template. However, it is recommended to keep custom templates relatively simple. As number of elements in the template grows, negative performance impact rises as well. Live-data feed with Dock Manager and igxGrid Components The purpose of this demo is to showcase a financial screen board with Real-time data stream using a SignalR hub back-end. As you can see the igxGrid component handles with ease the high-frequency updates from the server. The code for the ASP.NET Core application using SignalR could be found in this public GitHub repository. Start the hub connection The signal-r.service handles the connectivity and updates of the exposed manageable parameters frequency, volume and live-update state toggle (Start/Stop). this.hubConnection = new signalR.HubConnectionBuilder() .configureLogging(signalR.LogLevel.Trace) .withUrl('https://www.infragistics.com/angular-apis/webapi/streamHub') .build(); this.hubConnection .start() .then(() => { this.hasRemoteConnection = true; this.registerSignalEvents(); this.broadcastParams(interval, volume, live, updateAll); }) .catch(() => {}); Based on the specified frequency a total of 30 new updates will be received by the Grids from the server. A specific cellStyle classes are applied to the three columns that are handling the changes (Price, Change and Change in percent). Update frequency and data volume By using the Action panel on the left, you can manage the frequency of the data feed and the volume of the requested data. All grids use the same data source. Feel free to use the other action elements to stop the data feed, change the application theme or add dynamically a DockSlot container with a igxGrid. We use the 'updateparameters' method to request a new set of data with certain frequency. This method is part of the SignalR stream hub implementation. this.hubConnection.invoke('updateparameters', frequency, volume, live, updateAll) .then(() => console.log('requestLiveData', volume)) .catch(err => { console.error(err); }); Dynamically create DockSlot and Grid components By using the ComponentFactoryResolver we are able to create DockSlot and Grid components on the fly. DockManager component Take leverage of the Dock Manager WebComponent and build your own webview by using the docket or floating panels. In order to add a new floating panel, go ahead and open the Action pane on the right and click the 'Add floating pane' button. Drag and drop the new pane at the desired location. API References IgxGridComponent IgxGridComponent Styles IgxColumnComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow IgxGridCell Additional Resources Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/master-detail.html": {
    "href": "components/grid/master-detail.html",
    "title": "Angular Master-Detail Grid - Ignite UI for Angular",
    "keywords": "Angular Master-Detail Grid The igxGrid component supports specifying a detail template that displays additional details for a particular row by expanding/collapsing its content. When specified each record acts as a master, which upon expansion shows a customizable details template with contextual data for the current record. This mode is useful when you need to display master-detail style data in a hierarchical structure. Angular Grid Master-Detail Example Configuration To configure the igxGrid to display in master-detail mode you need to specify a template inside the grid, marked with the igxGridDetail directive: <igx-grid ... > <ng-template igxGridDetail let-dataItem> <!-- Custom detail template content here --> </ng-template> </igx-grid> Context of the template is the master record data, so that values from the master record can be displayed in the detail template. For example: <igx-grid ... > <ng-template igxGridDetail let-dataItem> <div *ngIf=\"dataItem.Category\"> <header>{{dataItem.Category.CategoryName}}</header> <span>{{dataItem.Category.Description}}</span> </div> </ng-template> </igx-grid> API The expansion states can be controlled via the expansionStates input of the igxGrid. States are stored in key-value pairs [row identifier, expansion state]. The property gets/sets the current expansion states and supports two-way binding: <igx-grid [(expansionStates)]='expansionState' > ... </igx-grid> Additional API methods for controlling the expansion states are also exposed: expandAll collapseAll toggleRow expandRow collapseRow Keyboard navigation When focus is on a detail row: Arrow Up - navigates one row up, focusing a cell from the previous row. Arrow Down - navigates one row down, focusing a cell from the next row. Tab - Allows focus to move to the next focusable element inside the template if there are focusable elements, otherwise moves to the next grid row. Shift + Tab - moves the focus to the previous row. When focus is on a data row with expander: Alt + Arrow Right/ Down - expands the row. Alt + Arrow Left/Down - collapses the row. Known Issues and Limitations Known Limitations Description Tab navigation inside the custom detail template may not update the master grid scroll position in case the next focused element is outside the visible view port. Tab navigation inside the custom detail template is left up to the browser. When templating a grid inside the details view that has a <igx-column> definitions, the parent grid will also render those columns. This can be avoided using autoGenerate=true for the nested grid. In case some aspect of those columns need to be modfied the columnInit event can be used. Details template will not be exported to Excel. As the details template can contain any type of content we cannot export it to excel out of the box. The search feature will not hightlight elements from the details template. API References IgxGridComponent IgxGridComponent Styles IgxColumnComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow IgxGridCell View page on GitHub"
  },
  "components/grid/multi-column-headers.html": {
    "href": "components/grid/multi-column-headers.html",
    "title": "Angular Multi-column Headers - Ignite UI for Angular",
    "keywords": "Angular Grid Multi-column Headers Overview IgxGrid supports multi-column headers which allows you to group columns by placing them under a common multi headers. Each multi-column headers group could be a representation of combinations between other groups or columns within the Material UI grid. Angular Grid Multi-column Headers Overview Example The declaration of Multi-column header could be achieved by wrapping a set of columns into igx-column-group component with header title passed. <igx-grid [data]=\"data\" [allowFiltering]=\"true\"> <igx-column-group header=\"Contact Information\"> <igx-column sortable=\"true\" resizable=\"true\" field=\"Phone\"></igx-column> <igx-column sortable=\"true\" resizable=\"true\" field=\"Fax\"></igx-column> <igx-column sortable=\"true\" resizable=\"true\" field=\"PostalCode\"></igx-column> </igx-column-group> </igx-grid> For achieving n-th level of nested headers, the declaration above should be followed. So by nesting igx-column-group leads to the desired result. <igx-grid [data]=\"data\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column-group header=\"General Information\"> <igx-column sortable=\"true\" resizable=\"true\" field=\"CompanyName\"></igx-column> <igx-column-group header=\"Person Details\"> <igx-column [pinned]=\"false\" sortable=\"true\" resizable=\"true\" field=\"ContactName\"></igx-column> <igx-column sortable=\"true\" resizable=\"true\" field=\"ContactTitle\"></igx-column> </igx-column-group> </igx-column-group> </igx-grid> Every igx-column-group supports moving, pinning and hiding. Note When there is a set of columns and column groups, pinning works only for top level column parents. More specifically pinning per nested column groups or columns is not allowed. Please note that when using Pinning with Multi-Column Headers, the entire Group gets pinned. Moving between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. When columns/column-groups are not wrapped by current group which means they are top level columns, moving is allowed between whole visible columns. <igx-grid [data]=\"data\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column-group [pinned]=\"true\" header=\"General Information\"> <igx-column sortable=\"true\" resizable=\"true\" field=\"CompanyName\"></igx-column> </igx-column-group> <igx-column sortable=\"true\" resizable=\"true\" field=\"Phone\"></igx-column> <igx-column sortable=\"true\" resizable=\"true\" field=\"Fax\"></igx-column> <igx-column sortable=\"true\" resizable=\"true\" field=\"PostalCode\"></igx-column> </igx-grid> Multi-column Header Template Each of the column groups of the grid can be templated separately. The column group expects ng-template tag decorated with the igxHeader directive. The ng-template is provided with the column group object as a context. ... <igx-column-group header=\"General Information\"> <ng-template igxHeader let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... </igx-column-group> ... If you want to re-use a single template for several column groups, you could set the headerTemplate property of the column group like this: <ng-template #columnGroupHeaderTemplate let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... <igx-column-group header=\"General Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> <igx-column-group header=\"Address Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> ... Note If a column header is retemplated and the grid moving is enabled, you have to set the draggable attribute of corresponding column to false on the templated elements, so that you can handle any of the events that are applied! <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> The following sample demonstrates how to implement collapsible column groups using header templates. Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $header-background, $header-text-color, $header-border-width, $header-border-style and $header-border-color parameters. $custom-theme: grid-theme( $header-background: #e0f3ff, $header-text-color: #e41c77, $header-border-width: 1px, $header-border-style: solid, $header-border-color: rgba(0, 0, 0, 0.08) ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $light-blue-color: #e0f3ff; $deep-pink-color: #e41c77; $custom-palette: palette($primary: $light-blue-color, $deep-pink-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $header-background: color($custom-palette, \"primary\", 500), $header-text-color: color($custom-palette, \"secondary\", 500), $header-border-width: 1px, $header-border-style: solid, $header-border-color: color($custom-palette, \"grays\", 200) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( header-background: (igx-color:('primary', 500)), header-text-color: (igx-color:('secondary', 500)), header-border-width: 1px, header-border-style: solid, header-border-color: (igx-color:('grays', 200)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations Using Grid with multi-column headers on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API References IgxGridComponent IgxGridComponent Styles IgxColumnGroupComponent Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Resizing Selection Group by Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/multi-row-layout.html": {
    "href": "components/grid/multi-row-layout.html",
    "title": "Angular Grid Multi-row Layout - Ignite UI for Angular",
    "keywords": "Angular Multi-row Layout Multi-row Layout extends the rendering capabilities of the igxGridComponent. The feature allows splitting a single data record into multiple visible rows. Angular Multi-row Layout Example The declaration of Multi-row Layout is achieved through igx-column-layout component. Each igx-column-layout component should be considered as a block, containing one or multiple igx-column components. Some of the grid features work on block level (those are listed in the \"Feature Integration\" section below). For example the virtualization will use the block to determine the virtual chunks, so for better performance split the columns into more igx-column-layout blocks if the layout allows it. There should be no columns outside of those blocks and no usage of IgxColumnGroupComponent when configuring a multi-row layout. Multi-row Layout is implemented on top of the grid layout specification and should conform to its requirements. IgxColumnComponent exposes four @Input properties to determine the location and span of each cell: colStart - column index from which the field is starting. This property is mandatory. rowStart - row index from which the field is starting. This property is mandatory. colEnd - column index where the current field should end. The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field. This property is optional. If not set defaults to colStart + 1. rowEnd - row index where the current field should end. The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field. This property is optional. If not set defaults to rowStart + 1. <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [rowEnd]=\"3\" field=\"ID\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"CompanyName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"2\" field=\"ContactName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"2\" [colEnd]=\"3\" field=\"ContactTitle\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"Country\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"3\" [colEnd]=\"5\" field=\"Region\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"5\" [colEnd]=\"7\" field=\"PostalCode\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"4\" field=\"City\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"4\" [colEnd]=\"7\" field=\"Address\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" field=\"Phone\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" field=\"Fax\"></igx-column> </igx-column-layout> The result of the above configuration can be seen on the screenshot below: Note rowStart and colStart properties must be set for each igx-column into igx-column-layout. The igxColumnLayout component is not verifying if the layout is correct and not throwing errors or warnings about that. The developers must make sure that the declaration of their layout is correct and complete, otherwise they may end up in broken layout with misalignments, overlaps and browser inconsistencies. Feature Integration Due to the completly different rendering approach of Multi-row Layout, some of the column features will work only on igx-column-layout component. Such features are Column Pinning and Column Hiding. Othes like - Sorting and Grouping will work in the same way - on igx-column component. Filtering - only Excel Style Filtering is supported. Setting filterMode explicitly to FilterMode.quickFilter has no effect. Paging - works on records, not visual rows. Group By - hideGroupedColumns option has no effect in Multi-row Layout. The grouped columns are always visible. The following features are currently not supported: Column Moving Multi-column Headers Export to Excel Summaries Keyboard Navigation IgxGridComponent with Multi-Row Layouts provides build-in keyboard navigation. Horizontal nagivation Arrow Left or Arrow Right - move to the adjacent cell on the left/right within the current row unaffected by the column layouts that are defined. If the current cell spans on more than one row, Arrow Left and Arrow Right should navigate to the first cell on the left and right with the same rowStart, unless you have navigated to some other adjacent cell before. The navigation stores the starting navigation cell and navigates to the cells with the same rowStart if possible. Ctrl + Arrow Left (HOME) or Ctrl + Arrow Right (END) - navigate to the start or end of the row and select the cell with accordance to the starting navigation cell. Vertical nagivation Arrow Up or Arrow Down - move to the cell above/below in relation to a starting position and is unaffected by the rows. If the current cell spans on more than one column the next active cell will be selected with accordance to the starting navigation cell. Ctrl + Arrow Up or Ctrl + Down - Navigate and apply focus on the same column on the first or on the last row. Ctrl + Home or Ctrl + End - Navigate to the first row and focus first cell or navigate to the last row and focus the last cell. Note Navigation through cells which span on multiple rows or columns is done with accordance to the starting navigation cell and will allow returning to the starting cell using the key for the opposite direction. The same approach is used when navigating through group rows. Note Selection and multi cell selection are working on layout, meaning that when a cell is active, its layout will be selected. Also all features of multiple selection like drag selection are applicable and will work per layout not per cell. Custom Keyboard Navigation The grid allows customizing the default navigation behavior when a certain key is pressed. Actions like going to the next cell or cell below could be handled easily with the powerful keyboard navigation API: gridKeydown is exposed. The event will emit IGridKeydownEventArgs. This event is available only through the keyboard key combinations mentioned above, for all other key actions you can use keydown event (keydown)=\"onKeydown($event)\" navigateTo - this method allows you to navigate to a position based on provided rowindex and visibleColumnIndex The demo below adds additional navigation down/up via the Enter and Shift + Enter keys, similar to the behavior observed in Excel. Demo Layout Configurator Sometimes when configuring a column layout it might be a challenge to calculate and set the proper colStart and colEnd or rowStart and rowEnd. Especially when there are a lot of columns in a single layout. That is why we have created a small configurator, so you can easily do that and have a similar preview of how it would look inside the igxGrid when applied. You can do the following interactions with it: Set number of rows for the whole configuration. All layouts must have the same amount of rows. Add/Remove column layouts by clicking the Add Layout chip or reordering them by dragging a layout chip left/right. Set specific settings for each layout as number of columns and how wide they will be. The setting refer to the currently selected layout. Resize column cells in the layout preview so they can span more columns/rows or clear them using the Delete button. Set columns in the preview by dragging a column chip in the place your will want it to be. Add/Remove new columns by using the Add Column chip. Get template output of the whole configuration ready to by placed inside an igxGrid or the JSON representation that can also be used and parsed in your template using NgForOf for example. By default we have set the same columns as our previous sample, but it can be cleared and configured to match your desired configuration. Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Multi-row Layout styling. Importing global theme To begin the customization of the Multi-row Layout feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the feature layout as desired. $custom-theme: grid-theme( $cell-active-border-color: #ffcd0f, $cell-selected-background: #6f6f6f, $row-hover-background: #fde069, $row-selected-background: #8d8d8d, $header-background: #494949, $header-text-color: #fff, $sorted-header-icon-color: #ffcd0f, $sortable-header-icon-hover-color: #e9bd0d ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #494949; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $cell-active-border-color: color($custom-palette, \"secondary\", 500), $cell-selected-background: color($custom-palette, \"primary\", 300), $row-hover-background: color($custom-palette, \"secondary\", 300), $row-selected-background: color($custom-palette, \"primary\", 100), $header-background: color($custom-palette, \"primary\", 500), $header-text-color:contrast-color($custom-palette, \"primary\", 500), $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"secondary\", 600) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 300)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('secondary', 600)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme do affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridComponent IgxGridComponent Styles IgxColumnLayoutComponent IgxColumnComponent Additional Resources Grid overview Virtualization and Performance Paging Sorting Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/paging.html": {
    "href": "components/grid/paging.html",
    "title": "Angular Grid Paging | Angular Pagination Table | Infragistics",
    "keywords": "Angular Grid Pagination Pagination is used to split a large set of data into a sequence of pages that have similar content. Angular table pagination improves user experience and data interaction. Grid pagination is configurable via a separate component projected in the grid tree by defining a igx-paginator tag, similar to adding of a column. As in any Angular Table, the pagination in the Grid supports template for custom pages. Angular Pagination Example The following example represents Grid pagination and exposes the options usage of items per page and how paging can be enabled. The user can also quickly navigate through the Grid pages via \"Go to last page\" and \"Go to first page\" buttons. Adding a igx-paginator component will control whether the feature is present, you can enable/disable it by using a simple *ngIf with a toggle property. The perPage input controls the visible records per page. Let’s update our Grid to enable paging: <igx-grid #grid [data]=\"data\" [height]=\"'500px'\" [width]=\"'100%'\"> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-grid> Example: <igx-paginator #paginator [totalRecords]=\"20\"> <igx-paginator-content> <div id=\"numberPager\" style=\"justify-content: center;\"> <button [disabled]=\"paginator.isFirstPage\" (click)=\"paginator.previousPage()\" igxButton=\"flat\"> PREV </button> <span> Page {{paginator.page}} of {{paginator.totalPages}} </span> <button [disabled]=\"paginator.isLastPage\" (click)=\"paginator.nextPage()\" igxButton=\"flat\"> NEXT </button> </div> </igx-paginator-content> </igx-paginator> Paging with Group By Group rows participate in the paging process along with data rows. They count towards the page size for each page. Collapsed rows are not included in the paging process. Integration between Paging and Group By is described in the Group By topic. Usage The igx-paginator component is used along with the igx-grid component in the example below, but you can use it with any other component in case paging functionality is needed. <igx-grid #grid [data]=\"data\"> <igx-paginator #paginator [(page)]=\"grid.page\" [totalRecords]=\"grid.totalRecords\" [(perPage)]=\"10\" [selectOptions]=\"selectOptions\"> </igx-paginator> </igx-grid> Paginator Component Demo Remote Paging Remote paging can be achieved by declaring a service, responsible for data fetching and a component, which will be responsible for the Grid construction and data subscription. For more detailed information, check the Grid Remote Data Operations topic. Remote Paging with Custom Template In some cases you may want to define your own paging behavior and this is when we can take advantage of the igx-paginator-content and add our custom logic along with it. This section explains how we are going to extend the Remote Paging example in order to demonstrate this. Pagination Styling in Angular To get started with styling the paginator, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the paginator-theme and accepts the $text-color, $background-color and the $border-color parameters. $dark-paginator: paginator-theme( $text-color: #F4D45C, $background-color: #575757, $border-color: #292826 ); As seen, the paginator-theme only controls colors for the paging container, but does not affect the buttons in the pager UI. To style those buttons, let's create a new button theme: $dark-button: button-theme( $icon-color: #FFCD0F, $icon-hover-color: #292826, $icon-hover-background: #FFCD0F, $icon-focus-color: #292826, $icon-focus-background: #FFCD0F, $disabled-color: #16130C ); In this example we only changed the icon color and background and the button disabled color, but the the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include grid-paginator($dark-grid-paginator); .igx-grid-paginator__pager { @include button($dark-button); } Note We scope the igx-button mixin within .igx-paginator__pager, so that only the paginator buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include paginator($dark-paginator); .igx-paginator__pager { @include button($dark-button); } } } Defining a Color Palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F9D342; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the pallette. $dark-paginator: paginator-theme( $palette: $dark-palette, $text-color: color($dark-palette, \"secondary\", 400), $background-color: color($dark-palette, \"primary\", 200), $border-color: color($dark-palette, \"primary\", 500) ); $dark-button: button-theme( $palette: $dark-palette, $icon-color: color($dark-palette, \"secondary\", 700), $icon-hover-color: color($dark-palette, \"primary\", 500), $icon-hover-background: color($dark-palette, \"secondary\", 500), $icon-focus-color: color($dark-palette, \"primary\", 500), $icon-focus-background: color($dark-palette, \"secondary\", 500), $disabled-color: color($dark-palette, \"primary\", 700) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-pagination and dark-button schemas: // Extending the dark paginator schema $dark-paginator-schema: extend($_dark-pagination, ( text-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ), border-color:( color:( \"primary\", 500) ) ) ); // Extending the dark button schema $dark-button-schema: extend($_dark-button, ( icon-color:( color:(\"secondary\", 700) ), icon-hover-color:( color:(\"primary\", 500) ), icon-hover-background:( color:(\"secondary\", 500) ), icon-focus-color:( color:(\"primary\", 500) ), icon-focus-background:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-paginator: $dark-paginator-schema, igx-button: $dark-button-schema )); // Definingpaginator-theme with the global dark schema $dark-paginator: paginator-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $dark-button: button-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Pagination Style Example API References IgxGridComponent API IgxGridComponent Styles IgxGridPaginator Styles Additional Resources Grid overview Paginator Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/paste-excel.html": {
    "href": "components/grid/paste-excel.html",
    "title": "Angular Excel Like Grid - Paste Form Excel - Infragistics",
    "keywords": "Angular Grid Paste from Excel The Ignite UI for Angular IgxGrid can read Excel data that is copied to the clipboard. In this section we will show you how to do this with some custom code. Angular Paste from Excel Example This sample demonstrates how to implement pasting from Excel into the igxGrid Material UI table. To work with the sample open up any Excel spreadsheet, copy some rows, and paste it into the grid using the keyboard (Ctrl + V, Shift + Insert, Command + V). On the top there is a dropdown button with 2 options: \"Paste data as new rows\" – in this mode any data copied from Excel will be appended to the grid as new rows \"Paste starting from active cell\" – in this mode the data in the grid will be overwritten. The new data after the paste is decorated in Italic. Usage You should add the paste-handler directive (you can find its code in the next section) to the igxGrid and handle its onDataProcessed event. The onDataProcessed event has one parameter that gives you access to the Excel data in the form of an array. For reference see the addRecords and updateRecords methods. <igx-grid #grid1 [data]=\"data\" [width]=\"'100%'\" [height]=\"'505px'\" [autoGenerate]=\"false\" paste-handler (onDataProcessed)=\"dataPasted($event)\" [primaryKey]=\"'ID'\"> <igx-column [field]=\"'Name'\"></igx-column> <igx-column [field]=\"'Title'\"></igx-column> <igx-column [field]=\"'Phone'\"></igx-column> <igx-column [field]=\"'Country'\"></igx-column> </igx-grid> public dataPasted(processedData) { if (this.pasteMode === \"Paste data as new records\") { this.addRecords(processedData); } else { this.updateRecords(processedData); } } public addRecords(processedData: any[]) { const columns = this.grid1.visibleColumns; const pk = this.grid1.primaryKey; const addedData = []; for (const curentDataRow of processedData) { const rowData = {}; for (const col of columns) { rowData[col.field] = curentDataRow[col.visibleIndex]; } // generate PK rowData[pk] = this.grid1.data.length + 1; this.grid1.addRow(rowData); addedData.push(rowData); this.grid1.cdr.detectChanges(); } // scroll to last added row this.grid1.verticalScrollContainer.scrollTo(this.grid1.data.length); this.grid1.verticalScrollContainer.chunkLoad.pipe(take(1)).subscribe(() => { this.clearStyles(); for (const data of addedData) { const row = this.grid1.getRowByKey(data[pk]); if (row) { row.nativeElement.style[\"font-style\"] = \"italic\"; row.nativeElement.style.color = \"gray\"; } } }); } public updateRecords(processedData: any[]) { const cell = this.grid1.selectedCells[0]; const pk = this.grid1.primaryKey; if (!cell) { return; } const rowIndex = cell.row.index; // const rowPkValue = cell.row.data[pk]; const cellIndex = cell.column.visibleIndex; const columns = this.grid1.visibleColumns; let index = 0; const updatedRecsPK = []; for (const curentDataRow of processedData) { const rowData = {}; const dataRec = this.grid1.data[rowIndex + index]; const rowPkValue = dataRec ? dataRec[pk] : this.grid1.data.length + 1; rowData[pk] = rowPkValue; for (let j = 0; j < columns.length; j++) { let currentCell; if (j >= cellIndex) { currentCell = curentDataRow.shift(); } const colKey = columns[j].field; rowData[colKey] = currentCell || (!!dataRec ? dataRec[colKey] : null); } if (!dataRec) { // no rec to update, add instead rowData[pk] = rowPkValue; this.grid1.addRow(rowData); continue; } this.grid1.updateRow(rowData, rowPkValue); this.grid1.cdr.detectChanges(); updatedRecsPK.push(rowPkValue); index++; } this.clearStyles(); for (const pkVal of updatedRecsPK) { const row = this.grid1.getRowByKey(pkVal); if (row) { row.nativeElement.style[\"font-style\"] = \"italic\"; row.nativeElement.style.color = \"gray\"; } } } protected clearStyles() { for (const row of this.grid1.rowList.toArray()) { row.nativeElement.style[\"font-style\"] = \"\"; row.nativeElement.style.color = \"\"; } } Paste Handler Directive This is the paste-handler implementation. The code creates a DOM textarea element which is used to receive the pasted data from the clipboard. When the data is pasted in the textarea the directive parses it into an array and then emits a custom event onDataProcessed passing the parsed data. import { Directive, EventEmitter, HostListener, Output} from \"@angular/core\"; @Directive({ selector: \"[paste-handler]\" }) export class PasteHandler { public textArea; @Output() public onDataProcessed = new EventEmitter<any>(); public ngOnInit(): void { const div = document.createElement(\"div\"); const divStyle = div.style; divStyle.position = \"fixed\"; document.body.appendChild(div); this.textArea = document.createElement(\"textarea\"); const style = this.textArea.style; style.opacity = \"0\"; style.height = \"0px\"; style.width = \"0px\"; style.overflow = \"hidden\"; div.appendChild(this.textArea); this.textArea.addEventListener(\"paste\", (eventArgs) => { this.onPaste(eventArgs); }); } @HostListener(\"focusin\", [\"$event\"]) public focusIn(eventArgs) { } @HostListener(\"keydown\", [\"$event\"]) public ControlV(eventArgs) { const ctrl = eventArgs.ctrlKey; const key = eventArgs.keyCode; // Ctrl-V || Shift-Ins || Cmd-V if ((ctrl || eventArgs.metaKey) && key === 86 || eventArgs.shiftKey && key === 45) { this.textArea.focus(); } } public onPaste(eventArgs) { let data; const clData = \"clipboardData\"; // get clipboard data - from window.cliboardData for IE or from the original event's arguments. if (window[clData]) { window.event.returnValue = false; data = window[clData].getData(\"text\"); } else { data = eventArgs[clData].getData(\"text/plain\"); } // process the clipboard data const processedData = this.processData(data); this.onDataProcessed.emit(processedData); } public processData(data) { const pasteData = data.split(\"\\n\"); for (let i = 0; i < pasteData.length; i++) { pasteData[i] = pasteData[i].split(\"\\t\"); // Check if last row is a dummy row if (pasteData[pasteData.length - 1].length === 1 && pasteData[pasteData.length - 1][0] === \"\") { pasteData.pop(); } // remove empty data if (pasteData.length === 1 && pasteData[0].length === 1 && (pasteData[0][0] === \"\" || pasteData[0][0] === \"\\r\")) { pasteData.pop(); } } return pasteData; } } API References IgxGridComponent Additional Resources Excel Exporter - Use the Excel Exporter service to export data to Excel from IgxGrid. It also provides the option to only export the selected data from the IgxGrid. The exporting functionality is encapsulated in the IgxExcelExporterService class and the data is exported in MS Excel table format. This format allows features like filtering, sorting, etc. To do this you need to invoke the IgxExcelExporterService's export method and pass the IgxGrid component as first argument. Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/remote-data-operations.html": {
    "href": "components/grid/remote-data-operations.html",
    "title": "Angular Grid Remote Data Operations - Ignite UI for Angular",
    "keywords": "Angular Grid Remote Data Operations The Ignite UI for Angular Grid supports remote data operations such as remote virtualization, remote sorting, remote filtering and others. This allows the developer to perform these tasks on a server, retrieve the data that is produced and display it in the Grid. Angular Grid Remote Data Operations Overview Example By default, the Grid uses its own logic for performing data operations. You can perform these tasks remotely and feed the resulting data to the Grid by taking advantage of certain inputs and events, which are exposed by the Grid. Remote Virtualization The IgxGrid supports the scenario in which the data chunks are requested from a remote service, exposing the behavior implemented in the igxForOf directive it uses internally. To utilize this feature, you need to subscribe to the dataPreLoad output so that you make the appropriate request based on the arguments received, as well as set the public IgxGrid property totalItemCount with the respective information coming from the service. <igx-grid #grid [data]=\"remoteData | async\" [autoGenerate]=\"false\" (dataPreLoad)=\"processData(false)\" (sortingDone)=\"processData(true)\"> <igx-column [field]=\"'ProductID'\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'ProductName'\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'UnitPrice'\" [dataType]=\"'number'\" [formatter]=\"formatCurrency\" [sortable]=\"true\"></igx-column> </igx-grid> public ngAfterViewInit() { this.grid.isLoading = true; this._remoteService.getData(this.grid.virtualizationState, this.grid.sortingExpressions[0], true, (data) => { this.grid.totalItemCount = data['@odata.count']; this.grid.isLoading = false; }); } public processData(reset) { if (this.prevRequest) { this.prevRequest.unsubscribe(); } this._prevRequest = this._remoteService.getData(this.grid.virtualizationState, this.grid.sortingExpressions[0], reset, () => { ... this.cdr.detectChanges(); }); } When requesting data, you need to utilize the IForOfState interface, which provides the startIndex and chunkSize properties. Note The first chunkSize will always be 0 and should be determined by you based on the specific application scenario. Remote Virtualization Demo Infinite Scroll A popular design for scenarios requiring fetching data by chunks from an end-point is the so-called infinite scroll. For data grids, it is characterised by continuous increase of the loaded data triggered by the end-user scrolling all the way to the bottom. The next paragraphs explain how you can use the available API to easily achieve infinite scrolling in IgxGrid. To implement infinite scroll, you have to fetch the data in chunks. The data that is already fetched should be stored locally and you have to determine the length of a chunk and how many chunks there are. You also have to keep a track of the last visible data row index in the grid. In this way, using the startIndex and chunkSize properties, you can determine if the user scrolls up and you have to show them already fetched data or scrolls down and you have to fetch more data from the end-point. The first thing to do is use the ngAfterViewInit lifecycle hook to fetch the first chunk of the data. Setting the totalItemCount property is important, as it allows the grid to size its scrollbar correctly. public ngAfterViewInit() { this._remoteService.loadDataForPage(this.page, this.pageSize, (request) => { if (request.data) { this.grid.totalItemCount = this.page * this.pageSize; this.grid.data = this._remoteService.getCachedData({startIndex: 0, chunkSize: 10}); this.totalItems = request.data['@odata.count']; this.totalPageCount = Math.ceil(this.totalItems / this.pageSize); this.grid.isLoading = false; } }); } Additionally, you have to subscribe to the dataPreLoad output, so that you can provide the data needed by the grid when it tries to display a different chunk, rather than the currently loaded one. In the event handler, you have to determine whether to fetch new data or return data, that's already cached locally. public handlePreLoad() { const isLastChunk = this.grid.totalItemCount === this.grid.virtualizationState.startIndex + this.grid.virtualizationState.chunkSize; // when last chunk reached load another page of data if (isLastChunk) { if (this.totalPageCount === this.page) { this.grid.data = this._remoteService.getCachedData(this.grid.virtualizationState); return; } this.page++; this.grid.isLoading = true; this._remoteService.loadDataForPage(this.page, this.pageSize, (request) => { if (request.data) { this.grid.totalItemCount = Math.min(this.page * this.pageSize, this.totalItems); this.grid.data = this._remoteService.getCachedData(this.grid.virtualizationState); this.grid.isLoading = false; } }); } else { this.grid.data = this._remoteService.getCachedData(this.grid.virtualizationState); } } Infinite Scroll Demo Remote Sorting/Filtering To provide remote sorting and filtering, you need to subscribe to the dataPreLoad, sortingExpressionsChange and filteringExpressionsTreeChange outputs, so that you make the appropriate request based on the arguments received, as well as set the public IgxGrid property totalItemCount with the respective information coming from the service. We will also take advantage of the rxjs debounceTime function, which emits a value from the source Observable only after a particular time span has passed without another source emission. This way the remote operation will be triggered only when the specified amount of time has passed without the user interrupting it. const DEBOUNCE_TIME = 300; ... public ngAfterViewInit() { ... this.grid.dataPreLoad.pipe( debounceTime(DEBOUNCE_TIME), takeUntil(this.destroy$) ).subscribe(() => { this.processData(); }); this.grid.filteringExpressionsTreeChange.pipe( debounceTime(DEBOUNCE_TIME), takeUntil(this.destroy$) ).subscribe(() => { this.processData(true); }); this.grid.sortingExpressionsChange.pipe( debounceTime(DEBOUNCE_TIME), takeUntil(this.destroy$) ).subscribe(() => { this.processData(); }); } When remote sorting and filtering are provided, usually we do not need the built-in sorting and filtering of the grid. We can disable them by setting the sortStrategy and the filterStrategy inputs of the grid to the NoopSortingStrategy and the NoopFilteringStrategy respective instances. <igx-grid #grid [data]=\"remoteData | async\" [height]=\"'500px'\" [width]=\"'100%'\" [autoGenerate]='false' [filterStrategy]=\"noopFilterStrategy\" [sortStrategy]=\"noopSortStrategy\" [allowFiltering]=\"true\"> ... </igx-grid> public noopFilterStrategy = NoopFilteringStrategy.instance(); public noopSortStrategy = NoopSortingStrategy.instance(); Note When remote data is requested, the filtering operation is case-sensitive. Remote Sorting/Filtering Demo You can see the result of the code from above at the beginning of this article in the Demo section. Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. The Grid generates these values based on its data source by default. In case of remote filtering, the grid data does not contain all the data from the server. In order to provide the unique values manually and load them on demand, we can take advantage of the Grid's uniqueColumnValuesStrategy input. This input is actually a method that provides three arguments: column - The respective column instance. filteringExpressionsTree - The filtering expressions tree, which is reduced based on the respective column. done - Callback that should be called with the newly generated column values when they are retrieved from the server. The developer can manually generate the necessary unique column values based on the information, that is provided by the column and the filteringExpressionsTree arguments and then invoke the done callback. Note When the uniqueColumnValuesStrategy input is provided, the default unique values generating process in the excel style filtering will not be used. <igx-grid #grid1 [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... </igx-grid> public columnValuesStrategy = (column: ColumnType, columnExprTree: IFilteringExpressionsTree, done: (uniqueValues: any[]) => void) => { // Get specific column data. this.remoteValuesService.getColumnData(column, columnExprTree, uniqueValues => done(uniqueValues)); } Unique Column Values Strategy Demo In order to provide a custom loading template for the excel style filtering, we can use the igxExcelStyleLoading directive: <igx-grid [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... <ng-template igxExcelStyleLoading> Loading ... </ng-template> </igx-grid> Remote Paging The paging feature can operate with remote data. In order to demonstrate this let's first declare our service that will be responsible for data fetching. We will need the count of all data items in order to calculate the page count. This logic will be added to our service. @Injectable() export class RemotePagingService { public remoteData: BehaviorSubject<any[]>; public dataLenght: BehaviorSubject<number> = new BehaviorSubject(0); public url = 'https://www.igniteui.com/api/products'; constructor(private http: HttpClient) { this.remoteData = new BehaviorSubject([]) as any; } public getData(index?: number, perPage?: number): any { let qS = ''; if (perPage) { qS = `?$skip=${index}&$top=${perPage}&$count=true`; } this.http .get(`${this.url + qS}`).pipe( map((data: any) => data) ).subscribe((data) => this.remoteData.next(data)); } public getDataLength(): any { return this.http.get(this.url).pipe( map((data: any) => data.length) ); } } After declaring the service, we need to create a component, which will be responsible for the Grid construction and data subscription. export class RemotePagingGridSample implements OnInit, AfterViewInit, OnDestroy { public data: Observable<any[]>; private _dataLengthSubscriber; constructor(private remoteService: RemoteService) {} public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngOnDestroy() { if (this._dataLengthSubscriber) { this._dataLengthSubscriber.unsubscribe(); } } } Now we can choose between setting-up our own custom paging template or using the default one that the igx-paginator provides. Let's first take a look what is necessary to set-up remote paging by using the default paging template. Remote paging with default template If you want to use the default paging template you need to set the Paginator's totalRecords property, only then the grid will be able to calculate the total page number based on total remote records. When performing a remote pagination the Paginator will pass to the Grid only the data for the current page, so the grid will not try to paginate the provided data source. That's why we should set Grid's pagingMode property to GridPagingMode.remote. Also it is necessary to either subscribe to pagingDone or perPageChange events in order to fetch the data from your remote service, it depends on the use case which event will be used. <igx-grid #grid1 [data]=\"data | async\" [isLoading]=\"isLoading\" [pagingMode]=\"mode\"> <igx-column field=\"ID\"></igx-column> ... <igx-paginator [(page)]=\"page\" [(perPage)]=\"perPage\" [totalRecords]=\"totalCount\" (pagingDone)=\"paginate($event.current)\"> </igx-paginator> </igx-grid> public totalCount = 0; public data: Observable<any[]>; public mode = GridPagingMode.remote; public isLoading = true; @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; private _dataLengthSubscriber; public set perPage(val: number) { this._perPage = val; this.paginate(0); } public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data: any) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngAfterViewInit() { const skip = this.page * this.perPage; this.remoteService.getData(skip, this.perPage); } public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } Remote Paging with custom igx-paginator-content When we define a custom paginator content we need to define the content in a way to get the data only for the requested page and to pass the correct skip and top parameters to the remote service according to the selected page and items perPage. We are going to use the <igx-paginator> in order to ease our example configuration, along with the IgxPageSizeSelectorComponent and IgxPageNavigationComponent that were introduced - igx-page-size will add the per page dropdown and label and igx-page-nav will add the navigation action buttons and labels. <igx-paginator #paginator [totalRecords]=\"totalCount\" [(page)]=\"page\" [(perPage)]=\"perPage\" [selectOptions]=\"selectOptions\" (pageChange)=\"paginate($event)\" (perPageChange)=\"perPageChange($event)\"> <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> </igx-paginator> @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; private _perPage = 15; private _dataLengthSubscriber: { unsubscribe: () => void; } | undefined; constructor(private remoteService: RemotePagingService) { } public ngAfterViewInit() { this.grid1.isLoading = true; this.remoteService.getData(0, this.perPage); } public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } public perPageChange(perPage: number) { const skip = this.page * perPage; const top = perPage; this.remoteService.getData(skip, top); } Note In order the Remote Paging to be configured properly a GridPagingMode.Remote should be set: <igx-grid #grid1 [data]=\"data | async\" width=\"100%\" height=\"580px\" [pagingMode]=\"mode\"></igx-grid> ... public mode = GridPagingMode.Remote; The last step will be to declare the paginator content based on your requirements. <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> After all the changes above, the following result will be achieved. Remote Paging with custom paginator In some cases you may want to define your own paging behavior and this is when we can take advantage of the Paging template and add our custom logic along with it. We are going to extend the Remote Paging example in order to demonstrate this: Below you will find the methods that we've defined in order to implement our own next and previous page actions. @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; public ngAfterViewInit() { this.grid1.isLoading = true; this.remoteService.getData(0, this.perPage); } public nextPage() { this.firstPage = false; this.page++; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); if (this.page + 1 >= this.totalPages) { this.lastPage = true; } this.setNumberOfPagingItems(this.page, this.totalPages); } public previousPage() { this.lastPage = false; this.page--; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); if (this.page <= 0) { this.firstPage = true; } this.setNumberOfPagingItems(this.page, this.totalPages); } public paginate(page: number, recalculate = false) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; if (recalculate) { this.totalPages = Math.ceil(this.totalCount / this.perPage); } this.setNumberOfPagingItems(this.page, this.totalPages); this.remoteService.getData(skip, top); this.buttonDeselection(this.page, this.totalPages); } Remote Paging with Batch editing With the examples so far we clarified how to set up the IgxGrid with remote data. Now, let's focus on enabling batch editing for the grid by following the Batch Editing topic/guide. Before continuing with the sample it is good to clarify the current use case. When pagination is done on the server, the grid contains the data only for the current page and if we add new rows the newly added rows (with Batch Editing) will be concatenated with the current data that the grid contains. Therefore, if the server returns no data for a given page, grid's data source will be consisted only from the newly added rows, which the grid will paginate based on the defined pagination settings (page, perPage). public ngOnInit() { this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data) => { this.totalCount = data; this._recordOnServer = data; this._totalPagesOnServer = Math.floor(this.totalCount / this.perPage); this.grid1.isLoading = false; }); } In order to handle this use case properly, we need to implement some custom logic. First, we have to know the total number of records that are on the server. Given that, we calculate the total number of data pages on the server (see this._totalPagesOnServer ) and based on its value, we will implement the custom pagination logic. public paginate(page: number) { this.grid1.endEdit(true); if (page > this._totalPagesOnServer) { if (this.page !== this._totalPagesOnServer) { const skipEl = this._totalPagesOnServer * this.perPage; this.remoteService.getData(skipEl, this.perPage); } this.page = page - this._totalPagesOnServer; this.page = page; return; } else { this.page = 0; } this.page = page; const skip = this.page * this.perPage; this.remoteService.getData(skip, this.perPage); } As you can see in the paginate method, custom pagination logic is performed, based on the _totalPagesOnServer value. Remote Paging with Batch Editing Demo Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. API References IgxPaginatorComponent API IgxGridComponent API IgxGridComponent Styles Additional Resources Paging Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/row-actions.html": {
    "href": "components/grid/row-actions.html",
    "title": "Row actions in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Row Actions in Angular Data Grid The grid component in Ignite UI for Angular provides the ability to use ActionStrip and utilize CRUD for row/cell components and row pinning. The Action Strip component can host predefined UI controls for these operations. Usage The first step is to import the IgxActionStripModule in our app.module.ts file: // app.module.ts ... import { IgxActionStripModule } from 'igniteui-angular'; // import { IgxActionStripModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxActionStripModule], ... }) The predefined actions UI components are: IgxGridEditingActionsComponent - includes functionality and UI specifically designed for the grid editing. It allows you to quickly toggle edit mode for cells or rows, depending on the rowEditable option and row deletion of the grid. IgxGridPinningActionsComponent - includes functionality and UI specifically designed for the grid row pinning. It allows you to quickly pin rows and navigate between pinned rows and their disabled counterparts. They are added inside the <igx-action-strip> and this is all needed to have an Action Strip providing default interactions. <igx-grid [data]=\"data\" [rowEditable]=\"true\" [primaryKey]=\"'ID'\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-grid> Note When IgxActionStripComponent is a child component of the grid, hovering a row will automatically show the UI. Custom implementation These components expose templates giving flexibility for customization. For instance, if we would like to use the ActionStrip for a Gmail scenario with row actions such as delete, edit and etc. You can simply create button component with igx-icon, add click event to it and insert it into the igx-action-strip component. <igx-grid> <igx-action-strip #actionstrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <button title=\"Edit\" igxIconButton=\"flat\" igxRipple (click)='startEdit(actionstrip.context)'> <igx-icon>edit</igx-icon> </button> <button title=\"Delete\" igxIconButton=\"flat\" igxRipple *ngIf='!isDeleted(actionstrip.context)' (click)='actionstrip.context.delete()'> <igx-icon>delete</igx-icon> </button> </igx-action-strip> </igx-grid> Note The predefined actions inherit IgxGridActionsBaseDirective and when creating a custom grid action component, it should also inherit IgxGridActionsBaseDirective. API References For more detailed information regarding the Action Strip API, refer to the following links: IgxActionStripComponent API Additional components and/or directives that can be used within the Action Strip: IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent IgxDividerDirective View page on GitHub"
  },
  "components/grid/row-adding.html": {
    "href": "components/grid/row-adding.html",
    "title": "Adding Rows in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Adding Rows in Angular Grid The Grid provides a convenient way to perform data manipulations through inline row adding and a powerful API for Angular CRUD operations. Add an Action Strip component with editing actions enabled in the grid's template, hover a row and use the provided button or press ALT + + to spawn the row adding UI. Angular Grid Row Adding Example The following sample demonstrates how to enable native row adding in the Grid. Changing a cell value and then clicking or navigating to another cell on the same row doesn't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Row Adding Usage To get started import the IgxGridModule in the app.module.ts file: // app.module.ts ... import { IgxGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxGridModule], ... }) export class AppModule {} Then define a Grid with bound data source and rowEditable set to true and an Action Strip component with editing actions enabled. The addRow input controls the visibility of the button that spawns the row adding UI. <igx-grid [data]=\"data\" [primaryKey]=\"'ProductID'\" [autoGenerate]=\"false\" [rowEditable]=\"true\"> <igx-column field=\"ProductID\" header=\"Product ID\" dataType=\"number\"></igx-column> <igx-column field=\"ReorderLevel\" header=\"ReorderLever\" dataType=\"number\"></igx-column> <igx-column field=\"ProductName\" header=\"ProductName\" dataType=\"string\"></igx-column> <igx-column field=\"UnitsInStock\" header=\"UnitsInStock\" dataType=\"number\"></igx-column> <igx-column field=\"OrderDate\" dataType=\"date\"></igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" dataType=\"boolean\"></igx-column> <igx-action-strip #actionstrip> <igx-grid-editing-actions [addRow]=\"true\"></igx-grid-editing-actions> </igx-action-strip> </igx-grid> Note Setting primary key is mandatory for row adding operations. Note Every column excluding the primary key one is editable in the row adding UI by default. If you want to disable editing for a specific column, then you have to set the editable column's input to false. Note The IgxGridEditingActions input controlling the visibility of the add row button may use the action strip context (which is of type RowType) to fine tune which records the button shows for. The internal IgxBaseTransactionService is automatically provided for Grid. It holds pending cell changes until the row state is submitted or cancelled. Start Row Adding Programmatically Grid allows to programmatically spawn the add row UI by using two different public methods. One that accepts a row ID for specifying the row under which the UI should spawn and another that works by index. You can use these methods to spawn the UI anywhere within the current data view. Changing the page or specifying a row that is e.g. filtered out is not supported. Using beginAddRowById requires you to specify the row to use as context for the operation by its rowID (PK). The method then functions as though the end-user clicked on the add row action strip button for the specified row, spawning the UI under it. You can also make the UI spawn as the very first row in the grid by passing null for the first parameter. this.grid.beginAddRowById('ALFKI'); // spawns the add row UI under the row with PK 'ALFKI' this.grid.beginAddRowById(null); // spawns the add row UI as the first record The beginAddRowByIndex method works similarly but requires you to specify the index at which the UI should spawn. Allowed values range between 0 and the size of the data view - 1. this.grid.beginAddRowByIndex(10); // spawns the add row UI at index 10 this.grid.beginAddRowByIndex(0); // spawns the add row UI as the first record Positioning The Default position row add UI is below the row that the end user clicked the add row button for. The Grid scrolls to fully display the add row UI automatically. The overlay for the add row UI maintains its position during scrolling. Behavior The add row UI has the same behavior as the row editing one as they are designed to provide a consistent editing experience to end users. Please, refer to the Grid Row Editing topic for more information. After a new row is added through the row adding UI, its position and/or visibility is determined by the sorting, filtering and grouping state of the Grid. In a Grid that does not have any of these states applied, it appears as the last record. A snackbar is briefly displayed containing a button the end user may use to scroll the Grid to its position if it is not in view. Keyboard Navigation ALT + + - Enters edit mode for adding a row ESC exits row adding mode without submitting any changes TAB move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any row adding operation will stop if the data view of the Grid gets modified. Any changes made by the end user are submitted. Operations that change the data view include but are not limited to sorting, grouping, filtering, paging, etc. Summaries are updated after the row add operation finishes. The same is valid for the other data view dependant features such as sorting, filtering, etc. Customizing Row Adding Overlay Customizing Text Customizing the text of the row adding overlay is possible using the igxRowAddTextDirective. <ng-template igxRowAddText> Adding Row </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Note Using igxRowEditActions directive will change edit actions for both editing and adding overlay buttons. Remote scenarios In most remote data scenarios the Primary Key assignment happens on the create server request. In this case the added records on the client will not have the final primary key value until saved on the server's data base. In that case the recommended way to handle this update in the Grid is as follows: If the Grid does not use transactions. Once the create request is successfully completed and returns the added record data, you can replace that record's id in the local data record instance. If the Grid uses transactions. Once the create request or batch update request is successfully completed and returns the added record instances (with their db generated ids), the related ADD transactions should be cleared from the transaction log using the clear API method. This is necessary because the local transaction will have a generated id field, which may differ than the one created in the data base, so they should be cleared. You can then add the record(s) passed in the response to the local data instance. This will ensure that the remotely generated ids are always reflected in the local data, and subsequent update/delete operations target the correct record ids. Styling The row adding UI comprises the buttons in the IgxActionStrip editing actions, the editing editors and overlay, as well as the snackbar which allows end users to scroll to the newly added row. To style these components you may refer to these comprehensive guides in their respective topics: Grid Row Editing IgxSnackbar IgxActionStrip API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit primaryKey IgxGridComponent IgxActionStripComponent IgxGridEditingActionsComponent Additional Resources Grid Overview Grid Editing Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/row-drag.html": {
    "href": "components/grid/row-drag.html",
    "title": "Row Dragging in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Row Dragging in Angular Grid In Ignite UI for Angular Grid, RowDrag is initialized on the root igx-grid component and is configurable via the rowDraggable input. Enabling row dragging provides users with a row drag-handle with which they can initiate dragging of a row. Angular Grid Row Drag Example Configuration In order to enable row-dragging for your igx-grid, all you need to do is set the grid's rowDraggable to true. Once this is enabled, a row-drag handle will be displayed on each row. This handle can be used to initiate row dragging. <igx-grid [rowDraggable]=\"true\"> ... </igx-grid> Clicking on the drag-handle and moving the cursor while holding down the button will cause the grid's rowDragStart event to fire. Releasing the click at any time will cause rowDragEnd event to fire. Below, you can find a walkthrough on how to configure an igx-grid to support row dragging and how to properly handle the drop event. In this example, we'll handle dragging a row from one grid to another, removing it from the first data source and adding it to the second. Drop Areas Enabling row-dragging was pretty easy, but now we have to configure how we'll handle row-dropping. We can define where we want our rows to be dropped using the igxDrop directive. First we need to import the IgxDragDropModule in our app module: import { ..., IgxDragDropModule } from 'igniteui-angular'; // import { ..., IgxDragDropModule } from '@infragistics/igniteui-angular'; for licensed package ... @NgModule({ imports: [..., IgxDragDropModule] }) Then, in our template, we define a drop-area using the directive's selector: In this case, our drop-area will be a whole second grid where we'll drop the rows. <igx-grid #targetGrid igxDrop [data]=\"data2\" [autoGenerate]=\"false\" [emptyGridTemplate]=\"dragHereTemplate\" (enter)=\"onEnterAllowed($event)\" (leave)=\"onLeaveAllowed($event)\" (dropped)=\"onDropAllowed($event)\" [primaryKey]=\"'ID'\"> ... </igx-grid> Since the grid will initially be empty, we also define a template that will be more meaningful to the user: <ng-template #dragHereTemplate> Drop a row to add it to the grid </ng-template> You may enable animation when a row is dropped on a non-droppable area using the animation parameter of the rowDragEnd event. If set to true, the dragged row will animate back to its' original position when dropped over a non-droppable area. You may enable animation like this: export class IgxGridRowDragComponent { public onRowDragEnd(args) { args.animation = true; } } Drop Area Event Handlers Once we've defined our drop-area in the template, we have to declare our handlers for the igxDrop's enter, leave and dropped events in our component's .ts file. First, let's take a look at our enter and leave handlers. In those methods, we just want to change the icon of the drag's ghost so we can indicate to the user that they are above an area that allows them to drop the row: export class IgxGridRowDragComponent { public onEnterAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.ALLOW); } public onLeaveAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.DEFAULT); } private changeGhostIcon(ghost, icon: string) { if (ghost) { const currentIcon = ghost.querySelector('.igx-grid__drag-indicator > igx-icon'); if (currentIcon) { currentIcon.innerText = icon; } } } } The changeGhostIcon private method just changes the icon inside of the drag ghost. The logic in the method finds the element that contains the icon (using the igx-grid__drag-indicator class that is applied to the drag-indicator container), changing the element's inner text to the passed one. The icons themselves are from the material font set and are defined in a separate enum: enum DragIcon { DEFAULT = 'drag_indicator', ALLOW = 'add' } Next, we have to define what should happen when the user actually drops the row inside of the drop-area. export class IgxGridRowDragComponent { @ViewChild('sourceGrid', { read: IgxGridComponent }) public sourceGrid: IgxGridComponent; @ViewChild('targetGrid', { read: IgxGridComponent }) public targetGrid: IgxGridComponent; public onDropAllowed(args) { this.targetGrid.addRow(args.dragData.data); this.sourceGrid.deleteRow(args.dragData.key); } } We define a reference to each of our grids via the ViewChild decorator and the handle the drop as follows: add a row to the targetGrid that contains the data of the row being dropped remove the dragged row from the sourceGrid Note When using row data from the event arguments (args.dragData.data) or any other row property, note that the entire row is passed in the arguments as a reference, which means that you must clone the data you need, if you want to distinguish it from the one in the source grid. Templating the drag ghost The drag ghost can be templated using the IgxRowDragGhost directive, applied to a <ng-template> inside of the igx-grid's body: <igx-grid> ... <ng-template igxRowDragGhost> <div> <igx-icon fontSet=\"material\">arrow_right_alt</igx-icon> </div> </ng-template> ... </igx-grid> The result of the configuration can be seem below in a igx-grid with row dragging and multiple selection enabled. The demo shows the count of the currently dragged rows: Example Demo Templating the drag icon The drag handle icon can be templated using the grid's dragIndicatorIconTemplate. In the example we're building, let's change the icon from the default one (drag_indicator) to drag_handle. To do so, we can use the igxDragIndicatorIcon to pass a template inside of the igx-grid's body: <igx-grid> ... <ng-template igxDragIndicatorIcon> <igx-icon>drag_handle</igx-icon> </ng-template> ... </igx-grid> Once we've set the new icon template, we also need to adjust the DEFAULT icon in our DragIcon enum, so it's properly change by the changeIcon method: enum DragIcon { DEFAULT = \"drag_handle\", ... } Once our drop handlers are properly configured, we're good to go! The result of the configuration can be seem below: Example Demo Application Demo Using Row Drag Events The following demo demonstrates how to use row drag event information to change both states of a custom component, where the row is dropped, and the source grid itself. Try to drag moons from the grid and drop them to their corresponding planets. Row drag ghost background is dynamically changed, depending on the hovered planet. If you succeed then the row in the grid will be selected and dragging will be disabled for it. Clicking planets will give you useful information. Note The classes applied to the row drag ghost, used in the demo above, are using ::ng-deep modifier, because row drag is an internal grid feature and cannot be accessed on application level, due to the CSS encapsulation. Row Reordering Demo With the help of the grid's row drag events and the igxDrop directive, you can create a grid that allows you to reorder rows by dragging them. Since all of the actions will be happening inside of the grid's body, that's where you have to attach the igxDrop directive: <igx-grid #grid [data]=\"data\" [rowDraggable]=\"true\" [primaryKey]=\"'ID'\" igxDrop (dropped)=\"onDropAllowed($event)\"> ... </igx-grid> Note Make sure that there is a primaryKey specified for the grid! The logic needs an unique identifier for the rows so they can be properly reordered Once rowDraggable is enabled and a drop zone has been defined, you need to implement a simple handler for the drop event. When a row is dragged, check the following: Was the row dropped inside of the grid? If so, on which other row was the dragged row dropped? Once you've found the target row, swap the records' places in the data array Below, you can see this implemented in the component's .ts file: export class GridRowReorderComponent { public onDropAllowed(args) { const event = args.originalEvent; const currRowIndex = this.getCurrentRowIndex(this.grid.rowList.toArray(), { x: event.clientX, y: event.clientY }); if (currRowIndex === -1) { return; } this.grid.deleteRow(args.dragData.key); this.data.splice(currRowIndex, 0, args.dragData.data); } private getCurrentRowIndex(rowList, cursorPosition) { for (const row of rowList) { const rowRect = row.nativeElement.getBoundingClientRect(); if (cursorPosition.y > rowRect.top + window.scrollY && cursorPosition.y < rowRect.bottom + window.scrollY && cursorPosition.x > rowRect.left + window.scrollX && cursorPosition.x < rowRect.right + window.scrollX) { return this.data.indexOf(this.data.find((r) => r.rowID === row.rowID)); } } return -1; } } With these few easy steps, you've configured a grid that allows reordering rows via drag/drop! You can see the above code in action in the following demo. Holding onto the drag icon will allow you to move a row anywhere in the grid: Improving UX in row drag scenarios Being able to obtain the row index which is currently below the cursor provides you with the opportunity to build rich custom functionalities and to improve the UX of your application. For example, you can change the drag ghost or display a drop indicator, based on the position of the dragged row over the grid. Another useful behavior that you can achieve that way is to scroll the grid up or down while dragging a row, when reaching the border of the grid. Below you can find example snippets of a couple of custom implementations you can achieve by knowing the row's position. Changing the drag ghost based on cursor position In the snippets below you see how you can change the text inside the drag ghost to display the name of the hovered row. First, you specify a template which you'd like to use for the drag ghost. The dropName property will dynamically change, getting the name of the row over which the cursor is hovering: <ng-template igxRowDragGhost> <div class=\"customGhost\"> <div>{{ dropName }}</div> </div> </ng-template> Then, define a method that returns the instance of the row you're over (similar to the one used in the row reordering demo): class MyRowGhostComponent { private getRowDataAtPoint(rowList: IgxGridRowComponent[], cursorPosition: Point): any { for (const row of rowList) { const rowRect = row.nativeElement.getBoundingClientRect(); if (cursorPosition.y > rowRect.top + window.scrollY && cursorPosition.y < rowRect.bottom + window.scrollY && cursorPosition.x > rowRect.left + window.scrollX && cursorPosition.x < rowRect.right + window.scrollX) { return this.data.find((r) => r.rowID === row.rowID); } } return null; } } Finally, we create a method that will be used to handle the IgxDragDirective.dragMove event (emitted for the dragged row). The method will change the value of the property used in the igxRowDragGhost template and force a rerender. We want to subscribe to the dragMove event only of the specific row we're dragging and unsub from it (to prevent memory leaks) each time a row is dropped. class MyRowGhostComponent { public ngAfterViewInit(): void { this.grid.rowDragStart.pipe(takeUntil(this.destroy$)).subscribe(this.onRowDragStart.bind(this)); } private onRowDragStart(e: IRowDragStartEventArgs) { if (e !== null) { this._draggedRow = e.dragData.rowData; } const directive = e.dragDirective; directive.dragMove .pipe(takeUntil(this.grid.rowDragEnd)) .subscribe(this.onDragMove.bind(this)); } private onDragMove(args: IDragMoveEventArgs) { const cursorPosition = this.getCursorPosition(args.originalEvent); const hoveredRowData = this.getRowDataAtPoint( this.grid.rowList.toArray(), cursorPosition ); if (!hoveredRowData) { args.cancel = true; return; } const rowID = hoveredRowData.ID; if (rowID !== null) { let newName = this.dropName; if (rowID !== -1) { const targetRow = this.grid.rowList.find((e) => { return e.rowData.ID === rowID; }); newName = targetRow?.rowData.Name; } if (newName !== this.dropName) { this.dropName = newName; args.owner.cdr.detectChanges(); } } } } Displaying a drop indicator based on cursor position In the demo in the next section you see how you can display an indicator of where the dragged row would be dropped. You can customize this indicator as you like - it may be a placeholder row, placed at the position where the dragged row would be dropped, a border style indicating if the dragged row would be dropped above or below the currently hovered row, etc. In order to track the position of the cursor, we bind to the dragMove event of the IgxDragDirective when we start dragging a row. Note Make sure that there is a primaryKey specified for the grid! The logic needs an unique identifier for the rows so they can be properly reordered public ngAfterViewInit() { this.grid.rowDragStart .pipe(takeUntil(this.destroy$)) .subscribe(this.handleRowStart.bind(this)); } private handleRowStart(e: IRowDragStartEventArgs): void { if (e !== null) { this._draggedRow = e.dragData.data; } const directive = e.dragDirective; directive.dragMove .pipe(takeUntil(this.grid.rowDragEnd)) .subscribe(this.handleDragMove.bind(this)); } private handleDragMove(event: IDragMoveEventArgs): void { this.handleOver(event); } private handleOver(event: IDragMoveEventArgs) { const ghostRect = event.owner.ghostElement.getBoundingClientRect(); const rowIndex = this.getRowIndexAtPoint(this.grid.rowList.toArray(), { x: ghostRect.x, y: ghostRect.y }); if (rowIndex === -1) { return; } const rowElement = this.grid.rowList.find( e => e.rowData.ID === this.grid.data[rowIndex].ID ); if (rowElement) { this.changeHighlightedElement(rowElement.element.nativeElement); } } private clearHighlightElement(): void { if (this.highlightedRow !== undefined) { this.renderer.removeClass(this.highlightedRow, 'underlined-class'); } } private setHightlightElement(newElement: HTMLElement) { this.renderer.addClass(newElement, 'underlined-class'); this.highlightedRow = newElement; } private changeHighlightedElement(newElement: HTMLElement) { if (newElement !== undefined) { if (newElement !== this.highlightedRow) { this.clearHighlightElement(); this.setHightlightElement(newElement); } else { return; } } } Scrolling the grid on row drag A very useful scenario is being able to scroll the grid when the dragged row reaches its' top or bottom border. This allows reordering rows outside of the current viewport when the number of rows in the grid requires a scrollbar. Below you see an example of the two methods we use to check if we have reached the edge of the viewport and to scroll it if needed. The isGridScrolledToEdge accepts one parameter - the direction we'd like to scroll the grid (1 for \"Down\", -1 for \"Up\") and returns true if we've reach the final row in that direction. The scrollGrid method will attempt to scroll the grid in a direction (1 or -1), doing nothing if the grid is already at that edge. class MyGridScrollComponent { private isGridScrolledToEdge(dir: 1 | -1): boolean { if (this.grid.data[0] === this.grid.rowList.first.data && dir === -1) { return true; } if ( this.grid.data[this.grid.data.length - 1] === this.grid.rowList.last.data && dir === 1 ) { return true; } return false; } private scrollGrid(dir: 1 | -1): void { if (!this.isGridScrolledToEdge(dir)) { if (dir === 1) { this.grid.verticalScrollContainer.scrollNext(); } else { this.grid.verticalScrollContainer.scrollPrev(); } } } } We'll still be subscribing to the dragMove event of the specific row in the way we did in the previous example. Since dragMove is fired only when the cursor actually moves, we want to have a nice and simple way to auto-scroll the grid when the row is at one of the edges, but the user does not move the mouse. We'll an additional method which will setup an interval, auto-scrolling the grid every 500ms. We create and subscribe to the interval when the pointer reaches the grid's edge and we unsubscribe from that interval everytime the mouse moves or the row is dropped (regardless of cursor position). class MyGridScrollComponent { public ngAfterViewInit() { this.grid.rowDragStart .pipe(takeUntil(this.destroy$)) .subscribe(this.onDragStart.bind(this)); this.grid.rowDragEnd .pipe(takeUntil(this.destroy$)) .subscribe(() => this.unsubInterval()); } private onDragMove(event: IDragMoveEventArgs): void { this.unsubInterval(); const dir = this.isPointOnGridEdge(event.pageY); if (!dir) { return; } this.scrollGrid(dir); if (!this.intervalSub) { this.interval$ = interval(500); this.intervalSub = this.interval$.subscribe(() => this.scrollGrid(dir)); } } private unsubInterval(): void { if (this.intervalSub) { this.intervalSub.unsubscribe(); this.intervalSub = null; } } } Following is the example of both scenarios described above - showing a drop indicator and scrolling the viewport when border's edge is reached. Limitations Currently, there are no known limitations for the rowDraggable directive. API References rowDraggable rowDragStart rowDragEnd IgxGridComponent Additional Resources Grid Overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/row-editing.html": {
    "href": "components/grid/row-editing.html",
    "title": "Editing Rows in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Row Editing The Grid provides a convenient way to perform data manipulations through inline editing and a powerful API for Angular CRUD operations. Click on a row and press Enter key or simply double click with the mouse on the row that needs to be modified. Angular Grid Row Editing Example The following sample demonstrates how to enable row editing in the Grid. Changing a cell value and then clicking or navigating to another cell on the same row won't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Note When a row is in edit mode, then clicking on a cell on another row will act like the Done button is pressed - submit all the changes of the previous row. If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. Row Editing Usage To get started import the IgxGridModule in the app.module.ts file: // app.module.ts ... import { IgxGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxGridModule], ... }) export class AppModule {} Then define a Grid with bound data source and rowEditable set to true: <igx-grid [data]=\"data\" [primaryKey]=\"'ProductID'\" width=\"100%\" height=\"500px\" [rowEditable]=\"true\"> <igx-column field=\"ProductID\" header=\"Product ID\" editable=\"false\"></igx-column> <igx-column field=\"ReorderLevel\" header=\"ReorderLever\" [dataType]=\"'number'\"></igx-column> <igx-column field=\"ProductName\" header=\"ProductName\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"UnitsInStock\" header=\"UnitsInStock\" [dataType]=\"'number'\"> <ng-template igxCellEditor let-cell=\"cell\"> <input name=\"units\" [(ngModel)]=\"cell.value\" style=\"color: black\" /> </ng-template> </igx-column> <igx-column field=\"OrderDate\" [dataType]=\"'date'\"></igx-column> <igx-column field=\"Discontinued\" header=\"Discontinued\" [dataType]=\"'boolean'\"></igx-column> </igx-grid> Note Setting primary key is mandatory for row editing operations. Note It's not needed to enable editing for individual columns. Using the rowEditable property in the Grid, will mean that all rows, with defined field property, excluding primary one, will be editable. If you want to disable editing for specific column, then you set the editable column's input to false. import { Component, ViewChild } from '@angular/core'; import { data } from './data'; import { IgxGridComponent } from 'igniteui-angular'; // import { IgxGridComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-grid-row-edit', styleUrls: [`grid-row-editing-sample.component.css`], templateUrl: 'grid-row-editing-sample.component.html' }) export class GridRowEditSampleComponent { @ViewChild('gridRowEdit', { read: IgxGridComponent }) public gridRowEdit: IgxGridComponent; public data: any[]; constructor() { this.data = data; } } Note The Grid uses internally a provider IgxBaseTransactionService that holds pending cell changes, until row state submitted or cancelled. Positioning Default position of the overlay will be below the row that is in edit mode If there is no space below the row then overlay will appear above the row. Once shown - top or bottom, overlay will maintain this position during scrolling, until the overlay is closed. Behavior If row is in edit mode, then editing will continue, if a cell from the same row is clicked. Clicking \"Done\" button will finish row editing and will submit changes either to the data source, or to a transaction if available. In addition row will exit edit mode. Clicking \"Cancel\" button will revert all current changes in the row and row will exit edit mode. If row is in edit mode, then clicking a cell from another row will finish the current row edit and will submit new row changes (the same behavior clicking \"Done\" button). If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. If row is in edit mode and Grid is scrolled so that row goes outside the visible area, the latter will be still in edit mode. When Grid is scrolled, so that the row is visible again, the row will be still in edit mode. When clicked outside the Grid, the cell will also stay in edit mode. When perform sorting, filtering, searching and hiding operations, will revert all current changes in the row and row will exit edit mode. When perform paging, resizing, pinning and moving operations, will exit edit mode and will submit latest value. Each modified cell gets edited style until row edit is finished. This is the behavior, when Grid is not provided with transactions. When transactions are available - then cell edit style is applied until all the changes are committed. Keyboard Navigation Enter and F2 enters row edit mode Esc exits row edit mode and doesn't submit any of the cell changes, made while the row was in edit mode. Tab move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any data changing operation will terminate row editing operations and will submit current row changes. This will include operations like sorting, changing grouping and filtering criteria, paging, etc. Summaries will be updated after row edit is finished. Same is valid for the other features like sorting, filtering, etc. Expanding and collapsing grouped rows will not terminate editing for the current row. Customizing Row Editing Overlay Customizing Text Customizing the text of the row editing overlay is possible using the igxRowEditTextDirective. The rowChangesCount property is exposed and it holds the count of the changed cells. <ng-template igxRowEditText let-rowChangesCount> Changes: {{rowChangesCount}} </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Styling Using the Ignite UI for Angular Theme Library, we can greatly alter the Row Editing overlay. The Row Editing overlay is a composite element - its UI is comprised of a couple of other components: - igx-banner in order to render its contents - igx-buttons are rendered in the default template (for the Done and Cancel buttons). In the below example, we will make use of those two components' styling options, ([button styling](../button.md#Angular Button Styling) & banner-styling), to customize the experience of our IgxGrid's Row Editing. We will also style the current cell's editor and background to make it more distinct. You can learn more about cell styling here. Import theme The easiest way to style the Row Editing banner is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Once we've imported the themes file, we can create custom themes. Define the theme We can now define a custom banner theme that will affect our Row Editing background and make use of one of the predefined palettes namely $purple-palette : $my-light-gray: #e3e3e3; $my-banner-palette: $purple-palette; $banner-theme: banner-theme( $banner-background: $my-light-gray, $banner-message-color: color($my-banner-palette, \"secondary\", 600) ); Here we are using my-banner-palette in conjunction with igx-color (exposed by the theme library) for generating our colors. Include the theme All we have to do now is apply the theme with a Sass @include statement. We pass our newly defined $banner-theme through the igx-banner mixin: @include banner($banner-theme); This will apply our custom banner theme to the Row Editing overlay. However, since we defined these in the global styles file, these styles will also apply to all banners in our application. Component styles Since the Row Editing overlay makes use of a lot of other components' themes, styling it via the global styles can affect other parts of our application (e.g. banners, buttons, etc.). The best way to prevent that is to scope our banner theme. We can define our styles (including the theme/index import) in the component containing our igx-grid. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: // custom.component.scss :host { ::ng-deep { @include banner($banner-theme); } } With the above syntax, our custom banner theme properly applies to the grid's Row Editing overlay. Custom Templates To further customize our Row Editing overlay, we can pass a custom template so we can style the Done and Cancel buttons separately: <!-- in component.html --> <igx-grid> <ng-template igxRowEditActions let-endRowEdit> <div class=\"custom-buttons\"> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(false)\"> <igx-icon>clear</igx-icon> </button> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(true)\"> <igx-icon>check</igx-icon> </button> </div> </ng-template> </igx-grid> After we've defined our custom buttons, we can make use of the button-theme to style them. You can learn more about igx-button styling here. We can create a custom theme for our Done and Cancel: // custom.component.scss ... $button-theme: button-theme( $palette: $purple-palette ); ... .custom-buttons { @include button($button-theme); } We scope our @include statement in .custom-buttons so that it is only applied to the Doneand Cancel buttons. Demo After styling the banner and buttons, we also define a custom style for the cell in edit mode. The result of all the combined styles can be seen below: Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit field editable primaryKey IgxGridComponent Additional Resources Build CRUD operations with igxGrid Grid Overview Grid Editing Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/row-pinning.html": {
    "href": "components/grid/row-pinning.html",
    "title": "Row Pinning in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Grid Row Pinning One or multiple rows can be pinned to the top or bottom of the Angular UI Grid. Row Pinning in Ignite UI for Angular allows end-users to pin rows in a particular order, duplicating them in a special area that is always visible even when they scroll the Grid vertically. The Material UI Grid has a built-in row pinning UI, which is enabled by initializing an igxActionStrip component in the context of Grid. In addition, you can define custom UI and change the pin state of the rows via the Row Pinning API. Angular Grid Row Pinning Example Row Pinning UI The built-in row pinning UI is enabled by adding an igxActionStrip component with the GridPinningActions component. The action strip is automatically shown when hovering a row and will display a pin or unpin button icon based on the state of the row it is shown for. An additional action allowing to scroll the copy of the pinned row into view is shown for each pinned row as well. <igx-grid [data]=\"data\" [autoGenerate]=\"false\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-grid> Row Pinning API Row pinning is controlled through the pinned input of the row. Pinned rows are rendered at the top of the Grid by default and stay fixed through vertical scrolling of the unpinned rows in the Grid body. this.grid.getRowByIndex(0).pinned = true; You may also use the Grid's pinRow or unpinRow methods of the IgxGridComponent to pin or unpin records by their ID: this.grid.pinRow('ALFKI'); this.grid.unpinRow('ALFKI'); Note that the row ID is the primary key value, defined by the primaryKey of the grid, or the record instance itself. Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the row is already in the desired state. A row is pinned below the last pinned row. Changing the order of the pinned rows can be done by subscribing to the rowPinning event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"true\" (rowPinning)=\"rowPinning($event)\"> </igx-grid> public rowPinning(event) { event.insertAtIndex = 0; } Pinning Position You can change the row pinning position via the pinning configuration option. It allows you to set the pin area position to either Top or Bottom. When set to Bottom pinned rows are rendered at the bottom of the grid, after the unpinned rows. Unpinned rows can be scrolled vertically, while the pinned rows remain fixed at the bottom. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-grid> public pinningConfig: IPinningConfig = { rows: RowPinningPosition.Bottom }; Custom Row Pinning UI You can define your custom UI and change the pin state of the rows via the related API. Via extra column with icon Let's say that instead of an action strip you would like to show a pin icon in every row allowing the end-user to click and change a particular row's pin state. This can be done by adding an extra column with a cell template containing the custom icon. <igx-grid [data]=\"data\" [primaryKey]=\"'ID'\" [autoGenerate]=\"false\"> <igx-column width=\"70px\"> <ng-template igxCell let-cell=\"cell\" let-val> <igx-icon class=\"pin-icon\" (mousedown)=\"togglePinning(cell.row, $event)\"> {{cell.row.pinned ? 'lock' : 'lock_open'}} </igx-icon> </ng-template> </igx-column> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> </igx-grid> On click of the custom icon the pin state of the related row can be changed using the row's API methods. public togglePinning(row: IgxGridRow, event) { event.preventDefault(); if (row.pinned) { row.unpin(); } else { row.pin(); } } Demo Via row drag Let's say that you want to be able to directly drag and drop a row between the pinned and unpinned rows to change its pin state. This can be achieved by enabling the row drag feature and pinning/unpinning the rows via the API on drop. First, the grid should be marked as a drop area using the igxDrop directive and the row drag functionality should be enabled via the rowDraggable option. <igx-grid [data]=\"data\" [autoGenerate]=\"true\" [rowDraggable]=\"true\" [primaryKey]=\"'ID'\" igxDrop (dropped)=\"onDropAllowed($event)\"> </igx-grid> Then the dropped event can be used to handle the reorder and pin/unpin logic. public onDropAllowed(args) { const event = args.originalEvent; let currRowPinnedIndex; const currRowIndex = this.getCurrentRowIndex(this.grid.rowList.toArray(), { x: event.clientX, y: event.clientY }); if (currRowIndex === -1) { return; } const currRowID = this.getCurrentRowID(this.grid.rowList.toArray(), { x: event.clientX, y: event.clientY }); const currentRow = this.grid.rowList.toArray().find((r) => r.rowID === currRowID); if (currentRow.pinned) { currRowPinnedIndex = this.grid.pinnedRows.indexOf(this.grid.pinnedRows.find((r) => r.rowID === currRowID)); } // remove the row that was dragged and place it onto its new location this.grid.deleteRow(args.dragData.key); this.data.splice(currRowIndex, 0, args.dragData.data); if (currentRow.pinned && !args.dragData.pinned) { this.grid.pinRow(args.dragData.key, currRowPinnedIndex); } else if (!currentRow.pinned && args.dragData.pinned) { this.grid.unpinRow(args.dragData.key); } else if (currentRow.pinned && args.dragData.pinned) { this.grid.unpinRow(args.dragData.key); this.grid.pinRow(args.dragData.key, currRowPinnedIndex); } } This would allow reordering the rows and moving them between the pinned and unpinned row collections. Demo Row Pinning Limitations Only records that exist in the data source can be pinned. The row pinning state is not exported to excel. The grid is exported as if no row pinning is applied. Because of how pinned rows are stored internally so that they may appear both in the pinned and unpinned areas of the grid, row pinning is not supported when records in the grid are fetched from a remote endpoint on demand (remote virtualization). The copies of pinned rows in the scrollable area of the grid are an integral part of how other grid features achieve their functionality in the presence of pinned rows and therefore their creation cannot be disabled nor can they be removed. As Row Selection works entirely with row Ids, selecting pinned rows selects their copies as well (and vise versa). Additionally, range selection (e.g. using Shift + click) within the pinned area works the same way as selecting a range of rows within the scrollable area. The resulting selection includes all rows in between even if they are not currently pinned. Getting the selected rows through the API only returns a single instance of each selected record. When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning Styling The IgxGrid allows styling through the Ignite UI for Angular Theme Library. The Grid's theme exposes a wide variety of properties, which allow the customization of all the features of the Grid. Below, we are going through the steps of customizing the Grid's row pinning styling. Importing the Styling Library To begin the customization of the row pinning feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining a Theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the row pinning feature as desired. $custom-grid-theme: grid-theme( /* Pinning properties that affect styling */ $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: #FFCD0F, $cell-active-border-color: #FFCD0F /* add other features properties here... */ ); Using CSS variables The last step is to pass the custom grid theme: @include css-vars($custom-grid-theme); Using mixins In order to style components for Internet Explorer 11, you have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. However, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom grid theme to the `igx-grid` mixin @include grid($custom-grid-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow RowType IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/row-selection.html": {
    "href": "components/grid/row-selection.html",
    "title": "Angular Grid Select Row - Ignite UI for Angular",
    "keywords": "Angular Grid Row Selection With row selection in Ignite UI for Angular, there is row selector column that precedes all other columns within the row. When a user clicks on the row selector, the row will either become selected or deselected, enabling the user to select multiple rows of data. Angular Row Selection Example The sample below demonstrates the three types of Grid's row selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Use the switch button to hide or show the row selector checkbox. To get newly selected elements you can use event.newSelection: public handleRowSelection(event: IRowSelectionEventArgs) { this.selectedRowsCount = event.newSelection.length; this.selectedRowIndex = event.newSelection[0]; this.snackbarRowCount.open(); this.snackbar.close(); this.logAnEvent(`=> 'rowSelectionChanging' with value: ` + JSON.stringify(event.newSelection)); } Setup In order to setup row selection in the igx-grid, you just need to set the rowSelection property. This property accepts GridSelectionMode enumeration. GridSelectionMode exposes the following three modes: none, single and multiple. Below we will take a look at each of them in more detail. None Selection In the igx-grid by default row selection is disabled, otherwise ([rowSelection]=\"'none'\"). So you can not select or deselect a row through interaction with the Grid UI, the only way to complete these actions is to use the provided API methods. Single Selection Single row selection can now be easily set up, the only thing you need to do, is to set [rowSelection] = '\"single\"' property. This gives you the opportunity to select only one row within a grid. You can select a row by clicking on a cell or pressing the space key when you focus on a cell of the row, and of course you can select a row by clicking on the row selector field. When row is selected or deselected rowSelectionChanging event is emitted. <!-- selectionExample.component.html --> <igx-grid [data]=\"remote | async\" [rowSelection]=\"'single'\" [autoGenerate]=\"true\" (rowSelectionChanging)=\"handleRowSelection($event)\" [allowFiltering]=\"true\"> </igx-grid> /* selectionExample.component.ts */ public handleRowSelection(args) { if (args.added.length && args.added[0] === 3) { args.cancel = true; } } Multiple Selection To enable multiple row selection in the igx-grid just set the rowSelection property to multiple. This will enable a row selector field on each row and in the Grid header. The row selector allows users to select multiple rows, with the selection persisting through scrolling, paging, and data operations, such as sorting and filtering. The row also can be selected by clicking on a cell or by pressing the space key when a cell is focused. If you have selected one row and click on another while holding the shift key, this will select the whole range of rows. In this selection mode, when you click on a single row, the previous selected rows will be deselected. If you click while holding the ctrl key, the row will be toggled and the previous selection will be preserved. <!-- selectionExample.component.html --> <igx-grid [data]=\"remote | async\" [primaryKey]=\"'ProductID'\" [rowSelection]=\"'multiple'\" (rowSelectionChanging)=\"handleRowSelection($event)\" [allowFiltering]=\"true\" [autoGenerate]=\"true\"> </igx-grid> <!-- selectionExample.component.ts --> public handleRowSelection(event: IRowSelectionEventArgs) { // use event.newSelection to retrieve primary key/row data of latest selected row this.selectedRowsCount = event.newSelection.length; this.selectedRowIndex = event.newSelection[0]; } Notes In order to have proper row selection and cell selection, while Grid has remote virtualization, a primaryKey should be provided. When the Grid has remote virtualization, then clicking the header checkbox will select/deselect all records that are currently in the grid. When new data is loaded in the Grid on demand, newly added rows will not be selected and it is a limitation, so you should handle that behavior by yourself and you can select these rows by using the provided API methods. Row selection will trigger rowSelectionChanging event. This event gives you information about the new selection, old selection, the rows that have been added and removed from the old selection. Also the event is cancellable, so this allows you to prevent selection. When row selection is enabled row selectors are displayed, but if you don't want to show them, you can set [hideRowSelectors] = true. When you switch between row selection modes at runtime, this will clear the previous row selection state. API usage Select rows programmatically The code snippet below can be used to select one or multiple rows simultaneously (via primaryKey); Additionally, the second parameter of this method is a boolean property through which you may choose whether the previous row selection will be cleared or not. The previous selection is preserved by default. <!-- selectionExample.component.html --> <igx-grid ... [primaryKey]=\"'ID'\"> ... </igx-grid> ... <button (click)=\"this.grid.selectRows([1,2,5], true)\">Select 1,2 and 5</button> // select rows and clear previous selection state This will add the rows which correspond to the data entries with IDs 1, 2 and 5 to the Grid selection. Deselect rows If you need to deselect rows programmatically, you can use the deselectRows(rowIds: []) method. <!-- selectionExample.component.html --> <igx-grid ... [primaryKey]=\"'ID'\"> ... </igx-grid> ... <button (click)=\"this.grid.deselectRows([1,2,5])\">Deselect 1,2 and 5</button> Row selection event When there is some change in the row selection rowSelectionChanging event is emitted. rowSelectionChanging exposes the following arguments: oldSelection - array of row's data that contains the previous state of the row selection. newSelection - array of row's data that match the new state of the row selection. added - array of row's data that are currently added to the selection. removed - array of row's data that are currently removed according old selection state. event - the original event that triggered row selection change. cancel - allows you the prevent the row selection change. Row selection event in remote data scenarios In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. <!-- selectionExample.component.html --> <igx-grid (rowSelectionChanging)=\"handleRowSelectionChange($event)\"> ... </igx-grid> /* selectionExample.component.ts */ public handleRowSelectionChange(args) { args.cancel = true; // this will cancel the row selection } Select all rows Another useful API method that igx-grid provides is selectAll(onlyFilteredData). By default this method will select all data rows, but if filtering is applied, it will select only the rows that match the filter criteria. But if you call the method with false parameter, selectAll(false) will always select all data in the grid, even if filtering is applied. Note Keep in mind that selectAll() will not select the rows that are deleted. Deselect all rows igx-grid provides deselectAll(onlyFilteredData) method, which by default will deselect all data rows, but if filtering is applied will deselect only the rows that match the filter criteria. But if you call the method with false parameter, deselectAll(false) will always clear all row selection state even if filtering is applied. How to get selected rows If you need to see which rows are currently selected, you can get their row IDs with the selectedRows getter. public getSelectedRows() { const currentSelection = this.grid.selectedRows; // return array of row IDs } Additionally, assigning row IDs to selectedRows will allow you to change the grid's selection state. public mySelectedRows = [1, 2, 3]; // an array of row IDs <igx-grid primaryKey=\"ProductID\" rowSelection=\"multiple\" [autoGenerate]=\"false\" [mySelectedRows]=\"selectedRows\" [data]=\"data\"> <igx-column [field]=\"'ProductID'\"></igx-column> <igx-column [field]=\"'ProductName'\"></igx-column> <igx-column [field]=\"'UnitsInStock'\"></igx-column> </igx-grid> Row selector templates You can template header and row selectors in the Grid and also access their contexts which provide useful functionality for different scenarios. By default, the Grid handles all row selection interactions on the row selector's parent container or on the row itself, leaving just the state visualization for the template. Overriding the base functionality should generally be done using the rowSelectionChanging event. In case you implement a custom template with a click handler which overrides the base functionality, you should stop the event's propagation to preserve the correct row state. Row template To create a custom row selector template, within the igx-grid, declare an <ng-template> with igxRowSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the row's state. The selected property shows whether the current row is selected or not while the index property can be used to access the row index. <ng-template igxRowSelector let-rowContext> {{ rowContext.index }} <igx-checkbox [checked]=\"rowContext.selected\" [readonly]=\"true\" ></igx-checkbox> </ng-template> The rowID property can be used to get a reference of an igx-grid row. This is useful when you implement a click handler on the row selector element. <ng-template igxRowSelector let-rowContext> <igx-checkbox (click)=\"onSelectorClick($event, rowContext.key)\"></igx-checkbox> </ng-template> In the above example we are using an igx-checkbox and we bind rowContext.selected to its checked property. See this in action in our Row Numbering Demo. Header template To create a custom header selector template, within the Grid, declare an <ng-template> with igxHeadSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the header's state. The selectedCount property shows you how many rows are currently selected while totalCount shows you how many rows there are in the Grid in total. <ng-template igxHeadSelector let-headContext> {{ headContext.selectedCount }} / {{ headContext.totalCount }} </ng-template> The selectedCount and totalCount properties can be used to determine if the head selector should be checked or indeterminate (partially selected). <igx-grid [data]=\"gridData\" primaryKey=\"ProductID\" rowSelection=\"multiple\"> <!-- ... --> <ng-template igxHeadSelector let-headContext> <igx-checkbox [checked]=\" headContext.selectedCount > 0 && headContext.selectedCount === headContext.totalCount\" [indeterminate]=\"headContext.selectedCount > 0 && headContext.selectedCount !== headContext.totalCount\"> </igx-checkbox> </ng-template> </igx-grid> Row Numbering Demo This demo shows the usage of custom header and row selectors. The latter uses rowContext.index to display row numbers and an igx-checkbox bound to rowContext.selected. Excel Style Row Selectors Demo This demo uses custom templates to resemble Excel-like header and row selectors. Conditional Selection Demo This demo prevents some rows from being selected using the rowSelectionChanging event and a custom template with disabled checkbox for non-selectable rows. API References IgxGridComponent API IgxGridRow API IgxGridCell API IgxGridComponent Styles Additional Resources Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/search.html": {
    "href": "components/grid/search.html",
    "title": "Angular Grid Search Filter - Ignite UI for Angular",
    "keywords": "Angular Grid Search Filter Angular Grid search enables the process of finding values in the collection of data. We make it easier to setup this functionality and it can be implemented with search input box, buttons, keyboard navigation and other useful features for an even better user experience. While browsers natively provide content search functionality, most of the time the Grid virtualizes its columns and rows that are out of view. In these cases, the native grid search is unable to search data in the virtualized cells, since they are not part of the DOM. We have extended the Ignite UI for Angular table-based grid with a search API that allows you to search through the virtualized content of the Grid. Angular Search Example The following example represents Grid with search input box that allows searching in all columns and rows, as well as specific filtering options for each column. Angular Search Usage Grid setup Let's start by creating our grid and binding it to our data. We will also add some custom styles for the components we will be using! <!--searchgrid.component.html--> <igx-grid #grid1 id=\"grid1\" [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column [field]=\"'IndustrySector'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'IndustryGroup'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'SectorType'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'KRD'\" dataType=\"number\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'MarketNotion'\" dataType=\"number\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Date'\" dataType=\"date\" [sortable]=\"true\"></igx-column> </igx-grid> /* searchgrid.component.css */ .grid__wrapper { margin: 15px; } .offset { margin-bottom: 15px; } .resultsText { font-size: 0.875rem; } .chips { margin-left: 5px; } .searchButtons { margin-left: 5px; } Great, and now let's prepare for the search API of our Grid! We can create a few properties, which can be used for storing the currently searched text and whether the search is case sensitive and/or by an exact match. // searchgrid.component.ts public searchText: string = ''; public caseSensitive: boolean = false; public exactMatch: boolean = false; Angular search box input Now let's create our search input! By binding our searchText as ngModel to our newly created input and subscribe to the ngModelChange event, we can detect every single searchText modification by the user. This will allow us to use the Grid's findNext and findPrev methods to highlight all the occurrences of the searchText and scroll to the next/previous one (depending on which method we have invoked). Both the findNext and the findPrev methods have three arguments: text: string (the text we are searching for) (optional) caseSensitive: boolean (should the search be case sensitive or not, default value is false) (optional) exactMatch: boolean (should the search be by an exact match or not, default value is false) When searching by an exact match, the search API will highlight as results only the cell values that match entirely the searchText by taking the case sensitivity into account as well. For example the strings 'software' and 'Software' are an exact match with a disregard for the case sensitivity. The methods from above return a number value (the number of times the Grid contains the given string). <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"grid.findNext(searchText, caseSensitive, exactMatch)\" /> Display results count Let's also display the position of the current occurrence, along with the total results count! We can do this by using the grid's lastSearchInfo property. This property is automatically updated when using the find methods. The grid.lastSearchInfo.matchInfoCache.length value will give us the total results count. The grid.lastSearchInfo.activeMatchIndex value will give us the index position of the current occurrence (match). <!--searchgrid.component.html--> <div class=\"resultsText\" *ngIf=\"grid.lastSearchInfo\"> <span *ngIf=\"grid.lastSearchInfo.matchInfoCache.length > 0\"> {{ grid.lastSearchInfo.activeMatchIndex + 1 }} of {{ grid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"grid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> Add search buttons In order to freely search and navigate among our search results, let's create a couple of buttons by invoking the findNext and the findPrev methods inside the buttons' respective click event handlers. <!--searchgrid.component.html--> <div class=\"searchButtons\"> <input type=\"button\" value=\"Previous\" (click)=\"grid.findPrev(searchText, caseSensitive, exactMatch)\" /> <input type=\"button\" value=\"Next\" (click)=\"grid.findNext(searchText, caseSensitive, exactMatch)\" /> </div> Add keyboard search We can also allow the users to navigate the results by using the keyboard's arrow keys and the Enter key. In order to achieve this, we can handle the keydown event of our search input by preventing the default caret movement of the input with the preventDefault() method and invoke the findNext/findPrev methods depending on which key the user has pressed. <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"grid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> // searchgrid.component.ts public searchKeyDown(ev) { if (ev.key === 'Enter' || ev.key === 'ArrowDown' || ev.key === 'ArrowRight') { ev.preventDefault(); this.grid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } else if (ev.key === 'ArrowUp' || ev.key === 'ArrowLeft') { ev.preventDefault(); this.grid.findPrev(this.searchText, this.caseSensitive, this.exactMatch); } } Case sensitive and Exact match Now let's allow the user to choose whether the search should be case sensitive and/or by an exact match. For this purpose we can use simple checkbox inputs by binding our caseSensitive and exactMatch properties to the inputs' checked properties respectively and handle their change events by toggling our properties and invoking the findNext method. <!--searchgrid.component.html--> <span>Case sensitive</span> <input type=\"checkbox\" [checked]=\"caseSensitive\" (change)=\"updateSearch()\"> <span>Exact match</span> <input type=\"checkbox\" [checked]=\"exactMatch\" (change)=\"updateExactSearch()\"> // searchgrid.component.ts public updateSearch() { this.caseSensitive = !this.caseSensitive; this.grid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } public updateExactSearch() { this.exactMatch = !this.exactMatch; this.grid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } Persistence What if we would like to filter and sort our Grid or even to add and remove records? After such operations, the highlights of our current search automatically update and persist over any text that matches the searchText! Furthermore, the search will work with paging and will persist the highlights through changes of the Grid's perPage property. Adding icons By using some of our other components, we can create an enriched user interface and improve the overall design of our entire search bar! We can have a nice search or delete icon on the left of the search input, a couple of chips for our search options and some material design icons combined with nice ripple styled buttons for our navigation on the right. We can wrap these components inside an input group for a more refined design. To do this, let's go and grab the IgxInputGroup, IgxIcon, IgxRipple, IgxButton and the IgxChip modules. // app.module.ts ... import { IgxGridModule, IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule } from 'igniteui-angular'; // import { // IgxInputGroupModule, // IgxIconModule, // IgxRippleModule, // IgxButtonModule, // IgxChipsModule // } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule], }) export class AppModule {} Finally, let's update our template with the new components! We will wrap all of our components inside an IgxInputGroup. On the left we will toggle between a search and a delete/clear icon (depending on whether the search input is empty or not). In the center, we will position the input itself. In addition, whenever the delete icon is clicked, we will update our searchText and invoke the Grid's clearSearch method to clear the highlights. <!--searchgrid.component.html--> <igx-input-group type=\"search\" class=\"offset\"> <igx-prefix> <igx-icon *ngIf=\"searchText.length == 0\">search</igx-icon> <igx-icon *ngIf=\"searchText.length > 0\" (click)=\"clearSearch()\">clear</igx-icon> </igx-prefix> <input #search1 id=\"search1\" igxInput placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"grid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> <igx-suffix *ngIf=\"searchText.length > 0\"> ... </igx-suffix> </igx-input-group> // searchgrid.component.ts public clearSearch() { this.searchText = ''; this.grid.clearSearch(); } On the right in our input group, let's create three separate containers with the following purposes: For displaying the search results. <!--searchgrid.component.html--> <igx-suffix *ngIf=\"searchText.length > 0\"> <div class=\"resultsText\" *ngIf=\"grid.lastSearchInfo\"> <span *ngIf=\"grid.lastSearchInfo.matchInfoCache.length > 0\"> {{ grid.lastSearchInfo.activeMatchIndex + 1 }} of {{ grid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"grid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> </igx-suffix> For displaying a couple of chips that toggle the caseSensitive and the exactMatch properties. We have replaced the checkboxes with two stylish chips that change color based on these properties. Whenever a chip is clicked, we invoke its respective handler - updateSearch or updateExactSearch depending on which chip has been clicked. <!--searchgrid.component.html--> ... <div class=\"chips\"> <igx-chips-area> <igx-chip (click)=\"updateSearch()\" [color]=\"caseSensitive? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Case Sensitive</span> </igx-chip> <igx-chip (click)=\"updateExactSearch()\" [color]=\"exactMatch? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Exact Match</span> </igx-chip> </igx-chips-area> </div> ... For the search navigation buttons, we have transformed our inputs into ripple styled buttons with material icons. The handlers for the click events remain the same - invoking the findNext/findPrev methods. <!--searchgrid.component.html--> <igx-suffix> <div class=\"searchButtons\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"grid.findPrev(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"grid.findNext(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </div> </igx-suffix> Known Limitations Limitation Description Searching in cells with a template The search functionality highlights work only for the default cell templates. If you have a column with custom cell template, the highlights will not work so you should either use alternative approaches, such as a column formatter, or set the searchable property on the column to false. Remote Virtualization The search will not work properly when using remote virtualization Cells with cut off text When the text in the cell is too large to fit and the text we are looking for is cut off by the ellipsis, we will still scroll to the cell and include it in the match count, but nothing will be highlighted API References In this article we implemented our own search bar for the Grid with some additional functionality when it comes to navigating between the search results. We also used some additional Ignite UI for Angular components like icons, chips and inputs. The search API is listed below. IgxGridComponent methods: findNext findPrev clearSearch refreshSearch IgxGridCell methods: IgxColumnComponent properties: searchable ISearchInfo Additional components and/or directives with relative APIs that were used: IgxInputGroupComponent IgxIconComponent IgxRippleDirective IgxButtonDirective IgxChipComponent Styles: IgxGridComponent Styles IgxInputGroupComponent Styles IgxIconComponent Styles IgxRippleDirective Styles IgxButtonDirective Styles IgxChipComponent Styles Additional Resources Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/selection.html": {
    "href": "components/grid/selection.html",
    "title": "Angular Grid Selection - Ignite UI for Angular",
    "keywords": "Angular Grid Selection With Ignite UI for Angular Grid you can easily select data by using variety of events, rich API or with simple mouse interactions like single select. Angular Grid Selection Example The sample below demonstrates the three types of Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Angular Grid Selection Options IgniteUI for Angular Grid component provides three different selection modes - Row selection, Cell selection and Column selection. By default only Multi-cell selection mode is enabled in the Grid. In order to change/enable selection mode you can use rowSelection, cellSelection or selectable properties. Angular Row Selection Property rowSelection enables you to specify the following options: none - Row selection would be disabled for the Grid single - Selection of only one row within the Grid would be available multiple - Multi-row selection would be available by using the Row selectors, with a key combination like ctrl + click, or by pressing the space key once a cell is focused Go to Row selection topic for more information. Angular Cell Selection Property cellSelection enables you to specify the following options: none - Cell selection would be disabled for the Grid single - Selection of only one cell within the Grid would be available. multiple - Currently, this is the default state of the selection in the Grid. Multi-cell selection is available by mouse dragging over the cells, after a left button mouse clicked continuously. Go to Cell selection topic for more information. Angular Column Selection The selectable property enables you to specify the following options for each column: false - the corresponding column selection will be disabled for the Grid true - the corresponding column selection will be enabled for the Grid This lead to the following three variations: Single selection - mouse click over the column cell. Multi column selection - holding ctrl + mouse click over the column cells. Range column selection - holding shift + mouse click selects everything in between. Go to Column selection topic for more information. Grid Context Menu Using the contextMenu event you can add a custom context menu to facilitate your work with IgxGrid. With a right click on the grid's body, the event emits the cell on which it is triggered. The context menu will operate with the emitted cell. If there is a multi-cell selection, we will put logic, which will check whether the selected cell is in the area of the multi-cell selection. If it is, we will also emit the values of the selected cells. Basically the main function will look like this: public rightClick(eventArgs: any) { // Prevent the default behavior of the right click eventArgs.event.preventDefault(); this.multiCellArgs = {}; // If we have multi-cell selection, check if selected cell is within the ranges if (this.multiCellSelection) { const node = eventArgs.cell.selectionNode; const isCellWithinRange = this.grid1.getSelectedRanges().some(range => { if (node.column >= range.columnStart && node.column <= range.columnEnd && node.row >= range.rowStart && node.row <= range.rowEnd) { return true; } return false; }) // If the cell is within a multi-cell selection range, bind all the selected cells data if (isCellWithinRange) { this.multiCellArgs = { data: this.multiCellSelection.data }; } } // Set the position of the context menu this.contextmenuX = eventArgs.event.clientX; this.contextmenuY = eventArgs.event.clientY; this.clickedCell = eventArgs.cell; // Enable the context menu this.contextmenu = true; } The context menu will have the following functions: Copy the selected cell's value Copy the selected cell's dataRow If the selected cell is within a multi-cell selection range, copy all the selected data //contextmenu.component.ts public copySelectedCellData(event) { const selectedData = { [this.cell.column.field]: this.cell.value }; this.copyData(JSON.stringify({ [this.cell.column.field]: this.cell.value })); this.onCellValueCopy.emit({ data: selectedData }); } public copyRowData(event) { const selectedData = this.cell.row.data ; this.copyData(JSON.stringify(this.cell.row.data)); this.onCellValueCopy.emit({ data: selectedData }); } public copySelectedCells(event) { const selectedData = this.selectedCells.data; this.copyData(JSON.stringify(selectedData)); this.onCellValueCopy.emit({ data: selectedData }); } The IgxGrid will fetch the copied data and will paste it in a container element. The template we are going to use to combine the grid with the context menu: <div class=\"wrapper\"> <div class=\"grid__wrapper\" (window:click)=\"disableContextMenu()\"> <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"500px\" width=\"100%\" (contextMenu)=\"rightClick($event)\" (rangeSelected)=\"getCells($event)\" (selected)=\"cellSelection($event)\"> <!-- Columns area --> </igx-grid> <div *ngIf=\"contextmenu==true\"> <contextmenu [x]=\"contextmenuX\" [y]=\"contextmenuY\" [cell]=\"clickedCell\" [selectedCells]=\"multiCellArgs\" (onCellValueCopy)=\"copy($event)\"> </contextmenu> </div> </div> <div class=\"selected-data-area\"> <div> <pre>{{copiedData}}</pre> </div> </div> </div> Select multiple cells and press the right mouse button. The context menu will appear and after selecting Copy cells data the selected data will appear in the right empty box. The result is: Known Issues and Limitations Using the Grid with Selection enabled on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. IE11 is no longer supported as of version 13.0.0. import 'core-js/es7/array'; When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References IgxGridComponent API IgxGridRow API IgxGridCell API IgxGridComponent Styles Additional Resources Grid overview Row Selection Cell Selection Paging Filtering Sorting Summaries Column Moving Virtualization and Performance Selection-based Aggregates Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/selection-based-aggregates.html": {
    "href": "components/grid/selection-based-aggregates.html",
    "title": "Angular Grid Selection-Based Data Aggregation- Ignite UI for Angular",
    "keywords": "Angular Grid Selection-Based Data Aggregation With the sample, illustrated beyond, you may see how multiple selection is being used, alongside with custom summary functions, to display aggregates based on the selected values in the grid footer. Topic Overview To achieve the selection-based aggregates functionality, you can use our Grid Selection feature, together with the Grid Summaries. The Summaries are allowing for customization of the basic Summary feature functionality through extending one of the base classess, IgxSummaryOperand, IgxNumberSummaryOperand or IgxDateSummaryOperand, depending on the column data type and your needs. Selection To start working with the data in the selected grid range, you will have to subscribe to events that are notifying of changes in the grid selection. That can be done by subscribing to the selected event and to the rangeSelected event. You need to bind to both of them because the Selection feature differentiates between selecting a single cell and selecting a range of cells. In the events subscription logic, you can extract the selected data using the grid's getSelectedData function and pass the selected data to the custom summary operand. Summary Within the custom summary class, you'd have to be differentiating the types of data in the grid. For instance, in the scenario below, there are four different columns, whose type of data is suitable for custom summaries. These are the Unit Price, the Units in Stock, Discontinued status and the Order Date. The operate method of the derived class of the IgxSummaryOperand, is where you will process the data, starting by casing it in different categories based on the data types: const numberData = data.filter(rec => typeof rec === \"number\"); const boolData = data.filter(rec => typeof rec === \"boolean\"); const dates = data.filter(rec => isDate(rec)); Note Bear in mind, that isDate is a custom function. After having the data types grouped accordingly, you can proceed to the aggregation itself. For that reason, you could use the already exposed methods of the IgxNumberSummaryOperand and IgxDateSummaryOperand. After that, you'd have to put the aggregated data in the same array, which would be returned to the template. For the visualization of the data, you might want to use the <igx-grid-footer>, which in a combination with the custom-summaries class will give the natural look of the Summary. Demo Change the selection to see summaries of the currently selected range. API References IgxGridComponent API IgxGridCell API IgxGridComponent Styles Additional Resources Grid overview Selection Service Row Selection Cell Selection IgxNumberSummaryOperand IgxDateSummaryOperand Summaries Paging Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/sizing.html": {
    "href": "components/grid/sizing.html",
    "title": "Angular Grid Sizing - Ignite UI for Angular",
    "keywords": "Angular Grid Sizing There are many different ways to size the IgxGrid in order to accommodate a lot of scenarios that the users can have. While some are straight forward, others might be more complex and that is why we will take each one and look into them in more depth. We will go through setting width and height separately since there are some differences e.g. when using percentages for each. When it comes to border and padding size for the IgxGrid, they are taken into its width/height size calculations or also known as Border box sizing. It is applied in all scenarios. Note If the Border box sizing is overridden by the user we cannot guarantee that the IgxGrid will size correctly. Width If the width input does not have value assigned, its default value is 100% and the IgxGrid tries to fill the available space. You can check how the grid reacts to it in the Percentages section. Note Setting manually the width style of the IgxGrid itself will result in an unexpected behavior. Null The grid's width can accepts value of null, which when set, renders all columns in the DOM. The grid sizes accordingly so there is no grid horizontal scrollbar since column virtualization is not applied. If there are 6 columns and none of them has width defined, the grid will have width of 816px, because each column by default have assigned width of 136px in this scenario. Same will happen if the columns have width in percentages. If vertical scrollbar is rendered or there are features that render additional columns their width will be added also. If there are 6 columns with column width set to 200px they will fit in our window and all will be visible: If there are more columns or ones with bigger width that go out of the browser's view, they will all still render. Let's have the same amount of columns but each with column width of 300px. Since they don't all fit in the browser view area, it will create a scrollbar natively. The next example displays this exact scenario: If the grid has a parent element of any sort and it doesn't have any overflow set, it will still render all columns visible. Otherwise if the parent element has overflow auto or scroll, a scrollbar for that parent element will be rendered natively. The parent has bigger height for easier visualization in the following example. Note Due to this behavior, if the grid data contains too many columns, it might have significant impact on the browser performance, since all columns would be rendered without virtualization. Pixels When the IgxGrid width input is set to pixels it will set the whole grid size to that value and it will be static. It will not react to any browser resizing or changes in the DOM, although this is not the case for the grid content: When width is set in pixels in order for the grid to render horizontal scrollbar, its content width needs to exceed the specified grid width. Let's, for example, have the combined width of the columns exceed 1200px. In this case a horizontal scrollbar will be rendered. For scenarios where the grid has a parent element, it depends on the parent styling if it will render scrollbar or not. Everything else related to the grid itself is still retained. If the parent element width is smaller than the grid's width and has overflow style set to auto or scroll, it will render scrollbar natively. For example, if the parent has width set to 1000px and the IgxGrid width is still 1200px, it will look similar to the following illustrations: Percentages When the width of the IgxGrid is set to percentages it will size the grid according to the parent element's width. If the parent element does not have width specified the IgxGrid will size relative to the browser window. For example, if we set the grid width input to 100% and there is no parent element it will fill 100% of the available width of the browser window. If it is resized the grid will resize as well accordingly. If we set grid's width to 100% and there is a parent element that has specific width of 1200px, this will mean that the grid will size relative to that element and his final width will be 1200px. If we have a parent element with width of 1000px and have the grid's width set to 150%, the calculated grid width will be 1500px. In this case the grid will still render fully visible but if we set overflow: auto of the parent, that parent will render scrollbar on its own. Height By default if no height is defined for the IgxGrid, it will be set to 100%. You can check how the grid reacts depending on the DOM structure in the Percentages section. Note Setting manually the height style of the IgxGrid itself will result in an unexpected behavior. Null The IgxGrid height input can accept null value, which when set, displays all rows with no scrollbar no matter how many they are. In this case, there is no vertical virtualization since the grid renders all rows anyway. If we have data with 14 rows in this case the grid will render all 14 of them and size the grid so all are visible without any empty space inside the grid. If we have 24 rows instead, the grid will still render all rows but since they are too many, they exceed the browser boundaries. That's why the browser itself will render vertical scrollbar by default so the user can scroll down to the rest of the rows. If there is a parent element with defined height, the grid will still render all rows and not be affected. Let's say the parent has height of 650px. If he has overflow set to auto or scroll, it will render a vertical scrollbar but the grid will still be unaffected: Note Due to this behavior, if the grid data contains too many rows, it might have significant impact on the browser performance, since all rows would be rendered without virtualization. Pixels Setting the IgxGrid height in pixels is more straightforward since the grid will size to that specific size in all occasions similarly to how width is set in pixels. If we set, for example, the height 500px with 4 rows for our data the grid will sit to that size and since 4 rows are not enough to fill the visible area it is expected to have some empty area. If the number of rows exceeds the visible area of the grid when height is set to pixels a vertical scrollbar will be rendered. For example, a grid with 500px height set and 14 rows will be rendered the following way: If there is a parent element with height defined, unless it has overflow set to auto or scroll, the grid will still be fully visible. Otherwise it will render a scrollbar. Percentages When the height input is set to percentages the IgxGrid will size based on the parent element height. If the parent element has its height set in pixels or percentages, the grid will size relative to the size of the parent. When the parent element does not have defined height, the browser does not assign height to it initially and sizes it based on its children and their size. That is why there is no way for the grid to know what base height to use in order to apply percentage sizing based on it. For this reason, it will render a maximum of 10 rows and if they are more rows, a vertical scrollbar will be rendered. Otherwise, the grid will fit to number of rendered rows. We will look in this scenario in more detail in the next examples. Let's have width set to 1200px and the parent element not having any size applied to it: If there are less than 10 rows the grid will try to fit all rows in the `visible area without having an empty space between the last row and the bottom of the visible area. For example, let's have the grid data to consist of 7 rows. The grid will render all 7 rows without vertical scrollbar and without empty space inside the grid. If there are more than 10 rows a vertical scrollbar will be rendered for the rest of the rows and only 10 rows can be visible at any time. In the next example only the row number is increased to 14. If we set the parent element height to 800px and the IgxGrid to 100% height this means that the grid will be sized to 100 percentages of 800px. If the IgxGrid height is set to a number bigger than 100% and the parent element has height, for the parent to render scrollbar it again needs to have overflow set to auto or scroll. Otherwise the grid will be fully visibly and size relative to the parent size. If we want the grid to be sized to 100% from the browser window we would need to set both body and parent grid element heights to 100%. In this case, the parent element can be sized and the grid will size accordingly if the browser is resized. Column Sizing Depending on the grid size itself, the columns inside it can also be sized differently that could result in scenarios where the grid renders horizontal scrollbar or not. Columns can have width set in pixels, percentages or autosized when nothing is set. We will take a deeper look regarding these scenarios in this section. Default By default when a column doesn't have a specified width it will try to autosize, so that it fills if any empty space is available in the grid view area. Autosized columns have minimum width of 136px, so if the area available is less than 136px for that column, it will default to that size. When the grid is resized in these scenarios, the column width is also updated to reflect the changes, so it fills any new empty space available. If a column does not have specified width and the IgxGrid has width set to null, it will be sized to the minimum of 136px. This means that for a grid with width null and 6 columns that don't have width, each column will be sized to 136px. When there are multiple autosized columns they will divide the available space between each other equally. This means that if we have 6 columns and there is empty area of 1200px, each will size to 200px. If there is available empty space, so that each autosized column will be less than 136px, all autosized columns will default to 136px and the grid will render horizontal scrollbar. In the next example let's have 12 autosized columns and the grid width set to 1000px. If a column does not have width specified, but all other columns have either width in pixels or percentages, that column will try to also fill the available space. For example, if we don't have width set to the first column and all other 5 have width of 100px, the first will fill the rest. Same applies if multiple columns does not have width specified, all will divide the available space between each other equally. In the next illustration the first column has width set to 100px. Note Feature columns like Row Selector checkbox column and etc. fill additional space that is taken into account when autosizing columns. Pixels When columns have set specific width in pixels, they stick to that size, unless they are resized manually. Since the combined width of the columns is static, it can be less than the IgxGrid width or exceed it. If the combined width of all columns is less than the IgxGrid width, there would be an empty are inside the grid that the columns wouldn't be able to fill. This is the expected behavior of the IgxGrid. In the next example the columns have 150px width. If the combined width of all columns is bigger than the actual IgxGrid width, a horizontal scrollbar will be rendered. In the next example each of the 6 columns have width of 300px and grid has width of 1200px, which means that the columns combined have excess of 600px that goes out of bounds. Auto When columns are set to auto their size adjusts to fit the longest word in the column. Empty areas are possible if there are cells with very short values, while other cells have very long ones. In this scenario, all cells in the column would adjust to take the width of the cell with the longest value. Percentages When columns have set width in percentages, their size is calculated relatively to the grid size. It is similar to how width in pixels works, but provides also responsiveness to the columns which means that when the grid is resized, the columns also will resize accordingly. If the combined width of all columns is less than 100%, similarly to when in pixels, there could be an empty area of the grid that the columns do not cover. If the combined width is exactly 100%, the columns will fill all available space of the grid. If the combined width exceeds 100% in order for the user to be able to see the columns out of view, a horizontal scrollbar is rendered. If columns are set in percentages and the grid width is set to null, it would applywidth of 136px to each column. That is because the columns cannot be sized relatively to the grid, since it doesn't have width itself and relies on its content to be sized when its width is null. In the following example all 6 columns have width set to 50%: API References IgxGridComponent API IgxGridRow API IgxGridComponent Styles Additional Resources Grid overview Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/sorting.html": {
    "href": "components/grid/sorting.html",
    "title": "Angular Grid Sorting - Ignite UI for Angular",
    "keywords": "Angular Grid Sorting In Ignite UI for Angular Grid, data sorting is enabled on a per-column level, meaning that the igx-grid can have a mix of sortable and non-sortable columns. Performing angular sort actions enables you to change the display order of the records based on specified criteria. Note Up until now, grouping/sorting worked in conjuction with each other. In 13.2 version, a new behavior which decouples gropuing from sorting is introduced. For example - clearing the grouping will not clear sorting expressions in the grid or vice versa. Still, if a column is both sorted and grouped, grouped expressions take precedence. Angular Grid Sorting Overview Example This is done via the sortable input. With the Grid sorting, you can also set the sortingIgnoreCase property to perform case sensitive sorting: <igx-column field=\"ProductName\" header=\"Product Name\" [dataType]=\"'string'\" sortable=\"true\"></igx-column> Sorting Indicators Having a certain amount of sorted columns could be really confusing if there is no indication of the sorted order. The IgxGrid provides a solution for this problem by indicating the index of each sorted column. Sorting through the API You can sort any column or a combination of columns through the Grid API using the Grid sort method: import { SortingDirection } from 'igniteui-angular'; // import { SortingDirection } from '@infragistics/igniteui-angular'; for licensed package // Perform a case insensitive ascending sort on the ProductName column. this.grid.sort({ fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }); // Perform sorting on both the ProductName and Price columns. this.grid.sort([ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]); Note Sorting is performed using our DefaultSortingStrategy algorithm. Any IgxColumnComponent or ISortingExpression can use a custom implementation of the ISortingStrategy as a substitute algorithm. This is useful when custom sorting needs to be defined for complex template columns, or image columns, for example. As with the filtering behavior, you can clear the sorting state by using the clearSort method: // Removes the sorting state from the ProductName column this.grid.clearSort('ProductName'); // Removes the sorting state from every column in the Grid this.grid.clearSort(); Note The sortStrategy of the Grid is of different type compared to the sortStrategy of the column, since they work in different scopes and expose different parameters. Note The sorting operation DOES NOT change the underlying data source of the Grid. Initial sorting state It is possible to set the initial sorting state of the Grid by passing an array of sorting expressions to the sortingExpressions property of the Grid. public ngOnInit() { this.grid.sortingExpressions = [ { fieldName: 'Name', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } public ngOnInit() { this.grid.sortingExpressions = [ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } Note If values of type string are used by a column of dataType Date, the Grid won't parse them to Date objects and using Grid sorting won't work as expected. If you want to use string objects, additional logic should be implemented on an application level, in order to parse the values to Date objects. Remote Sorting The Grid supports remote sorting, which is demonstrated in the Grid Remote Data Operations topic. Sorting Indicators Templates The sorting indicator icon in the column header can be customized using a template. The following directives are available for templating the sorting indicator for any sorting state (ascending, descending, none): IgxSortHeaderIconDirective – re-templates the sorting icon when no sorting is applied. <ng-template igxSortHeaderIcon> <igx-icon>unfold_more</igx-icon> </ng-template> IgxSortAscendingHeaderIconDirective – re-templates the sorting icon when the column is sorted in ascending order. <ng-template igxSortAscendingHeaderIcon> <igx-icon>expand_less</igx-icon> </ng-template> IgxSortDescendningHeaderIconDirective – re-templates the sorting icon when the column is sorted in descending order. <ng-template igxSortDescendingHeaderIcon> <igx-icon>expand_more</igx-icon> </ng-template> Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $sorted-header-icon-color and sortable-header-icon-hover-color parameters. $custom-theme: grid-theme( $sorted-header-icon-color: #ffb06a, $sortable-header-icon-hover-color: black ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $black-color: black; $orange-color: #ffb06a; $custom-palette: palette($primary: $black-color, $secondary: $orange-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"primary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('primary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridComponent API IgxGridComponent Styles ISortingExpression Additional Resources Grid overview Virtualization and Performance Paging Filtering Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/state-persistence.html": {
    "href": "components/grid/state-persistence.html",
    "title": "Angular Grid State Persistence - Ignite UI for Angular",
    "keywords": "Angular Grid State Persistence Тhe igxGridState directive allows developers to easily save and restore the grid state. When the IgxGridState directive is applied on the grid, it exposes the getState and setState methods that developers can use to achieve state persistence in any scenario. Supported Features IgxGridState directive supports saving and restoring the state of the following features: Sorting Filtering Advanced Filtering Paging Cell Selection Row Selection Column Selection Row Pinning Expansion GroupBy Columns NEW: Multi column headers are now supported out of the box Columns order Column properties defined by the IColumnState interface. Columns templates and functions are restored using application level code, see Restoring Column section. Note The IgxGridState directive does not take care of templates. Go to Restoring Column section to see how to restore column templates. Usage getState - This method returns the grid state in a serialized JSON string, so developers can just take it and save it on any data storage (database, cloud, browser localStorage, etc). The method accepts first optional parameter serialize, which determines whether getState will return an IGridState object or a serialized JSON string. The developer may choose to get only the state for a certain feature/features, by passing in the feature name, or an array with feature names as a second argument. // get all features` state in a serialized JSON string const gridState = state.getState(); // get an `IGridState` object, containing all features original state objects, as returned by the grid public API const gridState: IGridState = state.getState(false); // get the sorting and filtering expressions const sortingFilteringStates: IGridState = state.getState(false, ['sorting', 'filtering']); setState - The setState method accepts the serialized JSON string or IGridState object as argument and will restore the state of each feature found in the object/JSON string. state.setState(gridState); state.setState(sortingFilteringStates) options - The options object implements the IGridStateOptions interface, i.e. for every key, which is the name of a certain feature, there is the boolean value indicating if this feature state will be tracked. getState method will not put the state of these features in the returned value and setState method will not restore state for it. public options = { cellSelection: false; sorting: false; } <igx-grid [igxGridState]=\"options\"></igx-grid> The simple to use single-point API's allows to achieve a full state persistence functionality in just a few lines of code. Copy paste the code from below - it will save the grid state in the browser sessionStorage object every time the user leaves the current page. Whenever the user returns to main page, the grid state will be restored. No more need to configure those complex advanced filtering and sorting expressions every time to get the data you want - do it once and have the code from below do the rest for your users: // app.component.ts @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public ngOnInit() { this.router.events.pipe(take(1)).subscribe((event: NavigationStart) => { this.saveGridState(); }); } public ngAfterViewInit() { this.restoreGridState(); } public saveGridState() { const state = this.state.getState() as string; window.sessionStorage.setItem('grid1-state', state); } public restoreGridState() { const state = window.sessionStorage.getItem('grid1-state'); this.state.setState(state); } Restoring columns IgxGridState will not persist columns templates, column formatters, etc. by default (see limitations). Restoring any of these can be achieved with code on application level. Let's show how to do this for templated columns: Define a template reference variable (in the example below it is #activeTemplate) and assign an event handler for the columnInit event: <igx-grid id=\"grid\" #grid igxGridState (columnInit)=\"onColumnInit($event)\"> <igx-column [field]=\"'IsActive'\" header=\"IsActive\"> <ng-template igxCell #activeTemplate let-column let-val=\"val\"> <igx-checkbox [checked]=\"val\"></igx-checkbox> </ng-template> </igx-column> ... </igx-grid> Query the template view in the component using @ViewChild or @ViewChildren decorator. In the columnInit event handler, assign the template to the column bodyTemplate property: @ViewChild('activeTemplate', { static: true }) public activeTemplate: TemplateRef<any>; public onColumnInit(column: IgxColumnComponent) { if (column.field === 'IsActive') { column.bodyTemplate = this.activeTemplate; column.summaries = MySummary; column.filters = IgxNumberFilteringOperand.instance(); } } Demo Restoring Strategies IgxGridState will not persist neither remote operations nor custom dimension strategies (For further information see Grid Remote Operations sample) by default (see limitations). Restoring any of these can be achieved with code on application level. The IgxGridState exposes an event called stateParsed which can be used to additionally modify the grid state before it gets applied. Let's show how to do this: Note stateParsed is only emitted when we are using setState with string argument. Set custom sorting strategy and custom column and row dimension strategies: <igx-grid #grid [data]=\"data\" [igxGridState]=\"options\" [sortStrategy]=\"customStrategy\" [height]=\"'500px'\"> </igx-grid> @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public customStrategy = NoopSortingStrategy.instance(); public options: IGridStateOptions = {...}; Restoring the state from the sessionStorage and applying the custom strategies looks like the following: public restoreState() { const state = window.sessionStorage.getItem('grid-state'); this.state.stateParsed.pipe(take(1)).subscribe(parsedState => { parsedState.sorting.forEach(x => x.strategy = NoopSortingStrategy.instance()); }); this.state.setState(state as string); } Limitations getState method uses JSON.stringify() method to convert the original objects to a JSON string. JSON.stringify() does not support Functions, thats why the [IgxGridState] directive will ignore the columns formatter, filters, summaries, sortStrategy, cellClasses, cellStyles, headerTemplate and bodyTemplate properties. API References IgxGridComponent IgxGridStateDirective Additional Resources Grid overview Paging Filtering Sorting Selection View page on GitHub"
  },
  "components/grid/summaries.html": {
    "href": "components/grid/summaries.html",
    "title": "Angular Grid Summaries - Ignite UI for Angular",
    "keywords": "Angular Grid Summaries The Angular UI grid in Ignite UI for Angular has a summaries feature that functions on a per-column level as group footer. Angular grid summaries is powerful feature which enables the user to see column information in a separate container with a predefined set of default summary items, depending on the type of data within the column or by implementing a custom angular template in the Grid. Angular Grid Summaries Overview Example Note The summary of the column is a function of all column values, unless filtering is applied, then the summary of the column will be function of the filtered result values Grid summaries can also be enabled on a per-column level in Ignite UI for Angular, which means that you can activate it only for columns that you need. Grid summaries gives you a predefined set of default summaries, depending on the type of data in the column, so that you can save some time: For string and boolean data types, the following function is available: count For number, currency and percent data types, the following functions are available: count min max average sum For date data type, the following functions are available: count earliest latest All available column data types could be found in the official Column types topic. Grid summaries are enabled per-column by setting hasSummary property to true. It is also important to keep in mind that the summaries for each column are resolved according to the column data type. In the igx-grid the default column data type is string, so if you want number or date specific summaries you should specify the dataType property as number or date. Note that the summary values will be displayed localized, according to the grid locale and column pipeArgs. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\"> <igx-column field=\"ProductID\" header=\"Product ID\" width=\"200px\" [sortable]=\"true\"></igx-column> <igx-column field=\"ProductName\" header=\"Product Name\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"ReorderLevel\" width=\"200px\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"true\"></igx-column> </igx-grid> The other way to enable/disable summaries for a specific column or a list of columns is to use the public method enableSummaries/disableSummaries of the igx-grid. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\" > <igx-column field=\"ProductID\" header=\"Product ID\" width=\"200px\" [sortable]=\"true\"></igx-column> <igx-column field=\"ProductName\" header=\"Product Name\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"ReorderLevel\" width=\"200px\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"false\"></igx-column> </igx-grid> <button (click)=\"enableSummary()\">Enable Summary</button> <button (click)=\"disableSummary()\">Disable Summary </button> public enableSummary() { this.grid1.enableSummaries([ {fieldName: 'ReorderLevel', customSummary: this.mySummary}, {fieldName: 'ProductID'} ]); } public disableSummary() { this.grid1.disableSummaries('ProductName'); } Custom Grid Summaries If these functions do not fulfill your requirements you can provide a custom summary for the specific columns. In order to achieve this you have to override one of the base classes IgxSummaryOperand, IgxNumberSummaryOperand or IgxDateSummaryOperand according to the column data type and your needs. This way you can redefine the existing function or you can add new functions. IgxSummaryOperand class provides the default implementation only for the count method. IgxNumberSummaryOperand extends IgxSummaryOperand and provides implementation for the min, max, sum and average. IgxDateSummaryOperand extends IgxSummaryOperand and additionally gives you earliest and latest. import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from 'igniteui-angular'; // import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from '@infragistics/igniteui-angular'; for licensed package class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(data?: any[]): IgxSummaryResult[] { const result = super.operate(data); result.push({ key: 'test', label: 'Test', summaryResult: data.filter(rec => rec > 10 && rec < 30).length }); return result; } } As seen in the examples, the base classes expose the operate method, so you can choose to get all default summaries and modify the result, or calculate entirely new summary results. The method returns a list of IgxSummaryResult. interface IgxSummaryResult { key: string; label: string; summaryResult: any; } and take optional parameters for calculating the summaries. See Custom summaries, which access all data section below. Note In order to calculate the summary row height properly, the Grid needs the operate method to always return an array of IgxSummaryResult with the proper length even when the data is empty. And now let's add our custom summary to the column UnitsInStock. We will achieve that by setting the summaries property to the class we create below. <igx-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\" > <igx-column field=\"ProductID\" width=\"200px\" [sortable]=\"true\"> </igx-column> <igx-column field=\"ProductName\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\"> </igx-column> <igx-column field=\"UnitsInStock\" width=\"200px\" [dataType]=\"'number'\" [hasSummary]=\"true\" [summaries]=\"mySummary\" [sortable]=\"true\"> </igx-column> <igx-column field=\"ReorderLevel\" width=\"200px\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"true\"> </igx-column> </igx-grid> ... export class GridComponent implements OnInit { mySummary = MySummary; .... } Custom summaries, which access all data Now you can access all Grid data inside the custom column summary. Two additional optional parameters are introduced in the IgxSummaryOperand operate method. As you can see in the code snippet below the operate method has the following three parameters: columnData - gives you an array that contains the values only for the current column allGridData - gives you the whole grid data source fieldName - current column field class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(columnData: any[], allGridData = [], fieldName?): IgxSummaryResult[] { const result = super.operate(allData.map(r => r[fieldName])); result.push({ key: 'test', label: 'Total Discontinued', summaryResult: allData.filter((rec) => rec.Discontinued).length }); return result; } } Summary Template igxSummary targets the column summary providing as a context the column summary results. <igx-column ... [hasSummary]=\"true\"> <ng-template igxSummary let-summaryResults> <span> My custom summary template</span> <span>{{ summaryResults[0].label }} - {{ summaryResults[0].summaryResult }}</span> </ng-template> </igx-column> When a default summary is defined, the height of the summary area is calculated by design depending on the column with the largest number of summaries and the display density of the grid. Use the summaryRowHeight input property to override the default value. As an argument it expects a number value, and setting a falsy value will trigger the default sizing behavior of the grid footer. Note Column summary template could be defined through API by setting the column summaryTemplate property to the required TemplateRef. Formatting summaries By default, summary results, produced by the built-in summary operands, are localized and formatted according to the grid locale and column pipeArgs. When using custom operands, the locale and pipeArgs are not applied. If you want to change the default appearance of the summary results, you may format them using the summaryFormatter property. public dateSummaryFormat(summary: IgxSummaryResult, summaryOperand: IgxSummaryOperand): string { const result = summary.summaryResult; if(summaryOperand instanceof IgxDateSummaryOperand && summary.key !== 'count' && result !== null && result !== undefined) { const pipe = new DatePipe('en-US'); return pipe.transform(result,'MMM YYYY'); } return result; } <igx-column ... [summaryFormatter]=\"dateSummaryFormat\"></igx-column> Summaries with Group By When you have grouped by columns, the Grid allows you to change the summary position and calculation mode using the summaryCalculationMode and summaryPosition properties. Along with these two properties the IgxGrid exposes and showSummaryOnCollapse property which allows you to determine whether the summary row stays visible when the group row that refers to is collapsed. The available values of the summaryCalculationMode property are: rootLevelOnly - Summaries are calculated only for the root level. childLevelsOnly - Summaries are calculated only for the child levels. rootAndChildLevels - Summaries are calculated for both root and child levels. This is the default value. The available values of the summaryPosition property are: top - The summary row appears before the group by row children. bottom - The summary row appears after the group by row children. This is the default value. The showSummaryOnCollapse property is boolean. Its default value is set to false, which means that the summary row would be hidden when the group row is collapsed. If the property is set to true the summary row stays visible when group row is collapsed. Note The summaryPosition property applies only for the child level summaries. The root level summaries appear always fixed at the bottom of the Grid. Demo Exporting Summaries There is an exportSummaries option in IgxExcelExporterOptions that specifies whether the exported data should include the grid's summaries. Default exportSummaries value is false. The IgxExcelExporterService will export the default summaries for all column types as their equivalent excel functions so they will continue working properly when the sheet is modified. Try it for yourself in the example below: The exported file includes a hidden column that holds the level of each DataRecord in the sheet. This level is used in the summaries to filter out the cells that need to be included in the summary function. In the table below, you can find the corresponding Excel formula for each of the default summaries. Data Type Function Excel Function string, boolean count =\"Count: \"&COUNTIF(start:end, recordLevel) number, currency, percent count =\"Count: \"&COUNTIF(start:end, recordLevel) min =\"Min: \"&MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)) max =\"Max: \"&MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)) average =\"Avg: \"&AVERAGEIF(start:end, recordLevel, rangeStart:rangeEnd) sum =\"Sum: \"&SUMIF(start:end, recordLevel, rangeStart:rangeEnd) date count =\"Count: \"&COUNTIF(start:end, recordLevel) earliest =\"Earliest: \"& TEXT(MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) latest =\"Latest: \"&TEXT(MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) Known Limitations Limitation Description Exporting custom summaries Custom summaries will be exported as strings instead of Excel functions. Exporting templated summaries Templated summaries are not supported and will be exported as the default ones. Keyboard Navigation The summary rows can be navigated with the following keyboard interactions: UP - navigates one cell up DOWN - navigates one cell down LEFT - navigates one cell left RIGHT - navigates one cell right CTRL + LEFT or HOME - navigates to the leftmost cell CTRL + RIGHT or END - navigates to the rightmost cell Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-summary-theme and accepts the $background-color, $focus-background-color, $label-color, $result-color, $pinned-border-width, $pinned-border-style and $pinned-border-color parameters. $custom-theme: grid-summary-theme( $background-color: #e0f3ff, $focus-background-color: rgba( #94d1f7, .3 ), $label-color: #e41c77, $result-color: black, $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: #e41c77 ); The last step is to include the component mixins: @include grid-summary($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-summary($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $blue-color: #7793b1; $green-color: #00ff2d; $my-custom-palette: palette($primary: $blue-color, $secondary: $green-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-summary-theme( $background-color: color($my-custom-palette, \"primary\", 700), $focus-background-color: color($my-custom-palette, \"primary\", 800), $label-color: color($my-custom-palette, \"secondary\", 500), $result-color: color($my-custom-palette, \"grays\", 900), $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: color($my-custom-palette, \"secondary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid-summary: // Extending the light grid summary schema $my-summary-schema: extend($_light-grid-summary, ( background-color: (igx-color: ('primary', 700)), focus-background-color: (igx-color: ('primary', 800)), label-color: (igx-color: ('secondary', 500)), result-color: (igx-color: ('grays', 900)), pinned-border-width: 2px, pinned-border-style: dotted, pinned-border-color: (igx-color: ('secondary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid-summary: $my-summary-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-summary-theme( $palette: $my-custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxGridComponent API IgxGridComponent Styles IgxGridSummaries Styles IgxSummaryOperand IgxNumberSummaryOperand IgxDateSummaryOperand IgxColumnGroupComponent IgxColumnComponent Additional Resources Grid overview Column Data Types Virtualization and Performance Paging Filtering Sorting Column Moving Column Pinning Column Resizing Selection Selection-based Aggregates Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/toolbar.html": {
    "href": "components/grid/toolbar.html",
    "title": "Angular Grid Toolbar - Ignite UI for Angular",
    "keywords": "Angular Grid Toolbar The Grid in Ignite UI for Angular provides an IgxGridToolbarComponent which is essentially a container for UI operations. The Angular toolbar is located at the top of the Angular component, i.e the Grid and it matches its horizontal size. The toolbar container can host predefined UI controls for the following Grid's features: Column Hiding Column Pinning Excel Exporting Advanced Filtering or just any other custom content. The toolbar and the predefined UI components support Angular events and expose API for developers. Angular Toolbar Grid Example The predefined actions and title UI components are added inside the <igx-grid-toolbar> and this is all needed to have a toolbar providing default interactions with the corresponding Grid features: <igx-grid [data]=\"data\" [autoGenerate]=\"true\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Grid Toolbar</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering><igx-grid-toolbar-advanced-filtering> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning> <igx-grid-toolbar-exporter></igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-grid> Note: As seen in the code snippet above, the predefined actions UI components are wrapped in the <igx-grid-toolbar-actions> container. This way, the toolbar title is aligned to the left of the toolbar and the actions are aligned to the right of the toolbar. Of course, each of these UIs can be added independently of each other, or may not be added at all. This way the toolbar container will be rendered empty: <igx-grid [data]=\"data\" [autoGenerate]=\"true\"> <igx-grid-toolbar> </igx-grid-toolbar> </igx-grid> For a comprehensive look over each of the default UI components, continue reading the Features section below. Features The toolbar is great at separating logic/interactions which affects the grid as a whole. As shown above, it can be configured to provide default components for controlling, column hiding, column pinning, advanced filtering and exporting data from the grid. These features can be enabled independently from each other by following a pattern similar to the card component of the Ignite UI for Angular suite. Listed below are the main features of the toolbar with example code for each of them. Title Setting a title for the toolbar in your grid is achieved by using the IgxGridToolbarTitleComponent. Users can provide anything from simple text to more involved templates. <igx-grid-toolbar> <igx-grid-toolbar-title>Grid toolbar title</igx-grid-toolbar-title> </igx-grid-toolbar> Actions The toolbar exposes a specific container where users can place actions/interactions in relation to the parent grid. As with the title portion of the toolbar, users can provide anything inside that template part, including the default toolbar interaction components. <igx-grid-toolbar> <igx-grid-toolbar-actions> <button igxButton>Action</button> <igx-select></igx-select> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> Each action now exposes a way to change the overlay settings of the actions dialog by using the overlaySettings input, example: <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning [overlaySettings]=\"overlaySettingsScaleCenter\"></igx-grid-toolbar-pinning> <igx-grid-toolbar-hiding [overlaySettings]=\"overlaySettingsAuto\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> public data: any[]; public positionStrategyScaleCenter = new GlobalPositionStrategy({ openAnimation: scaleInCenter, closeAnimation: scaleOutCenter }); public overlaySettingsScaleCenter = { positionStrategy: this.positionStrategyScaleCenter, scrollStrategy: new AbsoluteScrollStrategy(), modal: true, closeOnEscape: true }; public positionStrategyAuto = new AutoPositionStrategy(); public overlaySettingsAuto = { positionStrategy: this.positionStrategyAuto, scrollStrategy: new AbsoluteScrollStrategy(), modal: false, closeOnEscape: false }; constructor() { this.data = athletesData; } The default overlaySettings are using ConnectedPositionStrategy with Absolute scroll strategy, modal set to false, with enabled close on escape and close on outside click interactions. Column pinning Toolbar Pinning component provides the default UI for interacting with column pinning in the grid. The component is setup to work out of the box with the parent grid containing the toolbar as well as several input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning title=\"Grid pinned columns\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-pinning> </igx-grid-toolbar-actions> </igx-grid-toolbar> Column hiding Toolbar Hiding component provides the default UI for interacting with column hiding. Exposes the same input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding title=\"Grid column hiding\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> Advanced filtering Toolbar Advanced Filtering component provides the default UI for the Advanced Filtering feature. The component exposes a way to change the default text of the button. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering>Custom text for the toggle button</igx-grid-toolbar-advanced-filtering> </igx-grid-toolbar-actions> </igx-grid-toolbar> Data exporting As with the rest of the toolbar actions, exporting is provided through a Toolbar Exporter component out of the box. The exporting component is using the respective service for the target data format (Excel CSV). That means if the respective service is not provided through the dependency injection chain, the component won't be able to export anything. If you need a refresher on the DI in Angular, check the official guide. Here is a sample snippet showing how to enable all export services for your application. // app.module.ts import { IgxExcelExporterService, IgxCsvExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService, IgxCsvExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... providers: [IgxExcelExporterService, IgxCsvExporterService ] }) export class AppModule { ... } Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. The toolbar exporter component exposes several input properties for customizing both the UI and the exporting experience. These range from changing the display text, to enabling/disabling options in the dropdown to customizing the name of the generated file. For full reference, consult the API documentation for the toolbar exporter component. Here is a snippet showing some of the options which can be customized through the Angular template: <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-exporter <!-- If active, enables the csv export entry in the dropdown UI --> [exportCSV]=\"csvExportEnabled\" <!-- If active, enables the excel export entry in the dropdown UI --> [exportExcel]=\"excelExportEnabled\" <!-- The name of the generated export file without the file extension --> filename=\"exported_data\" > Custom text for the exporter button <span excelText>Custom text for the excel export entry</span> <span csvText>Custom text for the CSV export entry</span> </igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> In addition to changing the exported filename, the user can further configure the exporter options by waiting for the toolbarExporting event and customizing the options entry in the event properties. Note By default when exporting to CSV the exporter exports using a comma separator and uses a '.csv' extension for the output file. You can customize these exporting parameters by subscribing to events of the exporter or changing the values of the exporter options fields. You can also cancel the export process by setting the cancel field of the event args to true. The following code snippet demonstrates subscribing to the toolbar exporting event and configuring the exporter options: <igx-grid (toolbarExporting)=\"configureExport($event)\" ></igx-grid> configureExport(args: IGridToolbarExportEventArgs) { const options: IgxExporterOptionsBase = args.options; options.fileName = `Report_${new Date().toDateString()}`; if (options instanceof IgxExcelExporterOptions) { options.columnWidth = 10; } else { options.fileType = CsvFileTypes.TSV; options.valueDelimiter = '\\t'; } args.exporter.columnExporting.subscribe((columnArgs: IColumnExportingEventArgs) => { // Don't export image fields columnArgs.cancel = columnArgs.header === 'Athlete' || columnArgs.header === 'Country'; }); } The following sample demonstrates how to customize the exported files: Exporting Indicator When using the default toolbar exporter component, whenever an export operation takes place the toolbar will show a progress indicator while the operation is in progress. Moreover, users can set the toolbar showProgress property and use for their own long running operations or just as another way to signify an action taking place in the grid. The sample belows uses has significant amount of data, in order to increase the time needed for data export so the progressbar can be seen. Additionally it has another button that simulates a long running operation in the grid: Custom Content Note This replaces the old toolbar template directive. If you are migrating from a version before v11 our migrations will handle the moving of the template content. However, we do not handle the bindings in the template, so make sure to double check the modified template files after the migration completes. If the actions part of the toolbar component is not sufficient for a particular use case, the toolbar itself has a general content projection where users can provide additional UI. If the user needs the respective grid instance for API calls or bindings, they can create a template reference variable. Here is a sample snippet: <igx-grid #gridRef ...> ... <igx-grid-toolbar> <igx-grid-toolbar-title>{{ titleBinding }}</igx-grid-toolbar-title> <!-- Everything between the toolbar tags except the default toolbar components/directives will be projected as custom content. --> <button igxButton=\"flat\" igxRipple (click)=\"#gridRef.clearSort()\"> <igx-icon fontSet=\"material\">clear</igx-icon> Clear Sort </button> <igx-grid-toolbar-actions> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-grid> The following sample demonstrates how to add an additional button to the toolbar to clear the sorting set by clicking on the columns' headers: Styling To get started with styling the toolbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; First, let's create a new palette. $my-dark-palette: palette( $primary: #2466ff, $secondary: #FFCD0F, $surface: #2a2b2f, $grays: #fff, ); $my-dark-color: color($my-dark-palette, 'surface'); Now, create a new theme that extends the grid-toolbar-theme and modify the $background-color and the $title-text-color parameters. $dark-grid-toolbar-theme: grid-toolbar-theme( $palette: $my-dark-palette, $background-color: $my-dark-color, $title-text-color: color($my-dark-palette, 'secondary'), $dropdown-background: $my-dark-color, ); To theme the column actions menus of the toolbar, we have to change the theme of the column-actions-theme component. $dark-column-actions-theme: column-actions-theme( $palette: $my-dark-palette, $title-color: color($my-dark-palette, 'secondary'), $background-color: color($my-dark-palette, 'surface') ); Since the column actions are using other components - igx-button, igx-checkbox, and igx-input-group, we need to change their themes to match our new toolbar theme. $dark-button-theme: button-theme( $palette: $my-dark-palette, $outlined-background: color($my-dark-palette, 'secondary'), $outlined-hover-background: color($my-dark-palette, 'grays', 100), $outlined-hover-text-color: color($my-dark-palette, 'secondary') ); $dark-checkbox-theme: checkbox-theme( $palette: $my-dark-palette, $tick-color: $my-dark-color, ); $dark-input-group-theme: input-group-theme( $palette: $my-dark-palette ); The last step is to include the newly created themes. :host { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } Note If $legacy-support is set to false(default), include the component css variables like that: :host { @include css-vars($dark-grid-toolbar-theme); @include css-vars($dark-column-actions-theme); @include css-vars($dark-checkbox-theme); @include css-vars($dark-input-group-theme); @include css-vars($dark-button-theme); } Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } } Demo API References The Grid Toolbar service has a few more APIs to explore, which are listed below. IgxGridToolbarActionsComponent IgxGridToolbarAdvancedFilteringComponent IgxGridToolbarComponent IgxGridToolbarExporterComponent IgxGridToolbarHidingComponent IgxGridToolbarPinningComponent IgxGridToolbarTitleComponent IgxGridComponent events: toolbarExporting Styles: IgxGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/validation.html": {
    "href": "components/grid/validation.html",
    "title": "Editing and Validation in Angular Grid - Infragistics",
    "keywords": "Angular Grid Editing and Validation The Grid's editing exposes a built-in validation mechanism of user input when editing cells/rows. It extends the Angular Form validation functionality to allow easier integration with a well known functionality. When the state of the editor changes, visual indicators are applied to the edited cell. Configuration Configure via template-driven configuration We extend some of the Angular Forms validator directives to directly work with the IgxColumn. The same validators are available as attributes to be set declaratively in igx-column. The following validators are supported out-of-the-box: required min max email minlength maxlength pattern To validate that a column input would be set and the value is going to be formatted as an email, you can use the related directives: <igx-column [field]=\"email\" [header]=\"User E-mail\" required email></igx-column> The following sample demonstrates how to use the prebuilt required, email and min validator directives in a Grid. Configure via reactive forms We expose the FormGroup that will be used for validation when editing starts on a row/cell via a formGroupCreated event. You can modify it by adding your own validators for the related fields: <igx-grid (formGroupCreated)='formCreateHandler($event)' ...> public formCreateHandler(args: IGridFormGroupCreatedEventArgs) { const formGroup = args.formGroup; const orderDateRecord = formGroup.get('OrderDate'); const requiredDateRecord = formGroup.get('RequiredDate'); const shippedDateRecord = formGroup.get('ShippedDate'); orderDateRecord.addValidators(this.futureDateValidator()); requiredDateRecord.addValidators(this.pastDateValidator()); shippedDateRecord.addValidators(this.pastDateValidator()); } You can decide to write your own validator function, or use one of the built-in Angular validator functions. Validation service API The grid exposes a validation service via the validation property. That service has the following public APIs: valid - returns if the grid validation state is valid. getInvalid - returns records with invalid states. clear - clears state for record by id or clears all state if no id is provided. markAsTouched - marks the related record/field as touched. Invalid states will persis until the validation errors in them are fixed according to the validation rule or they are cleared. Validation triggers Validation will be triggered in the following scenarios: While editing via the cell editor based on the grid's validationTrigger. Either on change while typing in the editor, or on blur when the editor loses focus or closes. When updating cells/rows via the API - updateRow, updateCell etc.. When using batch editing and the undo/redo API of the transaction service. Note: Validation will not trigger for records that have not been edited via user input or via the editing API. Visual indicators on the cell will only shown if the related input is considered touched - either via user interaction or via the markAsTouched API of the validation service. Angular Grid Validation Customization Options Set a custom validator You can define your own validation directive to use on a <igx-column> in the template. @Directive({ selector: '[phoneFormat]', providers: [{ provide: NG_VALIDATORS, useExisting: PhoneFormatDirective, multi: true }] }) export class PhoneFormatDirective extends Validators { @Input('phoneFormat') public phoneFormatString = ''; public validate(control: AbstractControl): ValidationErrors | null { return this.phoneFormatString ? phoneFormatValidator(new RegExp(this.phoneFormatString, 'i'))(control) : null; } } Once it is defined and added in your app module you can set it declaratively to a given column in the grid: <igx-column phoneFormat=\"\\+\\d{1}\\-(?!0)(\\d{3})\\-(\\d{3})\\-(\\d{4})\\b\" ...> Change default error template You can define your own custom error template that will be displayed in the error tooltip when the cell enters invalid state. This is useful in scenarios where you want to add your own custom error message or otherwise change the look or content of the message. <igx-column ... > <ng-template igxCellValidationError let-cell='cell' let-defaultErr=\"defaultErrorTemplate\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> <div *ngIf=\"cell.validation.errors?.['phoneFormat']\"> Please enter correct phone format </div> </ng-template> </igx-column> Prevent exiting edit mode on invalid state In some cases you may want to disallow submitting an invalid value in the data. In that scenarios you can use the cellEdit or rowEdit events and cancel the event in case the new value is invalid. Both events' arguments have a valid property and can be canceled accordingly. How it is used can be seen in the Cross-field Validation example <igx-grid (cellEdit)='cellEdit($event)' ...> public cellEdit(evt) { if (!evt.valid) { evt.cancel = true; } } Example The below example demonstrates the above-mentioned customization options. Cross-field validation In some scenarios validation of one field may depend on the value of another field in the record. In that case a custom validator can be used to compare the values in the record via their shared FormGroup. The below sample demonstrates a cross-field validation between different field of the same record. It checks the dates validity compared to the current date and between the active and created on date of the record as well as the deals won/lost ration for each employee. All errors are collected in a separate pinned column that shows that the record is invalid and displays the related errors. The next lines of code show the cross-field validator function, which contains the comparisons and sets the related errors relative to them. private rowValidator(): ValidatorFn { return (formGroup: FormGroup): ValidationErrors | null => { let returnObject = {}; const createdOnRecord = formGroup.get('created_on'); const lastActiveRecord = formGroup.get('last_activity'); const winControl = formGroup.get('deals_won'); const loseControl = formGroup.get('deals_lost'); const actualSalesControl = formGroup.get('actual_sales'); // Validate dates const curDate = new Date(); if (new Date(createdOnRecord.value) > curDate) { // The created on date shouldn't be greater than current date. returnObject['createdInvalid'] = true; } if (new Date(lastActiveRecord.value) > curDate) { // The last active date shouldn't be greater than current date. returnObject['lastActiveInvalid'] = true; } if (new Date(createdOnRecord.value) > new Date(lastActiveRecord.value)) { // The created on date shouldn't be greater than last active date. returnObject['createdLastActiveInvalid'] = true; } // Validate deals const dealsRatio = this.calculateDealsRatio(winControl.value, loseControl.value); if (actualSalesControl.value === 0 && dealsRatio > 0) { // If the actual sales value is 0 but there are deals made. returnObject['salesZero'] = true; } if (actualSalesControl.value > 0 && dealsRatio === 0) { // If the deals ratio based on deals won is 0 but the actual sales is bigger than 0. returnObject['salesNotZero'] = true; } return returnObject; }; } public calculateDealsRatio(dealsWon, dealsLost) { if (dealsLost === 0) return dealsWon + 1; return Math.round(dealsWon / dealsLost * 100) / 100; } The cross-field validator can be added to the formGroup of the row from formGroupCreated event, which returns the new formGroup for each row when entering edit mode: <igx-grid #grid1 [data]=\"transactionData\" [width]=\"'100%'\" [height]=\"'480px'\" [autoGenerate]=\"false\" [batchEditing]=\"true\" [rowEditable]=\"true\" [primaryKey]=\"'id'\" (formGroupCreated)='formCreateHandler($event)'> <!-- ... --> </igx-grid> public formCreateHandler(evt: IGridFormGroupCreatedEventArgs) { evt.formGroup.addValidators(this.rowValidator()); } The different errors are displayed in a templated cell that combines all errors in a single tooltip. Depending on the row valid state different icon is displayed: <igx-column field=\"row_valid\" header=\" \" [editable]=\"false\" [pinned]=\"true\" [width]=\"'50px'\"> <ng-template igxCell let-cell=\"cell\"> <div *ngIf=\"isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" style=\"margin-right: '-10px';\"> <img width=\"18\" src=\"assets/images/grid/active.png\"/> </div> <div *ngIf=\"!isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" style=\"margin-right: '-10px';\"> <img width=\"18\" src=\"assets/images/grid/expired.png\"/> </div> <div #tooltipRef=\"tooltip\" igxTooltip [style.width]=\"'max-content'\"> <div *ngFor=\"let message of stateMessage(cell)\"> {{message}} </div> </div> </ng-template> </igx-column> The error messages are gathered in the stateMessage function, which gathers the errors for each cell, because each column could have templated form validations and then checks the errors for the row itself, which come from the custom rowValidator. public stateMessage(cell: CellType) { const messages = []; const row = cell.row; const cellValidationErrors = row.cells.filter(x => !!x.validation.errors); cellValidationErrors.forEach(cell => { if (cell.validation.errors) { if (cell.validation.errors.required) { messages.push(`The \\`${cell.column.header}\\` column is required.`); } // Other cell errors ... } }); if (row.validation.errors?.createdInvalid) { messages.push(`The \\`Date of Registration\\` date cannot be in the future.`); } // Other cross-field errors... return messages; } Cross-field example The below sample demonstrates the cross-field validation in action. Styling Using the Ignite UI for Angular Theme Library, we can alter the default validation styles while editing. In the example below, we will make use of the exposed template for validation message, which pops out in a tooltip and overriding the error color to modify the default looks of the validation. We will also style the background of the invalid rows to make them more distinct. Import theme The easiest way to style and access css variables is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Include the styles In order to change the error color you can use the css variable --igx-error-500: --igx-error-500: 34, 80%, 63%; Custom Templates Changing the default error template allows setting custom classes and styles: <ng-template igxCellValidationError let-cell='cell' let-defaultErr='defaultErrorTemplate'> <div class=\"validator-container\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> </div> </ng-template> Invalid row and cell styles Rows and cells provide API for the developers to know if a row or cell is invalid and what kind of errors are active. public rowStyles = { background: (row: RowType) => row.validation.status === 'INVALID' ? '#FF000033' : '#00000000' }; public cellStyles = { 'invalid-cell': (rowData, columnKey) => { const pKey = this.grid.primaryKey; const cell = this.grid.getCellByKey(rowData[pKey], columnKey); return cell && cell.validation.status === 'INVALID'; } } <igx-grid [rowStyles]=\"rowStyles\"> <igx-column field=\"ReorderLevel\" header=\"ReorderLever\" required [cellClasses]=\"cellStyles\"> Demo API References IgxBaseTransactionService IgxGridComponent IgxColumnComponent Known Issues and Limitations Limitation Description When validationTrigger is blur, editValue and validation will trigger only after editor is blurred. Reason is that this utilizes the formControl's updateOn property. This determines the event on which the formControl will update and trigger related validators. Additional Resources Build CRUD operations with igxGrid Grid Overview Grid Editing Grid Row Editing Grid Row Adding Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grid/virtualization.html": {
    "href": "components/grid/virtualization.html",
    "title": "Angular Grid Virtualization and Performance - Ignite UI for Angular",
    "keywords": "Angular Grid Virtualization and Performance In Ignite UI for Angular, the IgxGrid control now utilizes the igxForOf directive and virtualizes its content both vertically and horizontally. Angular Grid Virtualization and Performance Example Enabling Virtualization By utilizing the igxForOf directive the IgxGrid now optimizes DOM rendering and memory consumption by rendering only what is currently visible in the view port and swapping the displayed data while the user scrolls the data horizontally/vertically. IgxGrid's width and height defaults to 100% which will enable virtualization if the content displayed cannot fit inside the available space and scrollbars are required either vertically or horizontally. However, it is also possible to explicitly set the Grid's width and/or height to null which means that the related dimension will be determined by the total size of the items inside. No scrollbar will then be shown and all items will be rendered along the respective dimension (columns if width is null and rows if height is null). The size of the data chunks is determined by: The row height for the vertical (row) virtualization. This is determined by the rowHeight option and is 50(px) by default. The individual column widths in pixels for the horizontal (column) virtualization. They can be determined by either setting explicit width for each column component or setting the Grid's columnWidth option, which will be applied to all columns that don't have explicit width set. In most cases, letting the grid apply its default behavior by leaving dimensions unset will produce the desired layout. For column widths it is determined by the column count, the columns with set width, and the calculated width of the Grid's container. The grid will try to fit all columns inside the available space as long as the width it attempts to assign is not under 136(px). In such cases, columns with unassigned width will receive the minimum width of 136(px) and a horizontal scrollbar will be shown. The grid will be horizontally virtualized. Explicitly setting column widths in percentages (%) will, in most cases, create a grid that is not virtualized horizontally as it will not have a horizontal scrollbar. Remote Virtualization The Grid supports remote virtualization, which is demonstrated in the Grid Remote Data Operations topic. Virtualization Limitations On Mac OS horizontal scrollbar is not visible when \"Show scrollbars only when scrolling\" system option is set to true (which is the default value). This is because the Grid’s row container has an overflow set to hidden. Change the option to \"Always\" and the scrollbar will appear. FAQ Why having dimensions in the Grid is necessary for virtualization to work? Without information about the sizes of the container and the items before rendering them setting the width or height of a scrollbar or determining which of the items should be in the view when you scroll to a random location in the Grid is erroneous. Any assumptions on what the actual dimensions might be could lead to unnatural behavior of the scrollbar and ultimately suboptimal experience for the end-user. This is why setting the related dimensions is enforced in order for virtualization to take effect. API References IgxGridComponent IgxGridComponent Styles IgxColumnComponent IgxForOfDirective IForOfState Additional Resources Grid overview Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/grids-and-lists.html": {
    "href": "components/grids-and-lists.html",
    "title": "Angular Grids & Tables | Fastest Angular UI Grid | Infragistics",
    "keywords": ".themes-container{ display: none !important; } .h3, h3{ font-weight: bold; } .cta-area{ text-align: center; background-color: #f8f8f8; padding: 2rem; } div#features-list{ margin: 0 auto; -webkit-column-gap: 12%; -moz-column-gap: 12%; column-gap: 12%; -webkit-columns: 2; -moz-columns: 2; columns: 2 } .feature{ padding: 15px 0; } .feature__details p{ margin: 0; margin-top: 1rem; } div#list-features-included{ display: -webkit-box; display: -ms-flexbox; display: flex; -ms-flex-wrap: wrap; flex-wrap: wrap; } div#list-features-included{ -webkit-columns: 3; -moz-columns: 3; columns: 3; -webkit-column-gap: 10%; -moz-column-gap: 10%; column-gap: 10%; } div#support-section-wrapper{ display: -webkit-box; display: -ms-flexbox; display: flex; } div.support-section{ padding: 1.25rem; text-align: left; } h2#frequently-asked-questions{ padding: .2rem 0 .5rem 1.1rem; margin-top: 1.5rem; border: 1px solid #ccc; border-top-left-radius: 9px; border-top-right-radius: 9px; } div#faqs-accordion-wrapper { border: 1px solid #ccc; border-top: none; border-bottom-left-radius: 9px; border-bottom-right-radius: 9px; } .faqs-accordion-content{ border-bottom: 1px solid #ccc; padding: 0 .9rem; cursor: pointer; } .faqs-accordion-content:hover{ background-color: #f2f2f2; } .faqs-accordion-content:last-child{ border-top: none; } .faqs-accordion-content:last-child{ border-bottom: none; } .faqs-accordion { display: -webkit-inline-box; display: -ms-inline-flexbox; display: inline-flex; background: transparent; border: none; text-align: left; outline: none; -webkit-transition: 0.4s; -o-transition: 0.4s; transition: 0.4s; } .faqs-accordion-panel { padding: 0 18px 5px 18px; background: transparent; max-height: 0; overflow: hidden; -webkit-transition: max-height 0.2s ease-out; -o-transition: max-height 0.2s ease-out; transition: max-height 0.2s ease-out; } .faqs-accordion:before { font-family: Material Icons; content: \"keyboard_arrow_down\"; font-size: 25px; width: 30px; height: 25px; } .faqs-accordion-content.active .faqs-accordion:before { font-family: Material Icons; content: \"keyboard_arrow_up\"; font-size: 25px; width: 30px; height: 25px; } .faqs-accordion-panel ul{ margin-bottom: 15px; } h3#quick-and-easy-to-customize-build-and-implement{ text-align: center; } h3#excel-library-for-the-angular-grid ~ h3{ visibility: visible; } @media only screen and (max-width: 767px){ div#list-features-included { -webkit-box-orient: vertical; -webkit-box-direction: normal; -ms-flex-direction: column; flex-flow: column; align-items: center; display: flex; } div#list-features-included ul { margin-left: auto; width: 70%; margin-right: auto; } div.support-section:last-child:last-child{ border-left: none; } div#support-section-wrapper{ flex-flow: column; } div.support-section:last-child{ padding-left: 1.25rem; } } The Fastest Angular Data Grid Ignite UI for Angular provides a complete library of Angular-native, Material-based UI components, including the world’s fastest virtualized Angular data grid. Angular Grid Example In this angular grid example, you can see how users can customize their data view by leveraging the various features built into the grid, like data search and filtering, columns sorting, resizing, pinning and hiding, row selection, export to excel and csv, horizontal and vertical scrolling. We have provided examples for cell templating that includes components like linear progress bar indicator and sparkline. What is an Angular Data Grid? An Angular data grid is a component used to display tabular data in a series of rows and columns. Data grids, also known as tables, are well known in the desktop world with popular software such as Microsoft Excel. While grids have been available on desktop platforms for a long time, they have recently become part of web app UIs, such as Angular UI. Modern grids can be complex and may include a range of functionalities, including data binding, editing, Excel-like filtering, custom sorting, grouping, row reordering, row and column freezing, row aggregation, and exporting to Excel, CSV, and pdf formats. Why Use an Angular Data Grid? Angular data grids are essential in use cases where lots of data must be stored and sorted through quickly. This can include industries such as financial or insurance that use high-volume, high-velocity data frequently. Often the success of these companies is dependent on the functionality and performance of these data grids. When stock decisions need to be made in microseconds, for example, it’s imperative that the data grid performs with no lag time or flicker. Key Features The Ignite UI for Angular Data Grid is not just for high-volume and real-time data. It is a feature-rich Angular grid that gives you capabilities that you would never be able to accomplish with so little code on your own. This example demonstrates a few of the data grid’s key features: Virtualized Rows and Columns so you can load millions of records Inline Editing with Cell, Row, and Batch Update options Excel-style Filtering and full Excel Keyboard Navigation capability Interactive Outlook-style Grouping Column Summaries based on any data in a grid cell or column Export to Excel, including Data Visualization Size (Display Density) to adjust the height and sizing of the rows Column templates like Sparkline Column and Image Column Data Virtualization and Performance Seamlessly scroll through unlimited rows and columns in your Angular grid, with the data grid’s column and row level virtualization. With support for local or remote data sources, you get the best performance no matter where your data lives. Your users will experience Excel-like scrolling, with enterprise speed — no lag, screen flicker, or visual delay — giving you the best user experience (UX) without compromising performance. Quick and Easy to Customize, Build and Implement The Ignite UI Angular Data Grid can handle unlimited rows and columns of data, while providing access to custom templates and real-time data updates. Featuring an intuitive API for easy theming and branding, you can quickly bind to data with minimal code. view samples Angular Grid Paging, Sorting, Filtering, & Searching Allow users to navigate your data set with our default pager or create your own template to give your own paging experience. With complete support for single and multi-column sorting, full-text search on the grid, and several advanced filtering options, including data-type based Microsoft Excel-style Filtering. Inline Angular Grid Editing We provide you default cell templates for editable columns which are based on the data type of the column. You can define your own custom templates for editable columns and override default behavior for committing and discarding changes in the cell value. Keyboard Navigation & Row/Cell Selection in the Angular Grid Ensure accessibility compliance and improve usability, enabling Excel-like keyboard navigation in the Angular data grid, using the up, down, right, left, tab, and Enter keys. You can toggle single or multiple row selection in the Angular grid using the mouse or keyboard to select or de-select full rows, or use the built-in select all / de-select all checkbox in the grid toolbar to work with row selection. Learn about our most recent enhancements to this feature. Angular Grid Accessibility & ARIA Support Each of our Angular components in Ignite UI for Angular has been implemented according to the latest accessibility guidelines and specifications. Our Angular components have been tested using OS or Browser provided accessibility technology – screen readers. Our team ensures not only that the guidelines are implemented, but also that the actual content delivered to visually impaired or blind people is actually consumable and user-friendly for them. The Ignite UI for Angular data grid is fully accessible with a11y Keyboard accessibility, ARIA, and accessible color palette. Learn more. Column Grouping, Pinning, Summaries, & Moving in the Angular Grid Group columns or pre-set column groups via mouse interaction, touch or our API, with support for built-in column summaries or custom summary templates. Enable users to interactively hide or move columns, with full support for interactive column pinning, during move, drag, and reorder operations. Multi-Column Headers in the Angular Grid Enable multi-column headers, allowing you to group columns under a common header. Every column group could be a representation of combinations between other groups or columns, with full support for column pinning, interactive column moving within groups, sorting, and hiding groups. Theming, Styling, & Templating in the Angular Grid With Ignite UI for Angular you can customize cell appearance with CSS or re-template any cell with ng-template to give any cell render appearance. With full support for Material Design, you can customize your branded experience with our simple-to-use theming engine. Excel Library for the Angular Grid Full support for exporting data grids to XLXS, XLS, TSV or CSV. The Ignite UI for Angular Excel library includes 300+ formulas, Table support, Conditional Formatting, Chart creation and more – all without needing Microsoft Excel on the client machine. Angular Grid Features Inline Editing Row and Column Filtering Grid Sorting Column Grouping Column Summaries Fixed/Pinned Columns Resizable Columns Column Hiding Column Moving Cell Copy and Paste Cell Styling Real-time/Live Data Theming Custom Grid Toolbar Grid Paging Row Selection Cell Selection Grid-level Searching Export to Excel, CSV, TSV Multi-Column Headers Combo Box/Dropdown Virtualization and Performance< Remote Data Load on Demand Cell Templates ARIA/a11y Support Download the Fastest Angular Grid Today! download now 30 days free trial. No credit card required. Ignite UI for Angular Supported Browsers The Angular Data Grid is supported on all modern web browsers, including: Chrome Edge / Edge Chromium Firefox Safari Internet Explorer 11 with polyfills Ignite UI for Angular Support Options There are multiple options to get access to our award-winning support at Infragistics for the Angular product. Start at the Angular Support home page Read the Angular Documentation and experiment with Angular Samples Read the Angular Blogs to stay up to date Submit a Support Case Learn from the Angular Reference Applications Ignite UI for Angular Trial License and Commercial Ignite UI for Angular is a commercially licensed product available via a subscription model. You can try the Ignite UI for Angular product for free when you register for a 30-day trial. When you are done with your Trial Period, you can purchase a license from our web site or by calling sales in your region. Frequently Asked Questions Why should I choose the Infragistics Ignite UI for Angular Data Grid? Virtualized Rows and Columns Inline Editing with Cell, Row, and Batch Update options Excel-style Filtering and full Excel Keyboard Navigation capability Interactive Outlook-style Grouping Column Summaries based on any data in a grid cell or column Export to Excel, including Data Visualization Size (Display Density) to adjust the height and sizing of the rows Column templates like Sparkline Column and Image Column What is the Pricing for the Infragistics Ignite UI for Angular Data Grid? Our Angular components are included as a part of our Ignite UI bundle. A single developer license starts at $1,295 USD for a one-year subscription, including one year of standard support and updates. We also offer discounts for multi-year licenses. Please refer to our Pricing page for more information on pricing. If you are developing applications on multiple platforms, consider our complete app development package, Infragistics Ultimate, which include desktop platforms like WPF and Windows Forms, plus all modern web toolsets for Angular, Web Components, ASP.NET MVC and ASP.NET Core. Can I purchase the Infragistics Ignite UI for Angular Data Grid control separately? No, you cannot purchase the Angular Data Grid separately. It is part of a the Ignite UI for Angular product, which includes dozens of UI controls and components, plus over 60 charts, including Angular Financial Charting. If you are interested in other modern web platforms like Angular, ASP.NET MVC, Web Components or ASP.NET Blazor, check out our Ignite UI product bundle, which gives you every web platform for only $100 more on your subscription. That is hundreds of controls, components, and data visualizations for a very low price. How do I Install Angular and the Infragistics Ignite UI for Angular Data Grid control? To get started with the Angular Data Grid, follow the steps in the [getting started guide](general/getting-started.md). We also maintain a library of sample applications, which are designed to not only inspire but are best practices guides for Angular development. View page on GitHub"
  },
  "components/hierarchicalgrid/advanced-filtering.html": {
    "href": "components/hierarchicalgrid/advanced-filtering.html",
    "title": "Advanced Filtering in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Advanced Filtering The Advanced filtering provides a dialog which allows the creation of groups with filtering conditions across all columns for any Angular table like the Hierarchical Grid. Angular Hierarchical Grid Advanced Filtering Example Interaction In order to open the advanced filtering dialog, the Advanced Filtering button in the grid toolbar should be clicked. The dialog is using the IgxQueryBuilder component to generate,display and edit the filtering logic. You can have a look at the Query Builder topic for details on the interaction process. In order to filter the data once you are ready with creating the filtering conditions and groups, you should click the Apply button. If you have modified the advanced filter, but you don't want to preserve the changes, you should click the Cancel button. You could also clear the advanced filter by clicking the Clear Filter button. Usage To enable the advanced filtering, the allowAdvancedFiltering input property should be set to true. <igx-hierarchical-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> <igx-grid-toolbar></igx-grid-toolbar> </igx-hierarchical-grid> The advanced filtering generates a FilteringExpressionsTree which is stored in the advancedFilteringExpressionsTree input property. You could use the advancedFilteringExpressionsTree property to set an initial state of the advanced filtering. ngAfterViewInit(): void { const tree = new FilteringExpressionsTree(FilteringLogic.And); tree.filteringOperands.push({ fieldName: 'ID', condition: IgxStringFilteringOperand.instance().condition('contains'), searchVal: 'a', ignoreCase: true }); const subTree = new FilteringExpressionsTree(FilteringLogic.Or); subTree.filteringOperands.push({ fieldName: 'ContactTitle', condition: IgxStringFilteringOperand.instance().condition('doesNotContain'), searchVal: 'b', ignoreCase: true }); subTree.filteringOperands.push({ fieldName: 'CompanyName', condition: IgxStringFilteringOperand.instance().condition('startsWith'), searchVal: 'c', ignoreCase: true }); tree.filteringOperands.push(subTree); this.hierarchicalGrid.advancedFilteringExpressionsTree = tree; } In case you don't want to show the Hierarchical Grid toolbar, you could use the openAdvancedFilteringDialog and closeAdvancedFilteringDialog methods to open and close the advanced filtering dialog programmatically. Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Hierarchical Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Hierarchical Grid is the intersection between the results of the two filters. External Advanced filtering As you see the demo above the Advanced filtering dialog is hosted in an overlay on top of the Hierarchical Grid. When the setup in the dialog is ready, the apply or close actions would hide that dialog. There is a way to make that dialog stay always visible - be used as a standalone component. In the demo below, the advanced filtering dialog is declared separately of the Hierarchical Grid. Demo Usage It's super easy to configure the advanced filtering to work outside of the Hierarchical Grid. All you need to do is to create the dialog and set its grid property: <igx-advanced-filtering-dialog [grid]=\"hierarchicalgrid1\"> </igx-advanced-filtering-dialog> You can also see how our drag and drop App Builder™ can streamline the entire design-to-Angular-code story. Styling To get started with styling the Advanced Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The advanced filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); Since we have other components inside the advanced filtering dialog, such as buttons, chips, dropdowns and inputs, we need to create a separate theme for each one: $custom-button: button-theme( $disabled-color: gray, ... ); $custom-button-group: button-group-theme( $item-background: #292826, ... ); $custom-input-group: input-group-theme( $box-background: #4a4a4a, ... ); $custom-chip: chip-theme( $background: #FFCD0F, ... ); $custom-drop-down: drop-down-theme( $background-color: #292826, ... ); In this example we only changed some of the parameters for the listed components, but the button-theme, button-group-theme, chip-theme, drop-down-theme, input-group-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also add some styles for other elements inside the advanced filtering dialog. @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); @include drop-down($custom-drop-down); .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } .igx-input-group__input::placeholder { color: gray; } } Note We scope most of the components' mixins within igx-advanced-filtering-dialog, so that these custom themes will affect only components nested in the advanced filtering dialog. Otherwise, other buttons, chips, inputs and dropdowns in the application would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); .igx-input-group__input::placeholder { color: gray; } .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: color($dark-palette, \"secondary\", 400) ); $custom-button: button-theme( $disabled-color: color($dark-palette, \"secondary\", 100), ... ); $custom-button-group: button-group-theme( $item-background: color($dark-palette, \"secondary\", 400), ... ); $custom-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 200), ... ); $custom-chip: chip-theme( $background: color($dark-palette, \"primary\", 400), ... ); $custom-drop-down: drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), ... ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-button, light-button-group, light-chip, light-input-group and light-drop-down schemas: $grid-dark-palette: palette($primary: #11bd7b, $secondary: #e32057, $info: $black-color); $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"info\") ) ) ); $custom-button-schema: extend($_light-button, ( disabled-color:( color: (\"secondary\", 100) ), ... ) ); $custom-button-group-schema: extend($_light-button-group, ( item-background:( color: (\"secondary\", 400) ), ... ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 200) ), ... ) ); $custom-chip-schema: extend($_light-chip, ( background:( color: (\"primary\", 400) ), ... ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), ... ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-button: $custom-button-schema, igx-button-group: $custom-button-group-schema, igx-input-group: $custom-input-group-schema, igx-chip: $custom-chip-schema, igx-drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $grid-dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button-group: button-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-chip: chip-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Filtering Excel Style Filtering Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/batch-editing.html": {
    "href": "components/hierarchicalgrid/batch-editing.html",
    "title": "Batch Editing and Transactions in Angular Hierarchical Grid Grid - Infragistics",
    "keywords": "Angular Hierarchical Grid Batch Editing and Transactions The Batch Editing feature of the IgxHierarchicalGrid is based on the TransactionService. Follow the Transaction Service class hierarchy topic to see an overview of the igxTransactionService and details how it is implemented. In order to use the HierarchicalTransactionService with IgxHierarchicalGrid, but have it accumulating separate transaction logs for each island, a service factory should be provided instead. One is exported and ready for use as IgxHierarchicalTransactionServiceFactory. Below is a detailed example of how is Batch Editing enabled for the Hierarchical Grid component. Angular Hierarchical Grid Batch Editing and Transactions Example The following sample demonstrates a scenario, where the hierarchicalGrid has batchEditing enabled and has row editing enabled. The latter will ensure that transaction will be added after the entire row edit is confirmed. Note Transaction state consists of all the updated, added and deleted rows, and their last states. Usage To get started import the IgxHierarchicalGridModule in the app.module.ts file: // app.module.ts ... import { IgxHierarchicalGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxHierarchicalGridModule], ... }) export class AppModule {} Then, all you need to do is enable batchEditing from your Hierarchical Grid: <igx-hierarchical-grid [data]=\"data\" [batchEditing]=\"true\"> ... </igx-hierarchical-grid> This will ensure a proper instance of Transaction service is provided for the igx-hierarchical-grid. The proper TransactionService is provided through a TransactionFactory. You can learn more about this internal implementation in the transactions topic. After batch editing is enabled, define a IgxHierarchicalGrid with bound data source and rowEditable set to true and bind: <igx-hierarchical-grid #hierarchicalGrid [batchEditing]=\"true\" [data]=\"data\" [primaryKey]=\"'Artist'\" [height]=\"'580px'\" [width]=\"'100%'\" [rowEditable]=\"true\" > ... <igx-row-island #childGrid [key]=\"'Albums'\" [primaryKey]=\"'Album'\" [rowEditable]=\"true\"> <igx-grid-toolbar></igx-grid-toolbar> ... <ng-template igxToolbarCustomContent let-grid=\"grid\"> <button igxButton [disabled]=\"!grid.transactions.canUndo\" (click)=\"undo(grid)\">Undo</button> <button igxButton [disabled]=\"!grid.transactions.canRedo\" (click)=\"redo(grid)\">Redo</button> </ng-template> </igx-row-island> </igx-hierarchical-grid> ... <div class=\"buttons-row\"> <div class=\"buttons-wrapper\"> <button igxButton [disabled]=\"!undoEnabledParent\" (click)=\"undo(hierarchicalGrid)\">Undo Parent</button> <button igxButton [disabled]=\"!redoEnabledParent\" (click)=\"redo(hierarchicalGrid)\">Redo Parent</button> </div> </div> ... The following code demonstrates the usage of the transactions API - undo, redo, commit. ... export class HierarchicalGridBatchEditingSampleComponent { public undo(grid: any) { /* exit edit mode and commit changes */ grid.endEdit(true); grid.transactions.undo(); } public redo(grid: any) { /* exit edit mode and commit changes */ grid.endEdit(true); grid.transactions.redo(); } public commit() { this.hierarchicalGrid.transactions.commit(this.data); this.childGrid.hgridAPI.getChildGrids().forEach((grid) => { grid.transactions.commit(grid.data); }); this.dialogChanges.close(); } } Note The transactions API won't handle end of edit and you'd need to do it by yourself. Otherwise, Hierarchical Grid would stay in edit mode. One way to do that is by calling endEdit in the respective method. Note Disabling rowEditable property will modify Hierarchical Grid to create transactions on cell change and will not expose row editing overlay in the UI. API References igxHierarchicalTransactionServiceFactory Additional Resources Build CRUD operations with igxGrid Hierarchical Grid Overview Hierarchical Grid Editing Hierarchical Grid Row Editing Hierarchical Grid Row Adding Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/cascading-combos.html": {
    "href": "components/hierarchicalgrid/cascading-combos.html",
    "title": "Cascading combos in Angular Hierarchical Grid Grid - Infragistics",
    "keywords": "Angular Grid with Cascading Combos The Grid's Editing functionality provides with the opportunity to use Cascading Combos. By selecting the value in any preceding Combos, the users will receive only the data that is relevant to their selection within the next Combo. Angular Grid with Cascading Combos Sample Overview The sample below demonstrates how Grid works with nested Cascading Combos. Setup In order enable column editing, make sure editable property is set to true. Once the column editig is enabled, you can start by adding your Single Select ComboBox. Please note that here in order to have only one single selection available, you will need to use igxSimpleCombo instead of modifying the igxCombo. To get started with the Simple ComboBox component, first you need to import the IgxSimpleComboModule in your app.module.ts file: import { IgxSimpleComboModule } from 'igniteui-angular'; @NgModule({ imports: [ ... IgxSimpleComboModule, ... ] }) export class AppModule {} Then, in the template, you should bind the combos igx-simple-combo to some data. displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the simple combobox will use the specified valueKey (if any). export class MySimpleComboComponent implements OnInit { public countriesData: Country[]; public selectedCountry: Country; public selectedCity: City; public ngOnInit() { this.countriesData = getCountries([ 'United States', 'Japan', 'United Kingdom' ]); } } In order to handle the selection change, we need selectionChanging(). The emitted event arguments, IComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the items that were added or removed. Therefore, it will filter the values based on the selection of the previous combo. <igx-combo [data]=\"countriesData\" (selectionChanging)=\"countryChanging($event)\"></igx-combo> public countryChanging(event: IComboSelectionChangeEventArgs) { if (event.added.length) { event.newSelection = event.added; } } And lastly, adding the Linear Progress, which is required while loading the list of data. The id is necessary to set the value of id attribute. <igx-linear-bar [id]=\"'region-progress-' + cell.row.data.ID\" [style.visibility]=\"'hidden'\" type=\"info\" [indeterminate]=\"true\"> </igx-linear-bar> API Summary IgxSimpleComboComponent IgxComboComponent Styles IgxLinearProgressBarComponent IgxLinearProgressBarComponent Styles Additional Resources Hierarchical Grid Editing Single Select ComboBox Cascading Combos Linear Progress View page on GitHub"
  },
  "components/hierarchicalgrid/cell-editing.html": {
    "href": "components/hierarchicalgrid/cell-editing.html",
    "title": "Cell Editing in Angular HierarchicalGrid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Cell Editing Ignite UI for Angular Hierarchical Grid component provides a great data manipulation capabilities and powerful API for Angular CRUD operations. By default the Hierarchical Grid is using in cell editing and different editors will be shown based on the column data type, thanks to the default cell editing template. In addition, you can define your own custom templates for update-data actions and to override the default behavior for committing and discarding any changes. Angular Hierarchical Grid cell editing and edit templates Example Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. Cell Editing Editing through UI You can enter edit mode for specific cell, when an editable cell is focused in one of the following ways: on double click; on single click - Single click will enter edit mode only if the previously selected cell was in edit mode and currently selected cell is editable. If the previously selected cell was not in edit mode, single click will select the cell without entering edit mode; on key press Enter; on key press F2; You can exit edit mode without committing the changes in one of the following ways: on key press Escape; when you perform sorting, filtering, searching and hiding operations; You can exit edit mode and commit the changes in one of the following ways: on key press Enter; on key press F2; on key press Tab; on single click to another cell - when you click on another cell in the Hierarchical Grid, your changes will be submitted. operations like paging, resize, pin or move will exit edit mode and changes will be submitted. Note The cell remains in edit mode when you scroll vertically or horizontally or click outside the Hierarchical Grid. This is valid for both cell editing and row editing. Editing through API You can also modify the cell value through the IgxHierarchicalGrid API but only if primary key is defined: public updateCell() { this.hierarchicalGrid.updateCell(newValue, rowID, 'Age'); } Another way to update cell is directly through update method of IgxGridCell: public updateCell() { const cell = this.hierarchicalGrid.getCellByColumn(rowIndex, 'ReorderLevel'); // You can also get cell by rowID if primary key is defined // cell = this.hierarchicalGrid.getCellByKey(rowID, 'ReorderLevel'); cell.update(70); } Cell Editing Templates You can see and learn more for default cell editing templates in the general editing topic. If you want to provide a custom template which will be applied when a cell is in edit mode, you can make use of the igxCellEditor directive. To do this, you need to pass an ng-template marked with the igxCellEditor directive and properly bind your custom control to the cell.editValue: <igx-column field=\"class\" header=\"Class\" [editable]=\"true\"> <ng-template igxCellEditor let-cell=\"cell\" let-value> <igx-select class=\"cell-select\" [(ngModel)]=\"cell.editValue\" [igxFocus]=\"true\"> <igx-select-item *ngFor=\"let class of classes\" [value]=\"class\"> {{ class }} </igx-select-item> </igx-select> </ng-template> </igx-column> This code is used in the sample below which implements an IgxSelectComponent in the cells of the Race, Class and Alignment columns. Note Any changes made to the cell's editValue in edit mode, will trigger the appropriate editing event on exit and apply to the transaction state (if transactions are enabled). Note The cell template igxCell controls how a column's cells are shown when outside of edit mode. The cell editing template directive igxCellEditor, handles how a column's cells in edit mode are displayed and controls the edited cell's edit value. Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. For more information on how to configure columns and their templates, you can see the documentation for Grid Columns configuration. CRUD operations Note Please keep in mind that when you perform some CRUD operation all of the applied pipes like filtering, sorting and grouping will be re-applied and your view will be automatically updated. The IgxHierarchicalGridComponent provides a straightforward API for basic CRUD operations. Adding a new record The Hierarchical Grid component exposes the addRow method which will add the provided data to the data source itself. public addRow() { // Adding a new record // Assuming we have a `getNewRecord` method returning the new row data const record = this.getNewRecord(); this.hierarchicalGrid.addRow(record, 1); } Updating data in the Hierarchical Grid Updating data in the Hierarchical Grid is achieved through updateRow and updateCell methods but only if primary key for the grid is defined. You can also directly update a cell and/or a row value through their respective update methods. // Updating the whole row this.hierarchicalGrid.updateRow(newData, this.selectedCell.cellID.rowID); // Just a particular cell through the Grid API this.hierarchicalGrid.updateCell(newData, this.selectedCell.cellID.rowID, this.selectedCell.column.field); // Directly using the cell `update` method this.selectedCell.update(newData); // Directly using the row `update` method const row = this.hierarchicalGrid.getRowByKey(rowID); row.update(newData); Deleting data from the Hierarchical Grid Please keep in mind that deleteRow() method will remove the specified row only if primary key is defined. // Delete row through Grid API this.hierarchicalGrid.deleteRow(this.selectedCell.cellID.rowID); // Delete row through row object const row = this.hierarchicalGrid.getRowByIndex(rowIndex); row.delete(); These can be wired to user interactions, not necessarily related to the igx-hierarchical-grid; for example, a button click: <button igxButton igxRipple (click)=\"deleteRow($event)\">Delete Row</button> Cell validation on edit event Using the grid's editing events we can alter how the user interacts with the grid. In this example, we'll validate a cell based on the data entered in it by binding to the cellEdit event. If the new value of the cell does not meet our predefined criteria, we'll prevent it from reaching the data source by cancelling the event (event.cancel = true). We'll also display a custom error message using IgxToast. The first thing we need to is bind to the grid's event: <igx-hierarchical-grid (cellEdit)=\"handleCellEdit($event)\" ...> ... </igx-hierarchical-grid> The cellEdit emits whenever any cell's value is about to be committed. In our handleCellEdit definition, we need to make sure that we check for our specific column before taking any action: export class MyHGridEventsComponent { public handleCellEdit(event: IGridEditEventArgs) { const today = new Date(); const column = event.column; if (column.field === 'Debut') { if (event.newValue > today.getFullYear()) { this.toast.message = 'The debut date must be in the past!'; this.toast.open(); event.cancel = true; } } else if (column.field === 'LaunchDate') { if (event.newValue > new Date()) { this.toast.message = 'The launch date must be in the past!'; this.toast.open(); event.cancel = true; } } } } Here, we are validating two columns. If the user tries to change an artist's Debut year or an album's Launch Date, the grid will not allow any dates that are greater than today. The result of the above validation being applied to our igx-hierarchical-grid can be seen in the below demo: Styling The IgxHierarchicalGrid allows for its cells to be styled through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide range of properties, which allow users to style many different aspects of the grid. In the below steps, we are going to go over how you can style the grid's cell in edit mode and how you can scope those styles. In order to use the Ignite UI Theming Library, we must first import the theme index file in our global styles: Importing style library @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Now we can make use of all of the functions exposed by the Ignite UI for Angular theme engine. Defining a palette After we've properly imported the index file, we create a custom palette that we can use. Let's define two colors that we like and use them to build a palette with igx-palette: $white: #fff; $blue: #4567bb; $color-palette: palette($primary: $white, $secondary: $blue); Defining themes We can now define the theme using our palette. The cells are styled by the grid-theme, so we can use that to generate a theme for our IgxHierarchicalGrid: $custom-grid-theme: grid-theme( $cell-editing-background: $blue, $cell-edited-value-color: $white, $cell-active-border-color: $white, $edit-mode-color: color($color-palette, \"secondary\", 200) ); Applying the theme The easiest way to apply our theme is with a sass @include statement in the global styles file: @include grid($custom-grid-theme); This way, the theme will apply to all grids in our application. If we wish to apply this custom styling only to a specific component, we need to scope the theme. Scoped component theme In order for the custom theme to affect only our specific component, we can move all of the styles we just defined from the global styles file to our custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, our styles will be applied only to our custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-grid-theme); } } } Styling Demo In addition to the steps above, we can also style the controls that are used for the cells' editing templates: igx-input-group, igx-datepicker & igx-checkbox Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridCell IgxHierarchicalGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Build CRUD operations with igxGrid Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection View page on GitHub"
  },
  "components/hierarchicalgrid/cell-selection.html": {
    "href": "components/hierarchicalgrid/cell-selection.html",
    "title": "Angular Hierarchical Grid Cell Selection - Ignite UI for Angular",
    "keywords": "Angular Cell Selection The selection feature enables rich data select capabilities in the Material UI based Hierarchical Grid. Variety of events and single select actions are available thanks to the powerful API and easy to use methods. The Hierarchical Grid now supports three modes for cell selection, and you can easily switch between them by changing cellSelection property. You can disable cell selection, you can select only one cell within the grid or to select multiple cells in the grid, which is provided as default option. In the Hierarchical Grid you can specify the cell selection mode on grid level. So for example in the parent grid multi-cell selection can be enabled, but in child grids cell selection mode can be single or disabled. But let's dive deeper in each of these options. Angular Cell Selection Example The sample below demonstrates the three types of Hierarchical Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Selection types Hierarchical Grid Multiple-cell Selection This is the default cell selection mode in both parent and child grids. Please keep in mind that you can make cell selection one grid at a time, you can not make cross grid range selection or to have a selected cells in multiple grids. Each key combination related to range selection and mouse drag functionality can be used only in the same grid. How to select cells: By Mouse drag - Rectangular data selection of cells would be performed. By Ctrl key press + Mouse drag - Multiple range selections would be performed. Any other existing cell selection will be persisted. Instant multi-cell selection by using Shift key. Select single cell and select another single cell by holding the Shift key. Cell range between the two cells will be selected. Keep in mind that if another second cell is selected while holding Shift key the cell selection range will be updated based on the first selected cell position (starting point). Keyboard multi-cell selection by using the Arrow keys while holding Shift key. Multi-cell selection range will be created based on the focused cell. Keyboard multi-cell selection by using the Ctrl + Arrow keys and Ctrl + Home/End while holding Shift key. Multi-cell selection range will be created based on the focused cell. Clicking with the Left Mouse key while holding Ctrl key will add single cell ranges into the selected cells collection. Continuous multiple cell selection is available, by clicking with the mouse and dragging. Hierarchical Grid Single Selection When you set the [cellSelection]=\"'single'\", this allows you to have only one selected cell in the grid at a time. Also the mode mouse drag will not work and instead of selecting a cell, this will make default text selection. Note When single cell is selected selected event is emitted, no matter if the selection mode is single or multiple. In multi-cell selection mode when you select a range of cells rangeSelected event is emitted. Hierarchical Grid None selection If you want to disable cell selection you can just set [cellSelection]=\"'none'\" property. In this mode when you click over the cell or try to navigate with keyboard, the cell is not selected, only the activation style is applied and it is going to be lost when you scroll or click over other element on the page. The only way for you to define selection is by using the API methods that are described below. Styling Guidelines The theme engine exposes properties that allows us to style the range of selected cells. Import theme To get started with styling the selection, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Define colors Once done, we can make use of the igx-contrast-color and igx-color functions. With them, we define the colors we would like to use for our selection range: $text-color:contrast-color($default-palette, 'primary', 900); $background-color: color($default-palette, \"primary\", 900); $border-yellow: #f2c43c; Create custom theme Next we create a new theme that extends the grid-theme passing our text-color, background-color and border-yellow variables as $cell-selected-text-color, $cell-selected-background and $cell-active-border-color, respectively: $custom-grid-theme: grid-theme( $cell-selected-text-color: $text-color, $cell-active-border-color: $border-yellow, $cell-selected-background: $background-color ); Apply theme Afterwards, all we need to do is include the mixin in our component's style (could also be in the app styles), so that our igx-hierarchical-grid uses the newly created theme instead of the default one: @include grid($custom-grid-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. We scope the style under :host selector so as not to affect any other grids we might have in our application. :host { ::ng-deep { @include grid($custom-grid-theme); } } With the custom theme applied, the selected grid cells are highlighted with our selected colors: Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxHierarchicalGridComponent API IgxGridRow API IgxGridCell API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Selection Row selection Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/clipboard-interactions.html": {
    "href": "components/hierarchicalgrid/clipboard-interactions.html",
    "title": "Angular Hierarchical Grid Clipboard Interactions",
    "keywords": "Angular Hierarchical Grid Clipboard Interactions Copy to clipboard operations are now available in the Hierarchical Grid. This functionality provides a fast, easy and customizable way to copy data of the Angular Data Grid through the current multi cell data select. System Clipboard behavior gives the user ability to copy data from the Hierarchical Grid into Excel or other external programs. Angular Hierarchical Grid Clipboard Interactions Example Functionality Copy behavior is working with the default interaction defined by the browser and operating system. Thus for the copy and paste behaviors, these are: Windows/Unix based Ctrl + C / Ctrl + Ins as a keyboard shortcut Ctrl + V / Shift + Ins as a keyboard shortcut Copy action through the browser menu macOS ⌘ Cmd + C as a keyboard shortcut ⌘ Cmd + V as a keyboard shortcut Copy action through the browser menu Limitations Both the cut and copy events are not natively supported in Internet Explorer. The exception is the paste event (IE 11) which is emitted but does not expose the clipboardData property in the event. Note In order to copy cells in IE 11, you can use the keyboard selection. Hold the shift key in order to make a multi-cell selection, press Ctrl + C in order to copy. The copy behavior is disabled while the grid is in edit mode. The current version of this feature covers only the copy from grid behavior. Later on we plan to expose paste within grid behavior. API Usage We expose clipboardOptions @Input property, which handles the following options: enabled Enables/disables copying of selected cells. copyHeaders Include the associated headers when copying. copyFormatters Apply any existing column formatters to the copied data. separator The string separator to use the for formatting the data in the clipboard. Default is /t Note Excel can automatically detect text that is separated by tabs (tab-delimited /t) and properly paste the data into separate columns. When the paste format doesn't work, and everything you paste appears in a single column, then Excel's delimiter is set to another character, or your text is using spaces instead of tabs. gridCopy Emitted when a copy operation is executed. Fired only if copy behavior is enabled through the clipboardOptions Additional Resources Hierarchical Grid overview Paging Filtering Sorting Summaries Column Pinning Selection Virtualization and Performance Multi-column headers Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/collapsible-column-groups.html": {
    "href": "components/hierarchicalgrid/collapsible-column-groups.html",
    "title": "Collapsible Column Groups in Angular Hierarchical Grid - Infragistics",
    "keywords": "Collapsible Column Groups in Angular Data Grid Multi-column headers allow you to have multiple levels of nested columns and column groups. They also provide the ability to mark each column group as collapsible. Collapsible multi-column headers make it possible to collapse/expand, i.e. to show and hide the nested headers under the current one, which will give you a shortened/summarized information for example. Angular Grid Collapsible Column Groups Overview Example Setup To get started with the IgxHierarchicalGrid and the Collapsible multi-column headers , first you need to install Ignite UI for Angular by typing the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxHierarchicalGridModule in the app.module.ts file. Also, we strongly suggest that you take a brief look at multi-column groups topic, to see more detailed information on how to setup the column groups in your grid. Usage Collapsible Column Groups is a part of the multi-column headers feature which provides a way to collapse/expand a column group to a smaller set of data. When a column group is collapsed, a subset of the columns will be shown to the end-user and the other child columns of the group will hide. Each collapsed/expanded column can be bound to the grid data source, or it may be unbound, thus calculated. In order to define a column group as collapsible, you need to set the property to [collapsible]=\"true\" and also keep in mind that you need to define the property visibleWhenCollapsed to at least two child columns: at least one column must be visible when the group is collapsed ([visibleWhenCollapsed]=\"true\") and at least one column must be hidden when the group is expanded ([visibleWhenCollapsed]=\"false\"), otherwise the collapsible functionality will be disabled. If visibleWhenCollapsed is not specified for some of the child columns, then this column will be always visible no matter whether the parent state is expanded or collapsed. So let's see the markup below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <!-- Initially the column groups will be expanded---> <!--The column below will be visible when its parent is collapsed--> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <!--The three columns below will be visible when its parent is expanded--> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column field=\"FirstName\" header=\"First Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column field=\"LastName\" header=\"Last Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column-group header=\"Customer Address\"> <!--This column visibility will not be changed based on parent expand/collapsed state--> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> </igx-column-group> </igx-column-group> And now let's sum up: every child column has three states: Can be always visible, no matter the expanded state of its parent; Can be visible, when its parent is collapsed; Can be hidden, when its parent is collapsed; The initial state of the column group which is specified as collapsible is [expanded]=\"true\". But you can easily change this behavour by setting the property [expanded]=\"false\". Expand/Collapse indicator template Default expand indicator for the igxGrid is the following: Default collapse indicator for the igxGrid is the following: Also, if you need to change the default expand/collapse indicator, we provide two easy ways to do so - via an input property or through a directive. Using an input property You can define custom expand/collapse template and provide it to each of the collapsible column groups using collapsibleIndicatorTemplate input property. Check the markup below: <ng-template #indTemplate let-column=\"column\"> <igx-icon [attr.draggable]=\"false\" >{{column.expanded ? 'remove' : 'add'}} </igx-icon> </ng-template> <igx-column-group header=\"Customer Information\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Using igxCollapsibleIndicator directive Another way to achieve this behavior is to use the igxCollapsibleIndicator directive as shown in the example below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <ng-template igxCollapsibleIndicator let-column=\"column\"> <igx-icon [attr.draggable]=\"false\">{{column.expanded ? 'remove' : 'add'}} </<igx-icon> </ng-template> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Note Please keep in mind that initially collapse group option takes precedence over column hidden - If you declared your column to be hidden using the property hidden and you have a group defined where the same column should be shown, the column will be shown. API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-hiding.html": {
    "href": "components/hierarchicalgrid/column-hiding.html",
    "title": "Column Hiding in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Column Hiding The Ignite UI for Angular Hierarchical Grid provides an IgxColumnActionsComponent with an IgxColumnHidingDirective which allows users to perform column hiding directly through the user interface or by using the Angular component. The Material UI Grid has a built-in column hiding UI, which can be used through the Hierarchical Grid's toolbar to change the visible state of the columns. In addition, developers can always define the column hiding UI as a separate component and place it anywhere they want on the page. Angular Hierarchical Grid Column Hiding Example Hierarchical Grid Setup Let's start by creating our Hierarchical Grid and binding it to our data. We will also enable both filtering and sorting for the columns. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [height]=\"'560px'\" [width]=\"'100%'\" columnWidth=\"200px\" [allowFiltering]=\"true\" #hGrid> <igx-column field=\"Artist\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column field=\"Photo\"> <ng-template igxCell let-cell=\"cell\"> <div class=\"cell__inner_2\"> <img [src]=\"cell.value\" class=\"photo\" /> </div> </ng-template> </igx-column> <igx-column field=\"Debut\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column field=\"Grammy Nominations\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column field=\"Grammy Awards\" [sortable]=\"true\"></igx-column> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"false\" #layout1 > <igx-column field=\"Album\" [sortable]=\"true\"></igx-column> <igx-column field=\"Launch Date\" [sortable]=\"true\"></igx-column> <igx-column field=\"Billboard Review\" [sortable]=\"true\"></igx-column> <igx-column field=\"US Billboard 200\" [sortable]=\"true\"></igx-column> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"false\"> <igx-column field=\"No.\"></igx-column> <igx-column field=\"Title\"></igx-column> <igx-column field=\"Released\"></igx-column> <igx-column field=\"Genre\"></igx-column> </igx-row-island> </igx-row-island> <igx-row-island [key]=\"'Tours'\" [autoGenerate]=\"false\"> <igx-column field=\"Tour\"></igx-column> <igx-column field=\"Started on\"></igx-column> <igx-column field=\"Location\"></igx-column> <igx-column field=\"Headliner\"></igx-column> </igx-row-island> </igx-hierarchical-grid> Toolbar's Column Hiding UI The built-in Column Hiding UI is placed inside an IgxDropDownComponent in the Hierarchical Grid's toolbar. We can show/hide the Column Hiding UI by using this exact dropdown. For this purpose all we have to do is set both the IgxGridToolbarActionsComponent and the IgxGridToolbarHidingComponent inside of the Hierarchical Grid. We will also add a title to our toolbar by using the IgxGridToolbarTitleComponent and a custom style for our Hierarchical Grid's wrapper. <!--columnHiding.component.html--> <div class=\"hgrid-sample\"> <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Singers</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> ... </igx-hierarchical-grid> </div> /* columnHiding.component.css */ .photo { vertical-align: middle; max-height: 62px; } .cell__inner_2 { margin: 1px } The Hierarchical Grid provides us with some useful properties when it comes to using the toolbar's column hiding UI. By using the igx-grid-toolbar-hiding title property, we will set the title that is displayed inside the dropdown button in the toolbar. <div class=\"hgrid-sample\"> <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Singers</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding #hidingActionRef title=\"Column Hiding\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-hierarchical-grid> </div> By using the columnsAreaMaxHeight property of the IgxGridToolbarHidingComponent, we can set the maximum height of the area that contains the column actions. This way if we have a lot of actions and not all of them can fit in the container, a scrollbar will appear, which will allow us to scroll to any action we want. // columnHiding.component.ts public ngAfterViewInit() { this.hidingActionRef.columnsAreaMaxHeight = \"200px\"; } In order to use the expanded set of functionalities for the column hiding UI, we can use the IgxColumnActionsComponent's columnsAreaMaxHeight property. This way we can use it according to our application's requirements. You can see the result of the code from above at the beginning of this article in the Angular Column Hiding Example section. Styling To get started with styling the column actions component, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; By using the simplest approach, we create a new theme that extends the column-actions-theme and accepts the $title-color and the $background-color parameters. $custom-column-actions-theme: column-actions-theme( $background-color: steelblue, $title-color: gold ); As seen, the column-actions-theme only controls colors for the column actions container, but does not affect the buttons, checkboxes and the input-group inside of it. Let's say we want to style the buttons as well, so we will create a new button theme: $custom-button: button-theme($flat-text-color: gold, $disabled-color: black); In this example we only changed the text-color of the flat buttons and the button disabled color, but the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } Note We scope the igx-button mixin within .igx-column-actions, so that only the column hiding buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: gold; $blue-color: steelblue; $custom-palette: palette($primary: $blue-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $title-color: color($custom-palette, \"secondary\", 400), $background-color: color($custom-palette, \"primary\", 200) ); $custom-button: button-theme( $palette: $custom-palette, $flat-text-color: color($custom-palette, \"secondary\", 400), $disabled-color: black ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. // Extending the dark column actions schema $custom-column-actions-schema: extend($_dark-column-actions, ( title-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ) ) ); // Extending the dark button schema $custom-button-schema: extend($_dark-button, ( flat-text-color:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-column-actions: $custom-column-actions-schema, igx-button: $custom-button-schema )); // Defining column-actions-theme with the global dark schema $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $custom-button: button-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References In this article we learned how to use the built-in column hiding UI in the Hierarchical Grid's toolbar. The column hiding UI has a few more APIs to explore, which are listed below. IgxColumnActionsComponent IgxColumnActionsComponent Styles Additional components and/or directives with relative APIs that were used: IgxHierarchicalGridComponent properties: hiddenColumnsCount IgxColumnComponent properties: disableHiding IgxGridToolbarComponent properties: showProgress IgxGridToolbarComponent components: IgxGridToolbarTitleComponent IgxGridToolbarActionsComponent IgxGridToolbarComponent methods: IgxHierarchicalGridComponent events: columnVisibilityChanged IgxRadioComponent Styles: IgxHierarchicalGridComponent Styles IgxRadioComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-moving.html": {
    "href": "components/hierarchicalgrid/column-moving.html",
    "title": "Column Reordering & Moving in Angular Hierarchical Grid - Infragistics",
    "keywords": "Hierarchical Grid Column Reordering & Moving The Hierarchical Grid component in Ignite UI for Angular provides the Column Moving feature to allow columns reordering via standard drag/drop mouse or touch gestures, or by using the Column Moving API. Column moving works both with pinned and unpinned columns and with Multi-column Headers. Moving a column into the pinned area pins the column and vice versa, moving a column outside of the pinned area unpins the column. Note Reordering between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. Moving is allowed between columns/column-groups, if they are top level columns. Note If a column header is templated and the Column Moving is enabled or the corresponding column is groupable, then the templated elements need to have the draggable attribute set to false! This allows to attach handlers for any event emitted by the element, otherwise the event is consumed by the igxDrag directive. Note If the pinned area exceeds its maximum allowed width (80% of the total Hierarchical Grid width), a visual clue notifies the end user that the drop operation is forbidden and pinning is not possible. This means you won't be allowed to drop a column in the pinned area. <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> Angular Hierarchical Grid Column Moving Overview Example Overview Column moving feature is enabled on a per-grid level, meaning that the igx-hierarchical-grid could have either movable or immovable columns. This is done via the moving input of the igx-grid. <igx-hierarchical-grid [moving]=\"true\"> ... <igx-row-island [moving]=\"true\"></igx-row-island> </igx-hierarchical-grid> API In addition to the drag and drop functionality, the Column Moving feature also provides two API methods to allow moving a column/reordering columns programmatically: moveColumn - Moves a column before or after another column (a target). The first parameter is the column to be moved, and the second parameter is the target column. Also accepts an optional third parameter position (representing a DropPosition value), which determines whether to place the column before or after the target column. // Move the ID column after the Name column const idColumn = grid.getColumnByName(\"ID\"); const nameColumn = grid.getColumnByName(\"Name\"); grid.moveColumn(idColumn, nameColumn, DropPosition.AfterDropTarget); move - Moves a column to a specified visible index. If the passed index parameter is invalid (is negative, or exceeds the number of columns), or if the column is not allowed to move to this index (if inside another group), no operation is performed. // Move the ID column at 3rd position. const idColumn = grid.getColumnByName(\"ID\"); idColumn.move(3); Note that when using the API, only the columnMovingEnd event will be emitted, if the operation was successful. Also note that in comparison to the drag and drop functionality, using the API does not require setting the moving property to true. Events There are several events related to the column moving to provide a means for tapping into the columns' drag and drop operations. These are columnMovingStart, columnMoving and columnMovingEnd. You can subscribe to the columnMovingEnd event of the igx-hierarchical-grid to implement some custom logic when a column is dropped to a new position. For example, you can cancel dropping the Category after the Change On Year(%) column. <igx-hierarchical-grid #hierarchicalGrid [data]=\"data\" [autoGenerate]=\"false\" [moving]=\"true\" (columnMovingEnd)=\"onColumnMovingEnd($event)\"> <igx-column [field]=\"'Country'\"></igx-column> <igx-column [field]=\"'Phone'\" [dataType]=\"'number'\"></igx-column> </igx-hierarchical-grid> public onColumnMovingEnd(event) { if (event.source.field === \"Phone\" && event.target.field === \"Country\") { event.cancel = true; } } Styling To get started with styling the Hierarchical Grid column moving headers, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $ghost-header-background, $ghost-header-text-color and the $ghost-header-icon-color parameters. // Define dark theme for the column moving $dark-grid-column-moving-theme: grid-theme( $ghost-header-text-color: #F4D45C, $ghost-header-background: #575757, $ghost-header-icon-color: #f4bb5c ); The last step is to include the component mixins with its respective theme: @include grid($dark-grid-column-moving-theme); Note Depending on the component View Encapsulation strategy, it may be necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include grid($dark-grid-column-moving-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #575757; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the pallete. $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $ghost-header-text-color: color($dark-palette, \"primary\", 400), $ghost-header-background: color($dark-palette, \"secondary\", 200), $ghost-header-icon-color: color($dark-palette, \"primary\", 500) ); Note The color and palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid. // Extending the dark grid schema $dark-grid-column-moving-schema: extend($_light-grid, ( ghost-header-text-color:( color: (\"primary\", 400) ), ghost-header-background:( color: (\"secondary\", 200) ), ghost-header-icon-color:( color:( \"primary\", 500) ) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global dark-schema $custom-light-schema: extend($light-schema,( igx-grid: $dark-grid-column-moving-schema, )); // Defining dark-grid-theme with the global dark schema $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References ColumnComponent IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-pinning.html": {
    "href": "components/hierarchicalgrid/column-pinning.html",
    "title": "Angular Hierarchical Grid Column Pinning - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Column Pinning A column or multiple columns can be pinned to the left or right side of the Angular UI Grid. Column Pinning in Ignite UI for Angular allows the end users to lock column in a particular column order, this will allow them to see it while horizontally scrolling the Hierarchical Grid. The Material UI Grid has a built-in column pinning UI, which can be used through the Hierarchical Grid's toolbar to change the pin state of the columns. In addition, you can define a custom UI and change the pin state of the columns via the Column Pinning API. Angular Hierarchical Grid Column Pinning Example Column Pinning API Column pinning is controlled through the pinned input of the igx-column. Pinned columns are rendered on the left side of the Hierarchical Grid by default and stay fixed through horizontal scrolling of the unpinned columns in the Hierarchical Grid body. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'800px'\" #hierarchicalGrid> <igx-column [field]=\"Artist\" [width]=\"200px\" [pinned]=\"true\"></igx-column> <igx-column [field]=\"Debut\" [width]=\"200px\"></igx-column> </igx-hierarchical-grid> You may also use the Hierarchical Grid's pinColumn or unpinColumn methods of the IgxHierarchicalGridComponent to pin or unpin columns by their field name: this.hierarchicalGrid.pinColumn('Artist'); this.hierarchicalGrid.unpinColumn('Debut'); Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the column is already in the desired state. A column is pinned to the right of the rightmost pinned column. Changing the order of the pinned columns can be done by subscribing to the columnPin event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'800px'\" (columnPin)=\"columnPinning($event)\" #hierarchicalGrid> </igx-hierarchical-grid> public columnPinning(event) { if (event.column.field === 'Artist') { event.insertAtIndex = 0; } } Pinning Position You can change the column pinning position via the pinning configuration option. It allows you to set the columns position to either Start or End. When set to End the columns are rendered at the end of the grid, after the unpinned columns. Unpinned columns can be scrolled horizontally, while the pinned columns remain fixed on the right. <igx-hierarchical-grid #grid1 [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-hierarchical-grid> public pinningConfig: IPinningConfig = { columns: ColumnPinningPosition.End }; Demo Custom Column Pinning UI You can define your custom UI and change the pin state of the columns via the related API. Let's say that instead of a toolbar you would like to define pin icons in the column headers that the end user can click to change the particular column's pin state. This can be done by creating a header template for the column with a custom icon. <ng-template igxHeader let-column #pinTemplate> <div class=\"title-inner\"> <span style=\"float:left\">{{column.header || column.field}}</span> <igx-icon class=\"pin-icon\" [class.pinned]=\"column.pinned\" [class.unpinned]=\"!column.pinned\" fontSet=\"fas\" name=\"fa-thumbtack\" (click)=\"toggleColumn(column)\"></igx-icon> </div> </ng-template> <igx-hierarchical-grid class=\"hierarchicalGrid\" [data]=\"localdata\" [autoGenerate]=\"false\" [height]=\"'500px'\" [width]=\"'100%'\" #hierarchicalGrid> <igx-column field=\"CompanyName\" header=\"Company Name\" [headerTemplate]=\"pinTemplate\" width=\"200px\" [pinned]=\"true\"></igx-column> <igx-column field=\"ContactName\" header=\"Contact Name\" [headerTemplate]=\"pinTemplate\" width=\"150px\"></igx-column> <igx-column field=\"ContactTitle\" header=\"Contact Title\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-row-island [key]=\"'Orders'\" [autoGenerate]=\"false\"> <igx-column field=\"OrderDate\" header=\"Order Date\" [headerTemplate]=\"pinTemplate\" [dataType]=\"'date'\" width=\"150px\"></igx-column> <igx-column field=\"RequiredDate\" header=\"Required Date\" [headerTemplate]=\"pinTemplate\" [dataType]=\"'date'\" width=\"150px\"></igx-column> <igx-column field=\"ShippedDate\" header=\"Shipped Date\" [headerTemplate]=\"pinTemplate\" [dataType]=\"'date'\" width=\"150px\"></igx-column> <igx-column field=\"ShipVia\" header=\"Ship Via\" [headerTemplate]=\"pinTemplate\" width=\"150px\"></igx-column> <igx-row-island [key]=\"'OrderDetails'\" [autoGenerate]=\"false\"> <igx-column field=\"UnitPrice\" header=\"Unit Price\" width=\"150px\"></igx-column> <igx-column field=\"Quantity\" width=\"150px\"></igx-column> <igx-column field=\"Discount\" width=\"150px\"></igx-column> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> On click of the custom icon the pin state of the related column can be changed using the column's API methods. public toggleColumn(col: ColumnType) { col.pinned ? col.unpin() : col.pin(); } Demo Pinning Limitations Setting column widths in percentage (%) explicitly makes the Hierarchical Grid body and header content to be misaligned when there are pinned columns. For column pinning to function correctly the column widths should be in pixels (px) or auto-assigned by the Hierarchical Grid. API References IgxHierarchicalGridComponent IgxColumnComponent Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-resizing.html": {
    "href": "components/hierarchicalgrid/column-resizing.html",
    "title": "Angular Hierarchical Grid Column Resizing - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Column Resizing With deferred grid column resizing, the user will see a temporary resize indicator while the Angular drag resizing operation is in effect. The new grid column width is applied once the drag operation has ended. Angular Hierarchical Grid Column Resizing Example Column resizing is also enabled per-column level, meaning that the igx-hierarchical-grid can have a mix of resizable and non-resizable columns. This is done via the resizable input of the igx-column. <igx-column [field]=\"'Artist'\" [resizable]=\"true\"></igx-column> You can subscribe to the columnResized event of the igx-hierarchical-grid to implement some custom logic when a column is resized. Both, previous and new column widths, as well as the IgxColumnComponent object, are exposed through the event arguments. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'100%'\" #hierarchicalGrid> <igx-column field=\"Artist\" [resizable]=\"true\"></igx-column> ... </igx-hierarchical-grid> public onResize(event) { this.col = event.column; this.pWidth = event.prevWidth; this.nWidth = event.newWidth; } Resizing columns in pixels/percentages Depending on the user scenario, the column width may be defined in pixels, percentages or a mix of both. All these scenarios are supported by the Column Resizing feature. By default if a column does not have width set, it fits the available space with width set in pixels. This means that the following configuration is possible: <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'100%'\" #hierarchicalGrid> <igx-column field=\"Artist\" [resizable]=\"true\" [width]=\"'10%'\"></igx-column> <igx-column field=\"GrammyNominations\" [resizable]=\"true\" [width]=\"'100px'\"></igx-column> <igx-column field=\"GrammyAwards\" [resizable]=\"true\"></igx-column> ... </igx-hierarchical-grid> Note There is a slight difference in the way resizing works for columns set in pixels and percentages. Pixels Resizing columns with width in pixels works by directly adding or subtracting the horizontal amount of the mouse movement from the size of the column. Percentages When resizing columns with width in percentages, the horizontal amount of the mouse movement in pixels translates roughly to its percentage amount relative to the grid width. The columns remain responsive and any future grid resizing will still reflect on the columns as well. Restrict column resizing You can also configure the minimum and maximum allowable column widths. This is done via the minWidth and maxWidth inputs of the igx-column. In this case the resize indicator drag operation is restricted to notify the user that the column cannot be resized outside the boundaries defined by minWidth and maxWidth. <igx-column [field]=\"'Artist'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> Mixing the minimum and maximum column width value types (pixels or percentages) is allowed. If the values set for minimum and maximum are set to percentages, the respective column size will be limited to those exact sizes similar to pixels. This means the following configurations are possible: <igx-column [field]=\"'Artist'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> or <igx-column [field]=\"'Artist'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'15%'\"></igx-column> Auto-size columns on double click Each column can be auto sized by double clicking the right side of the header - the column will be sized to the longest currently visible cell value, including the header itself. This behavior is enabled by default, no additional configuration is needed. However, the column will not be auto-sized in case maxWidth is set on that column and the new width exceeds that maxWidth value. In this case the column will be sized according to preset maxWidth value. You can also auto-size a column dynamically using the exposed autosize() method on IgxColumnComponent. @ViewChild('hierarchicalGrid') hierarchicalGrid: IgxHierarchicalGridComponent; let column = this.hierarchicalGrid.columnList.filter(c => c.field === 'Artist')[0]; column.autosize(); Auto-size columns on initialization Each column can be set to auto-size on initialization by setting width to 'auto': <igx-column width='auto'>... When the column is first initialized in the view it resolves its width to the size of the longest visible cell or header. Note that cells that are outside of the visible rows are not included. This approach is more performance optimized than auto-sizing post initialization and is recommended especially in cases where you need to auto-size a large number of columns. Styling To get started with the styling of the Hierarchical Grid column resize line, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The simplest approach to achieve this is to create a new theme that extends the grid-theme and accepts many parameters as well as the $resize-line-color parameter. $custom-grid-theme: grid-theme( $resize-line-color: #0288D1 ); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. :host { ::ng-deep { @include grid($custom-grid-theme); } } Defining a color palette Instead of hard-coding the color values, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the specified primary and secondary color: $primary-color: #0288D1; $secondary-color: #BDBDBD; $custom-theme-palette: palette($primary: $primary-color, $secondary: $secondary-color); And then, with igx-color, we can easily retrieve the color from the palette. $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $resize-line-color: color($custom-theme-palette, 'secondary', 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please, refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend the predefined schema provided for every component, in this case - light-grid schema: // Extending the light grid schema $light-grid-schema: extend($_light-grid, ( resize-line-color: ( color: ('secondary', 500) ), header-background: ( color: (\"primary\", 100) ), header-text-color: ( color: (\"primary\", 600) ) ) ); In order to apply our custom schema, we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global light-schema $custom-light-grid-schema: extend($light-schema,( igx-grid: $light-grid-schema )); // Specifying the palette and schema of the custom grid theme $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $schema: $custom-light-grid-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-selection.html": {
    "href": "components/hierarchicalgrid/column-selection.html",
    "title": "Angular Hierarchical Grid Column Selection - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Column Selection The Column selection feature provides an easy way to select an entire column with a single click. It emphasizes the importance of a particular column by focusing the header cell(s) and everything below. The feature comes with a rich API that allows for manipulation of the selection state, data extraction from the selected fractions and data analysis operations and visualizations. Angular Column Selection Example The sample below demonstrates the three types of Hierarchical Grid's column selection behavior. Use the column selection dropdown below to enable each of the available selection modes. *Photo and Debut are with disabled column selection. Basic usage The column selection feature can be enabled through the columnSelection input, which takes GridSelectionMode values. Interactions The default selection mode is none. If set to single or multiple all of the presented columns will be selectable. With that being said, in order to select a column, we just need to click on one, which will mark it as selected. If the column is not selectable, no selection style will be applied on the header, while hovering. Note Multi-column Headers don't reflect on the selectable input. The IgxColumnGroupComponent is selectable, if at least one of its children has the selection behaviour enabled. In addition, the component is marked as selected if all of its selectable descendents are selected. *Under Location Column Group only column City is selectable. Keyboard combinations Note The keyboard combinations are available only when the grid columnSelection input is set to multiple. There are two scenarios for keyboard navigation of the Column Selection feature: Multi-column selection - holding ctrl + click on every selectable header cell. Range column selection - holding shift + click selects all selectable columns in between. API manipulations The API provides some additional capabilities when it comes to the non-visible columns such that, every hidden column could be marked as selected by setting the corresponding setter. Note The above statement also applies to the IgxColumnGroupComponent, except that when the selected property is changed it changes the state of its descendants. More information regarding the API manipulations could be found in the API References section. Styling Before diving into the styling options, the core module and all component mixins need to be imported. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Note Please note that row selection and column selection can't be manipulated independently. They depend on the same variables. With that being said, let's move on and change the selection and hover styles. Following the simplest approach, let's define our custom theme. $custom-grid-theme: grid-theme( $row-selected-background: #011627, $row-selected-text-color: #ECAA53, $row-selected-hover-background: #011627, $header-selected-text-color: #ECAA53, $header-selected-background: #011627 ); grid-theme accepts several parameters but those are the five responsible for changing the appearance of all selected columns: $row-selected-background - sets the background of the selected fraction. $row-selected-text-color - sets the text color of the selected fraction $row-selected-hover-background - sets the color of the hovered cell or bunch of cells. $header-selected-text-color - sets the text color of the selected column header $header-selected-background - sets the background color of the selected column header. Using CSS Variables The last step is to include the custom igx-grid theme. @include css-vars($custom-grid-theme) Overriding the Base Theme In order to style components for Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. Note If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. In order to prevent the custom theme from leaking into other components, be sure that you have included the :host selector before ::ng-deep. :host { ::ng-deep { @include grid($custom-column-selection-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References The column selection UI has a few more APIs to explore, which are listed below. IgxHierarchicalGridComponent IgxColumnComponent IgxColumnGrpupComponent IgxHierarchicalGridComponent Styles IgxHierarchicalGridComponent properties: columnSelection selectedColumns selectColumns deselectColumns selectAllColumns deselectAllColumns IgxColumnComponent properties: selectable selected IgxColumnGrpupComponent properties: selectable selected IgxHierarchicalGridComponent events: onColumnsSelectionChange Additional Resources Hierarchical Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/column-types.html": {
    "href": "components/hierarchicalgrid/column-types.html",
    "title": "Column Data Types in Angular - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Column Types Ignite UI for Angular Hierarchical Grid provides a default handling of number, string, date, boolean, currency and percent column data types, based on which the appearance of the default and editing templates will be present. Default template If you want to enable a data type-specific template, you should set the column dataType input otherwise the column will be treated as a string column since that is the default value for column dataType. Let's see what are the default templates for each type. String This column dataType is not changing the appearance or format of the cell value. Number If the dataType is set to number, the cell value will be formatted based on application or grid's locale settings, as well as when pipeArgs property is specified. Then the number format will be changed based on them, for example it might change the: Number of digits after the decimal point Decimal separator with , or . public options = { digitsInfo: '1.4-4', }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatOptions\" [dataType]=\"'number'\"> </igx-column> DateTime, Date and Time The appearance of the date portions will be set (e.g. day, month, year) based on locale format or pipeArgs input. The pipe arguments can be used to specify a custom date format or timezone: format - The default value for formatting the date is 'mediumDate'. Other available options are 'short', 'long', 'shortDate', 'fullDate', 'longTime', 'fulLTime' and etc. This is a full list of all available pre-defined format options. timezone - The user's local system timezone is the default value. The timezone offset or standard GMT/UTC or continental US timezone abbreviation can also be passed. Different timezone examples which will display the corresponding time of the location anywhere in the world: public formatDateOptions = { /** The date/time components that a date column will display, using predefined options or a custom format string. */ /** e.g 'dd/mm/yyyy' or 'shortDate' **/ format: 'longDate', /** A timezone offset (such as '+0430'), or a standard UTC/GMT or continental US timezone abbreviation. */ timezone: 'GMT' }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatDateOptions\" [dataType]=\"'date'\"> </igx-column> Available timezones: Timezone Value Alpha Time Zone ‘UTC+1’ Australian Central Time ‘UTC+9:30/ +10:30’ Arabia Standard Time ‘UTC+3’ Central Standard Time ‘UTC-6’ China Standard Time ‘UTC+8’ Delta Time Zone ‘UTC+4’ Greenwich Mean Time ‘UTC+0’ Gulf Standard Time ‘UTC+4’ Hawaii Standard Time ‘UTC-10’ India Standard Time ‘UTC+4’ The Hierarchical Grid accepts date values of type Date object, Number (milliseconds), An ISO date-time string. This section shows how to configure a custom display format. As you can see in the sample, we specify a different format options in order to showcase the available formats for the specific column type. For example, below you can find the format options for the time portion of the date object: // Time format with equivalent example public timeFormats = [ { format: 'shortTime', eq: 'h:mm a' }, { format: 'mediumTime', eq: 'h:mm:ss a' }, { format: 'longTime', eq: 'h:mm:ss a z' }, { format: 'fullTime', eq: 'h:mm:ss a zzzz' }, ]; Cell editing When it comes to cell editing based on the column type a different editor will appear: dateTime - IgxDateTimeEditor directive will be used. This editor will give you a mask directions for the input elements part of the DateTime object. date - IgxDatePicker component will be used. time - IgxTimePicker component will be used. Filtering The same editors listed above will be used when it comes to Quick Filtering/Excel-style Filtering. These are the following filtering operands that each type exposes: dateTime and date - Equals, Does Not Equal, Before, After, Today, Yesterday, This Month, Last Month, Next Month, This Year, Last Year, Next Year, Empty, Not Empty, Null, Not Null; time - At, Not At, Before, After, At or Before, At or After, Empty, Not Empty, Null, Not Null; Summaries The available Summary operands will be Count, Earliest (date/time) and Latest (date/time). Sorting Time type column sorts based on the time portion of the object, ms will be disregarded. Date type column sorts based on the date portion, disregards the time portion. DateTime column sorts based on the full date Boolean The default template is using material icons for visualization of boolean values - 'clear' icon for false values and 'check' icon for true values. As for the editing template, it is using igx-checkbox component. <igx-column [dataType]=\"'boolean'\"> </igx-column> Currency Default template The default template will show a numeric value with currency symbol that would be either prefixed or suffixed. Both currency symbol location and number value formatting is based on the provided Application LOCALE_ID or Hierarchical Grid locale. By using LOCALE_ID import { LOCALE_ID } from '@angular/core'; ... @Component({ selector: 'app-component.sample', templateUrl: 'grid-component.sample.html', providers: [{provide: LOCALE_ID, useValue: 'fr-FR' }] }) By using Grid's locale <igx-grid [locale]=\"'fr-FR'\" [data]=\"data\"> </igx-grid> By using the pipeArgs input the end-user can customize the number format by decimal point, currencyCode and display. public options = { digitsInfo: '3.4-4', currencyCode: 'USD', display: 'symbol-narrow' }; public formatOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatOptions\" [dataType]=\"'currency'\"> </igx-column> Parameter Description digitsInfo Represents Decimal representation of currency value currencyCode ISO 4217 currency code display* Displays the value by narrow or wide symbol *display - for the default en-US locale, the code USD can be represented by the narrow symbol $ or the wide symbol US$. Upon editing of cell's value the currency symbol will be visible as suffix or prefix. More about that could be found in the official Cell editing topic. Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Percent Default template is showing the percent equivalent of the underlying numeric value. The displayed cell value is a multiplied result by display factor of '100' - for example, as the default factor is 100 and the \"value\" passed to the cell is 0.123, then the displayed cell value will be \"12.3%\". When it comes to cell editing, the value will be the same as the data source value - the display factor is '1'. Upon editing of the cell a preview of the percent value will be shown as a suffix element.For example, while editing '0.0547' the preview element will show '5.47%'. public options = { /** * Decimal representation options, specified by a string in the following format: * `{minIntegerDigits}`.`{minFractionDigits}`-`{maxFractionDigits}`. * `minIntegerDigits`: The minimum number of integer digits before the decimal point. Default is 1. * `minFractionDigits`: The minimum number of digits after the decimal point. Default is 0. * `maxFractionDigits`: The maximum number of digits after the decimal point. Default is 3. */ digitsInfo: '2.2-3' }; public formatPercentOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatPercentOptions\" [dataType]=\"'percent'\"> </igx-column> Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Image Default template is using the value coming from the data as an image source to a default image template. The default image template will extract the name of the image file and set it as alt attribute of the image to meet the accessibility requirement. The displayed cell size is adjusted to the sizes of the images rendered, so keep in mind that large images will still be rendered and the grid rows will become as large as the images in the image column. Filtering, sorting and grouping will be turned off by default for image type columns. If you want to enable them, you need to provide custom strategies which perform the data operations. <igx-column [dataType]=\"'image'\"> </igx-column> When auto-generating columns, the grid analyses the values in the first data record. If a value is of type string and matches the pattern of a url ending in an image extension (gif, jpg, jpeg, tiff, png, webp, bmp) then the column will automatically be marked as dataType === GridColumnDataType.Image and a default image template will be rendered. Default editing template See the editing templates part of Hierarchical Grid Editing topic Custom editing template and formatter Custom template and column formatter definition will always take precedence over the column data type set: Custom template <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"false\"> <igx-column [field]=\"'UnitsInStock'\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [editable]=\"true\"> <ng-template igxCellEditor let-value> {{ value | currency:'USD':'symbol':'1.0-0'}} </ng-template> </igx-column> </igx-grid> Column formatter // Through column formatter property public formatCurrency(value: number) { return `Dollar sign ${value.toFixed(0)}`; } public init(column: IgxColumnComponent) { switch (column.field) { case 'UnitsInStock': column.formatter = this.formatCurrency; break; default: return; } API References IgxGridCell Column pipeArgs Hierarchical Grid locale Column dataType Additional Resources For custom templates you can see cell editing topic Hierarchical Grid overview topic Editing topic Summaries topic View page on GitHub"
  },
  "components/hierarchicalgrid/conditional-cell-styling.html": {
    "href": "components/hierarchicalgrid/conditional-cell-styling.html",
    "title": "Conditional Cell Styling in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Conditional Styling If you need to provide any custom styling in the IgxHierarchicalGrid component, you can do it on either row or cell level. Hierarchical Grid Conditional Row Styling The IgxHierarchicalGrid component in Ignite UI for Angular provides two ways to conditional styling of rows based on custom rules. By setting rowClasses input on the IgxHierarchicalGrid component; By setting rowStyles input on the IgxHierarchicalGrid component; Further in this topic wi will cover both of them in more details. Using rowClasses You can conditionally style the IgxHierarchicalGrid rows by setting the rowClasses input and define custom rules. <igx-hierarchical-grid #hierarchicalGrid class=\"hgrid\" [data]=\"localData\" [height]=\"'580px'\" [width]=\"'100%'\" [rowStyles]=\"rowStyles\"> ... </igx-hierarchical-grid> The rowClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. // sample.component.ts public rowClasses = { activeRow: this.activeRowCondition }; public activeRowCondition = (row: RowType) => this.grid?.navigation.activeNode?.row === row.index; // sample.component.scss ::ng-deep { .activeRow { border: 2px solid #fc81b8; border-left: 3px solid #e41c77; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo Using rowStyles Columns now expose the rowStyles property which allows conditional styling of the data rows. Similar to rowClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling (without any conditions). The callback signature for both rowStyles and rowClasses is: (row: RowType) => boolean Let's define our styles: // component.ts public rowStyles = { background:(row: RowType) => row.data['HasGrammyAward'] ? '#eeddd3' : '#f0efeb', 'border-left': (row: RowType) => row.data['HasGrammyAward'] ? '2px solid #dda15e' : null }; public childRowStyles = { 'border-left': (row: RowType) => row.data['BillboardReview'] > 70 ? '3.5px solid #dda15e' : null }; <igx-hierarchical-grid #hierarchicalGrid [data]=\"localdata\" [autoGenerate]=\"false\" [height]=\"'580px'\" [width]=\"'100%'\" [rowStyles]=\"rowStyles\"> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"false\" [rowStyles]=\"childRowStyles\"> ... </igx-row-island> ... </igx-hierarchical-grid> Demo Hierarchical Grid Conditional Cell Styling Overview The IgxHierarchicalGrid component in Ignite UI for Angular provides two ways to conditional styling of cells based on custom rules. By setting the IgxColumnComponent input cellClasses to an object literal containing key-value pairs. The key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. The result is a convenient material styling of the cell. // component.ts file public beatsPerMinuteClasses = { downFont: this.downFontCondition, upFont: this.upFontCondition }; ... private downFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 95; } // component.scss file .upFont { color: red; } .downFont { color: green; } Using cellClasses You can conditionally style the IgxHierarchicalGrid cells by setting the IgxColumnComponent cellClasses input and define custom rules. The cellClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo By using the IgxColumnComponent input cellStyles which accepts an object literal where the keys are style properties and the values are expressions for evaluation. public styles = { 'background': 'linear-gradient(180deg, #dd4c4c 0%, firebrick 100%)', 'text-shadow': '1px 1px 2px rgba(25,25,25,.25)', 'animation': '0.25s ease-in-out forwards alternate popin' }; The callback signature for both cellStyles and cellClasses is now changed to: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Using cellStyles Columns now expose the cellStyles property which allows conditional styling of the column cells. Similar to cellClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling with ease (without any conditions). In the sample above we've created: Two different styles that will be applied based on the column index. You will also change the text color based on even/odd rows. The callback signature for both cellStyles is: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Let's define our styles: // component.ts public oddColStyles = { background: 'linear-gradient(to right, #b993d6, #8ca6db)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'white' : 'gray', animation: '0.75s popin' }; public evenColStyles = { background: 'linear-gradient(to right, #8ca6db, #b993d6)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'gray' : 'white', animation: '0.75s popin' }; On ngOnInit we will add the cellStyles configuration for each column of the predefined columns collection, which is used to create the IgxHierarchicalGrid columns dynamically. // component.ts public ngOnInit() { this.data = athletesData; this.columns = [ { field: 'Id' }, { field: 'Position' }, { field: 'Name' }, { field: 'AthleteNumber' }, { field: 'CountryName' } ]; this.applyCSS(); } public applyCSS() { this.columns.forEach((column, index) => { column.cellStyles = (index % 2 === 0 ? this.evenColStyles : this.oddColStyles); }); } public updateCSS(css: string) { this.oddColStyles = {...this.oddColStyles, ...JSON.parse(css)}; this.evenColStyles = {...this.evenColStyles, ...JSON.parse(css)}; this.applyCSS(); } // component.html <igx-grid #grid1 [data]=\"data\" primaryKey=\"ID\" width=\"80%\" height=\"300px\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\" [cellStyles]=\"c.cellStyles\"> </igx-column> </igx-grid> Define a popin animation // component.scss @keyframes popin { 0% { opacity: 0.1; transform: scale(.75, .75); filter: blur(3px) invert(1); } 50% { opacity: .5; filter: blur(1px); } 100% { transform: scale(1, 1); opacity: 1; filter: none; } } Demo Known issues and limitations If there are cells bind to the same condition (from different columns) and one cell is updated, the other cells won't be updated based on the new value, if the condition is met. A pipe check should be performed in order to apply the changes to the rest of the cells. The example below shows how to do that with a spread operator ... on onCellEdit event. This will copy the original object with a new instance, and lead pure pipe to be fired. public backgroundClasses = { myBackground: (rowData: any, columnKey: string) => { return rowData.Col2 < 10; } }; ... editDone(evt) { this.backgroundClasses = {...this.backgroundClasses}; } <igx-grid #grid1 [data]=\"data\" height=\"500px\" width=\"100%\" (onCellEdit)=\"editDone($event)\"> <igx-column field=\"Col1\" dataType=\"number\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col2\" dataType=\"number\" [editable]=\"true\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col3\" header=\"Col3\" dataType=\"string\" [cellClasses]=\"backgroundClasses\"></igx-column> </igx-grid> API References IgxColumnComponent IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Column Hiding Selection Searching Toolbar Multi-column Headers Size (Display Density) Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/display-density.html": {
    "href": "components/hierarchicalgrid/display-density.html",
    "title": "Angular Grid Size - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Size IgxHierarchicalGrid design is based on Material Design Guidelines. We currently provide an option to choose between predefined set of size options that will bring a small, medium, or large view respectively. By selecting the right size for your Material UI table / Material UI grid you can significantly improve the user experience when interacting with large amounts of content. Angular Hierarchical Grid Size Example Usage As you can see in the demo above, the IgxHierarchicalGrid provides three size options: small, medium and large. The code snippet below shows how to set size: <igx-hierarchical-grid #hierarchicalGrid [data]=\"data\" style=\"--ig-size: var(--ig-size-small)\"> </igx-hierarchical-grid> And now let's see in details how each option reflects on the Hierarchical Grid component. When you switch between different sizes the height of each Hierarchical Grid element and the corresponding paddings will be changed. Also if you want to apply custom column width, please consider the fact that it must be bigger than the sum of left and right padding. --ig-size-large - this is the default Hierarchical Grid size with the lowest intense and row height equal to 50px. Left and Right paddings are 24px; Minimal column width is 80px; --ig-size-medium - this is the middle size with 40px row height. Left and Right paddings are 16px; Minimal column width is 64px; --ig-size-small - this is the smallest size with 32px row height. Left and Right paddings are 12px; Minimal column width is 56px; Note Please keep in mind that currently you can not override any of the sizes. Let's now continue with our sample and see in action how each size is applied. Let's first add a button which will help us to switch between each size: <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\"></igx-buttongroup> </div> @ViewChild(IgxButtonGroupComponent) public buttonGroup: IgxButtonGroupComponent; public size = 'small'; public sizes; public ngOnInit() { this.sizes = [ { label: 'small', selected: this.size === 'small', togglable: true }, { label: 'medium', selected: this.sie === 'medium', togglable: true }, { label: 'large', selected: this.size === 'large', togglable: true } ]; } Now we can add the markup. <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\" (selected)=\"selectSize($event)\"></igx-buttongroup> </div> <igx-hierarchical-grid #hGrid [data]=\"localdata\" [height]=\"'600px'\" [width]=\"'100%'\" [allowFiltering]=\"true\"> <igx-column field=\"CustomerID\"></igx-column> <igx-column field=\"CompanyName\"></igx-column> <igx-column field=\"ContactName\"></igx-column> <igx-column field=\"ContactTitle\"></igx-column> <igx-column field=\"Address\"></igx-column> <igx-column field=\"City\"></igx-column> <igx-column field=\"PostalCode\"></igx-column> <igx-column field=\"Country\"></igx-column> <igx-column field=\"Phone\"></igx-column> <igx-column field=\"Fax\"></igx-column> <igx-row-island [key]=\"'Orders'\" [autoGenerate]=\"false\" #layout1 > <igx-column field=\"OrderID\"></igx-column> <igx-column field=\"EmployeeID\"></igx-column> <igx-column field=\"OrderDate\"></igx-column> <igx-column field=\"RequiredDate\"></igx-column> <igx-column field=\"ShippedDate\"></igx-column> <igx-column field=\"ShipVia\"></igx-column> <igx-column field=\"Freight\"></igx-column> <igx-column field=\"ShipName\"></igx-column> <igx-column field=\"ShipAddress\"></igx-column> <igx-column field=\"ShipCity\"></igx-column> <igx-column field=\"ShipPostalCode\"></igx-column> <igx-column field=\"ShipCountry\"></igx-column> <igx-row-island [key]=\"'OrderDetails'\" [autoGenerate]=\"false\"> <igx-column field=\"ProductID\"></igx-column> <igx-column field=\"UnitPrice\"></igx-column> <igx-column field=\"Quantity\"></igx-column> <igx-column field=\"Discount\"></igx-column> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> Finally, let's provide the necessary logic in order to actually apply the size: @ViewChild('hierarchicalGrid', { read: IgxHierarchicalGridComponent }) public hierarchicalGrid: IgxHierarchicalGridComponent; public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } Another option that IgxHierarchicalGrid provides for you, in order to be able to change the height of the rows in the Hierarchical Grid, is the property rowHeight. So let's see in action how this property affects the Hierarchical Grid layout along with the --ig-size CSS variable. Please keep in mind the following: --ig-size CSS variable will have NO impact on row height if there is rowHeight specified; --ig-size will affect all of the rest elements in the Hierarchical Grid, as it has been described above; And now we can extend our sample and add rowHeight property to the Hierarchical Grid: <igx-hierarchical-grid #hierarchicalGrid [data]=\"data\" [rowHeight]=\"'80px'\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> .............. </igx-hierarchical-grid> API References IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles IgxColumnComponent Additional Resources Hierarchical Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/editing.html": {
    "href": "components/hierarchicalgrid/editing.html",
    "title": "Angular Hierarchical Grid Editing - Ignite UI for Angular",
    "keywords": "/* Fix for the overlapping right side-affix when the screen is shrinked */ .table-responsive { width:63vw; } Angular Hierarchical Grid Editing Ignite UI for Angular Hierarchical Grid component provides an easy way to perform data manipulation operations like creating, updating, and deleting records. The data manipulation phases are: Cell Editing, Row Editing, and Batch Editing. The Hierarchical Grid gives you a powerful public API which allows you to customize the way these operations are performed. Additionally, Cell editing exposes several default editors based on the column data type, that could be easily customized via igxCellEditor directive or igxRow directives. Setup In order to specify which edit mode should be enabled, the Hierarchical Grid exposes the following boolean properties - editable and rowEditable. Property editable enables you to specify the following options: false - the editing for the corresponding column will be disabled; /default value/ true - the editing for the corresponding column will be enabled; Keep in mind that if the column is not editable, you can still modify its value through the public API exposed by the Hierarchical Grid. Property rowEditable enables you to specify the following options: false - the row editing in the corresponding grid will be disabled; /default value/ true - the row editing in the corresponding grid will be enabled; In the Hierarchical Grid if you set rowEditable property to true, and editable property is not explicitly defined for any column, the editing will be enabled for all the columns except the primary key. Batch editing in the grid can be enabled for both cell editing and row editing modes. In order to set up batch editing it is necessary to provide to the grid a TransactionService. Cell and Batch Editing - in this scenario every singe modification of each cell is preserved separately and undo/ redo operations are available on cell level; Row and Batch Editing - in this scenario the modifications are preserved on row level so undo/ redo operations will not be working for each cell that is modified but for the bunch of cell from each row. Editing Templates If you want to use a data type specific edit templates, you should specify the column dataType property. So let's now see what are the default templates for each type: For string data type, default template is using igxInput For number data type, default template is using igxInput type=\"number\", so if you try to update cell to a value which can not be parsed to a number your change is going to be discarded, and the value in the cell will be set to 0. For date data type, default template is using igxDatePicker For dateTime data type, default template is using IgxDateTimeEditor directive. This editor will give you a mask directions for the input elements part of the DateTime object. For date data type, default template is using IgxDatePicker component. For time - data type, default template is using IgxTimePicker component. For boolean data type, default template is using igxCheckbox For currency data type, default template is using IgxInputGroup with prefix/suffix configuration based on application or grid locale settings. For percent data type, default template is using IgxInputGroup with suffix element that shows a preview of the edited value in percents. For custom templates you can see Cell Editing topic All available column data types could be found in the official Column types topic. Event arguments and sequence The grid exposes a wide array of events that provide greater control over the editing experience. These events are fired during the Row Editing and Cell Editing lifecycle - when starting, committing or canceling the editing action. Event Description Arguments Cancellable rowEditEnter If rowEditing is enabled, fires when a row enters edit mode IGridEditEventArgs true cellEditEnter Fires when a cell enters edit mode (after rowEditEnter) IGridEditEventArgs true cellEdit If value is changed, fires just before a cell's value is committed (e.g. by pressing Enter) IGridEditEventArgs true cellEditDone If value is changed, fires after a cell has been edited and cell's value is committed IGridEditDoneEventArgs false cellEditExit Fires when a cell exits edit mode IGridEditDoneEventArgs false rowEdit If rowEditing is enabled, fires just before a row in edit mode's value is committed (e.g. by clicking the Done button on the Row Editing Overlay) IGridEditEventArgs true rowEditDone If rowEditing is enabled, fires after a row has been edited and new row's value has been committed. IGridEditDoneEventArgs false rowEditExit If rowEditing is enabled, fires when a row exits edit mode IGridEditDoneEventArgs false Event cancelation RowEditEnter - Neither Row nor Cell will enter edit mode. CellEditEnter - Prevents entering cell edit. If rowEditable is enabled, row edit will be triggered, although cell edit will remain forbidden. CellEdit - Allowed Cell/Row edit, hitting Done button or Enter won't commit the value or row transaction. Cell editing and Row editing won't be closed until Cancel button is clicked. RowEdit - Committing cell is possible, but not the whole row. The row will stay in edit mode and the row transaction will be considered open. Hitting Done does not commit or close the row. Cancel button closes the editing process and the transaction without committing the changes. The following sample demonstrates the editing execution sequence in action: Features integration While a cell/row is in edit mode, a user may interact with the grid in many ways. The following table specifies how a certain interaction affects the current editing: Hierarchical Grid Filtering Sorting Paging Moving Pinning Hiding GroupBy Resizing Escape Enter F2 Tab Cell Click Add new row/Delete/Edit Keep edit mode ✔ Exit edit mode ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ Commit ✔ ✔ ✔ ✔ ✔ Discard ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ As seen from the table, all interactions, except resizing a column, will end the editing and will discard the new values. Should the new value be committed, this can be done by the developer in the corresponding feature \"-ing\" event. Example how to commit new values, if user tries to sort the column while a cell/row is in edit mode: <igx-grid #grid [data]=\"localData\" [primaryKey]=\"'ProductID'\" (sorting)=\"onSorting($event)\"> ... </igx-grid> public onSorting(event: ISortingEventArgs) { this.grid.endEdit(true); // (event.owner as IgxGridComponent).endEdit(true); } API References IgxGridCell IgxHierarchicalGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Hierarchical Grid overview Build CRUD operations with igxGrid Column Data Types Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection View page on GitHub"
  },
  "components/hierarchicalgrid/excel-style-filtering.html": {
    "href": "components/hierarchicalgrid/excel-style-filtering.html",
    "title": "Excel Style Filtering in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Excel Filtering in Angular Hierarchical Grid The grid Excel filtering provides an Excel like filtering UI for any Angular table like the Hierarchical Grid. Angular Hierarchical Grid Excel Style Filtering Example Usage To turn on the grid excel filtering, two inputs should be set. The allowFiltering should be set to true and the filterMode should be set to excelStyleFilter. <igx-hierarchical-grid [data]=\"data\" [autoGenerate]=\"true\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\"> </igx-hierarchical-grid> Interactions In order to open the filter menu for a particular column, the Angular filter icon in the header should be clicked. Additionally, you can use the Ctrl + Shift + L combination on a selected header. If the column can be sorted, pinned, moved, selected or hidden along with the filtering functionality, there will be buttons available for the features that are turned on. If no filter is applied, all the items in the list will be selected. They can be filtered from the input above the list. In order to filter the data, you can select/deselect the items in the list and either click the Apply button, or press Enter. The filtering applied through the list items creates filter expressions with equals operator and the logic operator between the expressions is OR. If you type something in the search box and apply the filter, only the items that match the search criteria will be selected. If you want to add items to the currently filtered ones, however, you should select the option Add current selection to filter. If you want to clear the filter, you can check the Select All option and then click the Apply button. To apply a filter with different expressions, you can click the Text filter, which will open a sub menu with all available filter operators for the particular column. Selecting one of them will open the custom filter dialog, where you can add as many expressions as you want with different filter and logic operators. There is also a clear button, which can clear the filter. Configure Menu Features Sorting, pinning and hiding features can be removed from the filter menu using the corresponding inputs: sortable, selected, disablePinning, disableHiding. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\" [moving]=\"true\" [allowFiltering]='true' filterMode=\"excelStyleFilter\" [height]=\"'650px'\" [width]=\"'100%'\" [rowHeight]=\"'65px'\" #hierarchicalGrid> <igx-column field=\"Artist\" [filterable]='true' [sortable]=\"true\"></igx-column> <igx-column field=\"Photo\" [filterable]='false'> <ng-template igxCell let-cell=\"cell\"> <div class=\"cell__inner_2\"> <img [src]=\"cell.value\" class=\"photo\" /> </div> </ng-template> </igx-column> <igx-column field=\"Debut\" [filterable]='true' [disablePinning]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column field=\"Grammy Nominations\" [filterable]='true' [dataType]=\"'number'\" [sortable]=\"false\"></igx-column> <igx-column field=\"Grammy Awards\" [filterable]='true' [dataType]=\"'number'\"></igx-column> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"false\" [allowFiltering]='true' filterMode=\"excelStyleFilter\"> <igx-column field=\"Album\" [filterable]='true'></igx-column> <igx-column field=\"Launch Date\" [filterable]='true' [dataType]=\"'date'\"></igx-column> <igx-column field=\"Billboard Review\" [filterable]='true' [dataType]=\"'number'\"></igx-column> <igx-column field=\"US Billboard 200\" [filterable]='true' [dataType]=\"'number'\"></igx-column> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"false\" > <igx-column field=\"No.\"></igx-column> <igx-column field=\"Title\"></igx-column> <igx-column field=\"Released\"></igx-column> <igx-column field=\"Genre\"></igx-column> </igx-row-island> </igx-row-island> <igx-row-island [key]=\"'Tours'\" [autoGenerate]=\"false\"> <igx-column field=\"Tour\"></igx-column> <igx-column field=\"Started on\"></igx-column> <igx-column field=\"Location\"></igx-column> <igx-column field=\"Headliner\"></igx-column> </igx-row-island> </igx-hierarchical-grid> In the sample below 'Artist' column have all three features enabled, 'Debut' have all three disabled, 'Grammy Nominations' has only pinning and hiding. Templates If you want to further customize the Excel style filter menu without disabling the column features you could use custom templates. The Excel Style filter menu provides two directives for templating: IgxExcelStyleColumnOperationsTemplateDirective - re-templates the area with all column operations like sorting, pinning, etc. IgxExcelStyleFilterOperationsTemplateDirective - re-templates the area with all filter specific operations. You could either re-template only one of those areas or both of them. You could put any custom content inside those directives or you could use any of our built-in Excel style filtering components. The following code demonstrates how to define a custom Excel style filter menu using the igx-excel-style-header, igx-excel-style-sorting and igx-excel-style-search components. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\" [allowFiltering]='true' filterMode=\"excelStyleFilter\" [height]=\"'650px'\" [width]=\"'100%'\" [rowHeight]=\"'65px'\" #hierarchicalGrid> <igx-grid-excel-style-filtering [minHeight]=\"'380px'\" [maxHeight]=\"'500px'\"> <igx-excel-style-column-operations> <igx-excel-style-header [showPinning]=\"true\" [showHiding]=\"true\" > </igx-excel-style-header> <igx-excel-style-sorting></igx-excel-style-sorting> </igx-excel-style-column-operations> <igx-excel-style-filter-operations> <igx-excel-style-search></igx-excel-style-search> </igx-excel-style-filter-operations> </igx-grid-excel-style-filtering> ... <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"false\" [allowFiltering]='true' filterMode=\"excelStyleFilter\"> <igx-grid-excel-style-filtering [minHeight]=\"'380px'\" [maxHeight]=\"'500px'\"> <igx-excel-style-column-operations> <igx-excel-style-header [showPinning]=\"true\" [showHiding]=\"true\" > </igx-excel-style-header> <igx-excel-style-sorting></igx-excel-style-sorting> </igx-excel-style-column-operations> <igx-excel-style-filter-operations> <igx-excel-style-search></igx-excel-style-search> </igx-excel-style-filter-operations> </igx-grid-excel-style-filtering> .... </igx-hierarchical-grid> You could also re-template the Excel style filtering icon in the column header using the igxExcelStyleHeaderIcon directive: <igx-hierarchical-grid ...> <ng-template igxExcelStyleHeaderIcon> <igx-icon>filter_alt</igx-icon> </ng-template> </igx-hierarchical-grid> Here is the full list of Excel style filtering components that you could use: igx-excel-style-header igx-excel-style-sorting igx-excel-style-moving igx-excel-style-pinning igx-excel-style-hiding igx-excel-style-selecting igx-excel-style-clear-filters igx-excel-style-conditional-filter igx-excel-style-search Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. These values can be provided manually and loaded on demand, which is demonstrated in the Hierarchical Grid Remote Data Operations topic. Formatted Values Filtering Strategy By default, the Hierarchical Grid component filters the data based on the original cell values, however in some cases you may want to filter the data based on the formatted values. In order to do that you can use the FormattedValuesFilteringStrategy. The following sample demonstrates how to format the numeric values of a column as strings and filter the Hierarchical Grid based on the string values: Note The formatted values filtering strategy won't work correctly if you have more than one column bound to the same field from your data and one of the columns has a formatter. External Excel Style filtering As you see at the demos above the default appearance of the Excel Style filtering dialog is inside the Hierarchical Grid. So this dialog is only visible when configuring the filters. There is a way to make that dialog stay always visible - it can be used outside of the grid as a standalone component. In the demo below, the Excel style filtering is declared separately of the Hierarchical Grid. Demo Usage In order to configure the Excel style filtering component, you should set its column property to one of the Hierarchical Grid's columns. In the sample above, we have bound the column property to the value of an IgxSelectComponent that displays the Hierarchical Grid's columns. <igx-select #gridColums value=\"Artist\"> <label igxLabel>Columns:</label> <igx-select-item *ngFor=\"let c of hierarchicalgrid1.columns\" [value]=\"c.field\"> {{ c.field }} </igx-select-item> </igx-select> <igx-grid-excel-style-filtering [column]=\"hierarchicalgrid1.getColumnByName(gridColums.value)\"> </igx-grid-excel-style-filtering> External Outlet The Hierarchical Grid's z-index creates separate stacking context for each grid in the DOM. This ensures that all descendant elements of the grid will render as intended, without overlapping one another. However, elements that go outside of the grid (e.g. Excel Style filter) will conflict with outside elements with the same z-index (e.g. having two grids one under another) resulting in false rendering. The solution for this issue is to set the outlet property to an external outlet directive which allows the overlay elements to always appear on top. Demo Styling To get started with styling the Excel Style Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The excel style filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); We obviously have a lot more components inside the excel like filtering dialog, such as buttons, checkboxes, a list and even a drop-down. In order to style them, we need to create a separate theme for each one: $dark-button: button-theme( $background: #FFCD0F, $foreground: #292826, $hover-background: #292826, $hover-foreground: #FFCD0F ); $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $custom-list: list-theme( $background: #FFCD0F ); $custom-checkbox: checkbox-theme( $empty-color: #292826, $fill-color: #292826, $tick-color: #FFCD0F, $label-color: #292826 ); $custom-drop-down: drop-down-theme( $background-color: #FFCD0F, $item-text-color: #292826, $hover-item-background: #292826, $hover-item-text-color: #FFCD0F ); In this example we only changed some of the parameters for the listed components, but the button-theme, checkbox-theme, drop-down-theme, input-group-theme, list-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope most of the components' mixins within .igx-excel-filter and .igx-excel-filter__secondary, so that these custom themes will affect only components nested in the excel style filtering dialog and all of its sub-dialogs. Otherwise other buttons, checkboxes, input-groups and lists would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); $dark-button: button-theme( $background: color($dark-palette, \"secondary\", 400), $foreground: color($dark-palette, \"primary\", 400), $hover-background: color($dark-palette, \"primary\", 400), $hover-foreground: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $custom-list: list-theme( $background: color($dark-palette, \"secondary\", 400) ); $custom-checkbox: checkbox-theme( $empty-color: color($dark-palette, \"primary\", 400), $fill-color: color($dark-palette, \"primary\", 400), $tick-color: color($dark-palette, \"secondary\", 400), $label-color: color($dark-palette, \"primary\", 400) ); $custom-drop-down:drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), $item-text-color: color($dark-palette, \"primary\", 400), $hover-item-background: color($dark-palette, \"primary\", 400), $hover-item-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group, light-button, light-list, light-checkbox and light-drop-down schemas: $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"secondary\", 400) ) ) ); $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ), contained-background:( color: (\"secondary\", 400) ), contained-text-color:( color: (\"primary\", 400) ), contained-hover-background:( color: (\"primary\", 400) ), contained-hover-text-color:( color: (\"secondary\", 400) ) ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); $custom-list-schema: extend($_light-list, ( background:( color: (\"secondary\", 400) ) ) ); $custom-checkbox-schema: extend($_light-checkbox, ( empty-color:( color: (\"primary\", 400) ), fill-color:( color: (\"primary\", 400) ), tick-color:( color: (\"secondary\", 400) ), label-color:( color: (\"primary\", 400) ) ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), item-text-color:( color: (\"primary\", 400) ), hover-item-background:( color: (\"primary\", 400) ), hover-item-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( grid: $custom-grid-schema, button: $custom-button-schema, input-group: $custom-input-group-schema, list: $custom-list-schema, checkbox: $custom-checkbox-schema, drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-list: list-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-checkbox: checkbox-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/export-excel.html": {
    "href": "components/hierarchicalgrid/export-excel.html",
    "title": "Angular Hierarchical Grid Export to Excel - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Export to Excel Service The Excel Exporter service can export data to excel from the IgxHierarchicalGrid. The data export functionality is encapsulated in the IgxExcelExporterService class. To trigger the process, you need to invoke the IgxExcelExporterService's export method and pass the IgxHierarchicalGrid component as the first argument. Angular Excel Exporter Example Exporting Hierarchical Grid's Data To start using the IgniteUI Excel Exporter first import the IgxExcelExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts import { IgxExcelExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxExcelExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <igx-hierarchical-grid #hierarchicalGrid [data]=\"localData\" [autoGenerate]=\"true\"></igx-hierarchical-grid> <button (click)=\"exportButtonHandler()\">Export IgxHierarchicalGrid to Excel</button> You may access the exporter service by defining an argument of type IgxExcelExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in MS Excel format you need to invoke the exporter service's export method and pass the IgxHierarchicalGrid component as first argument. Here is the code which will execute the export process in the component's typescript file: // component.ts import { IgxExcelExporterService, IgxExcelExporterOptions } from 'igniteui-angular'; import { IgxHierarchicalGridComponent } from 'igniteui-angular'; @ViewChild('hierarchicalGrid') public hierarchicalGrid: IgxHierarchicalGridComponent; constructor(private excelExportService: IgxExcelExporterService) { } public exportButtonHandler() { this.excelExportService.export(this.hierarchicalGrid, new IgxExcelExporterOptions('ExportedDataFile')); } If all went well, you should see the IgxHierarchicalGrid component and a button under it. When pressing the button, it will trigger the export process and the browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the Hierarchical Grid component in MS Excel format. Export All Data There are some cases when you might be using remote operations like Paging and the Grid won't have access to all of its data. In these cases, we recommend using the Excel Export Service and pass the whole data collection, if available. Example: public exportButtonHandler() { this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions('ExportedDataFile')); } Export Multi Column Headers Grid It is now possible to export Hierarchical Grid with defined multi-column headers. All headers will be reflected in the exported excel file as they are displayed in the Hierarchical Grid. If you want to exclude the defined multi-column headers from the exported data you can set the exporter option ignoreMultiColumnHeaders to true. Note The exported Hierarchical Grid will not be formatted as a table, since Excel tables do not support multiple row headers. Export Grid with Frozen Column Headers By default Excel Exporter service exports the grid with scrollable (unfrozen) column headers. There are scenarios in which you may want to freeze all headers on top of the exported excel file so they always stay in view as the user scrolls through the records. To achieve this you could set the exporter option freezeHeaders to true. public exportButtonHandler() { const exporterOptions = new IgxExcelExporterOptions('ExportedDataFile'); exporterOptions.freezeHeaders = true; this.excelExportService.export(this.grid, exporterOptions); } Customizing the Exported Content In the above examples the Excel Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude a column from the export if its header is \"Age\" and if its index is 1: // component.ts this.excelExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Age' && args.columnIndex == 1) { args.cancel = true; } }); this.excelExportService.export(this.hierarchicalGrid, new IgxExcelExporterOptions('ExportedDataFile')); When you are exporting data from the Hierarchical Grid component, the export process takes in account features like row filtering and column hiding and exports only the data visible in the Hierarchical Grid. You can configure the exporter service to include filtered rows or hidden columns by setting properties on the IgxExcelExporterOptions object. Known Limitations Limitation Description Hierarchy levels The excel exporter service can create up to 8 levels of hierarchy. Max worksheet size The maximum worksheet size supported by Excel is 1,048,576 rows by 16,384 columns. Exporting pinned columns In the exported Excel file, the pinned columns will not be frozen but will be displayed in the same order as they appear in the grid. Cell Styling The excel exporter service does not support exporting a custom style applied to a cell component. In such scenarios we recommend using the Excel Library. API References The Excel Exporter service has a few more APIs to explore, which are listed below. IgxExcelExporterService API IgxExcelExporterOptions API Additional components that were used: IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/filtering.html": {
    "href": "components/hierarchicalgrid/filtering.html",
    "title": "Angular Hierarchical Grid Filter - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Filtering IgniteUI for Angular Hierarchical Grid component provides three different filtering types - Quick filtering, Excel style filtering and Advanced filtering which enable you to display only the records that meet specified criteria. The Material UI grid component in Ignite UI provides angular filter capabilities and extensive filtering API through the Data Container to which the Hierarchical Grid is bound. Angular Hierarchical Grid Filtering Example The sample below demonstrates Hierarchical Grid's Quick filtering user experience. Setup In order to specify if filtering is enabled and which filtering mode should be used, the Hierarchical Grid exposes the following boolean properties - allowFiltering, allowAdvancedFiltering, filterMode and filterable. Property allowFiltering enables you to specify the following options: false - the filtering for the corresponding grid will be disabled; /default value/ true - the filtering for the corresponding grid will be enabled; Property allowAdvancedFiltering enables you to specify the following options: false - the advanced filtering for the corresponding grid will be disabled; /default value/ true - the advanced filtering for the corresponding grid will be enabled; Property filterMode enables you to specify the following options: quickFilter - a simplistic filtering UI; /default value/ excelStyleFilter - an Excel-like filtering UI; Property filterable enables you to specify the following options: true - the filtering for the corresponding column will be enabled; /default value/ false - the filtering for the corresponding column will be disabled; <igx-hierarchical-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"ProductName\"></igx-column> <igx-column field=\"Price\" [dataType]=\"'number'\" [filterable]=\"false\"> </igx-hierarchical-grid> To enable the Advanced filtering however, you need to set the allowAdvancedFiltering input properties to true. <igx-hierarchical-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> </igx-hierarchical-grid> Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Hierarchical Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Hierarchical Grid is the intersection between the results of the two filters. Interaction In order to open the filter row for a particular column, the 'Filter' chip below its header should be clicked. To add conditions you should choose filter operand using the dropdown on the left of the input and enter value. For number and date columns 'Equals' is selected by default, for string - 'Contains' and for boolean - 'All'. Pressing 'Enter' confirms the condition and you are now able to add another one. There is a dropdown, between 'condition' chips, which determines the logical operator between them, 'AND' is selected by default. To remove a condition you can click the 'X' button of the chip, and to edit it you should select the chip and the input will be populated with the chip's data. While filter row is opened you can click on any filterable column's header in order to select it and to be able to add filter conditions for it. While some filtering conditions have been applied to a column, and the filter row is closed, you can either remove the conditions by clicking the chip's close button, or you can open the filter row by selecting any of the chips. When there is not enough space to show all the conditions, a filter icon is shown with a badge that indicates how many more conditions there are. It can also be clicked in order to open the filter row. Usage There's a default filtering strategy provided out of the box, as well as all the standard filtering conditions, which the developer can replace with their own implementation. In addition, we've provided a way to easily plug in your own custom filtering conditions. The Hierarchical Grid currently provides not only a simplistic filtering UI, but also more complex filtering options. Depending on the set dataType of the column, the correct set of filtering operations is loaded inside the filter UI dropdown. Additionally, you can set the ignoreCase and the initial condition properties. Filtering feature is enabled for the Hierarchical Grid component by setting the allowFiltering input to true. The default filterMode is quickFilter and it cannot be changed run time. To disable this feature for a certain column – set the filterable input to false. <igx-hierarchical-grid [data]=\"localdata\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"Artist\" [filterable]=\"true\"></igx-column> <igx-column field=\"Photo\" [filterable]=\"false\"> </igx-hierarchical-grid> Note If values of type string are used by a column of dataType Date, the Hierarchical Grid won't parse them to Date objects and using filtering conditions won't be possible. If you want to use string objects, additional logic should be implemented on the application level, in order to parse the values to Date objects. You can filter any column or a combination of columns through the Hierarchical Grid API. The Hierarchical Grid exposes several methods for this task - filter, filterGlobal and clearFilter. filter - filter a single column or a combination of columns. There are five filtering operand classes exposed: IgxFilteringOperand: this is a base filtering operand, which can be inherited when defining custom filtering conditions. IgxBooleanFilteringOperand defines all default filtering conditions for boolean type. IgxNumberFilteringOperand defines all default filtering conditions for numeric type. IgxStringFilteringOperand defines all default filtering conditions for string type. IgxDateFilteringOperand defines all default filtering conditions for Date type. // Single column filtering // Filter the `ProductName` column for values which `contains` the `myproduct` substring, ignoring case this.hierarchicalGrid.filter('ProductName', 'myproduct', IgxStringFilteringOperand.instance().condition('contains'), true); The only required parameters are the column field key and the filtering term. Both the condition and the case sensitivity will be inferred from the column properties if not provided. In the case of multiple filtering, the method accepts an array of filtering expressions. Note The filtering operation DOES NOT change the underlying data source of the Hierarchical Grid. // Multi column filtering const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'ch' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); const priceFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'Price'); const priceExpression = { condition: IgxNumberFilteringOperand.instance().condition('greaterThan'), fieldName: 'UnitPrice', ignoreCase: true, searchVal: 20 }; priceFilteringExpressionsTree.filteringOperands.push(priceExpression); gridFilteringExpressionsTree.filteringOperands.push(priceFilteringExpressionsTree); this.hierarchicalGrid.filteringExpressionsTree = gridFilteringExpressionsTree; filterGlobal - clears all existing filters and applies the new filtering condition to all Hierarchical Grid's columns. // Filter all cells for a value which contains `myproduct` this.hierarchicalGrid.filteringLogic = FilteringLogic.Or; this.hierarchicalGrid.filterGlobal('myproduct', IgxStringFilteringOperand.instance().condition('contains'), false); clearFilter - removes any applied filtering from the target column. If called with no arguments it will clear the filtering of all columns. // Remove the filtering state from the ProductName column this.hierarchicalGrid.clearFilter('ProductName'); // Clears the filtering state from all columns this.hierarchicalGrid.clearFilter(); Initial filtered state To set the initial filtering state of the Hierarchical Grid, set the IgxHierarchicalGridComponent filteringExpressionsTree property to an array of IFilteringExpressionsTree for each column to be filtered. constructor(private cdr: ChangeDetectorRef) { } public ngAfterViewInit() { const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'c' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); this.hierarchicalGrid.filteringExpressionsTree = gridFilteringExpressionsTree; this.cdr.detectChanges(); } Filtering logic The filteringLogic property of the Hierarchical Grid controls how filtering multiple columns will resolve in the Hierarchical Grid. You can change it at any time through the Hierarchical Grid API, or through the Hierarchical Grid input property. import { FilteringLogic } from 'igniteui-angular'; // import { FilteringLogic } from '@infragistics/igniteui-angular'; for licensed package ... this.hierarchicalGrid.filteringLogic = FilteringLogic.OR; The default value of AND returns only the rows that match all the currently applied filtering expressions. Following the example above, a row will be returned when both the 'ProductName' cell value contains 'myproduct' and the 'Price' cell value is greater than 55. When set to OR, a row will be returned when either the 'ProductName' cell value contains 'myproduct' or the 'Price' cell value is greater than 55. Custom Filtering Operands You can customize the filtering menu by adding, removing or modifying the filtering operands. By default, the filtering menu contains certain operands based on the column’s data type (IgxBooleanFilteringOperand, IgxDateFilteringOperand, IgxNumberFilteringOperand and IgxStringFilteringOperand). You can extend these classes or their base class IgxFilteringOperand to change the filtering menu items’ behavior. In the sample below, inspect the \"Product Name\" and \"Discontinued\" columns filters menus. For the \"Discontinued\" column filter, we have limited the number of operands to All, True and False. For the \"Product Name\" column filter – we have modified the Contains and Does Not Contain operands logic to perform case sensitive search and added also Empty and Not Empty operands. To do that, extend the IgxStringFilteringOperand and IgxBooleanFilteringOperand, modify the operations and their logic, and set the column filters input to the new operands. // grid-custom-filtering.component.ts export class GridCustomFilteringComponent { public caseSensitiveFilteringOperand = CaseSensitiveFilteringOperand.instance(); public booleanFilteringOperand = BooleanFilteringOperand.instance(); } export class CaseSensitiveFilteringOperand extends IgxStringFilteringOperand { private constructor() { super(); const customOperations = [ { iconName: 'contains', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) !== -1; }, name: 'Contains (case sensitive)' }, { iconName: 'does_not_contain', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) === -1; }, name: 'Does Not Contain (case sensitive)' } ]; const emptyOperators = [ // 'Empty' this.operations[6], // 'Not Empty' this.operations[7] ]; this.operations = customOperations.concat(emptyOperators); } } export class BooleanFilteringOperand extends IgxBooleanFilteringOperand { private constructor() { super(); this.operations = [ // 'All' this.operations[0], // 'TRUE' this.operations[1], // 'FALSE' this.operations[2] ]; } } <!-- hierarchical-grid-custom-filtering.component.html --> <igx-hierarchical-grid [data]=\"localdata\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"Artist\" [filterable]='true' [filters]=\"caseSensitiveFilteringOperand\"></igx-column> <igx-column field=\"HasGrammyAward\" [filterable]='true' [dataType]=\"'boolean'\" [filters]=\"booleanFilteringOperand\"> <ng-template igxCell let-cell=\"cell\" let-val> <img *ngIf=\"val\" src=\"https://www.infragistics.com/angular-demos/assets/images/grid/active.png\" title=\"True\" alt=\"True\" /> <img *ngIf=\"!val\" src=\"https://www.infragistics.com/angular-demos/assets/images/grid/expired.png\" title=\"False\" alt=\"False\" /> </ng-template> </igx-column> </igx-hierarchical-grid> Re-templating filter cell You can add a template marked with igxFilterCellTemplate in order to retemplate the filter cell. In the sample below, an input is added for the string columns and IgxDatePicker for the date column. When the user types or selects a value, a filter with contains operator for string columns and equals operator for date columns, is applied using grid's public API. Styling To get started with styling the filtering row, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $filtering-row-text-color, $filtering-row-background, $filtering-header-text-color and the $filtering-header-background parameters. $custom-grid: grid-theme( $filtering-row-text-color: #292826, $filtering-row-background: #FFCD0F, $filtering-header-text-color: #292826, $filtering-header-background: #FFCD0F ); As seen, the grid-theme only controls colors for the filtering row and the respective column header that is being filtered. We obviously have a lot more components inside the filtering row, such as an input group, chips, buttons and others. In order to style them, we need to create a separate theme for each one, so let's create a new input group theme and a new button theme: $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $dark-button: button-theme( $flat-background: #FFCD0F, $flat-text-color: #292826, $flat-hover-background: #292826, $flat-hover-text-color: #FFCD0F ); In this example we only changed some of the parameters for the input group and the button, but the input-group-theme and the button-theme provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope the igx-button and the igx-input-group mixins within .igx-grid__filtering-row, so that only the filtering row buttons and its input group would be styled. Otherwise other buttons and input groups in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-text-color: color($dark-palette, \"primary\", 400), $filtering-row-background: color($dark-palette, \"secondary\", 400), $filtering-header-text-color: color($dark-palette, \"primary\", 400), $filtering-header-background: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $dark-button: button-theme( $flat-background: color($dark-palette, \"secondary\", 400), $flat-text-color: color($dark-palette, \"primary\", 400), $flat-hover-background: color($dark-palette, \"primary\", 400), $flat-hover-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group and light-button schemas: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( filtering-row-text-color:( color: (\"primary\", 400) ), filtering-row-background:( color: (\"secondary\", 400) ), filtering-header-text-color:( color: (\"primary\", 400) ), filtering-header-background:( color: (\"secondary\", 400) ) ) ); // Extending the light input group schema $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); // Extending the light button schema $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-input-group: $custom-input-group-schema, igx-button: $custom-button-schema )); // Defining grid-theme with the global light schema $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining button-theme with the global light schema $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining input-group-theme with the global light schema $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Limitations Note Some browsers such as Firefox fail to parse regional specific decimal separators by considering them grouping separators, thus resulting in them being invalid. When inputting such values for a numeric column filter value, only the valid part of the number will be applied to the filtering expression. For further information, refer to the Firefox issue. API References IgxColumnComponent IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/hierarchical-grid.html": {
    "href": "components/hierarchicalgrid/hierarchical-grid.html",
    "title": "Angular Hierarchical Data Grid | Material Table | Ignite UI for Angular | Infragistics",
    "keywords": "Angular Hierarchical Data Grid Component Overview The Ignite UI for Angular Hierarchical Data Grid is used to display and manipulate hierarchical tabular data. Quickly bind your data with very little code or use a variety of events to customize different behaviors. This component provides a rich set of features like data selection, excel style filtering, sorting, paging, templating, column moving, column pinning, export to Excel and CSV, and more. The Hierarchical Grid builds upon the Flat Grid Component and extends its functionality by allowing the users to expand or collapse the rows of the parent grid, revealing corresponding child grids, when more detailed information is needed. Angular Hierarchical Data Grid Example In this angular grid example you can see how users can visualize hierarchical sets of data and use cell templating to add other visual components like Sparkline. Getting Started with Ignite UI for Angular Hierarchical Data Grid Note This component requires HammerModule to be imported in the root module of the application in order for touch interactions to work as expected.. To get started with the Ignite UI for Angular Hierarchical Data Grid component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxHierarchicalGridModule in your app.module.ts file. // app.module.ts import { IgxHierarchicalGridModule } from 'igniteui-angular'; // import { IgxHierarchicalGridModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxHierarchicalGridModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxHierarchicalGridComponent as a standalone dependency, or use the IGX_HIERARCHICAL_GRID_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_HIERARCHICAL_GRID_DIRECTIVES } from 'igniteui-angular'; // import { IGX_HIERARCHICAL_GRID_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-hierarchical-grid #hierarchicalGrid [data]=\"singers\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"true\"> </igx-row-island> </igx-row-island> <igx-row-island [key]=\"'Tours'\" [autoGenerate]=\"true\"> </igx-row-island> </igx-hierarchical-grid> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_HIERARCHICAL_GRID_DIRECTIVES] /* or imports: [IgxHierarchicalGridComponent, IgxRowIslandComponent] */ }) export class HomeComponent { public singers: Artist []; } Now that you have the Ignite UI for Angular Hierarchical Grid module or directives imported, you can start using the igx-hierarchical-grid component. Using the Angular Hierarchical Data Grid Data Binding igx-hierarchical-grid derives from igx-grid and shares most of its functionality. The main difference is that it allows multiple levels of hierarchy to be defined. They are configured through a separate tag within the definition of igx-hierarchical-grid, called igx-row-island. The igx-row-island component defines the configuration for each child grid for the particular level. Multiple row islands per level are also supported. The Hierarchical Grid supports two ways of binding to data: Using hierarchical data If the application loads the whole hierarchical data as an array of objects referencing children arrays of objects, then the Hierarchical Grid can be configured to read it and bind to it automatically. Here is an example of a properly structured hierarchical data source: export const singers = [{ \"Artist\": \"Naomí Yepes\", \"Photo\": \"assets/images/hgrid/naomi.png\", \"Debut\": \"2011\", \"Grammy Nominations\": 6, \"Grammy Awards\": 0, \"Tours\": [{ \"Tour\": \"Faithful Tour\", \"Started on\": \"Sep-12\", \"Location\": \"Worldwide\", \"Headliner\": \"NO\", \"Toured by\": \"Naomí Yepes\" }], \"Albums\": [{ \"Album\": \"Dream Driven\", \"Launch Date\": new Date(\"August 25, 2014\"), \"Billboard Review\": \"81\", \"US Billboard 200\": \"1\", \"Artist\": \"Naomí Yepes\", \"Songs\": [{ \"No.\": \"1\", \"Title\": \"Intro\", \"Released\": \"*\", \"Genre\": \"*\", \"Album\": \"Dream Driven\" }] }] }]; Each igx-row-island should specify the key of the property that holds the children data. <igx-hierarchical-grid #hierarchicalGrid [data]=\"singers\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"true\"> </igx-row-island> </igx-row-island> <igx-row-island [key]=\"'Tours'\" [autoGenerate]=\"true\"> </igx-row-island> </igx-hierarchical-grid> Note Note that instead of data the user configures only the key that the igx-hierarchical-grid needs to read to set the data automatically. Using Load-On-Demand Most applications are designed to load as little data as possible initially, which results in faster load times. In such cases igx-hierarchical-grid may be configured to allow user-created services to feed it with data on demand. The following configuration uses a special @Output and a newly introduced loading-in-progress template to provide a fully-featured load-on-demand. <!-- hierarchicalGridSample.component.html --> <igx-hierarchical-grid #hGrid [primaryKey]=\"'CustomerID'\" [autoGenerate]=\"true\" [height]=\"'600px'\" [width]=\"'100%'\"> <igx-row-island [key]=\"'Orders'\" [primaryKey]=\"'OrderID'\" [autoGenerate]=\"true\" (gridCreated)=\"gridCreated($event, 'CustomerID')\"> <igx-row-island [key]=\"'Order_Details'\" [primaryKey]=\"'ProductID'\" [autoGenerate]=\"true\" (gridCreated)=\"gridCreated($event, 'OrderID')\"> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> // hierarchicalGridSample.component.ts @Component({...}) export class HierarchicalGridLoDSampleComponent implements AfterViewInit { @ViewChild(\"hGrid\") public hGrid: IgxHierarchicalGridComponent; constructor(private remoteService: RemoteLoDService) { } public ngAfterViewInit() { this.hGrid.isLoading = true; this.remoteService.getData({ parentID: null, rootLevel: true, key: \"Customers\" }).subscribe((data) => { this.hGrid.isLoading = false; this.hGrid.data = data; this.hGrid.cdr.detectChanges(); }); } public gridCreated(event: IGridCreatedEventArgs, _parentKey: string) { const dataState = { key: event.owner.key, parentID: event.parentID, parentKey: _parentKey, rootLevel: false }; event.grid.isLoading = true; this.remoteService.getData(dataState).subscribe( (data) => { event.grid.isLoading = false; event.grid.data = data; event.grid.cdr.detectChanges(); } ); } } // remote-load-on-demand.service.ts @Injectable() export class RemoteLoDService { public url = `https://services.odata.org/V4/Northwind/Northwind.svc/`; constructor(private http: HttpClient) { } public getData(dataState?: any): Observable<any[]> { return this.http.get(this.buildUrl(dataState)).pipe( map((response) => response[\"value\"]) ); } public buildUrl(dataState) { let qS = \"\"; if (dataState) { qS += `${dataState.key}?`; if (!dataState.rootLevel) { if (typeof dataState.parentID === \"string\") { qS += `$filter=${dataState.parentKey} eq '${dataState.parentID}'`; } else { qS += `$filter=${dataState.parentKey} eq ${dataState.parentID}`; } } } return `${this.url}${qS}`; } } Hide/Show row expand indicators If you have a way to provide information whether a row has children prior to its expanding, you could use the hasChildrenKey input property. This way you could provide a boolean property from the data objects which indicates whether an expansion indicator should be displayed. <igx-hierarchical-grid #grid [data]=\"data\" primaryKey=\"ID\" hasChildrenKey=\"hasChildren\"> ... </igx-hierarchical-grid> Note that setting the hasChildrenKey property is not required. In case you don't provide it, expansion indicators will be displayed for each row. Additionally if you wish to show/hide the header expand/collapse all indicator you can use the showExpandAll property. This UI is disabled by default for performance reasons and it is not recommended to enable it in grids with large data or grids with load on demand. Features The grid features could be enabled and configured through the igx-row-island markup - they get applied for every grid that is created for it. Changing options at runtime through the row island instance changes them for each of the grids it has spawned. <igx-hierarchical-grid [data]=\"localData\" [autoGenerate]=\"false\" [allowFiltering]='true' [height]=\"'600px'\" [width]=\"'800px'\" #hGrid> <igx-column field=\"ID\" [pinned]=\"true\" [filterable]='true'></igx-column> <igx-column-group header=\"Information\"> <igx-column field=\"ChildLevels\"></igx-column> <igx-column field=\"ProductName\" hasSummary='true'></igx-column> </igx-column-group> <igx-row-island [key]=\"'childData'\" [autoGenerate]=\"false\" [rowSelection]=\"'multiple'\" #layout1> <igx-column field=\"ID\" [hasSummary]='true' [dataType]=\"'number'\"></igx-column> <igx-column-group header=\"Information2\"> <igx-column field=\"ChildLevels\"></igx-column> <igx-column field=\"ProductName\"></igx-column> </igx-column-group> <igx-paginator *igxPaginator [perPage]=\"5\"></igx-paginator> </igx-row-island> <igx-paginator> </igx-paginator> </igx-hierarchical-grid> The following grid features work on a per grid level, which means that each grid instance manages them independently of the rest of the grids: Sorting Filtering Paging Multi Column Headers Hiding Pinning Moving Summaries Search The Selection and Navigation features work globally for the whole igx-hierarchical-grid Selection Selection does not allow selected cells to be present for two different child grids at once. Navigation When navigating up/down, if next/prev element is a child grid, navigation will continue in the related child grid, marking the related cell as selected and focused. If the child cell is outside the current visible view port it is scrolled into view so that selected cell is always visible. Collapse All Button The Hierarchical Grid allows the users to conveniently collapse all its currently expanded rows by pressing the \"Collapse All\" button at its top left corner. Additionally, every child grid which contains other grids and is a Hierarchical Grid itself, also has such a button - this way the user is able to collapse only a given grid in the hierarchy: Sizing See the Grid Sizing topic. CRUD operations Note An important difference from the flat Data Grid is that each instance for a given row island has the same transaction service instance and accumulates the same transaction log. In order to enable the CRUD functionality users should inject the IgxHierarchicalTransactionServiceFactory. Calling CRUD API methods should still be done through each separate grid instance. Check out the How-to Build CRUD operations with igxGrid topic. Styling The igxHierarchicalGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the igxHierarchicalGrid styling. Importing global theme To begin the customization of the hierarchical grid, you need to import the index file, where all styling functions and mixins are located. @import '~igniteui-angular/lib/core/styles/themes/index' Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the hierarchical grid as desired. Note There is no specific sass hierarchical grid function. $custom-theme: grid-theme( $cell-active-border-color: #ffcd0f, $cell-selected-background: #6f6f6f, $row-hover-background: #f8e495, $row-selected-background: #8d8d8d, $header-background: #494949, $header-text-color: #fff, $expand-icon-color: #ffcd0f, $expand-icon-hover-color: #e0b710, $resize-line-color: #ffcd0f, $row-highlight: #ffcd0f ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #494949; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $cell-active-border-color: (igx-color($custom-palette, \"secondary\", 500)), $cell-selected-background: (igx-color($custom-palette, \"primary\", 300)), $row-hover-background: (igx-color($custom-palette, \"secondary\", 100)), $row-selected-background: (igx-color($custom-palette, \"primary\", 100)), $header-background: (igx-color($custom-palette, \"primary\", 500)), $header-text-color: (igx-contrast-color($custom-palette, \"primary\", 500)), $expand-icon-color: (igx-color($custom-palette, \"secondary\", 500)), $expand-icon-hover-color: (igx-color($custom-palette, \"secondary\", 600)), $resize-line-color: (igx-color($custom-palette, \"secondary\", 500)), $row-highlight: (igx-color($custom-palette, \"secondary\", 500)) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we will use $_light_grid. $custom-grid-schema: extend($_light-grid,( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 100)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), expand-icon-color: (igx-color:('secondary', 500)), expand-icon-hover-color: (igx-color:('secondary', 600)), resize-line-color: (igx-color:('secondary', 500)), row-highlight: (igx-color:('secondary', 500)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme do affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. Performance (Experimental) The igxHierarchicalGrid's design allows it to take advantage of the Event Coalescing feature that has Angular introduced. This feature allows for improved performance with roughly around 20% in terms of interactions and responsiveness. This feature can be enabled on application level by simply setting the ngZoneEventCoalescing and ngZoneRunCoalescing properties to true in the bootstrapModule method: platformBrowserDynamic() .bootstrapModule(AppModule, { ngZoneEventCoalescing: true, ngZoneRunCoalescing: true }) .catch(err => console.error(err)); Note This is still in experimental feature for the igxHierarchicalGrid. This means that there might be some unexpected behaviors in the Hierarchical Grid. In case of encountering any such behavior, please contact us on our Github page. Note Enabling it can affects other parts of an Angular application that the igxHierarchicalGrid is not related to. Known Limitations Limitation Description Group By Group By feature is not supported by the hierarchical grid. Note igxHierarchicalGrid uses igxForOf directive internally hence all igxForOf limitations are valid for igxHierarchicalGrid. For more details see igxForOf Known Issues section. API References IgxHierarchicalGridComponent IgxRowIslandComponent IgxGridComponent IgxGridComponent Styles IgxColumnComponent IgxHierarchicalGridRow IgxGridCell Theming Dependencies IgxIcon Theme IgxInputGroup Theme IgxChip Theme IgxRipple Theme IgxButton Theme IgxOverlay Theme IgxDropDown Theme IgxCalendar Theme IgxActionStrip Theme IgxSnackBar Theme IgxBadge Theme Additional Resources Grid Sizing Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/keyboard-navigation.html": {
    "href": "components/hierarchicalgrid/keyboard-navigation.html",
    "title": "Angular Hierarchical Grid Keyboard Navigation - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Keyboard Navigation Keyboard navigation in the IgxHierarchicalGrid provides a rich variety of keyboard interactions for the user. It enhances the accessibility of the IgxHierarchicalGrid and allows to navigate through any type of elements inside (cell, row, column header, toolbar, footer, etc.). This functionality is enabled by default, and the developer has the option to override any of the default behaviors in an easy way. The tabulations of the IgxHierarchicalGrid has been reduced so that the navigation is compliant with W3C accesibility standards and convenient to use. Currently, the IgxHierarchicalGrid introduces the following tab stops: GroupBy or Toolbar area (if enabled); IgxHierarchicalGrid header; IgxHierarchicalGrid body; Column summaries (if enabled); IgxHierarchicalGrid paginator (if enabled); Note Due to this change, navigating between the cells with tab and Shift + Tab is no longer supported in the IgxHierarchicalGrid. Pressing the Tab key now goes through the tab stops in the following order: GroupBy / Toolbar -> Headers -> Body -> Summaries -> Footer / Paginator. Note Exposing any focusable element into the IgxHierarchicalGrid body via template may introduce side effects in the keyboard navigation, since the default browser behavior is not prevented. It is the developer's responsibility to prevent or modify it appropriately. Header Navigation A full keyboard navigation support in the IgxHierarchicalGrid header is now introduced. Column headers can be easily traversed with the arrow keys. Additionally, there are a number of key combinations that trigger actions on the columns like filtering, sorting, grouping and etc. When the IgxHierarchicalGrid header container is focused, the following key combinations are available: Key Combinations Arrow Up navigates one cell up in the headers (no looping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Down navigates one cell down in the headers (no wrapping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Left navigates one cell left (no looping) Arrow Right navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Home navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Ctrl + Arrow Right navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level End navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level Alt + L opens Advanced Filtering dialog if Advanced Filtering is enabled Ctrl + Shift + L opens the Excel Style Filter dialog or the default (row) filter if the column is filterable Ctrl + Arrow Up sorts the active column header in ASC order. If the column is already sorted in ASC, sorting state is cleared Ctrl + Arrow Down sorts the active column header in DSC order. If the column is already sorted in DSC, sorting state is cleared Space selects the column; If the column is already selected, selection is cleared Body navigation When the IgxHierarchicalGrid body is focused, the following key combinations are available: Key Combination Arrow Up- navigates one cell up , or one level up the grid hierarchy if necessary (no wrapping) Arrow Down navigates one cell down , or one level down the grid hierarchy if necessary(no wrapping) Arrow Left navigates one cell left (no wrapping between lines) Arrow Right - navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row Ctrl + Arrow Right navigates to the rightmost cell in the row Ctrl + Arrow Up navigates to the first cell in the column Ctrl + Arrow Down navigates to the last cell in the column Home navigates to the leftmost cell in the row End navigates to the rightmost cell in the row Ctrl + Home navigates to the top leftmost data cell in the grid Ctrl + End navigates to the bottom rightmost data cell in the grid Page Up scrolls one page (view port) up Page Down scrolls one page (view port) down Enter enters edit mode F2 enters edit mode Esc exits edit mode Tab available only if there is a cell in edit mode; moves the focus to the next editable cell in the row; after reaching the last cell in the row, moves te focus to the first editable cell in the next row. When Row Editing is enabled, moves the focus from the right-most editable cell to the CANCEL and DONE buttons, and from DONE button to the left-most editable cell in the row Shift + Tab - available only if there is a cell in edit mode; moves the focus to the previous editable cell in the row; after reaching the first cell in the row, moves the focus to the last editable cell in the previous row. When Row Editing is enabled, moves the focus from the right-most editable cell to CANCEL and DONE buttons, and from DONE button to the right-most editable cell in the row Space - selects the row, if Row Selection is enabled Alt + Arrow Left or Alt + Arrow Up - collapses the row island Alt + Arrow Right or Alt + Arrow Down - expands the row island Practice all of the above mentioned actions in the demo sample below. Focus any navigable grid element and a list with some of the available actions for the element will be shown to guide you through. Demo Custom keyboard navigation Overriding the default behavior for a certain key or keys combination is one of the benefits that the Keyboard Navigation feature provides. For example: press the Enter or Tab key to navigate to the next cell or the cell below. This or any other navigation scenario is easily achieved by the Keyboard Navigation API: API Description Arguments gridKeydown An event that is emitted when any of key press/combinations described above is performed. Can be canceled. For any other key press/combination, use the default onkeydown event. IGridKeydownEventArgs activeNodeChange An event that is emitted when the active node is changed. You can use it to determine the Active focus position (header, tbody etc.), column index, row index or nested level. IActiveNodeChangeEventArgs navigateTo Navigates to a position in the grid, based on provided rowindex and visibleColumnIndex. It can also execute a custom logic over the target element, through a callback function that accepts param of type { targetType: GridKeydownTargetType, target: Object } . Usage: grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); }); rowindex: number, visibleColumnIndex: number, callback: ({ targetType: GridKeydownTargetType, target: Object }) => {} getNextCell returns ICellPosition object, which defines the next cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getNextCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const nextEditableCell = grid.getNextCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean getPreviousCell returns ICellPosition object, which defines the previous cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getPreviousCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const prevEditableCell = grid.getPreviousCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean Note Both getNextCell and getPreviousCell are availabe for the current level and cannot access cells from upper or lower level. Let's try the API to demonstrate how to achieve common scenarios like user input validation and custom navigation. First we need to register an event handler for the gridKeydown event: <igx-hierarchical-grid #grid1 [data]=\"data\" (gridKeydown)=\"customKeydown($event, grid1)\"> <igx-row-island [key]=\"'Albums'\" (gridCreated)=\"childGridCreated($event)\"> </igx-row-island> </igx-hierarchical-grid> In order to add custom keyboard navigation to igxHierarchicalGrid child grids too, each child grid should subscribe to gridKeydown event. That's why in example above we have registered and event handler for for the gridCreated event: public childGridCreated(event: IGridCreatedEventArgs) { const grid = event.grid; event.grid.gridKeydown.subscribe((args) => { this.customKeydown(args, grid); }); } public customKeydown(args: IGridKeydownEventArgs) { const target: IgxGridCell = args.target as IgxGridCell; const evt: KeyboardEvent = args.event as KeyboardEvent; const type = args.targetType; if (type === 'dataCell' && target.inEditMode && evt.key.toLowerCase() === 'tab') { // 1. USER INPUT VALIDATON ON TAB } if (type === 'dataCell' && evt.key.toLowerCase() === 'enter') { // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS } } Based on the IGridKeydownEventArgs values we identified two cases, where to provide our own logic (see above). Now, using the methods from the API, let's perform the desired - if the user is pressing Tab key over a cell in edit mode, we will perform validation on the input. If the user is pressing Enter key over a cell, we will move focus to cell in the next row: // 1. USER INPUT VALIDATON ON TAB if (target.column.dataType === 'number' && target.editValue < 0) { // alert the user that the input is invalid return; } // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS const nexRowIndex = target.row.expanded ? target.rowIndex + 2 : target.rowIndex + 1; grid.navigateTo(nexRowIndex, target.visibleColumnIndex, (obj) => { obj.target.nativeElement.focus(); }); Note: Please refer to the sample code for full implementation details. Use the demo below to try out the custom scenarios that we just implemented: Double click or press F2 key on a cell in the Grammy Nominations column, change the value to -2 and press tab key. Prompt message will be shown. Select a cell and press Enter key a couple of times. Every key press will move the focus to a cell in the next row, under the same column. Demo Known Limitations Limitation Description Navigating inside а grid with scrollable parent container. If the grid is positioned inside a scrollable parent container and the user navigates to a grid cell that is out of view, parent container will not be scrolled. API References IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Grid Keyboard Navigation Tree Grid Keyboard Navigation Hierarchical Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/live-data.html": {
    "href": "components/hierarchicalgrid/live-data.html",
    "title": "Angular Hierarchical Grid Live Data Updates",
    "keywords": "Angular Hierarchical Grid Live Data Updates The Hierarchical Grid component is able to handle thousands of updates per second, while staying responsive for user interactions. Angular Live-data Update Example The sample below demonstrates the Hierarchical Grid performance when all records are updated multiple times per second. Use the UI controls to choose the number of records loaded and the frequency of updates. Feed the same data into the Line Chart to experience the powerful charting capabilities of Ignite UI for Angular. The Chart button will show Category Prices per Region data for the selected rows and the Chart column button will show the same for the current row. View page on GitHub"
  },
  "components/hierarchicalgrid/load-on-demand.html": {
    "href": "components/hierarchicalgrid/load-on-demand.html",
    "title": "Hierarchical Grid load on demand - Native Angular | Ignite UI for Angular",
    "keywords": "Hierarchical Grid Load On Demand The Ignite UI for Angular IgxHierarchicalGrid allows fast rendering by requesting the minimum amount of data to be retrieved from the server so that the user can see the result in view and interact with the visible data as quickly as possible. Initially only the root grid’s data is retrieved and rendered, only after the user expands a row containing a child grid, he will receive the data for that particular child grid. This mechanism, also known as Load on Demand, can be easily configured to work with any remote data. This topic demonstrates how to configure Load on Demand by creating a Remote Service Provider that communicates with an already available remote oData v4 Service. Here's the working demo and later we will go through it step by step and describe the process of creating it. Angular Hierarchical Grid Load On Demand Example Remote Service Provider First we will prepare our service provider so we will be ready to get the data we would need for the hierarchical grid. Getting basic data We will be communicating with our backend service over HTTP protocol using the XMLHttpRequest interface the browsers provide. In order to achieve this more easily we will use Angular's HttpClient module that offers a simplified client HTTP API. That way in order to get our data we will need this simple method in our service: public getData(dataState): Observable<any[]> { return this.http.get(this.buildUrl(dataState)).pipe( map(response => response['value']), ); } As you can see this.http will be a reference to our HttpCLient module, and buildUrl() will be the method that will generate our url based on the data that we have received. We map our response so we get only the value of our result and return an Observable, since this is executed asynchronously. That way we can later subscribe to it, process it further in our application and pass it to our grid. Building our request url Next we will define how we should build our URL for the GET request. This is where we will be able to get the data for our main grid but also for any child grid inside it. We will use the Customers data from here for our root level and use Order and Order_Details for the lower levels. The model will differ per application but we will use the following one: What we first need is the key of our table to determine from where to get the data for the desired grid, the primary key of the parent row and its unique ID. We will define all this in an interface called IDataState. An example: export interface IDataState { key: string; parentID: any; parentKey: string; rootLevel: boolean; } //... public buildUrl(dataState: IDataState): string { let qS = \"\"; if (dataState) { qS += `${dataState.key}?`; if (!dataState.rootLevel) { if (typeof dataState.parentID === \"string\") { qS += `$filter=${dataState.parentKey} eq '${dataState.parentID}'`; } else { qS += `$filter=${dataState.parentKey} eq ${dataState.parentID}`; } } } return `${this.url}${qS}`; } //... Result Finally, this is how our remote-lod.service.ts would look like: import { HttpClient } from '@angular/common/http'; import { Injectable } from '@angular/core'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; export interface IDataState { key: string; parentID: any; parentKey: string; rootLevel: boolean; } @Injectable() export class RemoteLoDService { url = `https://services.odata.org/V4/Northwind/Northwind.svc/`; constructor(private http: HttpClient) { } public getData(dataState: IDataState): Observable<any[]> { return this.http.get(this.buildUrl(dataState)).pipe( map((response) => response['value']) ); } public buildUrl(dataState: IDataState): string { let qS = \"\"; if (dataState) { qS += `${dataState.key}?`; if (!dataState.rootLevel) { if (typeof dataState.parentID === \"string\") { qS += `$filter=${dataState.parentKey} eq '${dataState.parentID}'`; } else { qS += `$filter=${dataState.parentKey} eq ${dataState.parentID}`; } } } return `${this.url}${qS}`; } } Hierarchical Grid Setup Next we will setup our hierarchical grid and connect it to our remote service provider. Template defining First we will define our hierarchical grid template with the levels of hierarchy that we expect to have. We know that our root grid primaryKey for the customers is their CustomerID, for their orders on the first level - OrderID and respectively for order details - ProductID. Knowing each database table and their keys allows us to define our initial template: <igx-hierarchical-grid #hGrid [primaryKey]=\"'CustomerID'\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'100%'\"> <igx-column field=\"CustomerID\" [hidden]=\"true\"></igx-column> <igx-column field=\"CompanyName\"></igx-column> <igx-column field=\"ContactName\"></igx-column> <igx-column field=\"ContactTitle\"></igx-column> <igx-column field=\"Country\"></igx-column> <igx-column field=\"Phone\"></igx-column> <igx-row-island [key]=\"'Orders'\" [primaryKey]=\"'OrderID'\" [autoGenerate]=\"false\" > <igx-column field=\"OrderID\" [hidden]=\"true\"></igx-column> <igx-column field=\"ShipCountry\"></igx-column> <igx-column field=\"ShipCity\"></igx-column> <igx-column field=\"ShipAddress\"></igx-column> <igx-column field=\"OrderDate\"></igx-column> <igx-row-island [key]=\"'Order_Details'\" [primaryKey]=\"'ProductID'\" [autoGenerate]=\"false\" > <igx-column field=\"ProductID\" [hidden]=\"true\"></igx-column> <igx-column field=\"Quantity\"></igx-column> <igx-column field=\"UnitPrice\"></igx-column> <igx-column field=\"Discount\"></igx-column> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> There is one thing missing in our template though, and that is the data for our root level hierarchical grid, and eventually its children. We will easily set the data of the root grid after getting its data from the service in our code later, since we can use the #hGrid reference. Setting the data for any child that has been expanded is a bit different. When a row is expanded for the first time, a new child IgxHierarchicalGrid is rendered for it and we need to get the reference for the newly created grid to set its data. That is why each IgxRowIsland component provides the gridCreated event that is fired when a new child grid is created for that specific row island. We can use that to get the reference we need for the new grid, request its data from the service, and apply it. We can use one method for all row islands since we built our service so that it needs only information if it is the root level, the key of the row island, the primary key of the parent row, and its unique identifier. All this information can be accessed either directly from the event arguments, or from the row island responsible for triggering the event. Let's name the method that we will use gridCreated. Since the event gridCreated provides the parentID property, a reference to the row island as owner and the new child grid property, it will be passed as the first argument. We are only missing information about the parent row's primaryKey, but we can easily pass that as a second argument, depending on which row island we bind. The template file hierarchical-grid-lod.component.html, with these changes added, would look like this: <igx-hierarchical-grid #hGrid [primaryKey]=\"'CustomerID'\" [autoGenerate]=\"false\" [height]=\"'600px'\" [width]=\"'100%'\"> <igx-column field=\"CustomerID\" [hidden]=\"true\"></igx-column> <igx-column field=\"CompanyName\"></igx-column> <igx-column field=\"ContactName\"></igx-column> <igx-column field=\"ContactTitle\"></igx-column> <igx-column field=\"Country\"></igx-column> <igx-column field=\"Phone\"></igx-column> <igx-row-island [key]=\"'Orders'\" [primaryKey]=\"'OrderID'\" [autoGenerate]=\"false\" (gridCreated)=\"gridCreated($event, 'CustomerID')\"> <igx-column field=\"OrderID\" [hidden]=\"true\"></igx-column> <igx-column field=\"ShipCountry\"></igx-column> <igx-column field=\"ShipCity\"></igx-column> <igx-column field=\"ShipAddress\"></igx-column> <igx-column field=\"OrderDate\"></igx-column> <igx-row-island [key]=\"'Order_Details'\" [primaryKey]=\"'ProductID'\" [autoGenerate]=\"false\" (gridCreated)=\"gridCreated($event, 'OrderID')\"> <igx-column field=\"ProductID\" [hidden]=\"true\"></igx-column> <igx-column field=\"Quantity\"></igx-column> <igx-column field=\"UnitPrice\"></igx-column> <igx-column field=\"Discount\"></igx-column> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> Connecting our service One of our final steps now will be to connect our previously created service to our hierarchical grid. Since we defined it as an Injectable, we can pass it as a provider to our application. We will get a reference to our root grid as well, by using ViewChild query to set its data: @Component({ providers: [RemoteLoDService], selector: \"app-hierarchical-grid-lod\", styleUrls: [\"./hierarchical-grid-lod.component.scss\"], templateUrl: \"./hierarchical-grid-lod.component.html\" }) export class HierarchicalGridLoDSampleComponent { @ViewChild(\"hGrid\") public hGrid: IgxHierarchicalGridComponent; constructor(private remoteService: RemoteLoDService) { } } In order to make sure that out grid is rendered before we request its data from the service and assign it, we will use the AfterViewInit lifecycle hook. As it doesn't have any parents we can only pass that rootLevel is true, and the key for it, to the getData of our service. Since it returns an observable we will need to subscribe to it: public ngAfterViewInit() { this.remoteService.getData({ parentID: null, rootLevel: true, key: \"Customers\" }).subscribe((data) => { this.hGrid.data = data; this.hGrid.cdr.detectChanges(); }); } Next, we only need to create our gridCreated method that will request data for any new child grid created. It will be similar to getting the root level grid data, just this time we will need to pass more information, like parentID and parentKey. rootLevel will be false for any child: public gridCreated(event: IGridCreatedEventArgs, _parentKey: string) { const dataState = { key: event.owner.key, parentID: event.parentID, parentKey: _parentKey, rootLevel: false }; this.remoteService.getData(dataState).subscribe( (data) => { event.grid.data = data; event.grid.cdr.detectChanges(); } ); } With this, the setup of our application is almost done. This last step aims to improve the user experience by informing the user that the data is still loading so he doesn't have to look at an empty grid in the meantime. That's why the IgxHierarchicalGrid supports a loading indicator that can be displayed while the grid is empty. If new data is received, the loading indicator will hide and the data will be rendered. Setup of loading indication The IgxHierarchicalGrid can display a loading indicator by setting the isLoading property to true while there is no data. We need to set it initially for the root grid and also when creating new child grids, until their data is loaded. We could always set it to true in our template, but we want to hide it and display that the grid has no data if the service returns an empty array by setting it to false. In this case the final version of our hierarchical-grid-lod.component.ts would look like this: import { AfterViewInit, Component, ViewChild } from \"@angular/core\"; import { IGridCreatedEventArgs, IgxHierarchicalGridComponent, IgxRowIslandComponent } from \"igniteui-angular\"; import { RemoteLoDService } from \"../services/remote-lod.service\"; @Component({ providers: [RemoteLoDService], selector: \"app-hierarchical-grid-lod\", styleUrls: [\"./hierarchical-grid-lod.component.scss\"], templateUrl: \"./hierarchical-grid-lod.component.html\" }) export class HierarchicalGridLoDSampleComponent implements AfterViewInit { @ViewChild(\"hGrid\") public hGrid: IgxHierarchicalGridComponent; constructor(private remoteService: RemoteLoDService) { } public ngAfterViewInit() { this.hGrid.isLoading = true; this.remoteService.getData({ parentID: null, rootLevel: true, key: \"Customers\" }).subscribe((data) => { this.hGrid.isLoading = false; this.hGrid.data = data; this.hGrid.cdr.detectChanges(); }); } public gridCreated(event: IGridCreatedEventArgs, _parentKey: string) { const dataState = { key: event.owner.key, parentID: event.parentID, parentKey: _parentKey, rootLevel: false }; event.grid.isLoading = true; this.remoteService.getData(dataState).subscribe( (data) => { event.grid.isLoading = false; event.grid.data = data; event.grid.cdr.detectChanges(); } ); } } API References IgxHierarchicalGridComponent IgxRowIslandComponent Additional Resources Hierarchical Grid Component Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/multi-column-headers.html": {
    "href": "components/hierarchicalgrid/multi-column-headers.html",
    "title": "Angular Multi-column Headers - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Multi-column Headers Overview IgxHierarchicalGrid supports multi-column headers which allows you to group columns by placing them under a common multi headers. Each multi-column headers group could be a representation of combinations between other groups or columns within the Material UI grid. Angular Hierarchical Grid Multi-column Headers Overview Example The declaration of Multi-column header could be achieved by wrapping a set of columns into igx-column-group component with header title passed. <igx-hierarchical-grid [data]=\"localdata\" [moving]=\"true\" [allowFiltering]=\"true\"> <igx-column field=\"CustomerID\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column-group header=\"Address Information\"> <igx-column-group header=\"Location\"> <igx-column field=\"Address\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"City\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"PostalCode\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"Country\" sortable=\"true\" resizable=\"true\"></igx-column> </igx-column-group> <igx-column-group header=\"Contact Information\"> <igx-column field=\"Phone\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"Fax\" sortable=\"true\" resizable=\"true\"></igx-column> </igx-column-group> </igx-column-group> </igx-hierarchical-grid> For achieving n-th level of nested headers, the declaration above should be followed. So by nesting igx-column-group leads to the desired result. <igx-hierarchical-grid [data]=\"localdata\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column field=\"CustomerID\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column-group pinned]=\"false\" header=\"General Information\"> <igx-column field=\"CompanyName\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column-group header=\"Person Details\"> <igx-column field=\"ContactName\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"ContactTitle\" sortable=\"true\" resizable=\"true\"></igx-column> </igx-column-group> </igx-column-group> </igx-hierarchical-grid> Every igx-column-group supports moving, pinning and hiding. Note When there is a set of columns and column groups, pinning works only for top level column parents. More specifically pinning per nested column groups or columns is not allowed. Please note that when using Pinning with Multi-Column Headers, the entire Group gets pinned. Moving between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. When columns/column-groups are not wrapped by current group which means they are top level columns, moving is allowed between whole visible columns. <igx-hierarchical-grid [data]=\"localdata\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column field=\"CustomerID\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column-group [pinned]=\"false\" header=\"General Information\"> <igx-column field=\"CompanyName\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column-group header=\"Person Details\"> <igx-column field=\"ContactName\" sortable=\"true\" resizable=\"true\"></igx-column> <igx-column field=\"ContactTitle\" sortable=\"true\" resizable=\"true\"></igx-column> </igx-column-group> </igx-column-group> ... </igx-hierarchical-grid> Multi-column Header Template Each of the column groups of the grid can be templated separately. The column group expects ng-template tag decorated with the igxHeader directive. The ng-template is provided with the column group object as a context. ... <igx-column-group header=\"General Information\"> <ng-template igxHeader let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... </igx-column-group> ... If you want to re-use a single template for several column groups, you could set the headerTemplate property of the column group like this: <ng-template #columnGroupHeaderTemplate let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... <igx-column-group header=\"General Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> <igx-column-group header=\"Address Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> ... Note If a column header is retemplated and the grid moving is enabled, you have to set the draggable attribute of corresponding column to false on the templated elements, so that you can handle any of the events that are applied! <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> The following sample demonstrates how to implement collapsible column groups using header templates. Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $header-background, $header-text-color, $header-border-width, $header-border-style and $header-border-color parameters. $custom-theme: grid-theme( $header-background: #e0f3ff, $header-text-color: #e41c77, $header-border-width: 1px, $header-border-style: solid, $header-border-color: rgba(0, 0, 0, 0.08) ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $light-blue-color: #e0f3ff; $deep-pink-color: #e41c77; $custom-palette: palette($primary: $light-blue-color, $deep-pink-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $header-background: color($custom-palette, \"primary\", 500), $header-text-color: color($custom-palette, \"secondary\", 500), $header-border-width: 1px, $header-border-style: solid, $header-border-color: color($custom-palette, \"grays\", 200) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( header-background: (igx-color:('primary', 500)), header-text-color: (igx-color:('secondary', 500)), header-border-width: 1px, header-border-style: solid, header-border-color: (igx-color:('grays', 200)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations Using Hierarchical Grid with multi-column headers on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API References IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles IgxColumnGroupComponent Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/multi-row-layout.html": {
    "href": "components/hierarchicalgrid/multi-row-layout.html",
    "title": "Angular Grid Multi-row Layout - Ignite UI for Angular",
    "keywords": "Angular Multi-row Layout Multi-row Layout extends the rendering capabilities of the igxGridComponent. The feature allows splitting a single data record into multiple visible rows. Angular Multi-row Layout Example The declaration of Multi-row Layout is achieved through igx-column-layout component. Each igx-column-layout component should be considered as a block, containing one or multiple igx-column components. Some of the grid features work on block level (those are listed in the \"Feature Integration\" section below). For example the virtualization will use the block to determine the virtual chunks, so for better performance split the columns into more igx-column-layout blocks if the layout allows it. There should be no columns outside of those blocks and no usage of IgxColumnGroupComponent when configuring a multi-row layout. Multi-row Layout is implemented on top of the grid layout specification and should conform to its requirements. IgxColumnComponent exposes four @Input properties to determine the location and span of each cell: colStart - column index from which the field is starting. This property is mandatory. rowStart - row index from which the field is starting. This property is mandatory. colEnd - column index where the current field should end. The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field. This property is optional. If not set defaults to colStart + 1. rowEnd - row index where the current field should end. The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field. This property is optional. If not set defaults to rowStart + 1. <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [rowEnd]=\"3\" field=\"ID\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"CompanyName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"2\" field=\"ContactName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"2\" [colEnd]=\"3\" field=\"ContactTitle\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"Country\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"3\" [colEnd]=\"5\" field=\"Region\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"5\" [colEnd]=\"7\" field=\"PostalCode\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"4\" field=\"City\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"4\" [colEnd]=\"7\" field=\"Address\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" field=\"Phone\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" field=\"Fax\"></igx-column> </igx-column-layout> The result of the above configuration can be seen on the screenshot below: Note rowStart and colStart properties must be set for each igx-column into igx-column-layout. The igxColumnLayout component is not verifying if the layout is correct and not throwing errors or warnings about that. The developers must make sure that the declaration of their layout is correct and complete, otherwise they may end up in broken layout with misalignments, overlaps and browser inconsistencies. Feature Integration Due to the completly different rendering approach of Multi-row Layout, some of the column features will work only on igx-column-layout component. Such features are Column Pinning and Column Hiding. Othes like - Sorting and Grouping will work in the same way - on igx-column component. Filtering - only Excel Style Filtering is supported. Setting filterMode explicitly to FilterMode.quickFilter has no effect. Paging - works on records, not visual rows. Group By - hideGroupedColumns option has no effect in Multi-row Layout. The grouped columns are always visible. The following features are currently not supported: Column Moving Multi-column Headers Export to Excel Summaries Keyboard Navigation IgxGridComponent with Multi-Row Layouts provides build-in keyboard navigation. Horizontal nagivation Arrow Left or Arrow Right - move to the adjacent cell on the left/right within the current row unaffected by the column layouts that are defined. If the current cell spans on more than one row, Arrow Left and Arrow Right should navigate to the first cell on the left and right with the same rowStart, unless you have navigated to some other adjacent cell before. The navigation stores the starting navigation cell and navigates to the cells with the same rowStart if possible. Ctrl + Arrow Left (HOME) or Ctrl + Arrow Right (END) - navigate to the start or end of the row and select the cell with accordance to the starting navigation cell. Vertical nagivation Arrow Up or Arrow Down - move to the cell above/below in relation to a starting position and is unaffected by the rows. If the current cell spans on more than one column the next active cell will be selected with accordance to the starting navigation cell. Ctrl + Arrow Up or Ctrl + Down - Navigate and apply focus on the same column on the first or on the last row. Ctrl + Home or Ctrl + End - Navigate to the first row and focus first cell or navigate to the last row and focus the last cell. Note Navigation through cells which span on multiple rows or columns is done with accordance to the starting navigation cell and will allow returning to the starting cell using the key for the opposite direction. The same approach is used when navigating through group rows. Note Selection and multi cell selection are working on layout, meaning that when a cell is active, its layout will be selected. Also all features of multiple selection like drag selection are applicable and will work per layout not per cell. Custom Keyboard Navigation The grid allows customizing the default navigation behavior when a certain key is pressed. Actions like going to the next cell or cell below could be handled easily with the powerful keyboard navigation API: gridKeydown is exposed. The event will emit IGridKeydownEventArgs. This event is available only through the keyboard key combinations mentioned above, for all other key actions you can use keydown event (keydown)=\"onKeydown($event)\" navigateTo - this method allows you to navigate to a position based on provided rowindex and visibleColumnIndex The demo below adds additional navigation down/up via the Enter and Shift + Enter keys, similar to the behavior observed in Excel. Demo Layout Configurator Sometimes when configuring a column layout it might be a challenge to calculate and set the proper colStart and colEnd or rowStart and rowEnd. Especially when there are a lot of columns in a single layout. That is why we have created a small configurator, so you can easily do that and have a similar preview of how it would look inside the igxGrid when applied. You can do the following interactions with it: Set number of rows for the whole configuration. All layouts must have the same amount of rows. Add/Remove column layouts by clicking the Add Layout chip or reordering them by dragging a layout chip left/right. Set specific settings for each layout as number of columns and how wide they will be. The setting refer to the currently selected layout. Resize column cells in the layout preview so they can span more columns/rows or clear them using the Delete button. Set columns in the preview by dragging a column chip in the place your will want it to be. Add/Remove new columns by using the Add Column chip. Get template output of the whole configuration ready to by placed inside an igxGrid or the JSON representation that can also be used and parsed in your template using NgForOf for example. By default we have set the same columns as our previous sample, but it can be cleared and configured to match your desired configuration. Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Multi-row Layout styling. Importing global theme To begin the customization of the Multi-row Layout feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the feature layout as desired. $custom-theme: grid-theme( $cell-active-border-color: #ffcd0f, $cell-selected-background: #6f6f6f, $row-hover-background: #fde069, $row-selected-background: #8d8d8d, $header-background: #494949, $header-text-color: #fff, $sorted-header-icon-color: #ffcd0f, $sortable-header-icon-hover-color: #e9bd0d ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #494949; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $cell-active-border-color: color($custom-palette, \"secondary\", 500), $cell-selected-background: color($custom-palette, \"primary\", 300), $row-hover-background: color($custom-palette, \"secondary\", 300), $row-selected-background: color($custom-palette, \"primary\", 100), $header-background: color($custom-palette, \"primary\", 500), $header-text-color:contrast-color($custom-palette, \"primary\", 500), $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"secondary\", 600) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 300)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('secondary', 600)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme do affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles IgxColumnLayoutComponent IgxColumnComponent Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Sorting Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/paging.html": {
    "href": "components/hierarchicalgrid/paging.html",
    "title": "Angular Grid Paging | Angular Pagination Table | Infragistics",
    "keywords": "Angular Hierarchical Grid Pagination Pagination is used to split a large set of data into a sequence of pages that have similar content. Angular table pagination improves user experience and data interaction. Hierarchical Grid pagination is configurable via a separate component projected in the grid tree by defining a igx-paginator tag, similar to adding of a column. As in any Angular Table, the pagination in the Hierarchical Grid supports template for custom pages. Angular Pagination Example The following example represents Hierarchical Grid pagination and exposes the options usage of items per page and how paging can be enabled. The user can also quickly navigate through the Hierarchical Grid pages via \"Go to last page\" and \"Go to first page\" buttons. Adding a igx-paginator component will control whether the feature is present, you can enable/disable it by using a simple *ngIf with a toggle property. The perPage input controls the visible records per page. Let’s update our Hierarchical Grid to enable paging: <igx-hierarchical-grid #hierarchicalGrid [data]=\"data\" [height]=\"'500px'\" [width]=\"'100%'\"> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-hierarchical-grid> Example: <igx-paginator #paginator [totalRecords]=\"20\"> <igx-paginator-content> <div id=\"numberPager\" style=\"justify-content: center;\"> <button [disabled]=\"paginator.isFirstPage\" (click)=\"paginator.previousPage()\" igxButton=\"flat\"> PREV </button> <span> Page {{paginator.page}} of {{paginator.totalPages}} </span> <button [disabled]=\"paginator.isLastPage\" (click)=\"paginator.nextPage()\" igxButton=\"flat\"> NEXT </button> </div> </igx-paginator-content> </igx-paginator> Usage The igx-paginator component is used along with the igx-hierarchical-grid component in the example below, but you can use it with any other component in case paging functionality is needed. <igx-hierarchical-grid> <igx-column *ngFor=\"let c of hColumns\" [field]=\"c.field\"> </igx-column> <igx-row-island [key]=\"'childData'\" [autoGenerate]=\"true\"> <igx-row-island [key]=\"'childData'\" [autoGenerate]=\"true\"> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-row-island [key]=\"'childData2'\" [autoGenerate]=\"true\"> <igx-paginator *igxPaginator></igx-paginator> </igx-row-island> <igx-paginator></igx-paginator> </igx-hierarchical-grid> Paginator Configuration within child grids Due to certain limitations in how the child grids of an IgxHierarchicalGrid are implemented and how DI scope works, when defining a paginator component inside the igx-row-island tags, always make sure to use the IgxPaginator directive on the paginator itself. This will make sure that the child grid have the correct paginator instance as a reference: <igx-hierarchical-grid> ... <igx-row-island> ... <igx-grid-toolbar *igxPaginator> ... </igx-grid-toolbar> </igx-row-island> ... </igx-hierarchical-grid> Paginator Component Demo Remote Paging Remote paging can be achieved by declaring a service, responsible for data fetching and a component, which will be responsible for the Grid construction and data subscription. For more detailed information, check the Hierarchical Grid Remote Data Operations topic. Pagination Styling in Angular To get started with styling the paginator, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the paginator-theme and accepts the $text-color, $background-color and the $border-color parameters. $dark-paginator: paginator-theme( $text-color: #F4D45C, $background-color: #575757, $border-color: #292826 ); As seen, the paginator-theme only controls colors for the paging container, but does not affect the buttons in the pager UI. To style those buttons, let's create a new button theme: $dark-button: button-theme( $icon-color: #FFCD0F, $icon-hover-color: #292826, $icon-hover-background: #FFCD0F, $icon-focus-color: #292826, $icon-focus-background: #FFCD0F, $disabled-color: #16130C ); In this example we only changed the icon color and background and the button disabled color, but the the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include grid-paginator($dark-grid-paginator); .igx-grid-paginator__pager { @include button($dark-button); } Note We scope the igx-button mixin within .igx-paginator__pager, so that only the paginator buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include paginator($dark-paginator); .igx-paginator__pager { @include button($dark-button); } } } Defining a Color Palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F9D342; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the pallette. $dark-paginator: paginator-theme( $palette: $dark-palette, $text-color: color($dark-palette, \"secondary\", 400), $background-color: color($dark-palette, \"primary\", 200), $border-color: color($dark-palette, \"primary\", 500) ); $dark-button: button-theme( $palette: $dark-palette, $icon-color: color($dark-palette, \"secondary\", 700), $icon-hover-color: color($dark-palette, \"primary\", 500), $icon-hover-background: color($dark-palette, \"secondary\", 500), $icon-focus-color: color($dark-palette, \"primary\", 500), $icon-focus-background: color($dark-palette, \"secondary\", 500), $disabled-color: color($dark-palette, \"primary\", 700) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-pagination and dark-button schemas: // Extending the dark paginator schema $dark-paginator-schema: extend($_dark-pagination, ( text-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ), border-color:( color:( \"primary\", 500) ) ) ); // Extending the dark button schema $dark-button-schema: extend($_dark-button, ( icon-color:( color:(\"secondary\", 700) ), icon-hover-color:( color:(\"primary\", 500) ), icon-hover-background:( color:(\"secondary\", 500) ), icon-focus-color:( color:(\"primary\", 500) ), icon-focus-background:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-paginator: $dark-paginator-schema, igx-button: $dark-button-schema )); // Definingpaginator-theme with the global dark schema $dark-paginator: paginator-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $dark-button: button-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles IgxGridPaginator Styles Additional Resources Hierarchical Grid overview Paginator Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/remote-data-operations.html": {
    "href": "components/hierarchicalgrid/remote-data-operations.html",
    "title": "Angular Hierarchical Grid Remote Data Operations - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Remote Data Operations The Ignite UI for Angular Hierarchical Grid supports remote data operations such as remote virtualization, remote sorting, remote filtering and others. This allows the developer to perform these tasks on a server, retrieve the data that is produced and display it in the Hierarchical Grid. By default, the Hierarchical Grid uses its own logic for performing data operations. You can perform these tasks remotely and feed the resulting data to the Hierarchical Grid by taking advantage of certain inputs and events, which are exposed by the Hierarchical Grid. Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. The Hierarchical Grid generates these values based on its data source by default. In case of remote filtering, the grid data does not contain all the data from the server. In order to provide the unique values manually and load them on demand, we can take advantage of the Hierarchical Grid's uniqueColumnValuesStrategy input. This input is actually a method that provides three arguments: column - The respective column instance. filteringExpressionsTree - The filtering expressions tree, which is reduced based on the respective column. done - Callback that should be called with the newly generated column values when they are retrieved from the server. The developer can manually generate the necessary unique column values based on the information, that is provided by the column and the filteringExpressionsTree arguments and then invoke the done callback. Note When the uniqueColumnValuesStrategy input is provided, the default unique values generating process in the excel style filtering will not be used. <igx-hierarchical-grid #hierarchicalGrid [primaryKey]=\"'Artist'\" [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"singersColumnValuesStrategy\"> ... <igx-row-island [primaryKey]=\"'Album'\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"albumsColumnValuesStrategy\"> ... </igx-row-island> </igx-hierarchical-grid> public singersColumnValuesStrategy = (column: ColumnType, columnExprTree: IFilteringExpressionsTree, done: (uniqueValues: any[]) => void) => { // Get specific column data for the singers. this.remoteValuesService.getColumnData( null, 'Singers', column, columnExprTree, uniqueValues => done(uniqueValues)); } public albumsColumnValuesStrategy = (column: ColumnType, columnExprTree: IFilteringExpressionsTree, done: (uniqueValues: any[]) => void) => { // Get specific column data for the albums of a specific singer. const parentRowId = (column.grid as any).foreignKey; this.remoteValuesService.getColumnData( parentRowId, 'Albums', column, columnExprTree, uniqueValues => done(uniqueValues)); } Unique Column Values Strategy Demo In order to provide a custom loading template for the excel style filtering, we can use the igxExcelStyleLoading directive: <igx-hierarchical-grid [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... <ng-template igxExcelStyleLoading> Loading ... </ng-template> </igx-hierarchical-grid> Remote Paging The paging feature can operate with remote data. In order to demonstrate this let's first declare our service that will be responsible for data fetching. We will need the count of all data items in order to calculate the page count. This logic will be added to our service. @Injectable() export class RemotePagingService { public remoteData: BehaviorSubject<any[]>; public dataLenght: BehaviorSubject<number> = new BehaviorSubject(0); public url = 'https://www.igniteui.com/api/products'; constructor(private http: HttpClient) { this.remoteData = new BehaviorSubject([]) as any; } public getData(index?: number, perPage?: number): any { let qS = ''; if (perPage) { qS = `?$skip=${index}&$top=${perPage}&$count=true`; } this.http .get(`${this.url + qS}`).pipe( map((data: any) => data) ).subscribe((data) => this.remoteData.next(data)); } public getDataLength(): any { return this.http.get(this.url).pipe( map((data: any) => data.length) ); } } After declaring the service, we need to create a component, which will be responsible for the Hierarchical Grid construction and data subscription. export class HGridRemotePagingSampleComponent implements OnInit, AfterViewInit, OnDestroy { public data: BehaviorSubject<any> = new BehaviorSubject([]); private _dataLengthSubscriber; constructor(private remoteService: RemotePagingService) {} public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngOnDestroy() { if (this._dataLengthSubscriber) { this._dataLengthSubscriber.unsubscribe(); } } } Now we can choose between setting-up our own custom paging template or using the default one that the igx-paginator provides. Let's first take a look what is necessary to set-up remote paging by using the default paging template. Remote paging with default template If you want to use the default paging template you need to set the Paginator's totalRecords property, only then the grid will be able to calculate the total page number based on total remote records. When performing a remote pagination the Paginator will pass to the Grid only the data for the current page, so the grid will not try to paginate the provided data source. That's why we should set Grid's pagingMode property to GridPagingMode.remote. Also it is necessary to either subscribe to pagingDone or perPageChange events in order to fetch the data from your remote service, it depends on the use case which event will be used. <igx-hierarchical-grid #hierarchicalGrid [primaryKey]=\"'CustomerID'\" [pagingMode]=\"mode\"> <igx-column field=\"CustomerID\"></igx-column> ... <igx-paginator [(page)]=\"page\" [(perPage)]=\"perPage\" [totalRecords]=\"totalCount\" (pagingDone)=\"paginate($event.current)\" (perPageChange)=\"getFirstPage()\"> </igx-paginator> </igx-hierarchical-grid> public totalCount = 0; public data: Observable<any[]>; public mode = GridPagingMode.remote; public isLoading = true; @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; private _dataLengthSubscriber; public set perPage(val: number) { this._perPage = val; this.paginate(0); } public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data: any) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngAfterViewInit() { const skip = this.page * this.perPage; this.remoteService.getData(skip, this.perPage); } public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } Remote Paging with custom igx-paginator-content When we define a custom paginator content we need to define the content in a way to get the data only for the requested page and to pass the correct skip and top parameters to the remote service according to the selected page and items perPage. We are going to use the <igx-paginator> in order to ease our example configuration, along with the IgxPageSizeSelectorComponent and IgxPageNavigationComponent that were introduced - igx-page-size will add the per page dropdown and label and igx-page-nav will add the navigation action buttons and labels. <igx-paginator #paginator [totalRecords]=\"totalCount\" [(perPage)]=\"perPage\" [(page)]=\"page\" [selectOptions]=\"selectOptions\" (pageChange)=\"paginate($event)\" (perPageChange)=\"perPageChange($event)\"> <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> </igx-paginator> @ViewChild('hierarchicalGrid', { static: true }) public hierarchicalGrid: IgxHierarchicalGridComponent; public ngOnInit(): void { this._dataLengthSubscriber = this.remoteService.getDataLength( { parentID: null, rootLevel: true, key: 'Customers' }).subscribe((length) => { this.totalCount = length; }); } public ngAfterViewInit() { this.hierarchicalGrid.isLoading = true; this._dataSubscriber = this.remoteService.getData({parentID: null, rootLevel: true, key: 'Customers' }, 0, this.perPage) .subscribe((data) => { this.hierarchicalGrid.isLoading = false; this.data.next(data); },(error) => { this.hierarchicalGrid.emptyGridMessage = error.message; this.hierarchicalGrid.isLoading = false; this.hierarchicalGrid.cdr.detectChanges(); } ); } Note In order the Remote Paging to be configured properly a GridPagingMode.Remote should be set: <igx-hierarchical-grid #hierarchicalGrid [data]=\"data | async\" [primaryKey]=\"'CustomerID'\" [height]=\"'550px'\" [width]=\"'100%'\" [pagingMode]=\"mode\"></igx-hierarchical-grid> ... public mode = GridPagingMode.Remote; The last step will be to declare the paginator content based on your requirements. <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> After all the changes above, the following result will be achieved. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. API References IgxPaginatorComponent API IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles Additional Resources Paging Hierarchical Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/row-actions.html": {
    "href": "components/hierarchicalgrid/row-actions.html",
    "title": "Row actions in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Row Actions in Angular Hierarchical Grid The hierarchical grid component in Ignite UI for Angular provides the ability to use ActionStrip and utilize CRUD for row/cell components and row pinning. The Action Strip component can host predefined UI controls for these operations. Usage The first step is to import the IgxActionStripModule in our app.module.ts file: // app.module.ts ... import { IgxActionStripModule } from 'igniteui-angular'; // import { IgxActionStripModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxActionStripModule], ... }) The predefined actions UI components are: IgxGridEditingActionsComponent - includes functionality and UI specifically designed for the grid editing. It allows you to quickly toggle edit mode for cells or rows, depending on the rowEditable option and row deletion of the grid. IgxGridPinningActionsComponent - includes functionality and UI specifically designed for the grid row pinning. It allows you to quickly pin rows and navigate between pinned rows and their disabled counterparts. They are added inside the <igx-action-strip> and this is all needed to have an Action Strip providing default interactions. <igx-hierarchical-grid [data]=\"data\" [rowEditable]=\"true\" [primaryKey]=\"'ID'\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-hierarchical-grid> Note When IgxActionStripComponent is a child component of the grid, hovering a row will automatically show the UI. Custom implementation These components expose templates giving flexibility for customization. For instance, if we would like to use the ActionStrip for a Gmail scenario with row actions such as delete, edit and etc. You can simply create button component with igx-icon, add click event to it and insert it into the igx-action-strip component. <igx-grid> <igx-action-strip #actionstrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <button title=\"Edit\" igxIconButton=\"flat\" igxRipple (click)='startEdit(actionstrip.context)'> <igx-icon>edit</igx-icon> </button> <button title=\"Delete\" igxIconButton=\"flat\" igxRipple *ngIf='!isDeleted(actionstrip.context)' (click)='actionstrip.context.delete()'> <igx-icon>delete</igx-icon> </button> </igx-action-strip> </igx-grid> Note The predefined actions inherit IgxGridActionsBaseDirective and when creating a custom grid action component, it should also inherit IgxGridActionsBaseDirective. API References For more detailed information regarding the Action Strip API, refer to the following links: IgxActionStripComponent API Additional components and/or directives that can be used within the Action Strip: IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent IgxDividerDirective View page on GitHub"
  },
  "components/hierarchicalgrid/row-adding.html": {
    "href": "components/hierarchicalgrid/row-adding.html",
    "title": "Adding Rows in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Adding Rows in Angular Hierarchical Grid The Hierarchical Grid provides a convenient way to perform data manipulations through inline row adding and a powerful API for Angular CRUD operations. Add an Action Strip component with editing actions enabled in the grid's template, hover a row and use the provided button or press ALT + + to spawn the row adding UI. Angular Hierarchical Grid Row Adding Example The following sample demonstrates how to enable native row adding in the Hierarchical Grid. Changing a cell value and then clicking or navigating to another cell on the same row doesn't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Row Adding Usage To get started import the IgxHierarchicalGridModule in the app.module.ts file: // app.module.ts ... import { IgxHierarchicalGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxHierarchicalGridModule], ... }) export class AppModule {} Then define a Hierarchical Grid with bound data source and rowEditable set to true and an Action Strip component with editing actions enabled. The addRow input controls the visibility of the button that spawns the row adding UI. <igx-hierarchical-grid igxPreventDocumentScroll [data]=\"localdata\" [autoGenerate]=\"false\" [primaryKey]=\"'Debut'\" [rowEditable]=\"true\"> <igx-column field=\"Artist\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"HasGrammyAward\" header=\"Has Grammy Award?\" [dataType]=\"'boolean'\"> </igx-column> <igx-column field=\"Debut\" dataType=\"number\"></igx-column> <igx-column field=\"GrammyNominations\" header=\"Grammy Nominations\" dataType=\"number\"></igx-column> <igx-column field=\"GrammyAwards\" header=\"Grammy Awards\" dataType=\"number\"></igx-column> <igx-action-strip #actionstrip1> <igx-grid-editing-actions [addRow]=\"true\"></igx-grid-editing-actions> </igx-action-strip> <igx-row-island [key]=\"'Albums'\" [autoGenerate]=\"false\" [primaryKey]=\"'USBillboard200'\" [rowEditable]=\"true\"> <igx-column field=\"Album\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"LaunchDate\" header=\"Launch Date\" [dataType]=\"'date'\"></igx-column> <igx-column field=\"BillboardReview\" header=\"Billboard Review\" dataType=\"number\"></igx-column> <igx-column field=\"USBillboard200\" header=\"US Billboard 200\" dataType=\"number\"></igx-column> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"false\" [primaryKey]=\"'Number'\" [rowEditable]=\"true\"> <igx-column field=\"Number\" header=\"No.\" dataType=\"number\"></igx-column> <igx-column field=\"Title\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"Released\" [dataType]=\"'date'\"></igx-column> <igx-column field=\"Genre\" [dataType]=\"'string'\"></igx-column> <igx-action-strip #actionstrip3> <igx-grid-editing-actions [addRow]=\"true\"></igx-grid-editing-actions> </igx-action-strip> </igx-row-island> <igx-action-strip #actionstrip2> <igx-grid-editing-actions [addRow]=\"true\"></igx-grid-editing-actions> </igx-action-strip> </igx-row-island> </igx-hierarchical-grid> Note Setting primary key is mandatory for row adding operations. Note Every column excluding the primary key one is editable in the row adding UI by default. If you want to disable editing for a specific column, then you have to set the editable column's input to false. Note The IgxGridEditingActions input controlling the visibility of the add row button may use the action strip context (which is of type RowType) to fine tune which records the button shows for. The internal IgxBaseTransactionService is automatically provided for Hierarchical Grid. It holds pending cell changes until the row state is submitted or cancelled. Start Row Adding Programmatically Hierarchical Grid allows to programmatically spawn the add row UI by using two different public methods. One that accepts a row ID for specifying the row under which the UI should spawn and another that works by index. You can use these methods to spawn the UI anywhere within the current data view. Changing the page or specifying a row that is e.g. filtered out is not supported. Using beginAddRowById requires you to specify the row to use as context for the operation by its rowID (PK). The method then functions as though the end-user clicked on the add row action strip button for the specified row, spawning the UI under it. You can also make the UI spawn as the very first row in the grid by passing null for the first parameter. this.grid.beginAddRowById('ALFKI'); // spawns the add row UI under the row with PK 'ALFKI' this.grid.beginAddRowById(null); // spawns the add row UI as the first record The beginAddRowByIndex method works similarly but requires you to specify the index at which the UI should spawn. Allowed values range between 0 and the size of the data view - 1. this.grid.beginAddRowByIndex(10); // spawns the add row UI at index 10 this.grid.beginAddRowByIndex(0); // spawns the add row UI as the first record Positioning The Default position row add UI is below the row that the end user clicked the add row button for. The Hierarchical Grid scrolls to fully display the add row UI automatically. The overlay for the add row UI maintains its position during scrolling. Behavior The add row UI has the same behavior as the row editing one as they are designed to provide a consistent editing experience to end users. Please, refer to the Hierarchical Grid Row Editing topic for more information. After a new row is added through the row adding UI, its position and/or visibility is determined by the sorting, filtering and grouping state of the Hierarchical Grid. In a Hierarchical Grid that does not have any of these states applied, it appears as the last record. A snackbar is briefly displayed containing a button the end user may use to scroll the Hierarchical Grid to its position if it is not in view. Keyboard Navigation ALT + + - Enters edit mode for adding a row ESC exits row adding mode without submitting any changes TAB move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any row adding operation will stop if the data view of the Hierarchical Grid gets modified. Any changes made by the end user are submitted. Operations that change the data view include but are not limited to sorting, grouping, filtering, paging, etc. Summaries are updated after the row add operation finishes. The same is valid for the other data view dependant features such as sorting, filtering, etc. When spawning the UI for Hierarchical Grids, any child layout currently expanded for a row that the end user clicks the add row button for is collapsed. Customizing Row Adding Overlay Customizing Text Customizing the text of the row adding overlay is possible using the igxRowAddTextDirective. <ng-template igxRowAddText> Adding Row </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Note Using igxRowEditActions directive will change edit actions for both editing and adding overlay buttons. Remote scenarios In most remote data scenarios the Primary Key assignment happens on the create server request. In this case the added records on the client will not have the final primary key value until saved on the server's data base. In that case the recommended way to handle this update in the Hierarchical Grid is as follows: If the Hierarchical Grid does not use transactions. Once the create request is successfully completed and returns the added record data, you can replace that record's id in the local data record instance. If the Hierarchical Grid uses transactions. Once the create request or batch update request is successfully completed and returns the added record instances (with their db generated ids), the related ADD transactions should be cleared from the transaction log using the clear API method. This is necessary because the local transaction will have a generated id field, which may differ than the one created in the data base, so they should be cleared. You can then add the record(s) passed in the response to the local data instance. This will ensure that the remotely generated ids are always reflected in the local data, and subsequent update/delete operations target the correct record ids. Styling The row adding UI comprises the buttons in the IgxActionStrip editing actions, the editing editors and overlay, as well as the snackbar which allows end users to scroll to the newly added row. To style these components you may refer to these comprehensive guides in their respective topics: Hierarchical Grid Row Editing IgxSnackbar IgxActionStrip API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit primaryKey IgxHierarchicalGridComponent IgxActionStripComponent IgxGridEditingActionsComponent Additional Resources Hierarchical Grid Overview Hierarchical Grid Editing Hierarchical Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/row-drag.html": {
    "href": "components/hierarchicalgrid/row-drag.html",
    "title": "Row Dragging in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Row Dragging in Angular Hierarchical Grid In Ignite UI for Angular Hierarchical Grid, RowDrag is initialized on the root igx-hierarchical-grid component and is configurable via the rowDraggable input. Enabling row dragging provides users with a row drag-handle with which they can initiate dragging of a row. Angular Hierarchical Grid Row Drag Example Configuration In order to enable row-dragging for your igx-hierarchical-grid, all you need to do is set the grid's rowDraggable to true. Once this is enabled, a row-drag handle will be displayed on each row. This handle can be used to initiate row dragging. <igx-hierarchical-grid [rowDraggable]=\"true\"> ... </igx-hierarchical-grid> Clicking on the drag-handle and moving the cursor while holding down the button will cause the grid's rowDragStart event to fire. Releasing the click at any time will cause rowDragEnd event to fire. Below, you can find a walkthrough on how to configure an igx-hierarchical-grid to support row dragging and how to properly handle the drop event. In this example, we'll handle dragging a row from a grid to a designated area and, when dropping it, removing it from the grid. Drop Areas Enabling row-dragging was pretty easy, but now we have to configure how we'll handle row-dropping. We can define where we want our rows to be dropped using the igxDrop directive. First we need to import the IgxDragDropModule in our app module: import { ..., IgxDragDropModule } from 'igniteui-angular'; // import { ..., IgxDragDropModule } from '@infragistics/igniteui-angular'; for licensed package ... @NgModule({ imports: [..., IgxDragDropModule] }) Then, in our template, we define a drop-area using the directive's selector: <div class=\"drop-area\" igxDrop (enter)=\"onEnterAllowed($event)\" (leave)=\"onLeaveAllowed($event)\" (dropped)=\"onDropAllowed($event)\"> <igx-icon>delete</igx-icon> <div>Drag a row here to delete it</div> </div> You may enable animation when a row is dropped on a non-droppable area using the animation parameter of the rowDragEnd event. If set to true, the dragged row will animate back to its' original position when dropped over a non-droppable area. You may enable animation like this: export class IgxHierarchicalGridRowDragComponent { public onRowDragEnd(args) { args.animation = true; } } Drop Area Event Handlers Once we've defined our drop-area in the template, we have to declare our handlers for the igxDrop's enter, leave and dropped events in our component's .ts file. First, let's take a look at our enter and leave handlers. In those methods, we just want to change the icon of the drag's ghost so we can indicate to the user that they are above an area that allows them to drop the row: export class IgxHierarchicalGridRowDragComponent { public onEnterAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.ALLOW); } public onLeaveAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.DEFAULT); } private changeGhostIcon(ghost, icon: string) { if (ghost) { const currentIcon = ghost.querySelector('.igx-grid__drag-indicator > igx-icon'); if (currentIcon) { currentIcon.innerText = icon; } } } } The changeGhostIcon private method just changes the icon inside of the drag ghost. The logic in the method finds the element that contains the icon (using the igx-grid__drag-indicator class that is applied to the drag-indicator container), changing the element's inner text to the passed one. The icons themselves are from the material font set and are defined in a separate enum: enum DragIcon { DEFAULT = 'drag_indicator', ALLOW = 'remove' } Next, we have to define what should happen when the user actually drops the row inside of the drop-area. export class IgxHierarchicalGridRowDragComponent { public onDropAllowed(args: IDropDroppedEventArgs) { const draggedRow: RowType = args.dragData; draggedRow.delete(); } } Once the row is dropped, we just call the row's delete() method Note When using row data from the event arguments (args.dragData.data) or any other row property, note that the entire row is passed in the arguments as a reference, which means that you must clone the data you need, if you want to distinguish it from the one in the source grid. Templating the drag ghost The drag ghost can be templated using the IgxRowDragGhost directive, applied to a <ng-template> inside of the igx-hierarchical-grid's body: <igx-hierarchical-grid> ... <ng-template igxRowDragGhost> <div> <igx-icon fontSet=\"material\">arrow_right_alt</igx-icon> </div> </ng-template> ... </igx-hierarchical-grid> The result of the configuration can be seem below in a igx-hierarchical-grid with row dragging and multiple selection enabled. The demo shows the count of the currently dragged rows: Example Demo The drag ghost can be templated on every grid level, making it possible to have multiple ghost templates or to only provide a template for a single row island. <igx-hierarchical-grid> ... <ng-template igxRowDragGhost> <div> <igx-icon fontSet=\"material\">arrow_right_alt</igx-icon> </div> </ng-template> <igx-row-island> ... <ng-template IgxRowDragGhost> <img src=\"smile.gif\" height=\"42\" width=\"42\"> </ng-template> </igx-row-island> ... </igx-hierarchical-grid> Templating the drag icon The drag handle icon can be templated using the grid's dragIndicatorIconTemplate. In the example we're building, let's change the icon from the default one (drag_indicator) to drag_handle. To do so, we can use the igxDragIndicatorIcon to pass a template inside of the igx-hierarchical-grid's body: <igx-hierarchical-grid> ... <ng-template igxDragIndicatorIcon> <igx-icon>drag_handle</igx-icon> </ng-template> ... </igx-hierarchical-grid> Once we've set the new icon template, we also need to adjust the DEFAULT icon in our DragIcon enum, so it's properly change by the changeIcon method: enum DragIcon { DEFAULT = \"drag_handle\", ... } Styling the drop area Once our drop handlers are properly configured, all that's left is to style our drop area a bit: .drop-area { width: 160px; height: 160px; background-color: #d3d3d3; border: 1px dashed #131313; display: flex; justify-content: center; align-items: center; flex-flow: column; text-align: center; margin: 8px; } :host { display: flex; justify-content: center; align-items: center; flex-flow: column; width: 100%; } The result can be seen in the demo below: Example Demo Application Demo Row Reordering Demo With the help of the grid's row drag events and the igxDrop directive, you can create a grid that allows you to reorder rows by dragging them. Since all of the actions will be happening inside of the grid's body, that's where you have to attach the igxDrop directive: <igx-hierarchical-grid #grid [data]=\"localData\" [primaryKey]=\"'id'\" [rowDraggable]=\"true\" (rowDragStart)=\"rowDragStart($event)\" igxDrop (dropped)=\"rowDrop($event)\"> ... </igx-hierarchical-grid> Note Make sure that there is a primaryKey specified for the grid! The logic needs an unique identifier for the rows so they can be properly reordered Once rowDraggable is enabled and a drop zone has been defined, you need to implement a simple handler for the drop event. When a row is dragged, check the following: Is the row expanded? If so, collapse it. Was the row dropped inside of the grid? If so, on which other row was the dragged row dropped? Once you've found the target row, swap the records' places in the data array Was the row initially selected? If so, mark it as selected. Below, you can see this implemented in the component's .ts file: export class HGridRowReorderComponent { public rowDragStart(args: any): void { const targetRow = args.dragData; if (targetRow.expanded) { targetRow.expanded = false; } } public rowDrop(args: IDropDroppedEventArgs): void { const targetRow = args.dragData; const event = args.originalEvent; const cursorPosition: Point = { x: event.clientX, y: event.clientY }; this.moveRow(targetRow, cursorPosition); } private moveRow(draggedRow: RowType, cursorPosition: Point): void { // const parent: IgxHierarchicalGridComponent = (draggedRow as any).grid; // const parent = args.drag.ghostContext.grid; const parent = this.hGrid; const rowIndex: number = this.getTargetRowIndex(parent.rowList.toArray(), cursorPosition); if (rowIndex === -1) { return; } const wasSelected = draggedRow.selected; draggedRow.delete(); parent.data.splice(rowIndex, 0, draggedRow.data); if (wasSelected) { parent.selectRows([parent.rowList.toArray() .find((r) => r.rowID === draggedRow.key).rowID], false); } } private getTargetRowIndex(rowListArr: RowType[], cursorPosition: Point): number { const targetElem: IgxHierarchicalRowComponent = this.catchCursorPosOnElem(rowListArr, cursorPosition); return rowListArr.indexOf(rowListArr.find((r) => r.rowData.id === targetElem.rowData.id)); } private catchCursorPosOnElem(rowListArr: any[], cursorPosition: Point) : IgxHierarchicalRowComponent { for (const row of rowListArr) { const rowRect = row.nativeElement.getBoundingClientRect(); if (cursorPosition.y > rowRect.top + window.scrollY && cursorPosition.y < rowRect.bottom + window.scrollY && cursorPosition.x > rowRect.left + window.scrollX && cursorPosition.x < rowRect.right + window.scrollX) { return row; } else if (row === rowListArr[rowListArr.length - 1] && cursorPosition.y > rowRect.bottom) { return row; } } } } With these few easy steps, you've configured a grid that allows reordering rows via drag/drop! You can see the above code in action in the following demo. Notice that we also have row selection enabled and we preserve the selection when dropping the dragged row. Limitations Currently, there are no known limitations for the rowDraggable directive. API References rowDraggable rowDragStart rowDragEnd IgxHierarchicalGridComponent Additional Resources Hierarchical Grid Overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/row-editing.html": {
    "href": "components/hierarchicalgrid/row-editing.html",
    "title": "Editing Rows in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Row Editing The Hierarchical Grid provides a convenient way to perform data manipulations through inline editing and a powerful API for Angular CRUD operations. Click on a row and press Enter key or simply double click with the mouse on the row that needs to be modified. Angular Hierarchical Grid Row Editing Example The following sample demonstrates how to enable row editing in the Hierarchical Grid. Changing a cell value and then clicking or navigating to another cell on the same row won't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Note When a row is in edit mode, then clicking on a cell on another row will act like the Done button is pressed - submit all the changes of the previous row. If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. Row Editing Usage To get started import the IgxHierarchicalGridModule in the app.module.ts file: // app.module.ts ... import { IgxHierarchicalGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxHierarchicalGridModule], ... }) export class AppModule {} Then define a Hierarchical Grid with bound data source and rowEditable set to true: <igx-hierarchical-grid [data]=\"localdata\" [autoGenerate]=\"false\" [rowEditable]=\"true\"> <igx-column field=\"Artist\" [editable]=\"true\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"HasGrammyAward\" [editable]=\"true\" [dataType]=\"'boolean'\"> </igx-column> <igx-column field=\"Debut\" [editable]=\"true\" [dataType]=\"'number'\"></igx-column> <igx-column field=\"GrammyNominations\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"GrammyAwards\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"true\"></igx-column> <igx-column width=\"10%\"> <ng-template igxCell let-cell=\"cell\"> <button igxIconButton=\"flat\" (click)=\"removeRow(cell.cellID.rowIndex)\"> <igx-icon>delete</igx-icon> </button> </ng-template> </igx-column> <igx-row-island [key]=\"'Albums'\" #layout1 [autoGenerate]=\"false\"> <igx-column field=\"Album\" [editable]=\"true\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"Launch Date\" [editable]=\"true\" [dataType]=\"'date'\"></igx-column> <igx-column field=\"Billboard Review\" [editable]=\"true\" [dataType]=\"'number'\"></igx-column> <igx-column field=\"US Billboard 200\" [editable]=\"true\" [dataType]=\"'number'\"></igx-column> <igx-row-island [key]=\"'Songs'\" [autoGenerate]=\"false\"> <igx-column field=\"No.\"></igx-column> <igx-column field=\"Title\"></igx-column> <igx-column field=\"Released\"></igx-column> <igx-column field=\"Genre\"></igx-column> </igx-row-island> </igx-row-island> </igx-hierarchical-grid> Note Setting primary key is mandatory for row editing operations. Note It's not needed to enable editing for individual columns. Using the rowEditable property in the Hierarchical Grid, will mean that all rows, with defined field property, excluding primary one, will be editable. If you want to disable editing for specific column, then you set the editable column's input to false. import { Component, OnInit, ViewChild } from '@angular/core'; import { IgxRowIslandComponent, IgxHierarchicalGridComponent } from 'igniteui-angular'; // import { IgxRowIslandComponent, IgxHierarchicalGridComponen } from '@infragistics/igniteui-angular'; for licensed package import { SINGERS } from './data'; @Component({ selector: 'hierarchical-grid-row-editing', styleUrls: ['./hierarchical-grid-row-editing.component.scss'], templateUrl: 'hierarchical-grid-row-editing.component.html' }) export class HGridRowEditingSampleComponent implements OnInit { public localdata; @ViewChild('layout1') layout1: IgxRowIslandComponent; @ViewChild('hierarchicalGrid') hierarchicalGrid: IgxHierarchicalGridComponent; constructor() { this.localdata = SINGERS; } } Note The Hierarchical Grid uses internally a provider IgxBaseTransactionService that holds pending cell changes, until row state submitted or cancelled. Positioning Default position of the overlay will be below the row that is in edit mode If there is no space below the row then overlay will appear above the row. Once shown - top or bottom, overlay will maintain this position during scrolling, until the overlay is closed. Behavior If row is in edit mode, then editing will continue, if a cell from the same row is clicked. Clicking \"Done\" button will finish row editing and will submit changes either to the data source, or to a transaction if available. In addition row will exit edit mode. Clicking \"Cancel\" button will revert all current changes in the row and row will exit edit mode. If row is in edit mode, then clicking a cell from another row will finish the current row edit and will submit new row changes (the same behavior clicking \"Done\" button). If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. If row is in edit mode and Hierarchical Grid is scrolled so that row goes outside the visible area, the latter will be still in edit mode. When Hierarchical Grid is scrolled, so that the row is visible again, the row will be still in edit mode. When clicked outside the Hierarchical Grid, the cell will also stay in edit mode. When perform sorting, filtering, searching and hiding operations, will revert all current changes in the row and row will exit edit mode. When perform paging, resizing, pinning and moving operations, will exit edit mode and will submit latest value. Each modified cell gets edited style until row edit is finished. This is the behavior, when Hierarchical Grid is not provided with transactions. When transactions are available - then cell edit style is applied until all the changes are committed. Keyboard Navigation Enter and F2 enters row edit mode Esc exits row edit mode and doesn't submit any of the cell changes, made while the row was in edit mode. Tab move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any data changing operation will terminate row editing operations and will submit current row changes. This will include operations like sorting, changing grouping and filtering criteria, paging, etc. Summaries will be updated after row edit is finished. Same is valid for the other features like sorting, filtering, etc. Customizing Row Editing Overlay Customizing Text Customizing the text of the row editing overlay is possible using the igxRowEditTextDirective. The rowChangesCount property is exposed and it holds the count of the changed cells. <ng-template igxRowEditText let-rowChangesCount> Changes: {{rowChangesCount}} </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Styling Using the Ignite UI for Angular Theme Library, we can greatly alter the Row Editing overlay. The Row Editing overlay is a composite element - its UI is comprised of a couple of other components: - igx-banner in order to render its contents - igx-buttons are rendered in the default template (for the Done and Cancel buttons). In the below example, we will make use of those two components' styling options, ([button styling](../button.md#Angular Button Styling) & banner-styling), to customize the experience of our IgxHierarchicalGrid's Row Editing. We will also style the current cell's editor and background to make it more distinct. You can learn more about cell styling here. Import theme The easiest way to style the Row Editing banner is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Once we've imported the themes file, we can create custom themes. Define the theme We can now define a custom banner theme that will affect our Row Editing background and make use of one of the predefined palettes namely $purple-palette : $my-light-gray: #e3e3e3; $my-banner-palette: $purple-palette; $banner-theme: banner-theme( $banner-background: $my-light-gray, $banner-message-color: color($my-banner-palette, \"secondary\", 600) ); Here we are using my-banner-palette in conjunction with igx-color (exposed by the theme library) for generating our colors. Include the theme All we have to do now is apply the theme with a Sass @include statement. We pass our newly defined $banner-theme through the igx-banner mixin: @include banner($banner-theme); This will apply our custom banner theme to the Row Editing overlay. However, since we defined these in the global styles file, these styles will also apply to all banners in our application. Component styles Since the Row Editing overlay makes use of a lot of other components' themes, styling it via the global styles can affect other parts of our application (e.g. banners, buttons, etc.). The best way to prevent that is to scope our banner theme. We can define our styles (including the theme/index import) in the component containing our igx-hierarchical-grid. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: // custom.component.scss :host { ::ng-deep { @include banner($banner-theme); } } With the above syntax, our custom banner theme properly applies to the grid's Row Editing overlay. Custom Templates To further customize our Row Editing overlay, we can pass a custom template so we can style the Done and Cancel buttons separately: <!-- in component.html --> <igx-hierarchical-grid> <ng-template igxRowEditActions let-endRowEdit> <div class=\"custom-buttons\"> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(false)\"> <igx-icon>clear</igx-icon> </button> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(true)\"> <igx-icon>check</igx-icon> </button> </div> </ng-template> </igx-hierarchical-grid> After we've defined our custom buttons, we can make use of the button-theme to style them. You can learn more about igx-button styling here. We can create a custom theme for our Done and Cancel: // custom.component.scss ... $button-theme: button-theme( $palette: $purple-palette ); ... .custom-buttons { @include button($button-theme); } We scope our @include statement in .custom-buttons so that it is only applied to the Doneand Cancel buttons. Demo After styling the banner and buttons, we also define a custom style for the cell in edit mode. The result of all the combined styles can be seen below: Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit field editable primaryKey IgxHierarchicalGridComponent Additional Resources Build CRUD operations with igxGrid Hierarchical Grid Overview Hierarchical Grid Editing Hierarchical Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/row-pinning.html": {
    "href": "components/hierarchicalgrid/row-pinning.html",
    "title": "Row Pinning in Angular Hierarchical Grid - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Row Pinning One or multiple rows can be pinned to the top or bottom of the Angular UI Grid. Row Pinning in Ignite UI for Angular allows end-users to pin rows in a particular order, duplicating them in a special area that is always visible even when they scroll the Hierarchical Grid vertically. The Material UI Grid has a built-in row pinning UI, which is enabled by initializing an igxActionStrip component in the context of Hierarchical Grid. In addition, you can define custom UI and change the pin state of the rows via the Row Pinning API. Angular Hierarchical Grid Row Pinning Example Row Pinning UI The built-in row pinning UI is enabled by adding an igxActionStrip component with the GridPinningActions component. The action strip is automatically shown when hovering a row and will display a pin or unpin button icon based on the state of the row it is shown for. An additional action allowing to scroll the copy of the pinned row into view is shown for each pinned row as well. <igx-hierarchical-grid [data]=\"data\" [autoGenerate]=\"false\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-hierarchical-grid> Row Pinning API Row pinning is controlled through the pinned input of the row. Pinned rows are rendered at the top of the Hierarchical Grid by default and stay fixed through vertical scrolling of the unpinned rows in the Hierarchical Grid body. this.hierarchicalGrid.getRowByIndex(0).pinned = true; You may also use the Hierarchical Grid's pinRow or unpinRow methods of the IgxHierarchicalGridComponent to pin or unpin records by their ID: this.hierarchicalGrid.pinRow('ALFKI'); this.hierarchicalGrid.unpinRow('ALFKI'); Note that the row ID is the primary key value, defined by the primaryKey of the grid, or the record instance itself. Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the row is already in the desired state. A row is pinned below the last pinned row. Changing the order of the pinned rows can be done by subscribing to the rowPinning event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"true\" (rowPinning)=\"rowPinning($event)\"> </igx-hierarchical-grid> public rowPinning(event) { event.insertAtIndex = 0; } Pinning Position You can change the row pinning position via the pinning configuration option. It allows you to set the pin area position to either Top or Bottom. When set to Bottom pinned rows are rendered at the bottom of the grid, after the unpinned rows. Unpinned rows can be scrolled vertically, while the pinned rows remain fixed at the bottom. <igx-hierarchical-grid [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-hierarchical-grid> public pinningConfig: IPinningConfig = { rows: RowPinningPosition.Bottom }; Custom Row Pinning UI You can define your custom UI and change the pin state of the rows via the related API. Via extra column with icon Let's say that instead of an action strip you would like to show a pin icon in every row allowing the end-user to click and change a particular row's pin state. This can be done by adding an extra column with a cell template containing the custom icon. <igx-hierarchical-grid [data]=\"localdata\" [autoGenerate]=\"false\"> <igx-column width='70px' [filterable]='false'> <ng-template igxCell let-cell=\"cell\" let-val> <igx-icon class=\"pin-icon\" (mousedown)=\"togglePinning(cell.row, $event)\"> {{cell.row.pinned ? 'lock' : 'lock_open'}} </igx-icon> </ng-template> </igx-column> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> <igx-row-island [key]=\"'Orders'\" [autoGenerate]=\"true\"> </igx-row-island> </igx-hierarchical-grid> On click of the custom icon the pin state of the related row can be changed using the row's API methods. public togglePinning(row: IgxGridRow, event) { event.preventDefault(); if (row.pinned) { row.unpin(); } else { row.pin(); } } Demo Row Pinning Limitations Only records that exist in the data source can be pinned. The row pinning state is not exported to excel. The grid is exported as if no row pinning is applied. Because of how pinned rows are stored internally so that they may appear both in the pinned and unpinned areas of the grid, row pinning is not supported when records in the grid are fetched from a remote endpoint on demand (remote virtualization). The copies of pinned rows in the scrollable area of the grid are an integral part of how other grid features achieve their functionality in the presence of pinned rows and therefore their creation cannot be disabled nor can they be removed. As Row Selection works entirely with row Ids, selecting pinned rows selects their copies as well (and vise versa). Additionally, range selection (e.g. using Shift + click) within the pinned area works the same way as selecting a range of rows within the scrollable area. The resulting selection includes all rows in between even if they are not currently pinned. Getting the selected rows through the API only returns a single instance of each selected record. When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning Styling The IgxHierarchicalGrid allows styling through the Ignite UI for Angular Theme Library. The Hierarchical Grid's theme exposes a wide variety of properties, which allow the customization of all the features of the Hierarchical Grid. Below, we are going through the steps of customizing the Hierarchical Grid's row pinning styling. Importing the Styling Library To begin the customization of the row pinning feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining a Theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the row pinning feature as desired. $custom-grid-theme: grid-theme( /* Pinning properties that affect styling */ $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: #FFCD0F, $cell-active-border-color: #FFCD0F /* add other features properties here... */ ); Using CSS variables The last step is to pass the custom grid theme: @include css-vars($custom-grid-theme); Using mixins In order to style components for Internet Explorer 11, you have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. However, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom grid theme to the `igx-grid` mixin @include grid($custom-grid-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxHierarchicalGridComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow RowType IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/row-selection.html": {
    "href": "components/hierarchicalgrid/row-selection.html",
    "title": "Angular Grid Select Row - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Row Selection With row selection in Ignite UI for Angular, there is row selector column that precedes all other columns within the row. When a user clicks on the row selector, the row will either become selected or deselected, enabling the user to select multiple rows of data. Angular Row Selection Example The sample below demonstrates the three types of Hierarchical Grid's row selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Use the switch button to hide or show the row selector checkbox. Setup In order to setup row selection in the igx-hierarchical-grid, you just need to set the rowSelection property. This property accepts GridSelectionMode enumeration. GridSelectionMode exposes the following three modes: none, single and multiple. Below we will take a look at each of them in more detail. None Selection In the igx-hierarchical-grid by default row selection is disabled, otherwise ([rowSelection]=\"'none'\"). So you can not select or deselect a row through interaction with the Hierarchical Grid UI, the only way to complete these actions is to use the provided API methods. Single Selection Single row selection can now be easily set up, the only thing you need to do, is to set [rowSelection] = '\"single\"' property. This gives you the opportunity to select only one row within a grid. You can select a row by clicking on a cell or pressing the space key when you focus on a cell of the row, and of course you can select a row by clicking on the row selector field. When row is selected or deselected rowSelectionChanging event is emitted. <igx-hierarchical-grid [data]=\"localdata\" [autoGenerate]=\"true\" [rowSelection]=\"'single'\" (rowSelectionChanging)=\"handleRowSelection($event)\"> </igx-hierarchical-grid> /* selectionExample.component.ts */ public handleRowSelection(event) { if (args.added.lenght && args.added[0] === 3) { args.cancel = true; } } Multiple Selection To enable multiple row selection in the igx-hierarchical-grid just set the rowSelection property to multiple. This will enable a row selector field on each row and in the Hierarchical Grid header. The row selector allows users to select multiple rows, with the selection persisting through scrolling, paging, and data operations, such as sorting and filtering. The row also can be selected by clicking on a cell or by pressing the space key when a cell is focused. If you have selected one row and click on another while holding the shift key, this will select the whole range of rows. In this selection mode, when you click on a single row, the previous selected rows will be deselected. If you click while holding the ctrl key, the row will be toggled and the previous selection will be preserved. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"true\" [rowSelection]=\"'multiple'\" (rowSelectionChanging)=\"handleRowSelection($event)\"> </igx-hierarchical-grid> <!-- selectionExample.component.ts --> public handleRowSelection(event: IRowSelectionEventArgs) { // use event.newSelection to retrieve primary key/row data of latest selected row this.selectedRowsCount = event.newSelection.length; this.selectedRowIndex = event.newSelection[0]; } Notes In order to have proper row selection and cell selection, while Hierarchical Grid has remote virtualization, a primaryKey should be provided. When the Hierarchical Grid has remote virtualization, then clicking the header checkbox will select/deselect all records that are currently in the grid. When new data is loaded in the Hierarchical Grid on demand, newly added rows will not be selected and it is a limitation, so you should handle that behavior by yourself and you can select these rows by using the provided API methods. Row selection will trigger rowSelectionChanging event. This event gives you information about the new selection, old selection, the rows that have been added and removed from the old selection. Also the event is cancellable, so this allows you to prevent selection. When row selection is enabled row selectors are displayed, but if you don't want to show them, you can set [hideRowSelectors] = true. When you switch between row selection modes at runtime, this will clear the previous row selection state. API usage Select rows programmatically The code snippet below can be used to select one or multiple rows simultaneously (via primaryKey); Additionally, the second parameter of this method is a boolean property through which you may choose whether the previous row selection will be cleared or not. The previous selection is preserved by default. <!-- selectionExample.component.html --> <igx-hierarchical-grid ... [primaryKey]=\"'artist'\"> ... </igx-hierarchical-grid> ... <button (click)=\"this.hierarchicalGrid.selectRows([1,2,5], false)\">Select 1,2 and 5</button> // select rows and preserve previous selection state This will add the rows which correspond to the data entries with IDs 1, 2 and 5 to the Hierarchical Grid selection. Deselect rows If you need to deselect rows programmatically, you can use the deselectRows(rowIds: []) method. <!-- selectionExample.component.html --> <igx-hierarchical-grid ... [primaryKey]=\"'ID'\"> ... </igx-hierarchical-grid> ... <button (click)=\"this.hierarchicalGrid.deselectRows([1,2,5])\">Deselect 1,2 and 5</button> Row selection event When there is some change in the row selection rowSelectionChanging event is emitted. rowSelectionChanging exposes the following arguments: oldSelection - array of row's data that contains the previous state of the row selection. newSelection - array of row's data that match the new state of the row selection. added - array of row's data that are currently added to the selection. removed - array of row's data that are currently removed according old selection state. event - the original event that triggered row selection change. cancel - allows you the prevent the row selection change. owner - if the event is triggered from a child grid, this will give you a reference to the component, from which the event is emitted. Row selection event in remote data scenarios In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. <!-- selectionExample.component.html --> <igx-hierarchical-grid (rowSelectionChanging)=\"handleRowSelectionChange($event)\"> ... </igx-hierarchical-grid> /* selectionExample.component.ts */ public handleRowSelectionChange(args) { args.cancel = true; // this will cancel the row selection } Select all rows Another useful API method that igx-hierarchical-grid provides is selectAll(onlyFilteredData). By default this method will select all data rows, but if filtering is applied, it will select only the rows that match the filter criteria. But if you call the method with false parameter, selectAll(false) will always select all data in the grid, even if filtering is applied. Note Keep in mind that selectAll() will not select the rows that are deleted. Deselect all rows igx-hierarchical-grid provides deselectAll(onlyFilteredData) method, which by default will deselect all data rows, but if filtering is applied will deselect only the rows that match the filter criteria. But if you call the method with false parameter, deselectAll(false) will always clear all row selection state even if filtering is applied. How to get selected rows If you need to see which rows are currently selected, you can get their row IDs with the selectedRows getter. public getSelectedRows() { const currentSelection = this.hierarchicalGrid.selectedRows; // return array of row IDs } Additionally, assigning row IDs to selectedRows will allow you to change the grid's selection state. // arrays of row IDs public mySelectedRows = ['Naomi Yepes', 'Ahmad Nazeri']; public childSelectedRows = ['Initiation', 'Emergency']; <igx-hierarchical-grid primaryKey=\"Artist\" rowSelection=\"multiple\" [autoGenerate]=\"false\" [selectedRows]=\"mySelectedRows\" [data]=\"data\"> <igx-column field=\"Artist\"></igx-column> <igx-row-island [key]=\"'Albums'\" rowSelection=\"multiple\"> <igx-column field=\"Album\"></igx-column> <igx-column field=\"LaunchDate\"></igx-column> </igx-row-island> </igx-hierarchical-grid> Row selector templates You can template header and row selectors in the Hierarchical Grid and also access their contexts which provide useful functionality for different scenarios. By default, the Hierarchical Grid handles all row selection interactions on the row selector's parent container or on the row itself, leaving just the state visualization for the template. Overriding the base functionality should generally be done using the rowSelectionChanging event. In case you implement a custom template with a click handler which overrides the base functionality, you should stop the event's propagation to preserve the correct row state. Row template To create a custom row selector template, within the igx-hierarchical-grid, declare an <ng-template> with igxRowSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the row's state. The selected property shows whether the current row is selected or not while the index property can be used to access the row index. <ng-template igxRowSelector let-rowContext> {{ rowContext.index }} <igx-checkbox [checked]=\"rowContext.selected\" [readonly]=\"true\" ></igx-checkbox> </ng-template> The rowID property can be used to get a reference of an igx-hierarchical-grid row. This is useful when you implement a click handler on the row selector element. <ng-template igxRowSelector let-rowContext> <igx-checkbox (click)=\"onSelectorClick($event, rowContext.key)\"></igx-checkbox> </ng-template> In the above example we are using an igx-checkbox and we bind rowContext.selected to its checked property. See this in action in our Row Numbering Demo. Note The rowContext.select() and rowContext.deselect() methods are exposed in the template context of an igx-hierarchical-grid. They make it easier to toggle the current row, especially in a child grid, when you implement a click handler that overrides the base functionality. Header template To create a custom header selector template, within the Hierarchical Grid, declare an <ng-template> with igxHeadSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the header's state. The selectedCount property shows you how many rows are currently selected while totalCount shows you how many rows there are in the Hierarchical Grid in total. <ng-template igxHeadSelector let-headContext> {{ headContext.selectedCount }} / {{ headContext.totalCount }} </ng-template> The selectedCount and totalCount properties can be used to determine if the head selector should be checked or indeterminate (partially selected). <igx-hierarchical-grid [data]=\"hGridData\" primaryKey=\"ProductID\"> <ng-template igxHeadSelector let-headContext> <igx-checkbox [checked]=\"headContext.selectedCount > 0 && headContext.selectedCount === headContext.totalCount\" [indeterminate]=\"headContext.selectedCount > 0 && headContext.selectedCount !== headContext.totalCount\"> </igx-checkbox> </ng-template> <igx-row-island [key]=\"'ProductInfo'\"> <ng-template igxHeadSelector let-childHeadContext> <!-- header template goes here --> </ng-template> <ng-template igxRowSelector let-childRowContext> <!-- row template goes here --> </ng-template> </igx-row-island> </igx-hierarchical-grid> Each hierarchy level in an igx-hierarchical-grid can have its own row and header templating. Note The headContext.selectAll() and headContext.deselectAll() methods are exposed in the template context of an igx-hierarchical-grid. They make it easier to toggle all rows, especially in a child grid, when you implement a click handler that overrides the base functionality. Row Numbering Demo This demo shows the usage of custom header and row selectors. The latter uses rowContext.index to display row numbers and an igx-checkbox bound to rowContext.selected. Conditional Selection Demo This demo prevents some rows from being selected using the rowSelectionChanging event and a custom template with disabled checkbox for non-selectable rows. API References IgxHierarchicalGridComponent API IgxGridRow API IgxGridCell API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/search.html": {
    "href": "components/hierarchicalgrid/search.html",
    "title": "Angular Hierarchical Grid Search Filter - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Search Filter Angular Hierarchical Grid search enables the process of finding values in the collection of data. We make it easier to setup this functionality and it can be implemented with search input box, buttons, keyboard navigation and other useful features for an even better user experience. While browsers natively provide content search functionality, most of the time the Hierarchical Grid virtualizes its columns and rows that are out of view. In these cases, the native grid search is unable to search data in the virtualized cells, since they are not part of the DOM. We have extended the Ignite UI for Angular table-based grid with a search API that allows you to search through the virtualized content of the Hierarchical Grid. Angular Search Example The following example represents Hierarchical Grid with search input box that allows searching in all columns and rows, as well as specific filtering options for each column. Angular Search Usage Grid setup Let's start by creating our grid and binding it to our data. We will also add some custom styles for the components we will be using! Great, and now let's prepare for the search API of our Hierarchical Grid! We can create a few properties, which can be used for storing the currently searched text and whether the search is case sensitive and/or by an exact match. // searchgrid.component.ts public searchText: string = ''; public caseSensitive: boolean = false; public exactMatch: boolean = false; Angular search box input Now let's create our search input! By binding our searchText as ngModel to our newly created input and subscribe to the ngModelChange event, we can detect every single searchText modification by the user. This will allow us to use the Hierarchical Grid's findNext and findPrev methods to highlight all the occurrences of the searchText and scroll to the next/previous one (depending on which method we have invoked). Both the findNext and the findPrev methods have three arguments: text: string (the text we are searching for) (optional) caseSensitive: boolean (should the search be case sensitive or not, default value is false) (optional) exactMatch: boolean (should the search be by an exact match or not, default value is false) When searching by an exact match, the search API will highlight as results only the cell values that match entirely the searchText by taking the case sensitivity into account as well. For example the strings 'software' and 'Software' are an exact match with a disregard for the case sensitivity. The methods from above return a number value (the number of times the Hierarchical Grid contains the given string). <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"hierarchicalGrid.findNext(searchText, caseSensitive, exactMatch)\" /> Display results count Let's also display the position of the current occurrence, along with the total results count! We can do this by using the grid's lastSearchInfo property. This property is automatically updated when using the find methods. The hierarchicalGrid.lastSearchInfo.matchInfoCache.length value will give us the total results count. The hierarchicalGrid.lastSearchInfo.activeMatchIndex value will give us the index position of the current occurrence (match). <!--searchgrid.component.html--> <div class=\"resultsText\" *ngIf=\"hierarchicalGrid.lastSearchInfo\"> <span *ngIf=\"hierarchicalGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ hierarchicalGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ hierarchicalGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"hierarchicalGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> Add search buttons In order to freely search and navigate among our search results, let's create a couple of buttons by invoking the findNext and the findPrev methods inside the buttons' respective click event handlers. <!--searchgrid.component.html--> <div class=\"searchButtons\"> <input type=\"button\" value=\"Previous\" (click)=\"hierarchicalGrid.findPrev(searchText, caseSensitive, exactMatch)\" /> <input type=\"button\" value=\"Next\" (click)=\"hierarchicalGrid.findNext(searchText, caseSensitive, exactMatch)\" /> </div> Add keyboard search We can also allow the users to navigate the results by using the keyboard's arrow keys and the Enter key. In order to achieve this, we can handle the keydown event of our search input by preventing the default caret movement of the input with the preventDefault() method and invoke the findNext/findPrev methods depending on which key the user has pressed. <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"hierarchicalGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> // searchgrid.component.ts public searchKeyDown(ev) { if (ev.key === 'Enter' || ev.key === 'ArrowDown' || ev.key === 'ArrowRight') { ev.preventDefault(); this.hierarchicalGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } else if (ev.key === 'ArrowUp' || ev.key === 'ArrowLeft') { ev.preventDefault(); this.hierarchicalGrid.findPrev(this.searchText, this.caseSensitive, this.exactMatch); } } Case sensitive and Exact match Now let's allow the user to choose whether the search should be case sensitive and/or by an exact match. For this purpose we can use simple checkbox inputs by binding our caseSensitive and exactMatch properties to the inputs' checked properties respectively and handle their change events by toggling our properties and invoking the findNext method. <!--searchgrid.component.html--> <span>Case sensitive</span> <input type=\"checkbox\" [checked]=\"caseSensitive\" (change)=\"updateSearch()\"> <span>Exact match</span> <input type=\"checkbox\" [checked]=\"exactMatch\" (change)=\"updateExactSearch()\"> // searchgrid.component.ts public updateSearch() { this.caseSensitive = !this.caseSensitive; this.hierarchicalGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } public updateExactSearch() { this.exactMatch = !this.exactMatch; this.hierarchicalGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } Persistence What if we would like to filter and sort our Hierarchical Grid or even to add and remove records? After such operations, the highlights of our current search automatically update and persist over any text that matches the searchText! Furthermore, the search will work with paging and will persist the highlights through changes of the Hierarchical Grid's perPage property. Adding icons By using some of our other components, we can create an enriched user interface and improve the overall design of our entire search bar! We can have a nice search or delete icon on the left of the search input, a couple of chips for our search options and some material design icons combined with nice ripple styled buttons for our navigation on the right. We can wrap these components inside an input group for a more refined design. To do this, let's go and grab the IgxInputGroup, IgxIcon, IgxRipple, IgxButton and the IgxChip modules. // app.module.ts ... import { IgxHierarchicalGridModule, IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule } from 'igniteui-angular'; // import { // IgxInputGroupModule, // IgxIconModule, // IgxRippleModule, // IgxButtonModule, // IgxChipsModule // } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule], }) export class AppModule {} Finally, let's update our template with the new components! We will wrap all of our components inside an IgxInputGroup. On the left we will toggle between a search and a delete/clear icon (depending on whether the search input is empty or not). In the center, we will position the input itself. In addition, whenever the delete icon is clicked, we will update our searchText and invoke the Hierarchical Grid's clearSearch method to clear the highlights. <!--searchgrid.component.html--> <igx-input-group type=\"search\" class=\"offset\"> <igx-prefix> <igx-icon *ngIf=\"searchText.length == 0\">search</igx-icon> <igx-icon *ngIf=\"searchText.length > 0\" (click)=\"clearSearch()\">clear</igx-icon> </igx-prefix> <input #search1 id=\"search1\" igxInput placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"hierarchicalGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> <igx-suffix *ngIf=\"searchText.length > 0\"> ... </igx-suffix> </igx-input-group> // searchgrid.component.ts public clearSearch() { this.searchText = ''; this.hierarchicalGrid.clearSearch(); } On the right in our input group, let's create three separate containers with the following purposes: For displaying the search results. <!--searchgrid.component.html--> <igx-suffix *ngIf=\"searchText.length > 0\"> <div class=\"resultsText\" *ngIf=\"hierarchicalGrid.lastSearchInfo\"> <span *ngIf=\"hierarchicalGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ hierarchicalGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ hierarchicalGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"hierarchicalGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> </igx-suffix> For displaying a couple of chips that toggle the caseSensitive and the exactMatch properties. We have replaced the checkboxes with two stylish chips that change color based on these properties. Whenever a chip is clicked, we invoke its respective handler - updateSearch or updateExactSearch depending on which chip has been clicked. <!--searchgrid.component.html--> ... <div class=\"chips\"> <igx-chips-area> <igx-chip (click)=\"updateSearch()\" [color]=\"caseSensitive? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Case Sensitive</span> </igx-chip> <igx-chip (click)=\"updateExactSearch()\" [color]=\"exactMatch? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Exact Match</span> </igx-chip> </igx-chips-area> </div> ... For the search navigation buttons, we have transformed our inputs into ripple styled buttons with material icons. The handlers for the click events remain the same - invoking the findNext/findPrev methods. <!--searchgrid.component.html--> <igx-suffix> <div class=\"searchButtons\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"hierarchicalGrid.findPrev(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"hierarchicalGrid.findNext(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </div> </igx-suffix> Known Limitations Limitation Description Searching in cells with a template The search functionality highlights work only for the default cell templates. If you have a column with custom cell template, the highlights will not work so you should either use alternative approaches, such as a column formatter, or set the searchable property on the column to false. Remote Virtualization The search will not work properly when using remote virtualization Cells with cut off text When the text in the cell is too large to fit and the text we are looking for is cut off by the ellipsis, we will still scroll to the cell and include it in the match count, but nothing will be highlighted API References In this article we implemented our own search bar for the Hierarchical Grid with some additional functionality when it comes to navigating between the search results. We also used some additional Ignite UI for Angular components like icons, chips and inputs. The search API is listed below. IgxHierarchicalGridComponent methods: findNext findPrev clearSearch refreshSearch IgxGridCell methods: IgxColumnComponent properties: searchable ISearchInfo Additional components and/or directives with relative APIs that were used: IgxInputGroupComponent IgxIconComponent IgxRippleDirective IgxButtonDirective IgxChipComponent Styles: IgxHierarchicalGridComponent Styles IgxInputGroupComponent Styles IgxIconComponent Styles IgxRippleDirective Styles IgxButtonDirective Styles IgxChipComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/selection.html": {
    "href": "components/hierarchicalgrid/selection.html",
    "title": "Angular Hierarchical Grid Selection - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Selection With Ignite UI for Angular Hierarchical Grid you can easily select data by using variety of events, rich API or with simple mouse interactions like single select. Angular Grid Selection Example The sample below demonstrates the three types of Hierarchical Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Angular Grid Selection Options IgniteUI for Angular Hierarchical Grid component provides three different selection modes - Row selection, Cell selection and Column selection. By default only Multi-cell selection mode is enabled in the Hierarchical Grid. In order to change/enable selection mode you can use rowSelection, cellSelection or selectable properties. Angular Row Selection Property rowSelection enables you to specify the following options: none - Row selection would be disabled for the Hierarchical Grid single - Selection of only one row within the Hierarchical Grid would be available multiple - Multi-row selection would be available by using the Row selectors, with a key combination like ctrl + click, or by pressing the space key once a cell is focused Go to Row selection topic for more information. Angular Cell Selection Property cellSelection enables you to specify the following options: none - Cell selection would be disabled for the Hierarchical Grid single - Selection of only one cell within the Hierarchical Grid would be available. multiple - Currently, this is the default state of the selection in the Hierarchical Grid. Multi-cell selection is available by mouse dragging over the cells, after a left button mouse clicked continuously. Go to Cell selection topic for more information. Angular Column Selection The selectable property enables you to specify the following options for each column: false - the corresponding column selection will be disabled for the Hierarchical Grid true - the corresponding column selection will be enabled for the Hierarchical Grid This lead to the following three variations: Single selection - mouse click over the column cell. Multi column selection - holding ctrl + mouse click over the column cells. Range column selection - holding shift + mouse click selects everything in between. Go to Column selection topic for more information. Known Issues and Limitations Using the Hierarchical Grid with Selection enabled on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. IE11 is no longer supported as of version 13.0.0. import 'core-js/es7/array'; When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References IgxHierarchicalGridComponent API IgxGridRow API IgxGridCell API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Row Selection Cell Selection Paging Filtering Sorting Summaries Column Moving Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/sizing.html": {
    "href": "components/hierarchicalgrid/sizing.html",
    "title": "Angular Hierarchical Grid Sizing - Ignite UI for Angular",
    "keywords": "Angular Grid Sizing There are many different ways to size the IgxHierarchicalGrid in order to accommodate a lot of scenarios that the users can have. While some are straight forward, others might be more complex and that is why we will take each one and look into them in more depth. We will go through setting width and height separately since there are some differences e.g. when using percentages for each. When it comes to border and padding size for the IgxHierarchicalGrid, they are taken into its width/height size calculations or also known as Border box sizing. It is applied in all scenarios. Note If the Border box sizing is overridden by the user we cannot guarantee that the IgxHierarchicalGrid will size correctly. Width If the width input does not have value assigned, its default value is 100% and the IgxHierarchicalGrid tries to fill the available space. You can check how the grid reacts to it in the Percentages section. Note Setting manually the width style of the IgxHierarchicalGrid itself will result in an unexpected behavior. Null The grid's width can accepts value of null, which when set, renders all columns in the DOM. The grid sizes accordingly so there is no grid horizontal scrollbar since column virtualization is not applied. If there are 6 columns and none of them has width defined, the grid will have width of 816px, because each column by default have assigned width of 136px in this scenario. Same will happen if the columns have width in percentages. If vertical scrollbar is rendered or there are features that render additional columns their width will be added also. If there are 6 columns with column width set to 200px they will fit in our window and all will be visible: If there are more columns or ones with bigger width that go out of the browser's view, they will all still render. Let's have the same amount of columns but each with column width of 300px. Since they don't all fit in the browser view area, it will create a scrollbar natively. The next example displays this exact scenario: If the grid has a parent element of any sort and it doesn't have any overflow set, it will still render all columns visible. Otherwise if the parent element has overflow auto or scroll, a scrollbar for that parent element will be rendered natively. The parent has bigger height for easier visualization in the following example. Note Due to this behavior, if the grid data contains too many columns, it might have significant impact on the browser performance, since all columns would be rendered without virtualization. Pixels When the IgxHierarchicalGrid width input is set to pixels it will set the whole grid size to that value and it will be static. It will not react to any browser resizing or changes in the DOM, although this is not the case for the grid content: When width is set in pixels in order for the grid to render horizontal scrollbar, its content width needs to exceed the specified grid width. Let's, for example, have the combined width of the columns exceed 1200px. In this case a horizontal scrollbar will be rendered. For scenarios where the grid has a parent element, it depends on the parent styling if it will render scrollbar or not. Everything else related to the grid itself is still retained. If the parent element width is smaller than the grid's width and has overflow style set to auto or scroll, it will render scrollbar natively. For example, if the parent has width set to 1000px and the IgxHierarchicalGrid width is still 1200px, it will look similar to the following illustrations: Percentages When the width of the IgxHierarchicalGrid is set to percentages it will size the grid according to the parent element's width. If the parent element does not have width specified the IgxHierarchicalGrid will size relative to the browser window. For example, if we set the grid width input to 100% and there is no parent element it will fill 100% of the available width of the browser window. If it is resized the grid will resize as well accordingly. If we set grid's width to 100% and there is a parent element that has specific width of 1200px, this will mean that the grid will size relative to that element and his final width will be 1200px. If we have a parent element with width of 1000px and have the grid's width set to 150%, the calculated grid width will be 1500px. In this case the grid will still render fully visible but if we set overflow: auto of the parent, that parent will render scrollbar on its own. Height By default if no height is defined for the IgxHierarchicalGrid, it will be set to 100%. You can check how the grid reacts depending on the DOM structure in the Percentages section. Note Setting manually the height style of the IgxHierarchicalGrid itself will result in an unexpected behavior. Null The IgxHierarchicalGrid height input can accept null value, which when set, displays all rows with no scrollbar no matter how many they are. In this case, there is no vertical virtualization since the grid renders all rows anyway. If we have data with 14 rows in this case the grid will render all 14 of them and size the grid so all are visible without any empty space inside the grid. If we have 24 rows instead, the grid will still render all rows but since they are too many, they exceed the browser boundaries. That's why the browser itself will render vertical scrollbar by default so the user can scroll down to the rest of the rows. If there is a parent element with defined height, the grid will still render all rows and not be affected. Let's say the parent has height of 650px. If he has overflow set to auto or scroll, it will render a vertical scrollbar but the grid will still be unaffected: Note Due to this behavior, if the grid data contains too many rows, it might have significant impact on the browser performance, since all rows would be rendered without virtualization. Pixels Setting the IgxHierarchicalGrid height in pixels is more straightforward since the grid will size to that specific size in all occasions similarly to how width is set in pixels. If we set, for example, the height 500px with 4 rows for our data the grid will sit to that size and since 4 rows are not enough to fill the visible area it is expected to have some empty area. If the number of rows exceeds the visible area of the grid when height is set to pixels a vertical scrollbar will be rendered. For example, a grid with 500px height set and 14 rows will be rendered the following way: If there is a parent element with height defined, unless it has overflow set to auto or scroll, the grid will still be fully visible. Otherwise it will render a scrollbar. Percentages When the height input is set to percentages the IgxHierarchicalGrid will size based on the parent element height. If the parent element has its height set in pixels or percentages, the grid will size relative to the size of the parent. When the parent element does not have defined height, the browser does not assign height to it initially and sizes it based on its children and their size. That is why there is no way for the grid to know what base height to use in order to apply percentage sizing based on it. For this reason, it will render a maximum of 10 rows and if they are more rows, a vertical scrollbar will be rendered. Otherwise, the grid will fit to number of rendered rows. We will look in this scenario in more detail in the next examples. Let's have width set to 1200px and the parent element not having any size applied to it: If there are less than 10 rows the grid will try to fit all rows in the `visible area without having an empty space between the last row and the bottom of the visible area. For example, let's have the grid data to consist of 7 rows. The grid will render all 7 rows without vertical scrollbar and without empty space inside the grid. If there are more than 10 rows a vertical scrollbar will be rendered for the rest of the rows and only 10 rows can be visible at any time. In the next example only the row number is increased to 14. If we set the parent element height to 800px and the IgxHierarchicalGrid to 100% height this means that the grid will be sized to 100 percentages of 800px. If the IgxHierarchicalGrid height is set to a number bigger than 100% and the parent element has height, for the parent to render scrollbar it again needs to have overflow set to auto or scroll. Otherwise the grid will be fully visibly and size relative to the parent size. If we want the grid to be sized to 100% from the browser window we would need to set both body and parent grid element heights to 100%. In this case, the parent element can be sized and the grid will size accordingly if the browser is resized. Column Sizing Depending on the grid size itself, the columns inside it can also be sized differently that could result in scenarios where the grid renders horizontal scrollbar or not. Columns can have width set in pixels, percentages or autosized when nothing is set. We will take a deeper look regarding these scenarios in this section. Default By default when a column doesn't have a specified width it will try to autosize, so that it fills if any empty space is available in the grid view area. Autosized columns have minimum width of 136px, so if the area available is less than 136px for that column, it will default to that size. When the grid is resized in these scenarios, the column width is also updated to reflect the changes, so it fills any new empty space available. If a column does not have specified width and the IgxHierarchicalGrid has width set to null, it will be sized to the minimum of 136px. This means that for a grid with width null and 6 columns that don't have width, each column will be sized to 136px. When there are multiple autosized columns they will divide the available space between each other equally. This means that if we have 6 columns and there is empty area of 1200px, each will size to 200px. If there is available empty space, so that each autosized column will be less than 136px, all autosized columns will default to 136px and the grid will render horizontal scrollbar. In the next example let's have 12 autosized columns and the grid width set to 1000px. If a column does not have width specified, but all other columns have either width in pixels or percentages, that column will try to also fill the available space. For example, if we don't have width set to the first column and all other 5 have width of 100px, the first will fill the rest. Same applies if multiple columns does not have width specified, all will divide the available space between each other equally. In the next illustration the first column has width set to 100px. Note Feature columns like Row Selector checkbox column and etc. fill additional space that is taken into account when autosizing columns. Pixels When columns have set specific width in pixels, they stick to that size, unless they are resized manually. Since the combined width of the columns is static, it can be less than the IgxHierarchicalGrid width or exceed it. If the combined width of all columns is less than the IgxHierarchicalGrid width, there would be an empty are inside the grid that the columns wouldn't be able to fill. This is the expected behavior of the IgxHierarchicalGrid. In the next example the columns have 150px width. If the combined width of all columns is bigger than the actual IgxHierarchicalGrid width, a horizontal scrollbar will be rendered. In the next example each of the 6 columns have width of 300px and grid has width of 1200px, which means that the columns combined have excess of 600px that goes out of bounds. Auto When columns are set to auto their size adjusts to fit the longest word in the column. Empty areas are possible if there are cells with very short values, while other cells have very long ones. In this scenario, all cells in the column would adjust to take the width of the cell with the longest value. Percentages When columns have set width in percentages, their size is calculated relatively to the grid size. It is similar to how width in pixels works, but provides also responsiveness to the columns which means that when the grid is resized, the columns also will resize accordingly. If the combined width of all columns is less than 100%, similarly to when in pixels, there could be an empty area of the grid that the columns do not cover. If the combined width is exactly 100%, the columns will fill all available space of the grid. If the combined width exceeds 100% in order for the user to be able to see the columns out of view, a horizontal scrollbar is rendered. If columns are set in percentages and the grid width is set to null, it would applywidth of 136px to each column. That is because the columns cannot be sized relatively to the grid, since it doesn't have width itself and relies on its content to be sized when its width is null. In the following example all 6 columns have width set to 50%: Child Grid Sizing Because the IgxHierarchicalGrid usually contains children, they can also have their width and height specified, in order to accommodate different scenarios. Since the children are defined using row island template, this means that all children in the same level and island will have the same width and height property applied to them. Width The width for the children does not behave much different than the IgxHierarchicalGrid itself, since each child grid is instance of IgxHierarchicalGrid as well. The only difference is that the user cannot change the parent element of the child grid. That's why when the width is set to percentages, the 100% width allocated for the child is smaller than the parent grid width. This is so that it is easier to distinguish when it is expanded. The following image displays the default child grid sizes, since it defaults to 100% width. Height The height of each child in the IgxHierarchicalGrid behaves also similarly to the height of the root level grid. The difference is that for the child grid, when height is set to percentages, it behaves as if the parent element has unset height. This means that in this scenario, the grid will render maximum of 10 rows. When the number of rows in the data is less than 10, the grid will size the view area to fit all the rows. If the data has more rows, a vertical scrollbar will be rendered and the view area will be sized to 10 rows height. API References IgxHierarchicalGridComponent API IgxGridRow API IgxHierarchicalGridComponent Styles Additional Resources Hierarchical Grid overview Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/sorting.html": {
    "href": "components/hierarchicalgrid/sorting.html",
    "title": "Angular Hierarchical Grid Sorting - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Sorting In Ignite UI for Angular Hierarchical Grid, data sorting is enabled on a per-column level, meaning that the igx-hierarchical-grid can have a mix of sortable and non-sortable columns. Performing angular sort actions enables you to change the display order of the records based on specified criteria. Note Up until now, grouping/sorting worked in conjuction with each other. In 13.2 version, a new behavior which decouples gropuing from sorting is introduced. For example - clearing the grouping will not clear sorting expressions in the grid or vice versa. Still, if a column is both sorted and grouped, grouped expressions take precedence. Angular Hierarchical Grid Sorting Overview Example Additionally there is a custom contextmenu added for sorting using igx-hierarchical-grid's contextMenu Output. This is done via the sortable input. With the Hierarchical Grid sorting, you can also set the sortingIgnoreCase property to perform case sensitive sorting: <igx-column field=\"ProductName\" header=\"Product Name\" [dataType]=\"'string'\" sortable=\"true\"></igx-column> Sorting Indicators Having a certain amount of sorted columns could be really confusing if there is no indication of the sorted order. The IgxHierarchicalGrid provides a solution for this problem by indicating the index of each sorted column. Sorting through the API You can sort any column or a combination of columns through the Hierarchical Grid API using the Hierarchical Grid sort method: import { SortingDirection } from 'igniteui-angular'; // import { SortingDirection } from '@infragistics/igniteui-angular'; for licensed package // Perform a case insensitive ascending sort on the ProductName column. this.hierarchicalGrid.sort({ fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }); // Perform sorting on both the ProductName and Price columns. this.hierarchicalGrid.sort([ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]); Note Sorting is performed using our DefaultSortingStrategy algorithm. Any IgxColumnComponent or ISortingExpression can use a custom implementation of the ISortingStrategy as a substitute algorithm. This is useful when custom sorting needs to be defined for complex template columns, or image columns, for example. As with the filtering behavior, you can clear the sorting state by using the clearSort method: // Removes the sorting state from the ProductName column this.hierarchicalGrid.clearSort('ProductName'); // Removes the sorting state from every column in the Hierarchical Grid this.hierarchicalGrid.clearSort(); Note The sortStrategy of the Hierarchical Grid is of different type compared to the sortStrategy of the column, since they work in different scopes and expose different parameters. Note The sorting operation DOES NOT change the underlying data source of the Hierarchical Grid. Initial sorting state It is possible to set the initial sorting state of the Hierarchical Grid by passing an array of sorting expressions to the sortingExpressions property of the Hierarchical Grid. public ngOnInit() { this.hierarchicalGrid.sortingExpressions = [ { fieldName: 'Name', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } public ngOnInit() { this.hierarchicalGrid.sortingExpressions = [ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } Note If values of type string are used by a column of dataType Date, the Hierarchical Grid won't parse them to Date objects and using Hierarchical Grid sorting won't work as expected. If you want to use string objects, additional logic should be implemented on an application level, in order to parse the values to Date objects. Sorting Indicators Templates The sorting indicator icon in the column header can be customized using a template. The following directives are available for templating the sorting indicator for any sorting state (ascending, descending, none): IgxSortHeaderIconDirective – re-templates the sorting icon when no sorting is applied. <ng-template igxSortHeaderIcon> <igx-icon>unfold_more</igx-icon> </ng-template> IgxSortAscendingHeaderIconDirective – re-templates the sorting icon when the column is sorted in ascending order. <ng-template igxSortAscendingHeaderIcon> <igx-icon>expand_less</igx-icon> </ng-template> IgxSortDescendningHeaderIconDirective – re-templates the sorting icon when the column is sorted in descending order. <ng-template igxSortDescendingHeaderIcon> <igx-icon>expand_more</igx-icon> </ng-template> Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $sorted-header-icon-color and sortable-header-icon-hover-color parameters. $custom-theme: grid-theme( $sorted-header-icon-color: #ffb06a, $sortable-header-icon-hover-color: black ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $black-color: black; $orange-color: #ffb06a; $custom-palette: palette($primary: $black-color, $secondary: $orange-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"primary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('primary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles ISortingExpression Additional Resources Hierarchical Grid overview Virtualization and Performance Paging Filtering Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/state-persistence.html": {
    "href": "components/hierarchicalgrid/state-persistence.html",
    "title": "Angular Hierarchical Grid State Persistence - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid State Persistence Тhe igxGridState directive allows developers to easily save and restore the grid state. When the IgxGridState directive is applied on the grid, it exposes the getState and setState methods that developers can use to achieve state persistence in any scenario. Supported Features IgxGridState directive supports saving and restoring the state of the following features: RowIslands saving/restoring features for all child grids down the hierarchy Sorting Filtering Advanced Filtering Paging Cell Selection Row Selection Column Selection Row Pinning Expansion Columns NEW: Multi column headers are now supported out of the box Columns order Column properties defined by the IColumnState interface. Columns templates and functions are restored using application level code, see Restoring Column section. Note The IgxGridState directive does not take care of templates. Go to Restoring Column section to see how to restore column templates. Usage getState - This method returns the grid state in a serialized JSON string, so developers can just take it and save it on any data storage (database, cloud, browser localStorage, etc). The method accepts first optional parameter serialize, which determines whether getState will return an IGridState object or a serialized JSON string. The developer may choose to get only the state for a certain feature/features, by passing in the feature name, or an array with feature names as a second argument. // get all features` state in a serialized JSON string const gridState = state.getState(); // get an `IGridState` object, containing all features original state objects, as returned by the grid public API const gridState: IGridState = state.getState(false); // get the sorting and filtering expressions const sortingFilteringStates: IGridState = state.getState(false, ['sorting', 'filtering']); setState - The setState method accepts the serialized JSON string or IGridState object as argument and will restore the state of each feature found in the object/JSON string. state.setState(gridState); state.setState(sortingFilteringStates) options - The options object implements the IGridStateOptions interface, i.e. for every key, which is the name of a certain feature, there is the boolean value indicating if this feature state will be tracked. getState method will not put the state of these features in the returned value and setState method will not restore state for it. public options = { cellSelection: false; sorting: false; } <igx-hierarchical-grid [igxGridState]=\"options\"></igx-hierarchical-grid> The simple to use single-point API's allows to achieve a full state persistence functionality in just a few lines of code. Copy paste the code from below - it will save the grid state in the browser sessionStorage object every time the user leaves the current page. Whenever the user returns to main page, the grid state will be restored. No more need to configure those complex advanced filtering and sorting expressions every time to get the data you want - do it once and have the code from below do the rest for your users: // app.component.ts @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public ngOnInit() { this.router.events.pipe(take(1)).subscribe((event: NavigationStart) => { this.saveGridState(); }); } public ngAfterViewInit() { this.restoreGridState(); } public saveGridState() { const state = this.state.getState() as string; window.sessionStorage.setItem('grid1-state', state); } public restoreGridState() { const state = window.sessionStorage.getItem('grid1-state'); this.state.setState(state); } Restoring columns IgxGridState will not persist columns templates, column formatters, etc. by default (see limitations). Restoring any of these can be achieved with code on application level. Let's show how to do this for templated columns: Define a template reference variable (in the example below it is #activeTemplate) and assign an event handler for the columnInit event: <igx-hierarchical-grid id=\"grid\" #grid igxGridState (columnInit)=\"onColumnInit($event)\"> <igx-column [field]=\"'IsActive'\" header=\"IsActive\"> <ng-template igxCell #activeTemplate let-column let-val=\"val\"> <igx-checkbox [checked]=\"val\"></igx-checkbox> </ng-template> </igx-column> ... </igx-hierarchical-grid> Query the template view in the component using @ViewChild or @ViewChildren decorator. In the columnInit event handler, assign the template to the column bodyTemplate property: @ViewChild('activeTemplate', { static: true }) public activeTemplate: TemplateRef<any>; public onColumnInit(column: IgxColumnComponent) { if (column.field === 'IsActive') { column.bodyTemplate = this.activeTemplate; column.summaries = MySummary; column.filters = IgxNumberFilteringOperand.instance(); } } Restoring Child Grids Saving / Restoring state for the child grids is controlled by the rowIslands property and is enabled by default. IgxGridState will use the same options for saving/restoring features both for the root grid and all child grids down the hierarchy. For example, if we pass the following options: <!-- public options = {selection: false, sorting: false, rowIslands: true} --> <igx-grid [igxGridState]=\"options\"></igx-grid> Then the getState API will return the state for all grids (root grid and child grids) features excluding selection and sorting. If later on the developer wants to restore only the filtering state for all grids, use: this.state.setState(state, ['filtering', 'rowIslands']); Demo Limitations When restoring all grid features at once (using setState API with no parameters), then column properties for the root grid might be resetted to default. If this happens, restore the columns or column selection feature separately after that: state.setState(gridState); state.setState(gridState.columns); state.setState(gridState.columnSelection); getState method uses JSON.stringify() method to convert the original objects to a JSON string. JSON.stringify() does not support Functions, thats why the [IgxGridState] directive will ignore the columns formatter, filters, summaries, sortStrategy, cellClasses, cellStyles, headerTemplate and bodyTemplate properties. API References IgxHierarchicalGridComponent IgxGridStateDirective Additional Resources Hierarchical Grid overview Paging Filtering Sorting Selection View page on GitHub"
  },
  "components/hierarchicalgrid/summaries.html": {
    "href": "components/hierarchicalgrid/summaries.html",
    "title": "Angular Grid Summaries - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Summaries The Angular UI grid in Ignite UI for Angular has a summaries feature that functions on a per-column level as group footer. Angular grid summaries is powerful feature which enables the user to see column information in a separate container with a predefined set of default summary items, depending on the type of data within the column or by implementing a custom angular template in the Hierarchical Grid. Angular Hierarchical Grid Summaries Overview Example Note The summary of the column is a function of all column values, unless filtering is applied, then the summary of the column will be function of the filtered result values Hierarchical Grid summaries can also be enabled on a per-column level in Ignite UI for Angular, which means that you can activate it only for columns that you need. Hierarchical Grid summaries gives you a predefined set of default summaries, depending on the type of data in the column, so that you can save some time: For string and boolean data types, the following function is available: count For number, currency and percent data types, the following functions are available: count min max average sum For date data type, the following functions are available: count earliest latest All available column data types could be found in the official Column types topic. Hierarchical Grid summaries are enabled per-column by setting hasSummary property to true. It is also important to keep in mind that the summaries for each column are resolved according to the column data type. In the igx-hierarchical-grid the default column data type is string, so if you want number or date specific summaries you should specify the dataType property as number or date. Note that the summary values will be displayed localized, according to the grid locale and column pipeArgs. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\"> <igx-column field=\"Artist\" [hasSummary]='true'></igx-column> <igx-column field=\"Photo\"> <ng-template igxCell let-cell=\"cell\"> <div class=\"cell__inner_2\"> <img [src]=\"cell.value\" class=\"photo\" /> </div> </ng-template> </igx-column> <igx-column field=\"Debut\" [hasSummary]='true'></igx-column> <igx-column field=\"Grammy Nominations\" [hasSummary]='true' [dataType]=\"'number'\" [summaries]=\"mySummary\"></igx-column> <igx-column field=\"Grammy Awards\" [hasSummary]='true' [dataType]=\"'number'\"></igx-column> </igx-hierarchical-grid> The other way to enable/disable summaries for a specific column or a list of columns is to use the public method enableSummaries/disableSummaries of the igx-hierarchical-grid. <igx-hierarchical-grid #hierarchicalGrid [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\" > <igx-column field=\"Artist\" [hasSummary]='true'></igx-column> <igx-column field=\"Photo\"> <ng-template igxCell let-cell=\"cell\"> <div class=\"cell__inner_2\"> <img [src]=\"cell.value\" class=\"photo\" /> </div> </ng-template> </igx-column> <igx-column field=\"Debut\" [hasSummary]='true'></igx-column> <igx-column field=\"Grammy Nominations\" [hasSummary]='true' [dataType]=\"'number'\" [summaries]=\"mySummary\"></igx-column> <igx-column field=\"Grammy Awards\" [hasSummary]='true' [dataType]=\"'number'\"></igx-column> </igx-hierarchical-grid> <button (click)=\"enableSummary()\">Enable Summary</button> <button (click)=\"disableSummary()\">Disable Summary </button> public enableSummary() { this.hierarchicalGrid.enableSummaries([ {fieldName: 'Grammy Nominations', customSummary: this.mySummary}, {fieldName: 'Artist'} ]); } public disableSummary() { this.hierarchicalGrid.disableSummaries('Photo'); } Custom Hierarchical Grid Summaries If these functions do not fulfill your requirements you can provide a custom summary for the specific columns. In order to achieve this you have to override one of the base classes IgxSummaryOperand, IgxNumberSummaryOperand or IgxDateSummaryOperand according to the column data type and your needs. This way you can redefine the existing function or you can add new functions. IgxSummaryOperand class provides the default implementation only for the count method. IgxNumberSummaryOperand extends IgxSummaryOperand and provides implementation for the min, max, sum and average. IgxDateSummaryOperand extends IgxSummaryOperand and additionally gives you earliest and latest. import { IgxRowIslandComponent, IgxHierarchicalGridComponent, IgxNumberSummaryOperand, IgxSummaryResult } from 'igniteui-angular'; // import { IgxRowIslandComponent, IgxHierarchicalGridComponent, IgxNumberSummaryOperand, IgxSummaryResult } from '@infragistics/igniteui-angular'; for licensed package class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } public operate(data?: any[]): IgxSummaryResult[] { const result = super.operate(data); result.push({ key: 'test', label: 'More than 5', summaryResult: data.filter((rec) => rec > 5).length }); return result; } } As seen in the examples, the base classes expose the operate method, so you can choose to get all default summaries and modify the result, or calculate entirely new summary results. The method returns a list of IgxSummaryResult. interface IgxSummaryResult { key: string; label: string; summaryResult: any; } and take optional parameters for calculating the summaries. See Custom summaries, which access all data section below. Note In order to calculate the summary row height properly, the Hierarchical Grid needs the operate method to always return an array of IgxSummaryResult with the proper length even when the data is empty. And now let's add our custom summary to the column GramyNominations. We will achieve that by setting the summaries property to the class we create below. <igx-hierarchical-grid class=\"hgrid\" [data]=\"localdata\" [autoGenerate]=\"false\"> <igx-column field=\"Artist\" [hasSummary]='true'></igx-column> <igx-column field=\"Photo\"> <ng-template igxCell let-cell=\"cell\"> <div class=\"cell__inner_2\"> <img [src]=\"cell.value\" class=\"photo\" /> </div> </ng-template> </igx-column> <igx-column field=\"Debut\" [hasSummary]='true'></igx-column> <igx-column field=\"Grammy Nominations\" [hasSummary]='true' [dataType]=\"'number'\" [summaries]=\"mySummary\"></igx-column> <igx-column field=\"Grammy Awards\" [hasSummary]='true' [dataType]=\"'number'\"></igx-column> </igx-hierarchical-grid> ... export class HGridSummarySampleComponent implements OnInit { mySummary = MySummary; .... } Custom summaries, which access all data Now you can access all Hierarchical Grid data inside the custom column summary. Two additional optional parameters are introduced in the IgxSummaryOperand operate method. As you can see in the code snippet below the operate method has the following three parameters: columnData - gives you an array that contains the values only for the current column allGridData - gives you the whole grid data source fieldName - current column field class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(columnData: any[], allGridData = [], fieldName?): IgxSummaryResult[] { const result = super.operate(allData.map(r => r[fieldName])); result.push({ key: 'test', label: 'Total Discontinued', summaryResult: allData.filter((rec) => rec.Discontinued).length }); return result; } } Summary Template igxSummary targets the column summary providing as a context the column summary results. <igx-column ... [hasSummary]=\"true\"> <ng-template igxSummary let-summaryResults> <span> My custom summary template</span> <span>{{ summaryResults[0].label }} - {{ summaryResults[0].summaryResult }}</span> </ng-template> </igx-column> When a default summary is defined, the height of the summary area is calculated by design depending on the column with the largest number of summaries and the display density of the grid. Use the summaryRowHeight input property to override the default value. As an argument it expects a number value, and setting a falsy value will trigger the default sizing behavior of the grid footer. Note Column summary template could be defined through API by setting the column summaryTemplate property to the required TemplateRef. Formatting summaries By default, summary results, produced by the built-in summary operands, are localized and formatted according to the grid locale and column pipeArgs. When using custom operands, the locale and pipeArgs are not applied. If you want to change the default appearance of the summary results, you may format them using the summaryFormatter property. public dateSummaryFormat(summary: IgxSummaryResult, summaryOperand: IgxSummaryOperand): string { const result = summary.summaryResult; if(summaryOperand instanceof IgxDateSummaryOperand && summary.key !== 'count' && result !== null && result !== undefined) { const pipe = new DatePipe('en-US'); return pipe.transform(result,'MMM YYYY'); } return result; } <igx-column ... [summaryFormatter]=\"dateSummaryFormat\"></igx-column> Exporting Summaries There is an exportSummaries option in IgxExcelExporterOptions that specifies whether the exported data should include the grid's summaries. Default exportSummaries value is false. The IgxExcelExporterService will export the default summaries for all column types as their equivalent excel functions so they will continue working properly when the sheet is modified. Try it for yourself in the example below: The exported file includes a hidden column that holds the level of each DataRecord in the sheet. This level is used in the summaries to filter out the cells that need to be included in the summary function. In the table below, you can find the corresponding Excel formula for each of the default summaries. Data Type Function Excel Function string, boolean count =\"Count: \"&COUNTIF(start:end, recordLevel) number, currency, percent count =\"Count: \"&COUNTIF(start:end, recordLevel) min =\"Min: \"&MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)) max =\"Max: \"&MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)) average =\"Avg: \"&AVERAGEIF(start:end, recordLevel, rangeStart:rangeEnd) sum =\"Sum: \"&SUMIF(start:end, recordLevel, rangeStart:rangeEnd) date count =\"Count: \"&COUNTIF(start:end, recordLevel) earliest =\"Earliest: \"& TEXT(MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) latest =\"Latest: \"&TEXT(MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) Known Limitations Limitation Description Exporting custom summaries Custom summaries will be exported as strings instead of Excel functions. Exporting templated summaries Templated summaries are not supported and will be exported as the default ones. Keyboard Navigation The summary rows can be navigated with the following keyboard interactions: UP - navigates one cell up DOWN - navigates one cell down LEFT - navigates one cell left RIGHT - navigates one cell right CTRL + LEFT or HOME - navigates to the leftmost cell CTRL + RIGHT or END - navigates to the rightmost cell Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-summary-theme and accepts the $background-color, $focus-background-color, $label-color, $result-color, $pinned-border-width, $pinned-border-style and $pinned-border-color parameters. $custom-theme: grid-summary-theme( $background-color: #e0f3ff, $focus-background-color: rgba( #94d1f7, .3 ), $label-color: #e41c77, $result-color: black, $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: #e41c77 ); The last step is to include the component mixins: @include grid-summary($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-summary($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $blue-color: #7793b1; $green-color: #00ff2d; $my-custom-palette: palette($primary: $blue-color, $secondary: $green-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-summary-theme( $background-color: color($my-custom-palette, \"primary\", 700), $focus-background-color: color($my-custom-palette, \"primary\", 800), $label-color: color($my-custom-palette, \"secondary\", 500), $result-color: color($my-custom-palette, \"grays\", 900), $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: color($my-custom-palette, \"secondary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid-summary: // Extending the light grid summary schema $my-summary-schema: extend($_light-grid-summary, ( background-color: (igx-color: ('primary', 700)), focus-background-color: (igx-color: ('primary', 800)), label-color: (igx-color: ('secondary', 500)), result-color: (igx-color: ('grays', 900)), pinned-border-width: 2px, pinned-border-style: dotted, pinned-border-color: (igx-color: ('secondary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid-summary: $my-summary-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-summary-theme( $palette: $my-custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxHierarchicalGridComponent API IgxHierarchicalGridComponent Styles IgxHierarchicalGridSummaries Styles IgxSummaryOperand IgxNumberSummaryOperand IgxDateSummaryOperand IgxColumnGroupComponent IgxColumnComponent Additional Resources Hierarchical Grid overview Column Data Types Virtualization and Performance Paging Filtering Sorting Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/toolbar.html": {
    "href": "components/hierarchicalgrid/toolbar.html",
    "title": "Angular Grid Toolbar - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Toolbar The Hierarchical Grid in Ignite UI for Angular provides an IgxGridToolbarComponent which is essentially a container for UI operations. The Angular toolbar is located at the top of the Angular component, i.e the Hierarchical Grid and it matches its horizontal size. The toolbar container can host predefined UI controls for the following Hierarchical Grid's features: Column Hiding Column Pinning Excel Exporting Advanced Filtering or just any other custom content. The toolbar and the predefined UI components support Angular events and expose API for developers. Angular Toolbar Grid Example The predefined actions and title UI components are added inside the <igx-grid-toolbar> and this is all needed to have a toolbar providing default interactions with the corresponding Grid features: <igx-hierarchical-grid [data]=\"data\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Hierarchical Grid Toolbar</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering><igx-grid-toolbar-advanced-filtering> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning> <igx-grid-toolbar-exporter></igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-hierarchical-grid> Note: As seen in the code snippet above, the predefined actions UI components are wrapped in the <igx-grid-toolbar-actions> container. This way, the toolbar title is aligned to the left of the toolbar and the actions are aligned to the right of the toolbar. Of course, each of these UIs can be added independently of each other, or may not be added at all. This way the toolbar container will be rendered empty: <igx-hierarchical-grid [data]=\"data\"> <igx-grid-toolbar> </igx-grid-toolbar> </igx-hierarchical-grid> For a comprehensive look over each of the default UI components, continue reading the Features section below. Toolbar with child grids Due to certain limitations in how the child grids of an IgxHierarchicalGrid are implemented and how DI scope works, when defining a toolbar component inside the igx-row-island tags use the igxGridToolbar directive with the template shorthand. This allows child grids to create their own separate toolbar instances: <igx-hierarchical-grid> ... <igx-row-island> <igx-grid-toolbar *igxGridToolbar> <igx-grid-toolbar-title>Child toolbar</igx-grid-toolbar-title> </igx-grid-toolbar> </igx-row-island> ... </igx-hierarchical-grid> The toolbar template context implicitly exposes a reference to the respective grid instance, which you can use for any other binding/logic needs. See below for an example. With versions prior to 17.1.0 Versions prior to 17.1.0 also required to pass the provided grid instance as an input property to the toolbar itself. This will make sure you always have the correct grid instance in the scope of your template: <igx-hierarchical-grid> ... <igx-row-island> <!-- You can name the binding from igxGridToolbar however you want. Just make sure to use it inside the template if you need to access the grid instance. --> <igx-grid-toolbar [grid]=\"gridRef\" *igxGridToolbar=\"let gridRef\"> <igx-grid-toolbar-title>Child toolbar {{ gridRef.parentIsland.level }}</igx-grid-toolbar-title> </igx-grid-toolbar> </igx-row-island> ... </igx-hierarchical-grid> Features The toolbar is great at separating logic/interactions which affects the grid as a whole. As shown above, it can be configured to provide default components for controlling, column hiding, column pinning, advanced filtering and exporting data from the grid. These features can be enabled independently from each other by following a pattern similar to the card component of the Ignite UI for Angular suite. Listed below are the main features of the toolbar with example code for each of them. Title Setting a title for the toolbar in your grid is achieved by using the IgxGridToolbarTitleComponent. Users can provide anything from simple text to more involved templates. <igx-grid-toolbar> <igx-grid-toolbar-title>Grid toolbar title</igx-grid-toolbar-title> </igx-grid-toolbar> Actions The toolbar exposes a specific container where users can place actions/interactions in relation to the parent grid. As with the title portion of the toolbar, users can provide anything inside that template part, including the default toolbar interaction components. <igx-grid-toolbar> <igx-grid-toolbar-actions> <button igxButton>Action</button> <igx-select></igx-select> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> Each action now exposes a way to change the overlay settings of the actions dialog by using the overlaySettings input, example: <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning [overlaySettings]=\"overlaySettingsScaleCenter\"></igx-grid-toolbar-pinning> <igx-grid-toolbar-hiding [overlaySettings]=\"overlaySettingsAuto\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> public data: any[]; public positionStrategyScaleCenter = new GlobalPositionStrategy({ openAnimation: scaleInCenter, closeAnimation: scaleOutCenter }); public overlaySettingsScaleCenter = { positionStrategy: this.positionStrategyScaleCenter, scrollStrategy: new AbsoluteScrollStrategy(), modal: true, closeOnEscape: true }; public positionStrategyAuto = new AutoPositionStrategy(); public overlaySettingsAuto = { positionStrategy: this.positionStrategyAuto, scrollStrategy: new AbsoluteScrollStrategy(), modal: false, closeOnEscape: false }; constructor() { this.data = athletesData; } The default overlaySettings are using ConnectedPositionStrategy with Absolute scroll strategy, modal set to false, with enabled close on escape and close on outside click interactions. Column pinning Toolbar Pinning component provides the default UI for interacting with column pinning in the grid. The component is setup to work out of the box with the parent grid containing the toolbar as well as several input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning title=\"Grid pinned columns\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-pinning> </igx-grid-toolbar-actions> </igx-grid-toolbar> Column hiding Toolbar Hiding component provides the default UI for interacting with column hiding. Exposes the same input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding title=\"Grid column hiding\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> Advanced filtering Toolbar Advanced Filtering component provides the default UI for the Advanced Filtering feature. The component exposes a way to change the default text of the button. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering>Custom text for the toggle button</igx-grid-toolbar-advanced-filtering> </igx-grid-toolbar-actions> </igx-grid-toolbar> Data exporting Note When exporting the Hierarchical Grid or any of its child grids down the hierarchy, the exported data will be a flat collection of rows belonging to their respective grid (the child grids will not be included in the exported data). As with the rest of the toolbar actions, exporting is provided through a Toolbar Exporter component out of the box. The exporting component is using the respective service for the target data format (Excel CSV). That means if the respective service is not provided through the dependency injection chain, the component won't be able to export anything. If you need a refresher on the DI in Angular, check the official guide. Here is a sample snippet showing how to enable all export services for your application. // app.module.ts import { IgxExcelExporterService, IgxCsvExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService, IgxCsvExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... providers: [IgxExcelExporterService, IgxCsvExporterService ] }) export class AppModule { ... } Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. The toolbar exporter component exposes several input properties for customizing both the UI and the exporting experience. These range from changing the display text, to enabling/disabling options in the dropdown to customizing the name of the generated file. For full reference, consult the API documentation for the toolbar exporter component. Here is a snippet showing some of the options which can be customized through the Angular template: <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-exporter <!-- If active, enables the csv export entry in the dropdown UI --> [exportCSV]=\"csvExportEnabled\" <!-- If active, enables the excel export entry in the dropdown UI --> [exportExcel]=\"excelExportEnabled\" <!-- The name of the generated export file without the file extension --> filename=\"exported_data\" > Custom text for the exporter button <span excelText>Custom text for the excel export entry</span> <span csvText>Custom text for the CSV export entry</span> </igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> The following sample demonstrates how to customize the exported files: Exporting Indicator When using the default toolbar exporter component, whenever an export operation takes place the toolbar will show a progress indicator while the operation is in progress. Moreover, users can set the toolbar showProgress property and use for their own long running operations or just as another way to signify an action taking place in the grid. The sample belows uses has significant amount of data, in order to increase the time needed for data export so the progressbar can be seen. Additionally it has another button that simulates a long running operation in the grid: Custom Content Note This replaces the old toolbar template directive. If you are migrating from a version before v11 our migrations will handle the moving of the template content. However, we do not handle the bindings in the template, so make sure to double check the modified template files after the migration completes. If the actions part of the toolbar component is not sufficient for a particular use case, the toolbar itself has a general content projection where users can provide additional UI. If the user needs the respective grid instance for API calls or bindings, they can create a template reference variable. Here is a sample snippet: <igx-hierarchical-grid #gridRef ...> ... <igx-grid-toolbar> <igx-grid-toolbar-title>{{ titleBinding }}</igx-grid-toolbar-title> <!-- Everything between the toolbar tags except the default toolbar components/directives will be projected as custom content. --> <button igxButton=\"flat\" igxRipple (click)=\"#gridRef.clearSort()\"> <igx-icon fontSet=\"material\">clear</igx-icon> Clear Sort </button> <igx-grid-toolbar-actions> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-hierarchical-grid> The following sample demonstrates how to add an additional button to the toolbar to clear the sorting set by clicking on the columns' headers: Styling To get started with styling the toolbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; First, let's create a new palette. $my-dark-palette: palette( $primary: #2466ff, $secondary: #FFCD0F, $surface: #2a2b2f, $grays: #fff, ); $my-dark-color: color($my-dark-palette, 'surface'); Now, create a new theme that extends the grid-toolbar-theme and modify the $background-color and the $title-text-color parameters. $dark-grid-toolbar-theme: grid-toolbar-theme( $palette: $my-dark-palette, $background-color: $my-dark-color, $title-text-color: color($my-dark-palette, 'secondary'), $dropdown-background: $my-dark-color, ); To theme the column actions menus of the toolbar, we have to change the theme of the column-actions-theme component. $dark-column-actions-theme: column-actions-theme( $palette: $my-dark-palette, $title-color: color($my-dark-palette, 'secondary'), $background-color: color($my-dark-palette, 'surface') ); Since the column actions are using other components - igx-button, igx-checkbox, and igx-input-group, we need to change their themes to match our new toolbar theme. $dark-button-theme: button-theme( $palette: $my-dark-palette, $outlined-background: color($my-dark-palette, 'secondary'), $outlined-hover-background: color($my-dark-palette, 'grays', 100), $outlined-hover-text-color: color($my-dark-palette, 'secondary') ); $dark-checkbox-theme: checkbox-theme( $palette: $my-dark-palette, $tick-color: $my-dark-color, ); $dark-input-group-theme: input-group-theme( $palette: $my-dark-palette ); The last step is to include the newly created themes. :host { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } Note If $legacy-support is set to false(default), include the component css variables like that: :host { @include css-vars($dark-grid-toolbar-theme); @include css-vars($dark-column-actions-theme); @include css-vars($dark-checkbox-theme); @include css-vars($dark-input-group-theme); @include css-vars($dark-button-theme); } Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } } Demo API References The Grid Toolbar service has a few more APIs to explore, which are listed below. IgxGridToolbarActionsComponent IgxGridToolbarAdvancedFilteringComponent IgxGridToolbarComponent IgxGridToolbarExporterComponent IgxGridToolbarHidingComponent IgxGridToolbarPinningComponent IgxGridToolbarTitleComponent IgxHierarchicalGridComponent events: toolbarExporting Styles: IgxHierarchicalGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/validation.html": {
    "href": "components/hierarchicalgrid/validation.html",
    "title": "Editing and Validation in Angular Hierarchical Grid - Infragistics",
    "keywords": "Angular Hierarchical Grid Editing and Validation The Hierarchical Grid's editing exposes a built-in validation mechanism of user input when editing cells/rows. It extends the Angular Form validation functionality to allow easier integration with a well known functionality. When the state of the editor changes, visual indicators are applied to the edited cell. Configuration Configure via template-driven configuration We extend some of the Angular Forms validator directives to directly work with the IgxColumn. The same validators are available as attributes to be set declaratively in igx-column. The following validators are supported out-of-the-box: required min max email minlength maxlength pattern To validate that a column input would be set and the value is going to be formatted as an email, you can use the related directives: <igx-column [field]=\"email\" [header]=\"User E-mail\" required email></igx-column> The following sample demonstrates how to use the prebuilt required, email and min validator directives in a Hierarchical Grid. Configure via reactive forms We expose the FormGroup that will be used for validation when editing starts on a row/cell via a formGroupCreated event. You can modify it by adding your own validators for the related fields: <igx-hierarchical-grid (formGroupCreated)='formCreateHandler($event)' ...> public formCreateHandler(args: IGridFormGroupCreatedEventArgs) { const formGroup = args.formGroup; const orderDateRecord = formGroup.get('OrderDate'); const requiredDateRecord = formGroup.get('RequiredDate'); const shippedDateRecord = formGroup.get('ShippedDate'); orderDateRecord.addValidators(this.futureDateValidator()); requiredDateRecord.addValidators(this.pastDateValidator()); shippedDateRecord.addValidators(this.pastDateValidator()); } You can decide to write your own validator function, or use one of the built-in Angular validator functions. Validation service API The grid exposes a validation service via the validation property. That service has the following public APIs: valid - returns if the grid validation state is valid. getInvalid - returns records with invalid states. clear - clears state for record by id or clears all state if no id is provided. markAsTouched - marks the related record/field as touched. Invalid states will persis until the validation errors in them are fixed according to the validation rule or they are cleared. Validation triggers Validation will be triggered in the following scenarios: While editing via the cell editor based on the grid's validationTrigger. Either on change while typing in the editor, or on blur when the editor loses focus or closes. When updating cells/rows via the API - updateRow, updateCell etc.. When using batch editing and the undo/redo API of the transaction service. Note: Validation will not trigger for records that have not been edited via user input or via the editing API. Visual indicators on the cell will only shown if the related input is considered touched - either via user interaction or via the markAsTouched API of the validation service. Angular Hierarchical Grid Validation Customization Options Set a custom validator You can define your own validation directive to use on a <igx-column> in the template. @Directive({ selector: '[phoneFormat]', providers: [{ provide: NG_VALIDATORS, useExisting: PhoneFormatDirective, multi: true }] }) export class PhoneFormatDirective extends Validators { @Input('phoneFormat') public phoneFormatString = ''; public validate(control: AbstractControl): ValidationErrors | null { return this.phoneFormatString ? phoneFormatValidator(new RegExp(this.phoneFormatString, 'i'))(control) : null; } } Once it is defined and added in your app module you can set it declaratively to a given column in the grid: <igx-column phoneFormat=\"\\+\\d{1}\\-(?!0)(\\d{3})\\-(\\d{3})\\-(\\d{4})\\b\" ...> Change default error template You can define your own custom error template that will be displayed in the error tooltip when the cell enters invalid state. This is useful in scenarios where you want to add your own custom error message or otherwise change the look or content of the message. <igx-column ... > <ng-template igxCellValidationError let-cell='cell' let-defaultErr=\"defaultErrorTemplate\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> <div *ngIf=\"cell.validation.errors?.['phoneFormat']\"> Please enter correct phone format </div> </ng-template> </igx-column> Prevent exiting edit mode on invalid state In some cases you may want to disallow submitting an invalid value in the data. In that scenarios you can use the cellEdit or rowEdit events and cancel the event in case the new value is invalid. Both events' arguments have a valid property and can be canceled accordingly. How it is used can be seen in the Cross-field Validation example <igx-hierarchical-grid (cellEdit)='cellEdit($event)' ...> public cellEdit(evt) { if (!evt.valid) { evt.cancel = true; } } Example The below example demonstrates the above-mentioned customization options. Cross-field validation In some scenarios validation of one field may depend on the value of another field in the record. In that case a custom validator can be used to compare the values in the record via their shared FormGroup. Cross-field validators can be added to the formGroup on the formGroupCreated event. In them multiple fields can be compared for validity. public formCreateCustomerHandler(event: IGridFormGroupCreatedEventArgs) { const formGroup = event.formGroup; formGroup.addValidators(this.addressValidator()); } public formCreateOrderHandler(event: IGridFormGroupCreatedEventArgs) { const formGroup = event.formGroup; formGroup.addValidators(this.dateValidator()); } public addressValidator(): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const formGroup = control; let returnObject = {}; const city = formGroup.get('City'); const country = formGroup.get('Country'); const validCities = this.countryData.get(country.value); if (!validCities || !validCities[city.value]) { returnObject['invalidAddress'] = true; } return returnObject; } } public dateValidator(): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const formGroup = control; let returnObject = {}; const orderDate = formGroup.get('OrderDate').value; const shippedDate = formGroup.get('ShippedDate').value; if (new Date(shippedDate) < new Date(orderDate)) { returnObject['invalidRange'] = true; } return returnObject; } } The multi-field errors can then be displayed in a separate pinned column. <igx-column field=\"row_valid\" header=\" \" [editable]=\"false\" [dataType]=\"'number'\" [pinned]=\"true\" [width]=\"'50px'\"> <ng-template igxCell let-cell=\"cell\"> <div *ngIf=\"isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" > <img width=\"18\" src=\"assets/images/grid/active.png\"/> </div> <div *ngIf=\"!isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" > <img width=\"18\" src=\"assets/images/grid/expired.png\"/> </div> <div #tooltipRef=\"tooltip\" igxTooltip [style.width]=\"'max-content'\"> <div *ngFor=\"let message of stateMessage(cell)\"> {{message}} </div> </div> </ng-template> </igx-column> Errors and the detailed messages can be determined based on the row and cell's validity. public isRowValid(cell: CellType) { const hasErrors = !!cell.row.validation.errors || cell.row.cells.some(x => !!x.validation.errors); return !hasErrors; } public stateMessage(cell: CellType) { const messages = []; const row = cell.row; if (row.validation.errors?.invalidAddress) { messages.push('The address information is invalid. City does not match the Country.'); } if (row.validation.errors?.invalidRange) { messages.push('The ShippedDate cannot be before the OrderDate.'); } const cellValidationErrors = row.cells.filter(x => !!x.validation.errors); if (cellValidationErrors && cellValidationErrors.length > 0) { const fields = cellValidationErrors.map(x => x.column.field).join(','); messages.push('The following fields are required: ' + fields); } if (messages.length === 0) { // no errors return ['Valid']; } return messages; } Cross-field example The below sample demonstrates cross-field validation in a Hierarchical Grid for both the root and child data. Styling Using the Ignite UI for Angular Theme Library, we can alter the default validation styles while editing. In the example below, we will make use of the exposed template for validation message, which pops out in a tooltip and overriding the error color to modify the default looks of the validation. We will also style the background of the invalid rows to make them more distinct. Import theme The easiest way to style and access css variables is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Include the styles In order to change the error color you can use the css variable --igx-error-500: --igx-error-500: 34, 80%, 63%; Custom Templates Changing the default error template allows setting custom classes and styles: <ng-template igxCellValidationError let-cell='cell' let-defaultErr='defaultErrorTemplate'> <div class=\"validator-container\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> </div> </ng-template> Invalid row and cell styles Rows and cells provide API for the developers to know if a row or cell is invalid and what kind of errors are active. public rowStyles = { background: (row: RowType) => row.validation.status === 'INVALID' ? '#FF000033' : '#00000000' }; public cellStyles = { 'invalid-cell': (rowData, columnKey) => { let cell = this.hierarchicalGrid.getCellByKey(rowData, columnKey); // search in child grids if (!cell) { for (let grid of this.childGrid.gridAPI.getChildGrids()) { cell = grid.getCellByKey(rowData, columnKey); if (cell) break; } } return cell && cell.validation.status === 'INVALID'; } } <igx-hierarchical-grid [rowStyles]=\"rowStyles\"> <igx-column field=\"Artist\" [editable]=\"true\" [dataType]=\"'string'\" required [cellClasses]=\"cellStyles\"> ... <igx-row-island [key]=\"'Albums'\" [rowStyles]=\"rowStyles\"> <igx-column field=\"Album\" [editable]=\"true\" [dataType]=\"'string'\" required [cellClasses]=\"cellStyles\"> Demo API References IgxBaseTransactionService IgxGridComponent IgxColumnComponent Known Issues and Limitations Limitation Description When validationTrigger is blur, editValue and validation will trigger only after editor is blurred. Reason is that this utilizes the formControl's updateOn property. This determines the event on which the formControl will update and trigger related validators. Additional Resources Build CRUD operations with igxGrid Hierarchical Grid Overview Hierarchical Grid Editing Hierarchical Grid Row Editing Hierarchical Grid Row Adding Hierarchical Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/hierarchicalgrid/virtualization.html": {
    "href": "components/hierarchicalgrid/virtualization.html",
    "title": "Angular Grid Virtualization and Performance - Ignite UI for Angular",
    "keywords": "Angular Hierarchical Grid Virtualization and Performance In Ignite UI for Angular, the IgxHierarchicalGrid control now utilizes the igxForOf directive and virtualizes its content both vertically and horizontally. Demo Enabling Virtualization By utilizing the igxForOf directive the IgxHierarchicalGrid now optimizes DOM rendering and memory consumption by rendering only what is currently visible in the view port and swapping the displayed data while the user scrolls the data horizontally/vertically. IgxHierarchicalGrid's width and height defaults to 100% which will enable virtualization if the content displayed cannot fit inside the available space and scrollbars are required either vertically or horizontally. However, it is also possible to explicitly set the Hierarchical Grid's width and/or height to null which means that the related dimension will be determined by the total size of the items inside. No scrollbar will then be shown and all items will be rendered along the respective dimension (columns if width is null and rows if height is null). The size of the data chunks is determined by: The row height for the vertical (row) virtualization. This is determined by the rowHeight option and is 50(px) by default. The individual column widths in pixels for the horizontal (column) virtualization. They can be determined by either setting explicit width for each column component or setting the Hierarchical Grid's columnWidth option, which will be applied to all columns that don't have explicit width set. In most cases, letting the grid apply its default behavior by leaving dimensions unset will produce the desired layout. For column widths it is determined by the column count, the columns with set width, and the calculated width of the Hierarchical Grid's container. The grid will try to fit all columns inside the available space as long as the width it attempts to assign is not under 136(px). In such cases, columns with unassigned width will receive the minimum width of 136(px) and a horizontal scrollbar will be shown. The grid will be horizontally virtualized. Explicitly setting column widths in percentages (%) will, in most cases, create a grid that is not virtualized horizontally as it will not have a horizontal scrollbar. Virtualization Limitations On Mac OS horizontal scrollbar is not visible when \"Show scrollbars only when scrolling\" system option is set to true (which is the default value). This is because the Hierarchical Grid’s row container has an overflow set to hidden. Change the option to \"Always\" and the scrollbar will appear. FAQ Why having dimensions in the Hierarchical Grid is necessary for virtualization to work? Without information about the sizes of the container and the items before rendering them setting the width or height of a scrollbar or determining which of the items should be in the view when you scroll to a random location in the Hierarchical Grid is erroneous. Any assumptions on what the actual dimensions might be could lead to unnatural behavior of the scrollbar and ultimately suboptimal experience for the end-user. This is why setting the related dimensions is enforced in order for virtualization to take effect. API References IgxHierarchicalGridComponent IgxHierarchicalGridComponent Styles IgxColumnComponent IgxForOfDirective IForOfState Additional Resources Hierarchical Grid overview Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/icon.html": {
    "href": "components/icon.html",
    "title": "Angular Icon Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Icon Component Overview The Ignite UI for Angular Icon component unifies icon/font families so developers can use them interchangeably and add material icons to markup. Angular Icon Example Getting Started with Ignite UI for Angular Icon To get started with the Ignite UI for Angular Icon component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxIconModule in your app.module.ts file. // app.module.ts import { IgxIconModule } from 'igniteui-angular'; // import { IgxIconModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxIconModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxIconComponent as a standalone dependency. // home.component.ts import { IgxIconComponent } from 'igniteui-angular'; // import { IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-icon [style.color]=\"color\">home</igx-icon>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxIconComponent] }) export class HomeComponent { public color = '#e41c77'; } Now that you have the Ignite UI for Angular Icon module or component imported, you can start using the igx-icon component. Using the Angular Icon Icon Color Use style.color CSS property to change its default color: <igx-icon [style.color]=\"'#e41c77'\">home</igx-icon> Inactive Icon If you want to disable an icon, you can use the active property: <igx-icon [active]=\"false\">volume_off</igx-icon> Content Projection You can set icons with content projection: <igx-icon>bluetooth</igx-icon> Icon Size You can customize the icons using CSS. To change an icon size use the --size CSS variable: .custom-size { --size: 56px; } SVG Icons You can also use an SVG image as an icon. First, inject the IgxIconService dependency. In this example we will inject it in a component's constructor but you can use it wherever it is needed in your code. Use the addSvgIcon method to import the SVG file in cache. When the SVG is cached, it can be used anywhere in the application. The icon name and file URL path are the method's mandatory parameters; family can be specified as well. After that, you can use the SVG files in the HTML markup. Alternatively, you can use the addSvgIconFromText method to import an SVG file, providing the SVG text content instead of the file URL. Have in mind that if there are two icons with the same name and the same family, the SVG icon will be displayed with priority. It is better not to provide image width and height in the SVG file. You may need additional polyfill scripts (\"polyfills\") for Internet Explorer. constructor(private iconService: IgxIconService) { } public ngOnInit() { // register custom SVG icons this.iconService.addSvgIcon('contains', '/assets/images/svg/contains.svg', 'filter-icons'); } <igx-icon name=\"contains\" family=\"filter-icons\"></igx-icon> Material Symbols Additionally, users can take advantage of the latest Material icons and their design variations included in the newly created Material Symbols Library. To start using Material Symbols, first you have to add the library to your application: <link href=\"https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200\" rel=\"stylesheet\" /> Then we need to inject the IgxIconService dependency and make use of its registerFamilyAlias method so that Material Symbols can work with igx-icon: constructor(private iconService: IgxIconService) { } public ngOnInit() { // registers a 'material-symbols-outlined' class to be applied to all igx-icons with 'material-symbols' font-family this.iconService.registerFamilyAlias('material-symbols', 'material-symbols-outlined'); } Now, we are ready to add the desired icon into our markup and customize it using adjustable font styles: <igx-icon family=\"material-symbols\" class=\"custom-icon\">diamond</igx-icon> .custom-icon { font-variation-settings: 'FILL' 0, 'wght' 200, 'GRAD' 0, 'opsz' 40 } To learn more about Material Symbols styles please visit their official documentation. Server-side Rendering Note Note In case you have implemented server side rendering logic in your application using Angular Universal and have used the IgxIconService to register icons, this may cause the following exception: XMLHttpRequest is not defined. Could not fetch SVG from url. In order to avoid this, execute the listed steps: Install `xmlhttprequest`: npm i xmlhttprequest On the top of your `server.ts` file, add: (global as any).XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest; Styling To get started with styling the icons, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the icon-theme and accepts the parameters, required to customize the icon as desired. $custom-icon-theme: icon-theme( $color: #1481b8, $disabled-color: #494949 ); Using CSS variables The last step is to pass the custom icon theme in our application: @include css-vars($custom-icon-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include icon($custom-icon-theme); } } Demo Custom sizing You can either use the --size variable, targeting the igx-icon directly: igx-icon { --size: 50px; } Or you can use the universal --igx-icon-size variable to target all instances: <div class=\"my-app\"> <igx-icon></igx-icon> </div> .my-app { --igx-icon-size: 50px; } You can also use one of the predefined sizes, assigning it to the --ig-size variable. The available values for --ig-size are --ig-size-small, --ig-size-medium, and --ig-size-large: igx-icon { --ig-size: var(--ig-size-medium); } Learn more about it in the Size article. API References IgxIconComponent IgxIconComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/icon-button.html": {
    "href": "components/icon-button.html",
    "title": "Angular Icon Button Component – Ignite UI for Angular",
    "keywords": "Angular Icon Button Overview The Ignite UI for Angular Icon Button directive is intended to turn any icon into a fully functional button. The igxIconButton comes in three types - flat, outlined, and contained which is the default one. Angular Icon Button Example Getting Started with Ignite UI for Angular Icon Button To get started with the Ignite UI for Angular Icon Button directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxIconButtonDirective as a standalone dependency: // home.component.ts ... import { IgxIconButtonDirective } from 'igniteui-angular'; // import { IgxIconButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button igxIconButton=\"outlined\"> <igx-icon>home</igx-icon> </button>`, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxIconButtonDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Icon Button directive imported, you can start using the igxIconButton directive on elements. Angular Icon Button Types Flat Icon Button Use the igxIconButton directive to add a simple flat icon button in your component template: <button igxIconButton=\"flat\"> <igx-icon>edit</igx-icon> </button> Contained Icon Button All you have to do to create a contained icon button is to change the value of the igxIconButton property. Note that if you do not choose a type, by default it will also be set to contained. <button igxIconButton> <igx-icon>favorite</igx-icon> </button> Outlined Icon Button Analogically, we can switch to outlined type: <button igxIconButton=\"outlined\"> <igx-icon>more_vert</igx-icon> </button> Examples Disabled Icon Button If you want to disable an icon button, you can use the disabled property. In this sample we also demonstrate how to use icons from different families with the igxIconButton directive: <button igxIconButton=\"flat\" disabled> <igx-icon family=\"fa\" name=\"fa-home\"></igx-icon> </button> SVG Icons In addition to material icons, the igxIconButton directive also supports usage of SVG images as icons. To do so, first we should inject the IgxIconService dependency and then use the addSvgIcon method to import the SVG file in cache. For further information, you can read the SVG section in the icon topic. constructor(private _iconService: IgxIconService) { } public ngOnInit() { // register custom SVG icon this._iconService.addSvgIcon('rain', 'assets/images/card/icons/rain.svg', 'weather-icons'); } <button igxIconButton> <igx-icon family=\"weather-icons\" name=\"rain\"></igx-icon> </button> Size Users can choose one of the three predefined igxIconButton sizes by using the --ig-size custom CSS property. By default, the size of the component is set medium. As you can see from the sample above, we can also use the igxIconButton directive to turn elements like span and div into Ignite UI for Angular styled icon buttons. Angular Icon Button Styling Following the simplest approach, we use CSS variables to customize the appearance of the icon button: [igxIconButton=\"contained\"] { --background: #011627; --foreground: #fefefe; --hover-foreground: #011627dc; --hover-background: #ecaa53; --focus-foreground: #011627dc; --focus-background: #ecaa53; --focus-border-color: #0116276c; --active-foreground: #011627dc; --active-background: #ecaa53; } Take a look at the icon-button-theme section for a complete list of available parameters for styling any type of icon button. API References IgxIconButtonDirective IgxIconButton Styles IgxRippleDirective Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/input-group.html": {
    "href": "components/input-group.html",
    "title": "Angular Input Group Component | Ignite UI for Angular",
    "keywords": "Angular Input Group Component Overview The IgxInputGroupComponent allows the user to enhance input elements like input, select, textarea, etc. This can be achieved by adding custom content like text, icons, buttons, custom validation, floating label, etc., on either side of them, as a prefix, suffix, or hint. Angular Input Group Example Getting Started with Ignite UI for Angular Input Group To get started with the Ignite UI for Angular Input Group component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxInputGroupModule in your app.module.ts file. Note that the IgxInputGroupComponent also depends on the Angular FormsModule in order to have a working Template Driven Form: // app.module.ts import { FormsModule } from '@angular/forms'; import { IgxInputGroupModule } from 'igniteui-angular'; // import { IgxInputGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, FormsModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxInputGroupComponent as a standalone dependency, or use the IGX_INPUT_GROUP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_INPUT_GROUP_DIRECTIVES, IgxIconComponent } from 'igniteui-angular'; // import { IGX_INPUT_GROUP_DIRECTIVES, IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-input-group> <igx-prefix>+359</igx-prefix> <label igxLabel for=\"phone\">Phone</label> <input igxInput [(ngModel)]=\"value\" name=\"phone\" type=\"tel\" maxlength=\"9\" /> <igx-icon igxSuffix>phone</igx-icon> </igx-input-group> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_INPUT_GROUP_DIRECTIVES, IgxIconComponent, FormsModule] /* or imports: [IgxInputGroupComponent, IgxPrefixDirective, IgxLabelDirective, IgxInputDirective, IgxIconComponent, IgxSuffixDirective, FormsModule] */ }) export class HomeComponent { public value = '123456789'; } Now that you have the Ignite UI for Angular Input Group module or directives imported, you can start using the igx-input-group component. Note To use any of the directives igxInput, igxLabel, igx-prefix, igx-suffix or igx-hint, you have to wrap them in an <igx-input-group> container. Using the Angular Input Group Label & Input You can read about the igxLabel and igxInput directives as well as their validation, data binding and API in a separate topic here. Prefix & Suffix The igx-prefix or igxPrefix and igx-suffix or igxSuffix directives can contain or be attached to HTML elements, strings, icons or even other components. In the following sample we will create a new input field with a string prefix and an icon suffix: <igx-input-group> <igx-prefix>+359</igx-prefix> <label igxLabel for=\"phone\">Phone</label> <input igxInput name=\"phone\" type=\"tel\" maxlength=\"9\" /> <igx-icon igxSuffix>phone</igx-icon> </igx-input-group> Hints The igx-hint directive provides a helper text placed below the input. It can be at the beginning or at the end of the input depending on the value of the position property. Let's add a hint to our phone input: <igx-input-group> <igx-prefix>+359</igx-prefix> <label igxLabel for=\"phone\">Phone</label> <input igxInput name=\"phone\" type=\"tel\" /> <igx-suffix> <igx-icon>phone</igx-icon> </igx-suffix> <igx-hint position=\"start\">Ex.: +359 888 123 456</igx-hint> </igx-input-group> This is how the phone field with hint looks: Input Types & Input Group Type Token The input group styles can be altered by using the type property of the igxInputGroup component. The input group component supports the following types: line (default if type is not specified), border, box, and search. The line, border, and box types are made specifically for the Material Design themes. Setting those types with other themes will not have any effect on how the input group looks. An example of setting a specific type declaratively: <igx-input-group type=\"border\"> Using the IGX_input-group_TYPE injection token allows to specify a type on an application level for all input-group instances. It provides an easy way to style all related components at once. To set the type, use the IGX_input-group_TYPE injection token to create a DI provider. providers: [{provide: IGX_input-group_TYPE, useValue: 'box' }] Note The type property has precedence over a IGX_INPUT_GROUP_TYPE, thus a token value can be overridden on a component level if the type property is set explicitly. Most of the igniteui-angular form controls use input-group component internally, or allow for a custom template. Setting a global token will affect these components as well. Ignite UI for Angular also provides styling for the input of type=\"file\" and it supports all the input group types and themes, just add this to your template: <igx-input-group> <input igxInput type=\"file\" multiple /> </igx-input-group> Input Group Theme The input group component supports several themes - material, fluent, bootstrap, and indigo-design; The theme is automatically set during component initialization and is inferred from the currently used stylesheet. If you plan to support several themes in your application with runtime switching, you can explicitly set the theme using the theme Input property. <igx-input-group theme=\"fluent\">...</igx-input-group> Typed Forms The Ignite UI for Angular Input Group component can be used inside strictly typed reactive forms which are the default ones as of Angular 14. To find out more about the typed forms, you can check Angular official documentation. Validation The following samples demonstrate how to configure input validation when using template-driven or reactive forms. Template-Driven Forms Template-driven form validation is achieved by adding validation attributes, i.e., required, minlength, etc., to the input element. <form> <igx-input-group> <label igxLabel for=\"username\">Username</label> <input igxInput name=\"username\" type=\"text\" required /> </igx-input-group> <igx-input-group> <label igxLabel for=\"email\">Email</label> <input igxInput name=\"email\" type=\"email\" required email /> </igx-input-group> <igx-input-group> <label igxLabel for=\"password\">Password</label> <input igxInput name=\"password\" type=\"password\" required minlength=\"8\" /> </igx-input-group> <button igxButton=\"contained\" igxRipple type=\"submit\">Submit</button> </form> The required attribute adds an asterisk next to the label, indicating that this field must be filled in. Furthermore, when the input has additional validation applied to it, such as email and minlength, this could allow the developer to notify the end user for additional requirements via the igx-hint directive. The following example uses two-way data binding and demonstrates how to inspect the control's state by exporting the ngModel to a local variable. <form #login=\"ngForm\"> ... <igx-input-group> <label igxLabel for=\"email\">Email</label> <input igxInput name=\"email\" type=\"email\" [(ngModel)]=\"user.email\" #email=\"ngModel\" required email /> <igx-hint *ngIf=\"email.errors?.email\">Please enter a valid email</igx-hint> </igx-input-group> <igx-input-group> <label igxLabel for=\"password\">Password</label> <input igxInput name=\"password\" type=\"password\" [(ngModel)]=\"user.password\" #password=\"ngModel\" required minlength=\"8\" /> <igx-hint *ngIf=\"password.errors?.minlength\">Password should be at least 8 characters</igx-hint> </igx-input-group> <button igxButton=\"contained\" igxRipple type=\"submit\">Submit</button> </form> The user should not be able to submit the form if any of the form controls in it are invalid. This could be achieved by enabling/disabling the submit button based on the form's state. The following example demonstrates how to inspect the form's state by exporting the ngForm to a local variable. <form #registrationForm=\"ngForm\"> <igx-input-group> <label igxLabel for=\"email\">Email</label> <input igxInput name=\"email\" type=\"email\" [(ngModel)]=\"user.email\" #email=\"ngModel\" required email /> <igx-hint *ngIf=\"email.errors?.email\">Please enter a valid email</igx-hint> </igx-input-group> ... <button igxButton=\"contained\" igxRipple type=\"submit\" [disabled]=\"!registrationForm.valid\">Submit</button> </form> The result from the above configurations could be seen in the below sample. Start typing into the Email and Password fields and you will notice that the igx-hint is shown if the entered values are invalid. The sample also demonstrates how to toggle the password's visibility by using the igx-icon and the igx-suffix directive. Reactive Forms Reactive form validation is achieved by adding validator functions directly to the form control model in the component class. After creating the control in the component class, it should be associated with a form control element in the template. public registrationForm: FormGroup<User>; constructor(fb: FormBuilder) { this.registrationForm = fb.group({ username: ['', { nonNullable: true, validators: [Validators.required] }], email: ['', { nonNullable: true, validators: [Validators.required, Validators.email] }], password: ['', { nonNullable: true, validators: [Validators.required, Validators.minLength(8)] }] }); } <form [formGroup]=\"registrationForm\"> <igx-input-group> <label igxLabel for=\"username\">Username</label> <input igxInput name=\"username\" type=\"text\" formControlName=\"username\" /> </igx-input-group> <igx-input-group> <label igxLabel for=\"email\">Email</label> <input igxInput name=\"email\" type=\"email\" formControlName=\"email\" /> </igx-input-group> <igx-input-group> <label igxLabel for=\"password\">Password</label> <input igxInput name=\"password\" type=\"password\" formControlName=\"password\" /> </igx-input-group> <button igxButton=\"contained\" igxRipple type=\"submit\">Submit</button> </form> Similar to the template-driven form sample, when having additional validation like email and minlength, an igx-hint directive could be used to notify the end user if the validation has failed. The following example demonstrates how to access the control through a get method and inspect its state. It also demonstrates how to enable/disable the submit button by inspecting the state of the FormGroup. public get email() { return this.registrationForm.get('email'); } public get password() { return this.registrationForm.get('password'); } <form [formGroup]=\"registrationForm\"> ... <igx-input-group> <label igxLabel for=\"email\">Email</label> <input igxInput name=\"email\" type=\"email\" formControlName=\"email\" /> <igx-hint *ngIf=\"email.errors?.email\">Please enter a valid email</igx-hint> </igx-input-group> <igx-input-group> <label igxLabel for=\"password\">Password</label> <input igxInput name=\"password\" type=\"password\" formControlName=\"password\" /> <igx-hint *ngIf=\"password.errors?.minlength\">Password should be at least 8 characters</igx-hint> </igx-input-group> <button igxButton=\"contained\" igxRipple type=\"submit\" [disabled]=\"!registrationForm.valid\">Submit</button> </form> The result from the above configurations could be seen in the below sample. Similar to the template-driven form sample, it also demonstrates how to toggle the password's visibility by using the igx-icon and the igx-suffix directive. Custom Validators Some input fields may require custom validation and this could be achieved via custom validators. When the value is invalid, the validator will generate a set of errors that could be used to display a specific error message. Below is an example of a simple custom reactive form validator that validates if the entered email address contains a predefined value and generates different errors based on where the value occurs. public registrationForm: FormGroup<User>; constructor(fb: FormBuilder) { this.registrationForm = fb.group({ email: ['', { nonNullable: true, validators: [ Validators.required, Validators.email, this.emailValidator('infragistics') ] }], ... }); } private emailValidator(val: string): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const value = control.value?.toLowerCase(); const localPartRegex = new RegExp(`(?<=(${val})).*[@]`); const domainRegex = new RegExp(`(?<=[@])(?=.*(${val}))`); const returnObj: ValidatorErrors = {}; if (value && localPartRegex.test(value)) { returnObj.localPart = true; } if (value && domainRegex.test(value)) { returnObj.domain = true; } return returnObj; } } Cross-Field Validation In some scenarios, the validation of one control may depend on the value of another one. To evaluate both controls in a single custom validator the validation should be performed in a common ancestor control, i.e., the FormGroup. The validator retrieves the child controls by calling the FormGroup's get method, compares the values and if the validation fails, a set of errors is generated for the FormGroup. This will set only the form's state to invalid. To set the control's state, we could use the setErrors method and add the generated errors manually. Then, when the validation is successful, the errors could be removed by using the setValue method that will rerun the control's validation for the provided value. The below example demonstrates a cross-field validation where the Password should not contain the Email address and the Repeat password should match the Password. private passwordValidator(): ValidatorFn { return (control: AbstractControl): ValidationErrors | null => { const email = control.get('email'); const password = control.get('password'); const repeatPassword = control.get('repeatPassword'); const returnObj: ValidatorErrors = {}; if (email.value && password.value && password.value.toLowerCase().includes(email.value)) { password.setErrors({ ...password.errors, containsEmail: true }); returnObj.containsEmail = true; } if (password && repeatPassword && password.value !== repeatPassword.value) { repeatPassword.setErrors({ ...repeatPassword.errors, mismatch: true }); returnObj.mismatch = true; } if (!returnObj.containsEmail && password.errors?.containsEmail) { password.setValue(password.value); } if (!returnObj.mismatch && repeatPassword.errors?.mismatch) { repeatPassword.setValue(repeatPassword.value); } return returnObj; } } To add the custom validator to the FormGroup it should be passed as a second argument when creating the form. public registrationForm: FormGroup<User>; constructor(fb: FormBuilder) { this.registrationForm = fb.group({ email: ['', { nonNullable: true, validators: [ Validators.required, Validators.email, this.emailValidator('infragistics') ] }], ... }, { validators: [this.passwordValidator()] }); } The below sample demonstrates how the built-in validators could be used in combination with the custom emailValidator and cross-field passwordValidator from the previous examples. Styling The first thing we need to do, in order to get started with the input group styling, is to include the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Next, we have to create a new theme that extends the input-group-theme and pass the parameters which we'd like to change: $custom-input-group: input-group-theme( $filled-text-color: #288a54, $focused-text-color: #174f30, $idle-text-color: #288a54, $idle-bottom-line-color: #288a54, $interim-bottom-line-color: #288a54, $hover-bottom-line-color: #288a54, $focused-secondary-color: #174f30, $box-background: #eeeeee ); Using CSS variables The last step is to include the newly created theme: @include css-vars($custom-input-group); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use the input group mixin, since it doesn't support CSS variables. However, if we just leave the include statement, as shown in the previous step, our styles will not properly apply - while our text color has properly changed, the bottom border and the background remain the same. This is because our component is using the Emulated ViewEncapsulation. The input and label elements are part of that view, so their styles are applied correctly. The bottom border, on the other hand, is generated by the igx-input-group component and is not affected by the styles of our component. In order to style the border, we have to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, we also need to make sure that we scope the styles with a :host selector before the ::ng-deep: :host { ::ng-deep { @include input-group($custom-input-group); } } Demo API References IgxInputDirective IgxHintDirective IgxInputGroup Types IgxInputGroupComponent IgxInputGroupComponent Styles Theming Dependencies IgxButton Theme IgxIcon Theme Additional Resources Related topics: Label & Input Reactive Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/interactivity/accessibility-compliance.html": {
    "href": "components/interactivity/accessibility-compliance.html",
    "title": "Ignite UI for Angular Accessibility Compliance | Ignite UI for Angular | Infragistics",
    "keywords": ".greenCheck { content:url(\"../../images/general/greenCheck.png\"); } .redCheck { content:url(\"../../images/general/redX.png\"); } Accessibility Compliance As the leading global provider of UI and UX tools for developers, our Angular team at Infragistics is committed to providing components and tools that make it easier for you to create the best possible user experience. Our goal is to enable you to focus on crafting the best applications and the best user experience for all users. Here you can find specific information regarding the accessibility support and compliance for our Angular grids, charts, and UI components and controls within Ignite UI for Angular. Section 508 Compliance Section 508 of the Rehabilitation Act was amended in 1998 by Congress to require all Federal agencies to make their electronic and information technology accessible to people with disabilities. Since then, Section 508 compliance has not only been a requirement in government agencies, but it's also important when providing software solutions and designing Web pages. Section 1194.22 of the Section 508 law specifically targets Web-based intranet and internet information and systems, and contains a set of 16 rules to follow. In order to enable you to keep your Web applications and Web sites compatible with these rules with minimal effort on your part, Infragistics has taken steps to ensure that the Ignite UI for Angular controls and components are compliant with the relevant accessibility rules. The matrix below provides a high-level outline of the accessibility support provided by our visual controls (and related components). To learn more about an individual control/component's accessibility compliance, click the name of the control/component. Ignite UI for Angular Compliance with Section 508 Component/Principle (a) (b) (c) (d) (e) (f) (g) (h) (i) (j) (k) (l) (m) (n) (o) (p) Grids - Grid * - HierarchicalGrid * - TreeGrid * Other * - Avatar - Badge - Banner * - Bottom navigation * - Button * - Button group * - Calendar * - Card - Carousel * - Checkbox - Chip * - Circular progress * - Combo * - Date time editor * - Date picker * - Divider - Dialog * - Drop down * - Expansion panel * - Icon - Input - Input group * - Label - Linear progress * - List - Month picker * - Navbar * - Navigation drawer * - Radio group - Radio - Select * - Slider * - Snackbar * - Switch * - Tabs * - Time picker * - Toast * - Tooltip * LEGEND The control/component is completely accessible in this particular area. * The control/component is accessible in this particular area after implementing certain configurations Example: Use NoopAnimationsModule utility module to allow disabling of animations The control/component is not entirely accessible unless you perform some sort of action. 'white space' this particular rule does not apply to the control Warning The table above is relevant only to the Default theme of Ignite UI for Angular theming library. The checklist compliance might be different when it comes to custom themes, typography and any visual changes related to animations and colors. Compliance Information a - A text equivalent for every non-text element shall be provided (e.g., via \"alt\", \"longdesc\", or in element content). b - Equivalent alternatives for any multimedia presentation shall be synchronized with the presentation. c - Web pages shall be designed so that all information conveyed with color is also available without color, for example from context or markup. d - Documents shall be organized so they are readable without requiring an associated style sheet. e - Redundant text links shall be provided for each active region of a server-side image map. f - Client-side image maps shall be provided instead of server-side image maps except where the regions cannot be defined with an available geometric shape. g - Row and column headers shall be identified for data tables. h - Markup shall be used to associate data cells and header cells for data tables that have two or more logical levels of row or column headers. i - Frames shall be titled with text that facilitates frame identification and navigation. j - Pages shall be designed to avoid causing the screen to flicker with a frequency greater than 2 Hz and lower than 55 Hz. k - A text-only page, with equivalent information or functionality, shall be provided to make a web site comply with the provisions of this part, when compliance cannot be accomplished in any other way. The content of the text-only page shall be updated whenever the primary page changes. l - When pages utilize scripting languages to display content, or to create interface elements, the information provided by the script shall be identified with functional text that can be read by assistive technology. m - When a web page requires that an applet, plug-in or other application be present on the client system to interpret page content, the page must provide a link to a plug-in or applet that complies with §1194.21(a) through l. n - When electronic forms are designed to be completed on-line, the form shall allow people using assistive technology to access the information, field elements, and functionality required for completion and submission of the form, including all directions and cues. o - A method shall be provided that permits users to skip repetitive navigation links. p - When a timed response is required, the user shall be alerted and given sufficient time to indicate more time is required. WCAG compliance WCAG is simply a set of formal guidelines on how to develop accessible web content. These standards represent a higher level of accessibility than 508 standards, although they are identical or very similar. WCAG focuses primarily on HTML accessibility. Component/Guideline 1.1 1.2 1.3 1.4 2.1 2.2 2.3 2.4 2.5 3.1 3.2 3.3 4.1 Grids - Grid * * - HierarchicalGrid * * - TreeGrid * * Other * - Avatar * - Badge * - Banner * * * - Bottom navigation * * - Button * * - Button group * * - Calendar * * * - Card * - Carousel * * * - Checkbox * - Chip * * - Circular progress * * * - Combo * * * - Date time editor * * * - Date picker * * * - Divider * - Dialog * * * - Drop down * * * - Expansion panel * * * - Icon * - Input * - Input group * * - Label * - Linear progress * * * - List * - Month picker * * * - Navbar * * - Navigation drawer * * * - Radio group * - Radio * - Select * * * - Slider * * - Snackbar * * * - Switch * * - Tabs * * - Time picker * * * - Toast * * * - Tooltip * * * Legend The control/component is completely accessible in this particular area. * The control/component is accessible in this particular area after implementing certain configurations Example 1: Guideline 2.2. For certain components additional actions and time parameters should be set; Example 2: Guideline 2.3. Use NoopAnimationsModule utility module to allow disabling of animations; The control/component is not entirely accessible unless you perform some sort of action. 'white space' this particular rule does not apply to the control Warning The table above is relevant only to the Default theme of Ignite UI for Angular theming library. The checklist compliance might be different when it comes to custom themes, typography and any visual changes related to animations and colors. Compliance Information Principle 1 - Perceivable - Information and user interface components must be presentable to users in ways they can perceive Guideline 1.1 – Text Alternatives - Provide text alternatives for any non-text content so that it can be changed into other forms people need, such as large print, braille, speech, symbols or simpler language. Guideline 1.2 – Time-based Media - Provide alternatives for time-based media. Guideline 1.3 – Adaptable - Create content that can be presented in different ways (for example simpler layout) without losing information or structure. Guideline 1.4 – Distinguishable - Make it easier for users to see and hear content including separating foreground from background. Principle 2 – Operable - User interface components and navigation must be operable. Guideline 2.1 – Keyboard Accessible - Make all functionality available from a keyboard. Guideline 2.2 – Enough Time - Provide users enough time to read and use content. Guideline 2.3 – Seizures and Physical Reactions - Do not design content in a way that is known to cause seizures or physical reactions. Guideline 2.4 – Navigable - Provide ways to help users navigate, find content, and determine where they are. Guideline 2.5 – Input Modalities - Make it easier for users to operate functionality through various inputs beyond keyboard. Principle 3 – Understandable - Information and the operation of the user interface must be understandable. Guideline 3.1 – Readable - Make text content readable and understandable. Guideline 3.2 – Predictable - Make Web pages appear and operate in predictable ways. Guideline 3.3 – Input Assistance - Help users avoid and correct mistakes. Principle 4 – Robust - Content must be robust enough that it can be interpreted by a wide variety of user agents, including assistive technologies. Guideline 4.1 – Compatible - Maximize compatibility with current and future user agents, including assistive technologies WAI-ARIA Support In 2014 the W3C finalized their WAI-ARIA specification which defined how to design Web content and Web applications to be more accessible to users with disabilities. This section shows the accessibility (ARIA) support of the framework as well as how easily manageable the directionality of the components is. Enabling right-to-left direction (RTL) Ignite UI for Angular library is susceptible to directionality manipulation only when setting dir attribute on either html or body tags. With that being said, let's move to the following example: <html dir=\"rtl\"> ... <body dir=\"ltr\"> </body> </html> Note The precedence takes the inner tag which in the above case is the attribute at the body tag. RTL Support Right-to-left (RTL) direction is fully supported in all Ignite UI themes by default. Note Currently the Igx-Grid component have only partial RTL support. View page on GitHub"
  },
  "components/interactivity/right-to-left-support.html": {
    "href": "components/interactivity/right-to-left-support.html",
    "title": "Ignite UI for Angular Frameworks and features | Ignite UI for Angular | Infragistics",
    "keywords": "Right to Left (RTL) Support RTL Support Most of the components in the framework have full right-to-left (RTL) support by default. To switch to RTL direction you have to just set the dir attribute of the html or the body tag to rtl. Example: // $direction defaults to ltr if it's omitted. @include igx-core($direction: rtl); Currently the following components have only partial RTL support: Grid (igx-grid) RTL Example This section shows the accessibility (ARIA) support of the framework as well as how easily manageable the directionality of the components is. Enabling right-to-left direction (RTL). Ignite UI for Angular library is susceptible to directionality manipulation only when setting dir attribute on either html or body tags. Also, keep in mind that runtime changes are not detected. With that being said, let's move to the following example: Step 1 - Setting the 'dir' attribute on both tags. <html dir=\"rtl\"> ... </html> or <html> <body dir=\"ltr\"> ... </body> </html> Note Currently the Igx-Grid component only has partial(visual) RTL support. Note Breaking Changes in version 13.2.0 All RTL specific stylesheets have been removed, therefore, users who have previously used *-rtl.css specific themes must switch to the regular theme files. View page on GitHub"
  },
  "components/label-input.html": {
    "href": "components/label-input.html",
    "title": "Angular Label and Input Directives",
    "keywords": "Angular Label & Input Directives Overview The Ignite UI for Angular Input and Label directives are used to decorate and style single-line or multi-line input elements in an igx-input-group component. Angular Label & Input Example Getting Started with Ignite UI for Angular Label & Input To get started with the Ignite UI for Angular Label and Input directives, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxInputGroupModule in your app.module.ts file. // app.module.ts import { FormsModule } from '@angular/forms'; import { IgxInputGroupModule } from 'igniteui-angular'; // import { IgxInputGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, FormsModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxLabelDirective, IgxInputDirective, and IgxInputGroupComponent as standalone dependencies, or use the IGX_INPUT_GROUP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_INPUT_GROUP_DIRECTIVES } from 'igniteui-angular'; // import { IGX_INPUT_GROUP_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-input-group> <input igxInput name=\"fullName\" type=\"text\" [(ngModel)]=\"fullName\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_INPUT_GROUP_DIRECTIVES, FormsModule] /* or imports: [IgxInputGroupComponent, IgxLabelDirective, IgxInputDirective, FormsModule] */ }) export class HomeComponent { public fullName = 'John Doe'; } Now that you have the Ignite UI for Angular Input Group module or directives imported, you can start using the igxLabel and igxInput directives and the igx-input-group component. Using the Angular Label & Input The default styling of the Label and Input directives follows the text fields specification in the Material Design guidelines. To use the igxInput and igxLabel, you have to wrap them in an <igx-input-group> container: <igx-input-group> <input igxInput name=\"fullName\" type=\"text\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> The igxInput directive could be applied to <input> and <textarea> HTML elements, in both single-line and multi-line text fields. Validation We can validate an input using the required attribute. This will add an asterisk next to the label, indicating that this field must be completed. The input will turn green/red depending on whether the validation passes/fails. <igx-input-group> <input igxInput name=\"fullName\" type=\"text\" required=\"required\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> Data Binding The Ignite UI for Angular Input directive supports both one-way and two-way data-binding. The following code illustrates how to add a two-way data-binding using the NgModel: public user = { fullName: \"\" }; in our markup: <igx-input-group> <input igxInput name=\"fullName\" type=\"text\" [(ngModel)]=\"user.fullName\" required=\"required\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> Focus & Text Selection You can add logic to force focus on input elements using the igxFocus directive. <igx-input-group> <input igxInput [igxFocus]=\"isFocused\" name=\"fullName\" type=\"text\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> Note To use the igxFocus directive, you have to import the IgxFocusModule. If you want the text in an input element, marked with igxInput, to be selected on focus, you have to enable the igxTextSelection directive. <igx-input-group> <input igxInput [igxTextSelection]=\"true\" [igxFocus]=\"isFocused\" name=\"fullName\" type=\"text\" /> <label igxLabel for=\"fullName\">Full Name</label> </igx-input-group> <igx-input-group> <input igxInput [igxTextSelection]=\"true\" name=\"email\" type=\"text\" /> <label igxLabel for=\"email\">Email</label> </igx-input-group> Note To use the igxTextSelection directive, you have to import the IgxTextSelectionModule. Input Group The Ignite UI for Angular Input Group component helps developers to create easy-to-use and aesthetic forms. For further information, you can read the separate topic here. API References IgxLabelDirective IgxInputDirective IgxInputGroupComponent Additional Resources Related topics: Input Group Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/layout.html": {
    "href": "components/layout.html",
    "title": "Angular Layout Manager Directives",
    "keywords": "Angular Layout Manager Directives Overview The Ignite UI for Angular Layout Directives allow developers to specify a layout direction for any children of the container it is applied to. Layout can flow vertically or horizontally, with controls for wrapping, justification, and alignment. Angular Layout Manager Example Usage Use the igxLayout directive on a container element to specify the layout direction for its children: Horizontally with Row direction Use igxLayoutDir=\"row\". Vertically with Column direction Use igxLayoutDir=\"column\". Note Reverse order using igxLayoutReverse=\"true\". Customize the order of the elements Customize the order of the element by using igxFlexOrder. Change element spacing Use igxLayoutJustify=\"space-between | space-around\". Position elements along the main axis Use igxLayoutJustify=\"flex-start | center | flex-end\" to specify the elements position along the main axis according to your preferences. Position elements along the cross axis Use igxLayoutItemAlign=\"flex-start | center | flex-end\" to specify the elements position along the cross axis according to your preferences. You can also wrap elements Use igxLayoutWrap=\"wrap\". Note The igxLayout directive affects the flow directions for that container's immediate children. Nesting Use the igxFlex directive for elements inside an igxLayout parent to control specific flexbox properties. API References IgxLayoutDirective IgxFlexDirective View page on GitHub"
  },
  "components/linear-gauge.html": {
    "href": "components/linear-gauge.html",
    "title": "Angular Linear Gauge | Data Visualization Tools | Infragistics",
    "keywords": "Angular Linear Gauge Overview The Ignite UI for Angular linear gauge component allows for visualizing data in the form of a linear gauge. The IgxLinearGaugeComponent provides a simple and concise view of a value compared against a scale and one or more ranges. It supports one scale, one set of tick marks and one set of labels. The component has also a built-in support for animated transitions. This animation is easily customizable by setting the transitionDuration property. The features of the linear gauge component include configurable orientation and direction, configurable visual elements such as the needle, and more. Angular Linear Gauge Example The following sample demonstrates how setting multiple properties on the same IgxLinearGaugeComponent can transform it to completely different linear gauge. Dependencies When installing the Angular gauge component, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-gauges Component Modules The IgxLinearGaugeComponent requires the following modules: // app.module.ts import { IgxLinearGaugeModule } from 'igniteui-angular-gauges'; @NgModule({ imports: [ // ... IgxLinearGaugeModule // ... ] }) export class AppModule {} Usage The following code demonstrates how create a linear gauge containing a needle and three comparative ranges on the scale. <igx-linear-gauge width=\"700px\" height=\"30px\" minimumValue = \"5\" maximumValue = \"55\" value = \"43\"> <igx-linear-graph-range startValue=\"0\" endValue=\"15\" brush=\"red\"> </igx-linear-graph-range> <igx-linear-graph-range startValue=\"15\" endValue=\"30\" brush=\"yellow\"> </igx-linear-graph-range> <igx-linear-graph-range startValue=\"30\" endValue=\"55\" brush=\"green\"> </igx-linear-graph-range> </igx-linear-gauge> Needle This is the primary measure displayed by the linear gauge component and is visualized as a bar or you can customize it to show almost any shape as is demonstrated below. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 maximumValue=100 interval=10 value=50 isNeedleDraggingEnabled=true needleShape=\"Custom\" needleBrush=\"DodgerBlue\" needleOutline=\"DodgerBlue\" needleStrokeThickness=1 needleBreadth=15 needleInnerExtent=0.35 needleOuterExtent=0.65 needleOuterPointExtent=0.8 needleInnerPointExtent=0.325 needleInnerPointWidth=0 needleOuterPointWidth=0.3 needleInnerBaseWidth=0 needleOuterBaseWidth=0.07> </igx-linear-gauge> Ranges The ranges are visual elements that highlight a specified range of values on a scale. Their purpose is to visually communicate the qualitative state of the performance bar measure, illustrating at the same times the degree to which it resides within that state. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100 interval=10 rangeBrushes=\"#a4bd29, #F86232\" rangeOutlines=\"#a4bd29, #F86232\" > <igx-linear-graph-range startValue=0 endValue=50 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.25 outerEndExtent=0.4> </igx-linear-graph-range> <igx-linear-graph-range startValue=50 endValue=100 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.4 outerEndExtent=0.55> </igx-linear-graph-range> </igx-linear-gauge> Tick Marks The tick marks serve as a visual division of the scale into intervals in order to increase the readability of the linear gauge. Major tick marks – The major tick marks are used as primary delimiters on the scale. The frequency they appear at, their extents and style can be controlled by setting their corresponding properties. Minor tick marks – The minor tick marks represent helper tick marks, which might be used to additionally improve the readability of the scale and can be customized in a way similar to the major ones. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100 interval=10 tickBrush=\"DodgerBlue\" ticksPreTerminal=0 ticksPostInitial=0 tickStrokeThickness=2 tickStartExtent=0.25 tickEndExtent=0.05 minorTickCount=4 minorTickBrush=\"DarkViolet\" minorTickEndExtent=0.05 minorTickStartExtent=0.15 minorTickStrokeThickness=1> </igx-linear-gauge> Labels The labels indicate the measures on the scale. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100 interval=10 labelInterval=10 labelExtent=0.025 labelsPreTerminal=0 labelsPostInitial=0 fontBrush=\"DodgerBlue\" font=\"11px Verdana\"> </igx-linear-gauge> Backing The backing element represents background and border of the linear gauge component. It is always the first element rendered and all the rest of elements such as labels, and tick marks are overlaid on top of it. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100 interval=10 backingBrush=\"#bddcfc\" backingOutline=\"DodgerBlue\" backingStrokeThickness=4 backingInnerExtent=0 backingOuterExtent=1> </igx-linear-gauge> Scale The scale is a visual element that highlights the full range of values in the linear gauge. You can customize the appearance and the shape of the scale. It can also be inverted (using isScaleInverted property) and all labels will be rendered from right-to-left instead of left-to-right. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 value=50 maximumValue=100 interval=10 isScaleInverted=false scaleBrush=\"DodgerBlue\" scaleOutline=\"DarkViolet\" scaleStrokeThickness=1 scaleInnerExtent=0.05 scaleOuterExtent=0.65 scaleStartExtent=0.05 scaleEndExtent=0.95> </igx-linear-gauge> Summary For your convenience, all above code snippets are combined into one code block below that you can easily copy to your project and see the linear gauge with all features and visuals enabled. <igx-linear-gauge height=\"80px\" width=\"400px\" minimumValue=0 maximumValue=100 labelInterval=10 labelExtent=0.025 labelsPreTerminal=0 labelsPostInitial=0 fontBrush=\"Black\" font=\"11px Verdana\" interval=10 tickBrush=\"Black\" ticksPreTerminal=0 ticksPostInitial=0 tickStrokeThickness=2 tickStartExtent=0.25 tickEndExtent=0.05 minorTickCount=4 minorTickBrush=\"Black\" minorTickEndExtent=0.05 minorTickStartExtent=0.15 minorTickStrokeThickness=1 value=50 isNeedleDraggingEnabled=true needleShape=\"Custom\" needleBrush=\"Black\" needleOutline=\"Black\" needleStrokeThickness=1 needleBreadth=15 needleInnerExtent=0.35 needleOuterExtent=0.65 needleOuterPointExtent=0.8 needleInnerPointExtent=0.325 needleInnerPointWidth=0 needleOuterPointWidth=0.3 needleInnerBaseWidth=0 needleOuterBaseWidth=0.07 isScaleInverted=false scaleBrush=\"Gray\" scaleOutline=\"Gray\" scaleStrokeThickness=1 scaleInnerExtent=0.05 scaleOuterExtent=0.65 scaleStartExtent=0.05 scaleEndExtent=0.95 backingBrush=\"#cecece\" backingOutline=\"#cecece\" backingStrokeThickness=4 backingInnerExtent=0 backingOuterExtent=1 rangeBrushes =\"#C62828, #F96232, #FF9800\" rangeOutlines=\"#C62828, #F96232, #FF9800\"> <igx-linear-graph-range startValue=0 endValue=50 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.25 outerEndExtent=0.4> </igx-linear-graph-range> <igx-linear-graph-range startValue=50 endValue=100 innerStartExtent=0.075 innerEndExtent=0.075 outerStartExtent=0.4 outerEndExtent=0.55> </igx-linear-graph-range> </igx-linear-gauge> API References The following is a list of API members mentioned in the above sections: IgxLinearGaugeComponent IgxLinearGraphRangeComponent Additional Resources You can find more information about other types of gauges in these topics: Bullet Graph Radial Gauge View page on GitHub"
  },
  "components/linear-progress.html": {
    "href": "components/linear-progress.html",
    "title": "Angular Linear Progress Component",
    "keywords": "Angular Linear Progress Component Overview The Ignite UI for Angular Linear Progress Bar Indicator component provides a visual indicator of an application’s process as it changes. The indicator updates its appearance as its state changes. The indicator can be styled with a choice of colors in stripes or solids. Angular Linear Progress Example Getting Started with Ignite UI for Angular Linear Progress To get started with the Ignite UI for Angular Linear Progress component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxProgressBarModule in the app.module.ts file: // app.module.ts ... import { IgxProgressBarModule } from 'igniteui-angular'; // import { IgxProgressBarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxProgressBarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxLinearProgressBarComponent as a standalone dependency, or use the IGX_LINEAR_PROGRESS_BAR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_LINEAR_PROGRESS_BAR_DIRECTIVES } from 'igniteui-angular'; // import { IGX_LINEAR_PROGRESS_BAR_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-linear-bar [value]=\"progress\"></igx-linear-bar>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_LINEAR_PROGRESS_BAR_DIRECTIVES] /* or imports: [IgxLinearProgressBarComponent] */ }) export class HomeComponent { public progress = 50; } Now that you have the Ignite UI for Angular Progress Bar module or directives imported, you can start using the igx-linear-bar component. Using the Angular Linear Progress To have a better understanding of how everything works, let's create a simple example, like the one in the demo: <igx-linear-bar [value]=\"100\"></igx-linear-bar> After that, you should see the demo sample in your browser. Progress Types You can set the type of your bar, using the type attribute. There are five types of linear progress bars - default, error, success, info, and warning. Striped Progress You can make the bar striped, using the striped property and by setting it to true. Let's see how we can create different types of progress bars that can be both striped or not. <div class=\"linear-container\"> <igx-linear-bar [value]=\"100\" type=\"default\"></igx-linear-bar> <igx-linear-bar [value]=\"100\" type=\"success\" [striped]=\"true\"></igx-linear-bar> <igx-linear-bar [value]=\"100\" type=\"error\"></igx-linear-bar> <igx-linear-bar [value]=\"100\" type=\"info\" [striped]=\"true\"></igx-linear-bar> <igx-linear-bar [value]=\"100\" type=\"warning\"></igx-linear-bar> </div> So if we set up everything correctly, you should see the following in your browser: Indeterminate Progress If you want to track a process that is not determined precisely, you can set the indeterminate input property to true. Animation Duration The animationDuration input property is used to specify how long the animation cycle should take. The following example specifies the animation duration set to 5 seconds. <igx-linear-bar [striped]=\"false\" [value]=\"100\" [animationDuration]=\"5000\"></igx-linear-bar> Text Properties You can align the text, using the textAlign property. Permitted values are left, center, and right. To hide the text, use the textVisibility property and set its value to false. Set the textTop property to true to move the text above the bar. The text property can be used to customize the value of the text itself. Let's update our previous sample by using the aforementioned text properties. We will also throw an indeterminate progress bar in the mix. <div class=\"linear-container\"> <igx-linear-bar type=\"default\" [value]=\"100\" ></igx-linear-bar> <igx-linear-bar type=\"success\" [value]=\"100\" class=\"indeterminate\" [indeterminate]=\"true\" [striped]=\"true\" ></igx-linear-bar> <igx-linear-bar type=\"error\" [value]=\"100\" [textAlign]=\"positionEnd\" [text]=\"'Custom text'\" ></igx-linear-bar> <igx-linear-bar type=\"info\" [value]=\"100\" [textVisibility]=\"false\" [striped]=\"true\" ></igx-linear-bar> <igx-linear-bar type=\"warning\" [value]=\"100\" [textTop]=\"true\" ></igx-linear-bar> </div> And do not forget to import the IgxTextAlign enumerator in your component if you're using the textAlign property. import { ..., IgxTextAlign } from 'igniteui-angular'; // import { ..., IgxTextAlign } from '@infragistics/igniteui-angular'; for licensed package ... public positionCenter: IgxTextAlign = IgxTextAlign.CENTER; public positionEnd: IgxTextAlign = IgxTextAlign.END; Let's take a look at how this turned out: Note If the step input value is not defined, the progress update is 1% of the max value. In case you want the progress to be faster, the step value should be greater than (max * 1%), respectfully for slower progress the step should be less than the default progress update. Note If the step value is defined greater than the value input, there is only one update, which gets the value that is passed for progress update. Dynamic Progress You can dynamically change the value of the progressbar by using external controls like buttons. To achieve this, we can bind the value to a class property: <div class=\"linear-container\"> <igx-linear-bar [value]=\"currentValue\" [max]=\"100\" ></igx-linear-bar> <div class=\"button-container\"> <button igxIconButton=\"flat\" (click)=\"decrementProgress()\"> <igx-icon fontSet=\"material\">remove</igx-icon> </button> <button igxIconButton=\"flat\" (click)=\"incrementProgress()\"> <igx-icon fontSet=\"material\">add</igx-icon> </button> </div> </div> Create the methods that increment and decrement the value: public currentValue: number; public ngOnInit() { this.currentValue = 0; } public incrementProgress() { this.currentValue += 10; if (this.currentValue > 100) { this.currentValue = 100; } } public decrementProgress() { this.currentValue -= 10; if (this.currentValue < 0) { this.currentValue = 0; } } After completing the steps above, our progressbar should look like this: Styling To get started with styling the linear progress bar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the progress-linear-theme and accepts the $track-color, $fill-color-default and $text-color parameters. $custom-theme: progress-linear-theme( $track-color: #D3D3D3, $fill-color-default: #ECAA53, $text-color: #ECAA53 ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include progress-linear($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include progress-linear($custom-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-theme); } Demo API IgxLinearProgressBarComponent IgxLinearProgressBarComponent Styles IgxTextAlign View page on GitHub"
  },
  "components/list.html": {
    "href": "components/list.html",
    "title": "Angular List View | Angular List Example | Infragistics",
    "keywords": "Angular List View Component Overview The Ignite UI for Angular List component displays rows of items and supports one or more header items as well as search and filtering of list items. Each list item is completely templatable and supports any valid HTML or Angular component. The list component also providers built in panning functionality, templates for empty and loading states, and supports virtualization for large lists using the IgxForOf directive. Angular List Example The following example represents a list populated with contacts with a name and a phone number properties. The IgxList component uses igx-avatar and igx-icon to enrich the user experience and expose the capabilities of setting avatar picture and different icon for favorite a contact. In addition, the List View expose sorting capabilities achieved by using our filtering pipe. Getting Started with Ignite UI for Angular List To get started with the Ignite UI for Angular List View component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxListModule in the app.module.ts file. Note This component requires HammerModule to be imported in the root module of the application in order for touch interactions to work as expected.. // app.module.ts import { HammerModule } from '@angular/platform-browser'; import { IgxListModule } from 'igniteui-angular'; // import { IgxListModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxListModule, HammerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxListComponent as a standalone dependency, or use the IGX_LIST_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { IGX_LIST_DIRECTIVES } from 'igniteui-angular'; // import { IGX_LIST_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-list> <igx-list-item isHeader=\"true\">Header</igx-list-item> <igx-list-item>Item 1</igx-list-item> <igx-list-item>Item 2</igx-list-item> <igx-list-item>Item 3</igx-list-item> </igx-list> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_LIST_DIRECTIVES, HammerModule] /* or imports: [IgxListComponent, IgxListItemComponent, HammerModule] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular List module or directives imported, you can start using the igx-list component. Using the Angular List Then in the template of our contacts component we can create our list, but what if currently (or at some point in the future) we have no items in it? In this case, the Angular list provides us with a default template that is used when the list is empty. We can always provide our own template for the look of our empty list by simply using the igxEmptyList directive. In this case, the default template will not be used: <!--contacts.component.html--> <igx-list> <ng-template igxEmptyList> <p class=\"empty\">No contacts! :(</p> </ng-template> </igx-list> And our style for the empty template: /* contacts.component.css */ .empty { color: rgba(0, 153, 255, 1); font-size: 25px; font-weight: 600; text-shadow: 2px 1px 2px rgba(150, 150, 150, 1); } If all went great, this is how our empty list should look like: Sometimes there may be a delay in your data loading. In this case you can set the list's isLoading property to true and a default template will inform the user regarding the ongoing data loading process. You can also provide your own loading template using the igxDataLoading directive: <!--contacts.component.html--> <igx-list> <ng-template igxDataLoading> <p class=\"loading\">Patience, we are currently loading your data...</p> </ng-template> </igx-list> /* contacts.component.css */ .loading { color: rgba(255, 153, 0, 1); font-size: 25px; font-weight: 600; text-shadow: 2px 1px 2px rgba(150, 150, 150, 1); } Add List Items It's nice having a template for when the list is empty, but now let's add some items! We can add the following code to get a simple list of items: <!--contacts.component.html--> <igx-list> <igx-list-item isHeader=\"true\">Header</igx-list-item> <igx-list-item>Item 1</igx-list-item> <igx-list-item>Item 2</igx-list-item> <igx-list-item>Item 3</igx-list-item> </igx-list> If all went well, you should see the following in your browser: Let's up our game a bit and enhance our list items. Say we want to create an Angular list of contacts with a name and a phone number displayed under the name. In our component typescript file we can define a list of contacts: // contacts.component.ts ... public contacts = [{ name: \"Terrance Orta\", phone: \"770-504-2217\" }, { name: \"Richard Mahoney\", phone: \"423-676-2869\" }, { name: \"Donna Price\", phone: \"859-496-2817\" }, { name: \"Lisa Landers\", phone: \"901-747-3428\" }, { name: \"Dorothy H. Spencer\", phone: \"573-394-9254\" }]; Now that we have some data we want to render, let's set up some markup. If we want some styling out of the box we can use some of the directives that come with the list items. Let's look at how we can use some of them in the next example: <!--contacts.component.html--> <igx-list> <igx-list-item isHeader=\"true\"> Contacts </igx-list-item> <igx-list-item *ngFor=\"let contact of contacts\"> <h4 igxListLineTitle>{{ contact.name }}</h4> <p igxListLineSubTitle>{{ contact.phone }}</p> </igx-list-item> </igx-list> Both directives igxListLineTitle and igxListLineSubTitle gives our list items some default look. After all that our Angular list should now look like that: Adding Avatar and Icons We can use some of our other components in conjunction with the IgxList component to enrich the experience and add some functionality. We can have a nice picture avatar to the left of the name and phone values. Additionally, we can add a star icon to the right of them to allow the user to favorite a contact. To do that let's grab the IgxAvatar and IgxIcon modules and import them in our app.module.ts file. // app.module.ts ... import { IgxListModule, IgxAvatarModule, IgxIconModule } from 'igniteui-angular'; // import { IgxListModule, IgxAvatarModule, IgxIconModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxAvatarModule, IgxIconModule], }) export class AppModule {} Next, we need to add some more information to our contact object, like a photo source for our avatar and a isFavorite property to indicate the contact's favorite status. // contacts.component.ts public contacts = [{ name: 'Terrance Orta', phone: '770-504-2217', photo: 'https://randomuser.me/api/portraits/men/27.jpg', isFavorite: false }, { name: 'Richard Mahoney', phone: '423-676-2869', photo: 'https://randomuser.me/api/portraits/men/1.jpg', isFavorite: true }, { name: 'Donna Price', phone: '859-496-2817', photo: 'https://randomuser.me/api/portraits/women/50.jpg', isFavorite: false }, { name: 'Lisa Landers', phone: '901-747-3428', photo: 'https://randomuser.me/api/portraits/women/3.jpg', isFavorite: false }, { name: 'Dorothy H. Spencer', phone: '573-394-9254', photo: 'https://randomuser.me/api/portraits/women/67.jpg', isFavorite: true }]; Cool, now let's update the template for our contacts list to show the avatar and icon. Again we can do that by using some of the list directives. <!--contacts.component.html--> <igx-list> <igx-list-item isHeader=\"true\"> Contacts </igx-list-item> <igx-list-item #item *ngFor=\"let contact of contacts;\"> <igx-avatar igxListThumbnail [src]=\"contact.photo\" shape=\"circle\"></igx-avatar> <h4 igxListLineTitle>{{ contact.name }}</h4> <p igxListLineSubTitle class=\"phone\">{{ contact.phone }}</p> <span igxListLine>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dicta, laborum.</span> <igx-icon igxListAction [color]=\"contact.isFavorite ? 'orange' : 'lightgray'\" (click)=\"toggleFavorite(item)\">star</igx-icon> </igx-list-item> </igx-list> igxListThumbnail is meant to be used if we need to add some kind of media at the beginning of our list items. The directive will wrap the target element in our case igx-avatar in a container that will provide some default position and spacing. igxListAction is meant to be used for list items that have some kind of action or metadata, for example, switch, radio-button, checkbox, etc. In our case the action is will be represented by an igx-icon. Again, the directive will wrap the target element in a container that will have the correct position and spacing. igxListLine is meant to be used if we need some text in-between igxListThumbnail and igxListAction the directive will make sure that the text position, spacing and alignment will look great with the other two directives around. Next we listen for a click event on the IgxIcon component to toggle the isFavorite property in our contact object. // contacts.component.ts ... toggleFavorite(item: IgxListItem) { const contact = this.contacts[item.index - 1]; contact.isFavorite = !contact.isFavorite; } Let's also allow the user to choose the size of the list by using the --ig-size CSS custom property. We will do this by importing the IgxButtonGroupModule and using the IgxButtonGroup to display all size values. This way whenever one gets selected, we will update the size of the list. // app.module.ts ... import { IgxButtonGroupModule } from 'igniteui-angular'; // import { IgxButtonGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [..., IgxButtonGroupModule] }) <!--contacts.component.html--> <igx-buttongroup [values]=\"sizes\" (selected)=\"selectSize($event)\"></igx-buttongroup> ... <igx-list> ... </igx-list> // contacts.component.ts public size = 'large'; public sizes; public ngOnInit() { this.sizes = [ { label: 'large', selected: this.size === 'large', togglable: true }, { label: 'medium', selected: this.size === 'medium', togglable: true }, { label: 'small', selected: this.size === 'small', togglable: true } ]; } public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } And here's the result of all that work: List Items Panning Now that we have such a beautiful Angular list with contacts and their phone numbers, why don't we implement an ability to call a contact. The IgxList has the perfect solution for this - list item panning. To do this you have to implement the following steps: Enable the panning using the allowLeftPanning and/or the allowRightPanning properties Define template(s) for the left and/or right panning Handle the list item's panning event(s) and perform the desired action The following example demonstrates how to handle both left and right panning. The event handler for right panning shows a toast message. The event handler for the left panning deletes an item from the IgxList. Note Please note that the list item removal is an application task. The IgxList itself cannot remove items from the data source because the IgxList does not have reference to the data source. Here is the HTML code of the example: <!-- contacts.component.html --> <igx-list [allowLeftPanning]=\"true\" [allowRightPanning]=\"true\" (leftPan)=\"leftPanPerformed($event)\" (rightPan)=\"rightPanPerformed($event)\"> <ng-template igxListItemLeftPanning> <div class=\"listItemLeftPanningStyle\"> <igx-icon [color]=\"white\" style=\"margin-left:10px\">delete</igx-icon>Delete </div> </ng-template> <ng-template igxListItemRightPanning> <div class=\"listItemRightPanningStyle\"> <igx-icon [color]=\"white\" style=\"margin-right:10px\">call</igx-icon>Dial </div> </ng-template> <igx-list-item isHeader=\"true\">Contacts</igx-list-item> <igx-list-item #item *ngFor=\"let contact of contacts\"> <igx-avatar igxListThumbnail [src]=\"contact.photo\" shape=\"circle\"></igx-avatar> <h4 igxListLineTitle>{{ contact.name }}</h4> <p igxListLineSubTitle class=\"phone\">{{ contact.phone }}</p> <igx-icon igxListAction [color]=\"contact.isFavorite ? 'orange' : 'lightgray'\" (click)=\"toggleFavorite(item)\">star</igx-icon> </igx-list-item> </igx-list> <igx-toast #toast></igx-toast> The above example is using some CSS styles which may be found here: /* contacts.component.css */ igx-icon { cursor: pointer; user-select: none; } .listItemLeftPanningStyle { display: flex; flex-direction: row-reverse; background-color:orange; color: white; width: 100%; padding-right: 10px; align-items: center; } .listItemRightPanningStyle { display: flex; flex-direction: row; background-color:limegreen; color: white; width: 100%; padding-left: 10px; align-items: center; } And finally here is the typescript code handling the panning events: // contacts.component.ts ... @ViewChild('toast') public toast: IgxToastComponent; public rightPanPerformed(args) { args.keepItem = true; this.toast.message = 'Dialing ' + this.contacts[args.item.index - 1].name; this.toast.open(); } public leftPanPerformed(args) { args.keepItem = false; setTimeout((idx = args.item.index - 1) => { this.toast.message = 'Contact ' + this.contacts[idx].name + ' removed.'; this.toast.open(); this.contacts.splice(idx, 1); }, 500); } ... Note When panning list items there is a threshold which must be reached in order for the panning events to be emitted. You can change the threshold using the IgxList's panEndTriggeringThreshold property. By default this property has a value of 0.5 which means 50% of list item's width. Now try panning the list items for yourself: Angular filter list Our list is looking good, but wouldn't it be even better if we could search for contacts by name? We can easily achieve that by using our filtering pipe. Let's do this. Let's add an input field to the top in our Angular component template first and bind it to a property in our component called searchContact: <!--contacts.component.html--> <igx-input-group type=\"search\" class=\"search\"> <igx-prefix> <igx-icon>search</igx-icon> </igx-prefix> <input #search igxInput placeholder=\"Search Contacts\" [(ngModel)]=\"searchContact\"> <igx-suffix *ngIf=\"search.value.length > 0\" (click)=\"searchContact = null\"> <igx-icon>clear</igx-icon> </igx-suffix> </igx-input-group> It's time to import the IgxFilterModule and the IgxInputGroupModule in our app.module.ts file and IgxFilterOptions in our contacts component: // app.module.ts ... import { IgxFilterModule, IgxInputGroupModule } from 'igniteui-angular'; // import { IgxFilterModule, IgxInputGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [..., IgxFilterModule, IgxInputGroupModule] }) // contacts.component.ts ... import { IgxFilterOptions } from 'igniteui-angular'; // import { IgxFilterOptions } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class ContactListComponent { public searchContact: string; ... get filterContacts(): IgxFilterOptions { const fo = new IgxFilterOptions(); fo.key = 'name'; fo.inputValue = this.searchContact; return fo; } } After importing the IgxFilterOptions, we need to register a new getter method that will return the filtering options to be used by the pipe each time the searchContact property gets updated. For the filter to work we need to register a key to filter the contact object by. In our case that would be the name of each contact. The second property that has to be registered on the IgxFilterOptions object is the value that we should check against when comparing our contact name. This would be the searchContact property that we bound to the input field above our contacts list. Finally, we need to apply the filtering pipe to our contacts data before we can use it. So in our template we simply add: <!--contacts.component.html--> <igx-list-item *ngFor=\"let contact of contacts | igxFilter: filterContacts; let i = index\"> ... </igx-list-item> List Item Selection As you probably have already noticed, list items do not provide selection states. However, if your application requires your list to keep track of which item is selected, we give you an example of how this can be achieved. All you need to do is keep track of the state somewhere in your component, or in the data the list is bound to. Here's an example, in which we apply a background color to the list according to the theme's secondary 500 color, based on state tracking coming from the data the list is bound to: What we are doing is we are adding an additional selected property to each data member, which defaults to false. Upon list item click, we're resetting all the selected properties in the data collection and setting the one corresponding to the clicked item to true. Based on the selected property, we're applying a css class to the list item which gives it the selected background. <igx-list> <igx-list-item isHeader=\"true\">Contacts</igx-list-item> <igx-list-item [ngClass]=\"contact.selected ? 'selected' : ''\" (click)=\"selectItem(contact)\" *ngFor=\"let contact of contacts | igxFilter: filterContacts;\"> <igx-avatar igxListThumbnail [src]=\"contact.photo\" shape=\"circle\"></igx-avatar> <span igxListLineTitle>{{ contact.name }}</span> <span igxListLineSubTitle>{{ contact.phone }}</span> <igx-icon igxListAction [style.color]=\"contact.isFavorite ? 'orange' : 'lightgray'\" (click)=\"toggleFavorite(contact, $event)\">star</igx-icon> </igx-list-item> </igx-list> public selectItem(item) { if (!item.selected) { this.contacts.forEach(c => c.selected = false); item.selected = true; } } .selected { background-color: hsla(var(--igx-secondary-500)) } Applying theme to the list component Let's see how we can change the background of our list. First we need to import index.scss in to our component .scss file. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Then we need to create a theme for our component. :host ::ng-deep { $my-list-theme: list-theme( $background: #0568ab ); @include list($my-list-theme); } The result from the above code is Note Please note that if we create our component theme in the component .scss file we need to use ::ng-deep in order to pass the view encapsulation otherwise our new theme will not work! for more info please refer to: Component Themes. For full list of parameters that you can change for the list component please refer to: IgxListComponent Styles API References In this article we covered a lot of ground with the Angular list component. We created a list of contact items. Used some additional Ignite UI for Angular components inside our list items, like avatars and icons. Created some custom item layout and styled it. Finally, we added list filtering. The list component has a few more APIs to explore, which are listed below. IgxListComponent API IgxListComponent Styles IgxListItemComponent API Additional Angular components that were used: IgxAvatarComponent API IgxAvatarComponent Styles IgxIconComponent API IgxIconComponent Styles Theming Dependencies IgxRipple Theme IgxAvatar Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/maps/map-api.html": {
    "href": "components/maps/map-api.html",
    "title": "Angular Chart API | Data Visualization Tools | Infragistics",
    "keywords": "Angular Geographic Map API The Angular IgxGeographicMapComponent has the following API members: zoomable zoomToGeographic worldRect windowRect windowScale getGeographicFromZoom getGeographicPoint getPixelPoint Angular Geographic Series Types The Angular IgxGeographicMapComponent has 7 types of series and they have the ItemsSource property for data binding. IgxGeographicHighDensityScatterSeriesComponent IgxGeographicSymbolSeriesComponent IgxGeographicProportionalSymbolSeriesComponent IgxGeographicPolylineSeriesComponent IgxGeographicShapeSeriesComponent IgxGeographicScatterAreaSeriesComponent IgxGeographicContourLineSeriesComponent In addition, each type of series has specific properties for mapping data items and styling their appearance: Angular Geographic Symbol Series API The Angular IgxGeographicSymbolSeriesComponent (Geographic Marker Series) has the following API members: latitudeMemberPath longitudeMemberPath markerType markerBrush markerOutline Angular Geographic Bubble Series API The Angular IgxGeographicProportionalSymbolSeriesComponent (Geographic Bubble Series) has the following API members: latitudeMemberPath longitudeMemberPath radiusMemberPath radiusScale fillScale fillMemberPath Angular Geographic Shape Series API The Angular IgxGeographicShapeSeriesComponent and IgxGeographicPolylineSeriesComponent have the same API members: shapeMemberPath Thickness Brush Outline Angular Geographic Area Series API The Angular IgxGeographicScatterAreaSeriesComponent has the following API members: latitudeMemberPath longitudeMemberPath colorMemberPath colorScale Angular Geographic Contour Series API The Angular IgxGeographicContourLineSeriesComponent has the following API members: latitudeMemberPath longitudeMemberPath valueMemberPath fillScale Angular Geographic HD Series API The Angular IgxGeographicHighDensityScatterSeriesComponent has the following API members: latitudeMemberPath longitudeMemberPath heatMaximumColor heatMinimumColor View page on GitHub"
  },
  "components/mask.html": {
    "href": "components/mask.html",
    "title": "Angular Mask Directive Component | Ignite UI for Angular",
    "keywords": "Angular Mask Directive Overview By applying the igxMask directive on a text input field, the developer can control user input and format the visible value, based on configurable mask rules. It provides different input options and ease in use and configuration. Angular Mask Example Getting Started with Ignite UI for Angular Mask To get started with the Ignite UI for Angular Mask directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxMaskModule and IgxInputGroupModule in your app.module.ts file. Note igxMask directive is used on an input of type text. // app.module.ts ... import { IgxMaskModule, IgxInputGroupModule } from 'igniteui-angular'; // import { IgxMaskModule, IgxInputGroupModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxMaskModule, IgxInputGroupModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxMaskDirective as a standalone dependency. // home.component.ts import { IgxMaskDirective, IGX_INPUT_GROUP_DIRECTIVES } from 'igniteui-angular'; // import { IgxMaskDirective, IGX_INPUT_GROUP_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-input-group> <igx-prefix> <igx-icon>phone</igx-icon> </igx-prefix> <label igxLabel>Phone</label> <input igxInput type=\"text\" [igxMask]=\"'(####) 00-00-00 Ext. 9999'\"/> </igx-input-group> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxMaskDirective, IGX_INPUT_GROUP_DIRECTIVES] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Mask module or directive imported, you can start using the igxMask directive. Using the Angular Mask Supported Built-in Mask Rules Mask Character Description 0 requires a digit (0-9) 9 requires a digit (0-9) or a space # requires a digit (0-9), plus (+), or minus (-) sign L requires a letter (a-Z) ? requires a letter (a-Z) or a space A requires an alphanumeric (0-9, a-Z) a requires an alphanumeric (0-9, a-Z) or a space & any keyboard character (excluding space) C any keyboard character Apply Mask on Input In the following example, we apply a phone number with an extension mask to an input. <!--sample.component.html--> <igx-input-group> <igx-prefix> <igx-icon>phone</igx-icon> </igx-prefix> <label igxLabel>Phone</label> <input igxInput type=\"text\" [igxMask]=\"'(####) 00-00-00 Ext. 9999'\"/> </igx-input-group> If configured properly, you should see the demo sample in your browser. Note The IgxMaskDirective supports IME input and updates the mask when composition ends. Bind to Formatted/Raw Value Use the includeLiterals input to configure which input value (formatted or raw) to bind in your form when a specific mask is applied. By default, includeLiterals is set to false and the raw value is used. <!--sample.component.html--> <igx-switch [(ngModel)]=\"includeLiterals\" (change)=\"clear()\"> Include Literals </igx-switch> <igx-input-group> <label igxLabel> Social Security Number </label> <input #ssn name=\"socialSecurityNumber\" type=\"text\" igxInput [igxMask]=\"'###-##-####'\" [(ngModel)]=\"socialSecurityNumber\" [includeLiterals]=\"includeLiterals\" /> </igx-input-group> <p *ngIf=\"socialSecurityNumber.length > 0\">Value: {{ socialSecurityNumber }}</p> // sample.component.ts public socialSecurityNumber: string = '123-45-6789'; public includeLiterals: boolean = true; public clear() { if (this.includeLiterals === false){ this.socialSecurityNumber = '123-45-6789'; } else { this.socialSecurityNumber = ''; } } Validate Masked Values In addition to setting a mask to an input, you can validate the entered value as well. The following example implements masks, validation and notification for invalid data using the Mask directive and Snack Bar component. <!--sample.component.html--> <igx-input-group> <label igxLabel for=\"birthday\">Birthday</label> <input igxInput #dateInput [igxMask]=\"'00/00/0000'\" [igxTextSelection]=\"true\" name=\"birthday\" type=\"text\" (blur)=\"validateDate(dateInput, snackbar)\" /> </igx-input-group> <igx-snackbar #snackbar></igx-snackbar> // sample.component.ts public validateDate(dateInput, snackbar) { if (!this.isDateValid(dateInput.value)) { this.notify(snackbar, 'Invalid Date', dateInput); } } private isDateValid(date) { return (new Date(date).toLocaleString() !== 'Invalid Date'); } private notify(snackbar, message, input) { snackbar.message = message; snackbar.show(); } Text Selection You can force the component to select all of the input text on focus using igxTextSelection. Find more info on igxTextSelection at Label & Input. Import the IgxTextSelectionModule in your app.module.ts file: ... import { ..., IgxTextSelectionModule } from 'igniteui-angular'; // import { ..., IgxTextSelectionModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxTextSelectionModule] ... }) export class AppModule {} Then add this to the template: <igx-input-group> <input igxInput [igxMask]=\"'###-##-####'\" [igxTextSelection]=\"true\"/> </igx-input-group> You can see how this works in the previous sample. Note In order for the component to work properly, it is crucial to set igxTextSelection after the igxMask directive. The reason for this is both directives operate on the input focus event so text selection should happen after the mask is set. Apply additional formatting on focus and blur In addition to the default mask behavior, the user can implement his own custom pipes and take advantage of the focusedValuePipe and displayValuePipe input properties, to transform the value to a desired output when the input gets or loses focus. This will not affect the underlying model value. Let's demonstrate how this can be achieved! Implement two pipes that will append/remove a '%' sign at the end of the displayed value: @Pipe({ name: 'displayFormat' }) export class DisplayFormatPipe implements PipeTransform { public transform(value: any): string { return value + ' %'; } } @Pipe({ name: 'inputFormat' }) export class InputFormatPipe implements PipeTransform { public transform(value: any): string { return value; } } Pass an instance of each pipe to the focusedValuePipe and displayValuePipe input properties as follows: public value = 100; public displayFormat = new DisplayFormatPipe(); public inputFormat = new InputFormatPipe(); <igx-input-group> <label igxLabel for=\"email\">Increase</label> <input igxInput type=\"text\" [(ngModel)]=\"value\" [igxMask]=\"'000'\" [igxTextSelection]=\"true\" [focusedValuePipe]=\"inputFormat\" [displayValuePipe]=\"displayFormat\"/> </igx-input-group> As a result, a '%' sign should be appended to the value on blur (i.e. when the user clicks outside the input) and will be removed once the input gets focus! Adding a placeholder The user can also take advantage of the placeholder input property, which serves the purpose of the native input placeholder attribute. If no value is provided for the placeholder, the value set for the mask is used. value = null; <igx-input-group> <label igxLabel>Date</label> <input igxInput type=\"text\" [(ngModel)]=\"value\" [igxMask]=\"'00/00/0000'\" [placeholder]=\"'dd/mm/yyyy'\"/> </igx-input-group> API References IgxInputDirective IgxInputGroupComponent IgxMaskDirective IgxSnackbarComponent Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/material-icons-extended.html": {
    "href": "components/material-icons-extended.html",
    "title": "Material Icons Extended - Superset of material icons",
    "keywords": "Material Icons Extended The Ignite UI Material Icons Extended is a subset of icons that extends the material icon set by Google. Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. Installation npm install @igniteui/material-icons-extended Usage First, let's see how we can register a single icon in our component: import { Component, OnInit } from '@angular/core'; import { IgxIconService } from 'igniteui-angular'; // import { IgxIconService } from '@infragistics/igniteui-angular'; for licensed package import { github } from '@igniteui/material-icons-extended'; // ... export class SampleComponent implements OnInit { constructor(private iconService: IgxIconService) {} ngOnInit(): void { // Register a single icon this.iconService.addSvgIconFromText(github.name, github.value, 'imx-icons'); } } Now, let's see how to register multiple icons/categories: //... import { health, programming } from '@igniteui/material-icons-extended'; export class SampleComponent implements OnInit { public allIcons = [ ...health, ...programming, ]; //... addIcons() { for (let icon of this.allIcons) { this.iconService.addSvgIconFromText(icon.name, icon.value, 'imx-icons'); } } ngOnInit(): void { this.addIcons(); } } To use the icons in your component template: <igx-icon family=\"imx-icons\" name=\"github\"></igx-icon> For more information and other types of usage, go to our GitHub Repository. Additional Resources IgxIconService Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/menus/toolbar.html": {
    "href": "components/menus/toolbar.html",
    "title": "Angular Toolbar Component | Ignite UI for Angular",
    "keywords": "Angular Toolbar Overview The Angular Toolbar component is a companion container for UI operations to be used primarily with our charting components. The toolbar will dynamically update with a preset of properties and tool items when linked to our IgxDataChartComponent or IgxCategoryChartComponent components. You'll be able to create custom tools for your project allowing end users to provide changes, offering an endless amount of customization. Angular Toolbar Example Dependencies Install the Ignite UI for Angular layouts, inputs, charts and core packages: npm install igniteui-angular-layouts npm install igniteui-angular-inputs npm install igniteui-angular-charts npm install igniteui-angular-core The following modules are required when using the IgxToolbarComponent with the IgxDataChartComponent component and it's features. import { IgxToolbarModule } from 'igniteui-angular-layouts'; import { IgxDataChartToolbarModule, IgxDataChartCoreModule, IgxDataChartCategoryModule, IgxDataChartAnnotationModule, IgxDataChartInteractivityModule, IgxDataChartCategoryTrendLineModule } from 'igniteui-angular-charts'; @NgModule({ imports: [ // ... IgxToolbarModule, IgxDataChartToolbarModule, IgxDataChartCoreModule, IgxDataChartCategoryModule, IgxDataChartAnnotationModule, IgxDataChartInteractivityModule, IgxDataChartCategoryTrendLineModule // ... ] }) export class AppModule {} import { IgxToolbarModule } from 'igniteui-react-layouts'; import { IgrDataChartToolbarModule, IgrDataChartCoreModule, IgrDataChartCategoryModule, IgrDataChartAnnotationModule, IgrDataChartInteractivityModule, IgrDataChartCategoryTrendLineModule } from 'igniteui-react-charts'; IgxToolbarModule.register(); IgrDataChartToolbarModule.register(); IgrDataChartCoreModule.register(); IgrDataChartCategoryModule.register(); IgrDataChartAnnotationModule.register(); IgrDataChartInteractivityModule.register(); IgrDataChartCategoryTrendLineModule.register(); Usage Tool Actions The following is a list of the different IgxToolActionComponent items that you can add to the Toolbar. IgxToolActionButtonComponent IgxToolActionCheckboxComponent IgxToolActionIconButtonComponent IgxToolActionIconMenuComponent IgxToolActionLabelComponent IgxToolActionNumberInputComponent IgxToolActionRadioComponent Each of these tools exposes an OnCommand event that is triggered by mouse click. New and existing tools can be repositioned and marked hidden using the overlayId, beforeId and afterId properties on the IgxToolActionComponent object. ToolActions also expose a visibility property. The following example demonstrates hiding both the built-in ZoomReset and AnalyzeMenu menu tool actions. A new instance of the ZoomReset tool action is added and placed within the ZoomMenu by using the the afterId property and assigning that to ZoomOut. This will ensure the new Reset tool is displayed at the bottom of the ZoomMenu. Angular Data Chart Integration The Angular Toolbar contains a Target property. This is used to link a component, such as the IgxDataChartComponent as shown in the code below: <div class=\"legend\"> <igx-toolbar name=\"toolbar\" [target]=\"chart\" #toolbar> </igx-toolbar> </div> <div class=\"container fill\"> <igx-data-chart name=\"chart\" #chart> </igx-data-chart> Several pre-existing IgxToolActionComponent items and menus become available when the IgxDataChartComponent is linked with the Toolbar. Here is a list of the built-in Angular IgxDataChartComponent Tool Actions and their associated overlayId: Zooming Actions ZoomReset: A IgxToolActionLabelComponent that invokes the resetZoom method on the chart to reset the zoom level to it's default position. ZoomMenu: A IgxToolActionIconMenuComponent that exposes two IgxToolActionLabelComponent items to invoke the zoomIn and zoomOut methods on the chart for increasing/decreasing the chart's zoom level. Trend Actions AnalyzeMenu: A IgxToolActionIconMenuComponent that contains several options for configuring different options of the chart. AnalyzeHeader: A sub section header. LinesMenu: A sub menu containing various tools for showing different dashed horizontal lines on the chart. LinesHeader: A sub menu section header for the following three tools: MaxValue: A IgxToolActionCheckboxComponent that displays a dashed horizontal line along the yAxis at the maximum value of the series. MinValue: A IgxToolActionCheckboxComponent that displays a dashed horizontal line along the yAxis at the minimum value of the series. Average: A IgxToolActionCheckboxComponent that displays a dashed horizontal line along the yAxis at the average value of the series. TrendsMenu: A sub menu containing tools for applying various trendlines to the IgxDataChartComponent plot area. TrendsHeader: A sub menu section header for the following three tools: Exponential: A IgxToolActionRadioComponent that sets the trendLineType on each series in the chart to ExponentialFit. Linear: A IgxToolActionRadioComponent that sets the trendLineType on each series in the chart to LinearFit. Logarithmic: A IgxToolActionRadioComponent that sets the trendLineType on each series in the the chart to LogarithmicFit. HelpersHeader: A sub section header. SeriesAvg: A IgxToolActionCheckboxComponent that adds or removes a IgxValueLayerComponent to the chart's series collection using the ValueLayerValueMode of type Average. ValueLabelsMenu: A sub menu containing various tools for showing different annotations on the IgxDataChartComponent's plot area. ValueLabelsHeader: A sub menu section header for the following tools: ShowValueLabels: A IgxToolActionCheckboxComponent that toggles data point values by using a IgxCalloutLayerComponent. ShowLastValueLabel: A IgxToolActionCheckboxComponent that toggles final value axis annotations by using a IgxFinalValueLayerComponent. ShowCrosshairs: A IgxToolActionCheckboxComponent that toggles mouse-over crosshair annotations via the chart's crosshairsDisplayMode property. ShowGridlines: A IgxToolActionCheckboxComponent that toggles extra gridlines by applying a MajorStroke to the X-Axis. Save to Image Action CopyAsImage: A IgxToolActionLabelComponent that exposes an option to copy the chart to the clipboard. CopyHeader: A sub section header. SVG Icons When adding tools manually, icons can be assigned using the RenderIconFromText method. There are three paramters to pass in this method. The first is the icon collection name defined on the tool eg. iconCollectionName. The second is the name of the icon defined on the tool eg. iconName, followed by adding the SVG string. <igx-tool-action-label title=\"Custom Icon\" iconName=\"CustomIcon\" iconCollectionName=\"CustomCollection\"> </igx-tool-action-label> public toolbarCustomIconOnViewInit(): void { const icon = '<svg width=\"28px\" height=\"28px\" stroke=\"none\" viewBox=\"0 0 3.5 3.5\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" aria-hidden=\"true\" role=\"img\" class=\"iconify iconify--gis\" preserveAspectRatio=\"xMidYMid meet\"><path d=\"M0.436 0.178a0.073 0.073 0 0 0 -0.062 0.036L0.01 0.846a0.073 0.073 0 0 0 0.063 0.109h0.729a0.073 0.073 0 0 0 0.063 -0.109L0.501 0.214a0.073 0.073 0 0 0 -0.064 -0.036zm0.001 0.219 0.238 0.413H0.199zM1.4 0.507v0.245h0.525v-0.245zm0.77 0v0.245h1.33v-0.245zM0.073 1.388A0.073 0.073 0 0 0 0 1.461v0.583a0.073 0.073 0 0 0 0.073 0.073h0.729A0.073 0.073 0 0 0 0.875 2.045V1.461a0.073 0.073 0 0 0 -0.073 -0.073zm0.073 0.146h0.583v0.438H0.146zM1.4 1.674v0.245h0.945v-0.245zm1.19 0v0.245h0.91v-0.245zM0.438 2.447c-0.241 0 -0.438 0.197 -0.438 0.438 0 0.241 0.197 0.438 0.438 0.438s0.438 -0.197 0.438 -0.438c0 -0.241 -0.197 -0.438 -0.438 -0.438zm0 0.146a0.291 0.291 0 0 1 0.292 0.292 0.291 0.291 0 0 1 -0.292 0.292 0.291 0.291 0 0 1 -0.292 -0.292A0.291 0.291 0 0 1 0.438 2.593zM1.4 2.842v0.245h0.525v-0.245zm0.77 0v0.245h1.33v-0.245z\" fill=\"#000000\" fill-rule=\"evenodd\"/></svg>'; this.toolbar.registerIconFromText(\"CustomCollection\", \"CustomIcon\", icon); } public toolbarCustomIconOnViewInit(): void { const icon = '<svg width=\"28px\" height=\"28px\" stroke=\"none\" viewBox=\"0 0 3.5 3.5\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" aria-hidden=\"true\" role=\"img\" class=\"iconify iconify--gis\" preserveAspectRatio=\"xMidYMid meet\"><path d=\"M0.436 0.178a0.073 0.073 0 0 0 -0.062 0.036L0.01 0.846a0.073 0.073 0 0 0 0.063 0.109h0.729a0.073 0.073 0 0 0 0.063 -0.109L0.501 0.214a0.073 0.073 0 0 0 -0.064 -0.036zm0.001 0.219 0.238 0.413H0.199zM1.4 0.507v0.245h0.525v-0.245zm0.77 0v0.245h1.33v-0.245zM0.073 1.388A0.073 0.073 0 0 0 0 1.461v0.583a0.073 0.073 0 0 0 0.073 0.073h0.729A0.073 0.073 0 0 0 0.875 2.045V1.461a0.073 0.073 0 0 0 -0.073 -0.073zm0.073 0.146h0.583v0.438H0.146zM1.4 1.674v0.245h0.945v-0.245zm1.19 0v0.245h0.91v-0.245zM0.438 2.447c-0.241 0 -0.438 0.197 -0.438 0.438 0 0.241 0.197 0.438 0.438 0.438s0.438 -0.197 0.438 -0.438c0 -0.241 -0.197 -0.438 -0.438 -0.438zm0 0.146a0.291 0.291 0 0 1 0.292 0.292 0.291 0.291 0 0 1 -0.292 0.292 0.291 0.291 0 0 1 -0.292 -0.292A0.291 0.291 0 0 1 0.438 2.593zM1.4 2.842v0.245h0.525v-0.245zm0.77 0v0.245h1.33v-0.245z\" fill=\"#000000\" fill-rule=\"evenodd\"/></svg>'; this.toolbar.registerIconFromText(\"CustomCollection\", \"CustomIcon\", icon); } Vertical Orientation By default the Angular Toolbar is shown horizontally, but it also has the ability to shown vertically by setting the orientation property. <igx-toolbar orientation=\"Vertical\" /> The following example demonstrates the vertical orientation of the Angular Toolbar. API References IgxToolbarComponent IgxDataChartComponent Additional Resources Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/month-picker.html": {
    "href": "components/month-picker.html",
    "title": "Angular Month Picker Component – Ignite UI for Angular",
    "keywords": "Angular Month Picker Component Overview The Ignite UI for Angular Month Picker component provides an easy and intuitive way to select a specific month and year using a month-year calendar view. The component allows you bind it's value to a date object, and users can change the month and year portion of the date object through the month picker component UI. It also supports localization. Angular Month Picker Example What you see here is a basic Angular Month Picker example with a the component's default view, enabling users to select the year and the month. Getting Started with Ignite UI for Angular Month Picker To get started with the Ignite UI for Angular Month Picker component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The first step is to import the IgxCalendarModule inside our app.module.ts file. Note The IgxMonthPickerComponent also depends on the BrowserAnimationsModule and the HammerModule for touch interactions, so they need to be added to the AppModule as well: // app.module.ts ... import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxCalendarModule } from 'igniteui-angular'; // import { IgxCalendarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., BrowserAnimationsModule, HammerModule, IgxCalendarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxMonthPickerComponent as a standalone dependency, or use the IGX_CALENDAR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxMonthPickerComponent } from 'igniteui-angular'; // import { IgxMonthPickerComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-month-picker></igx-month-picker>', styleUrls: ['home.component.scss'], standalone: true, imports: [BrowserAnimationsModule, HammerModule, IgxMonthPickerComponent] /* or imports: [BrowserAnimationsModule, HammerModule, IGX_CALENDAR_DIRECTIVES] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Calendar module or Month Picker component imported, you can start using the igx-month-picker component. Note Note that the IgxMonthPickerComponent uses the Intl WebAPI for localization and formatting of dates. Consider using the appropriate polyfills if your target platform does not support them. Using the Angular Month Picker To add the Angular Month Picker in a template, use the following code: <!-- month-picker-sample.component.html --> <igx-month-picker></igx-month-picker> Setting date Set a date to IgxMonthPickerComponent using the value input. // month-picker-sample.component.ts public date: Date = new Date(); <!-- month-picker-sample.component.html --> <igx-month-picker [value]=\"date\"></igx-date-picker> To create a two-way data-binding, set ngModel like this: <!-- month-picker-sample.component.html --> <igx-month-picker [(ngModel)]=\"date\"></igx-date-picker> Formatting Change the month picker display format, using the formatOptions inputs. <!-- month-picker-sample.component.html --> <igx-month-picker [(ngModel)]=\"date\" [formatOptions]=\"numericFormatOptions\"></igx-month-picker> // month-picker-sample.component.ts public date: Date = new Date(); public numericFormatOptions = { month: '2-digit' }; Localization Use the locale input, to customize the Ignite UI for Angular Month Picker localization. <!-- month-picker-sample.component.html --> <igx-month-picker [(ngModel)]=\"date\" [locale]=\"locale\" [formatOptions]=\"formatOptions\"></igx-month-picker> // month-picker-sample.component.ts public date: Date = new Date(); public locale: 'fr'; public formatOptions = { month: 'long' }; Here is an example of localizing and formatting the month picker component: Keyboard navigation When the igxMonthPicker component is focused, use PageUp key to move to the previous year, PageDown key to move to the next year, Home key to focus the first month of the current year, End key to focus the last month of the current year, Tab key to navigate through the sub-header buttons. When < (previous) or > (next) year button (in the sub-header) is focused, use Space or Enter key to scroll into view the next or previous year. When years button (in the sub-header) is focused, use Space or Enter key to open the years view, Right or Left arrow key to scroll the previous/next year into view. When a month inside the months view is focused, use Arrow keys to navigate through the months, Home key to focus the first month inside the months view, End key to focus the last month inside the months view, Enter key to select the currently focused month and close the view, Tab key to navigate through the months. Styling To get started with styling the month picker, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The month picker uses the calendar's theme, so we have to create a new theme that extends the calendar-theme and use some of its parameters to style the month picker's items: $my-calendar-theme: calendar-theme( $border-radius: 15px, $content-background: #011627, $picker-background-color: #011627, $month-current-text-color: #ECAA53, $month-hover-background: #ECAA53, $year-current-text-color: #ECAA53, $year-hover-text-color: #D37B08, $picker-arrow-color: #ECAA53, $picker-text-hover-color: #D37B08, $picker-arrow-hover-color: #D37B08, $picker-text-color: #ECAA53 ); Including themes The next step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include calendar($my-calendar-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include calendar($my-calendar-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($my-calendar-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($my-calendar-theme); } After everything's done, your component should look like this: Demo API References IgxMonthPickerComponent IgxCalendarComponent IgxCalendarComponent Styles Theming Dependencies IgxCalendar Theme IgxIcon Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/multi-column-combobox.html": {
    "href": "components/multi-column-combobox.html",
    "title": "Angular Combo | Data Visualization Tools | Infragistics",
    "keywords": "Angular Multi-Column Combo Box Overview The Multi-Column Combo Box automatically generates columns for properties on the data object. This component is unique in that it's a combo box that visualizes large amounts of data similar to a data grid embedded in the dropdown. Angular Multi-Column Combo Box Overview Example View on StackBlitz Dependencies When installing the charts component, the core package must also be installed. npm install --save igniteui-angular-core npm install --save {PackageInputs} Required Modules The Multi-Column Combo Box requires the following modules: Usage Binding a Data Source In order to display your objects in the Multi-Column Combo Box component, you will need to bind the DataSource property. This can be bound in the form of an array of complex objects. The following code demonstrates how to bind the data source property. Setting Display Value and Data Value You can configure different properties of the Multi-Column Combo Box's bound DataSource to act as the display text for the control as well as the underlying value when a selection is made. This is done by setting the TextField and ValueField properties of the control, respectively, to the name of the property on the data item that you want to represent these things. The following code snippet shows how to set these properties, given that the underlying data item has a \"Country\" and \"ID\" property: Setting Fields By default, the Multi-Column Combo Box will show all of the properties on the underlying data item, but this can be controlled by setting the Fields property on the component. This property takes a string[] of property paths on the underlying data item to determine which properties are shown. The following code snippet shows how to set this, and the resulting drop-down would only show the ID and Country columns: Setting Placeholder Text It is possible to configure the text that shows as a placeholder for when there is no selection in the Multi-Column Combo Box component. This is done by setting the Placeholder property to the string you would like to be displayed. The following code demonstrates how to set this: Configuring Sorting Mode The user has the ability to sort the columns that are displayed in the Multi-Column Combo Box by clicking the header of the column in the drop-down. The way the sorting is configured can be modified as well, as the columns can be sorted by only a single column or multiple columns, and they can be limited to either ascending and descending, or they can be tri-state. This is done by setting the SortMode property of the component. Note, the TriState sort options will allow sorted columns to be unsorted. The following code demonstrates how to set the Multi-Column Combo Box to be able to sort by multiple columns tri-state. View page on GitHub"
  },
  "components/navbar.html": {
    "href": "components/navbar.html",
    "title": "Angular Navbar Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Navbar Component Overview The Ignite UI for Angular IgxNavbarComponent is an application header component that informs the user of their current position in an app, and helps them move back (much like the “back” button in a browser). The Navigation Bar can also provide links to quick actions such as search or favorite, helping users navigate smoothly through an application without trying to move to invalid routes or states. The bar sits at the top of the container it is placed in. Angular Navbar Example Getting Started with Ignite UI for Angular Navbar To get started with the Ignite UI for Angular Navbar component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The first step is to import the IgxNavbarModule inside our app.module.ts file. // app.module.ts import { IgxNavbarModule } from 'igniteui-angular'; // import { IgxNavbarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxNavbarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxNavbarComponent as a standalone dependency, or use the IGX_NAVBAR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_NAVBAR_DIRECTIVES } from 'igniteui-angular'; // import { IGX_NAVBAR_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-navbar title=\"Ignite UI for Angular\"></igx-navbar>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_NAVBAR_DIRECTIVES] /* or imports: [IgxNavbarComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Navbar module or directives imported, you can start using the igx-navbar component. Using the Angular Navbar Then in the template of our component we can add the following code to show a basic navbar with a title: <!--navbar.component.html--> <igx-navbar title=\"Ignite UI for Angular\"> </igx-navbar> Add Menu Button In order to add a menu button, we will show the action button using the actionButtonIcon property, and make it use a menu icon as follows: <!--navbar.component.html--> <igx-navbar title=\"Sample App\" actionButtonIcon=\"menu\" [isActionButtonVisible]=\"true\"> </igx-navbar> Note The actionButtonIcon uses the Material fontset by design. Add Icon Buttons We can make our app a little more functional by adding options for searching, favorites and more. To do that let's grab the IgxIconButton and IgxIcon modules and import them in our app.module.ts file. // app.module.ts ... import { IgxNavbarModule, IgxIconButtonDirective, IgxIconModule } from 'igniteui-angular'; // import { IgxNavbarModule, IgxButtonModule, IgxIconModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxIconButtonDirective, IgxIconModule], }) export class AppModule {} Next, we need to update our template with an icon button for each of the options we want our app to provide: <!--navbar.component.html--> <igx-navbar title=\"Sample App\"> <button igxIconButton=\"flat\"> <igx-icon>search</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>favorite</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>more_vert</igx-icon> </button> </igx-navbar> If all went well, you should see the following in your browser: Add Custom Action What if we want to use a custom template for our app navigation on the left-most part of the navbar? We can easily achieve this by using the igx-navbar-action directive, which will render the content we have provided. We will do that by using a button with the Font Awesome home icon. /* navbar.component.css */ @import url(\"https://unpkg.com/@fortawesome/fontawesome-free-webfonts@^1.0.9/css/fontawesome.css\"); @import url(\"https://unpkg.com/@fortawesome/fontawesome-free-webfonts@^1.0.9/css/fa-regular.css\"); @import url(\"https://unpkg.com/@fortawesome/fontawesome-free-webfonts@^1.0.9/css/fa-solid.css\"); <!--navbar.component.html--> <igx-navbar title=\"Sample App\"> <igx-navbar-action> <button igxIconButton=\"flat\"> <igx-icon family=\"fa\" name=\"fa-home\"></igx-icon> </button> </igx-navbar-action> <button igxIconButton=\"flat\"> <igx-icon>search</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>favorite</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>more_vert</igx-icon> </button> </igx-navbar> Finally, this is how our navbar should look like with its custom action button icon: Add Navigation Icon If we want to create a navbar with an icon navigating back, we should follow a couple of steps. First, we can use the actionButtonIcon property to choose a suitable icon from the Material fontset. Then, we can make a simple check if there are any previously visited pages to go back to, and pass the result to the isActionButtonVisible property. The last step is to create a method for navigating back and hook it to the action property. <!--navbar.component.html--> <igx-navbar title=\"Ignite UI for Angular\" actionButtonIcon=\"arrow_back\" [isActionButtonVisible]=\"canGoBack()\" (action)=\"navigateBack()\"> </igx-navbar> export class NavbarSample3Component { constructor(private _location: Location) { } public ngOnInit() { } public navigateBack() { this._location.back(); } public canGoBack() { return window.history.length > 0; } } If the sample is configured properly, you should see the following in your browser: Note If igx-navbar-action or igxNavbarAction is provided, the default actionButtonIcon will not be used. Add Custom Title If we want to provide a custom content for a navbar's title, we can achieve this by using igx-navbar-title or igxNavbarTitle directive. They will replace the default navbar's title provided by title input property. The sample below has a custom title containing a link with an image: <!--navbar.component.html--> <div class=\"sample-column\"> <igx-navbar> <igx-navbar-action> <button igxIconButton=\"flat\"> <igx-icon>menu</igx-icon> </button> </igx-navbar-action> <div igxNavbarTitle> <a href=\"https://www.infragistics.com/products/ignite-ui-angular\" target=\"_blank\"> <img src=\"https://static.infragistics.com/marketing/Website/products/ignite-ui-landing/ignite-ui-logo.svg\" width=\"120px\" height=\"50px\" alt style=\"margin-top: 7px;\"> </a> </div> <button igxIconButton=\"flat\"> <igx-icon>search</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>favorite</igx-icon> </button> <button igxIconButton=\"flat\"> <igx-icon>more_vert</igx-icon> </button> </igx-navbar> </div> Note If igx-navbar-title or igxNavbarTitle is provided, the default title will not be used. Styling To get started with styling the navbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the navbar-theme and accepts the $text-color, $background, $idle-icon-color and the $hover-icon-color parameters. $custom-navbar-theme: navbar-theme( $text-color: #151515, $background: #dedede, $idle-icon-color: #151515, $hover-icon-color: #8c8c8c ); Using CSS variables The last step is to pass the newly created theme: @include css-vars($custom-navbar-theme); Using mixins In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom navbar theme to the `igx-navbar` mixin @include navbar($custom-navbar-theme); } } Using color palettes Instead of hardcoding the color values, like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $white-color: #dedede; $black-color: #151515; $light-navbar-palette: palette($primary: $white-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-navbar-theme: navbar-theme( $text-color: color($light-navbar-palette, \"secondary\", 400), $background: color($light-navbar-palette, \"primary\", 400), $idle-icon-color: color($light-navbar-palette, \"secondary\", 400), $hover-icon-color: #8c8c8c ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to the Palettes topic for detailed guidance on how to use them. Using schemas You can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-navbar schema: // Extending the navbar schema $light-navbar-schema: extend($_light-navbar, ( text-color: ( color: (\"secondary\", 400) ), background: ( color: (\"primary\", 400) ), idle-icon-color:( color: (\"secondary\", 400) ), $hover-icon-color: #8c8c8c ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( navbar: $light-navbar-schema )); // Defining navbar with the global light schema $cutom-navbar-theme: navbar-theme( $palette: $light-navbar-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxNavbarComponent IgxNavbarActionDirective IgxNavbarTitleDirective IgxNavbarComponent Styles Additional components and/or directives with relative APIs that were used: IgxIconComponent IgxIconComponent Styles Theming Dependencies IgxIconComponent Theme IgxButtonComponent Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/navdrawer.html": {
    "href": "components/navdrawer.html",
    "title": "Angular Navigation Drawer Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Navigation Drawer Component Overview The Ignite UI for Angular Navigation Drawer component is a side navigation container. It can rest above content and slide in/out of view or be pinned to expand/collapse within the content. A mini version provides quick access to navigation even when closed. The Navigation Drawer features responsive mode selection and touch gestures. Content is completely customizable and can make use of default menu item styling. Angular Navigation Drawer Example Getting Started with Ignite UI for Angular Navigation Drawer To get started with the Ignite UI for Angular Navigation Drawer component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The first step is to import the IgxNavigationDrawerModule inside our app.module.ts file. Note The IgxNavigationDrawerComponent also depends on the BrowserAnimationsModule and the HammerModule for touch interactions, so they need to be added to the AppModule as well: // app.module.ts ... import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxNavigationDrawerModule } from 'igniteui-angular'; // import { IgxNavigationDrawerModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., BrowserAnimationsModule, HammerModule, IgxNavigationDrawerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxNavigationDrawerComponent as a standalone dependency, or use the IGX_NAVIGATION_DRAWER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { NgFor } from '@angular/common'; import { IGX_NAVIGATION_DRAWER_DIRECTIVES, IgxRippleDirective, IgxIconComponent } from 'igniteui-angular'; // import { IGX_NAVIGATION_DRAWER_DIRECTIVES, IgxRippleDirective, IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <div class=\"content-wrap\"> <igx-nav-drawer [isOpen]=\"true\"> <ng-template igxDrawer> <nav> <span igxDrawerItem [isHeader]=\"true\">Components</span> <span *ngFor=\"let item of navItems\" igxDrawerItem [active]=\"item.text === selected\" igxRipple (click)=\"navigate(item)\"> <igx-icon fontSet=\"material\">{{ item.name }}</igx-icon> <span>{{ item.text }}</span> </span> </nav> </ng-template> </igx-nav-drawer> <main> <!-- app content --> </main> </div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [BrowserAnimationsModule, HammerModule, IGX_NAVIGATION_DRAWER_DIRECTIVES, IgxRippleDirective, IgxIconComponent, NgFor] /* or imports: [BrowserAnimationsModule, HammerModule, IgxNavigationDrawerComponent, IgxNavDrawerTemplateDirective, IgxNavDrawerItemDirective, IgxIconComponent, IgxRippleDirective, NgFor] */ }) export class HomeComponent { public navItems: Product []; } Now that you have the Ignite UI for Angular Navigation Drawer module or directives imported, you can start using the igx-nav-drawer component. Using the Angular Navigation Drawer With the dependencies imported, the Navigation Drawer can be defined in the app component template: <igx-nav-drawer id=\"navdrawer\" [isOpen]=\"true\"> <!-- template(s) --> </igx-nav-drawer> The content for the drawer should be provided via <ng-template> decorated with igxDrawer directive. While any content can be provided in the template, the igxDrawerItem directive (see Item styling) is available to apply out-of-the-box styling to items. The directive has two @Input properties: active to style an item as selected. isHeader to style an item as a group header, cannot be active. The igxRipple directive completes the look and feel: <!-- app.component.html --> <div class=\"content-wrap\"> <igx-nav-drawer id=\"navigation\" #drawer [isOpen]=\"true\"> <ng-template igxDrawer> <nav> <span igxDrawerItem [isHeader]=\"true\">Components</span> <span *ngFor=\"let item of navItems\" igxDrawerItem [active]=\"item.text === selected\" igxRipple (click)=\"navigate(item)\"> <igx-icon fontSet=\"material\">{{ item.name }}</igx-icon> <span>{{ item.text }}</span> </span> </nav> </ng-template> </igx-nav-drawer> <main> <!-- app content --> </main> </div> An additional template decorated with igxDrawerMini directive can be provided for the alternative Mini variant as closed state. Note The Navigation Drawer can float above the content or be pinned alongside it. By default the drawer switches between those modes depending on the viewport size. See Modes for more information. To accommodate for the drawer switching modes, a simple flexible wrapper around the two content sections can be styled like so: /* app.component.css */ .content-wrap { width: 100%; height: 100%; display: flex; } To add elements to our navigation drawer and be able to select them, our typescript file should look like this: /* app.component.ts */ @Component({...}) export class AppComponent { public navItems = [ { name: 'account_circle', text: 'Avatar' }, ... ]; public selected = 'Avatar'; public navigate(item) { this.selected = item.text; } } There are various ways to open and close the drawer. Input properties can be bound to app state, programatic access to the API in the component using a @ViewChild(IgxNavigationDrawerComponent) reference or even in this case using the #drawer template reference variable: <button (click)=\"drawer.toggle()\"> Menu </button> The Navigation Drawer also integrates with igxNavigationService and can be targeted by id with an igxToggleAction directive. Let's replace the <main> in app.component.html with the following, adding igxIconButton and Icon component to style our toggle: <main> <span igxIconButton=\"flat\" igxToggleAction=\"navigation\"> <igx-icon fontSet=\"material\">menu</igx-icon> </span> </main> Also, if you want the drawer to close when you select an item from it, you can use a @ViewChild(IgxNavigationDrawerComponent) reference like that: /* app.component.ts */ import { Component, ViewChild } from '@angular/core'; import { IgxNavigationDrawerComponent } from 'igniteui-angular'; // import { IgxNavigationDrawerComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class AppComponent { @ViewChild(IgxNavigationDrawerComponent, { static: true }) public drawer: IgxNavigationDrawerComponent; // And of course add the key line to our navigate function public navigate(item) { this.selected = item.text; this.drawer.close(); } } If everything went well, you should see the demo sample in your browser. Modes Unpinned (elevated above the content) mode is the normal behavior where the drawer sits above and applies a darkened overlay over the content. Generally used to provide temporary navigation suitable for mobile devices. The drawer can be pinned to take advantage of larger screens, placing it within normal content flow with relative position. Depending on whether the app provides a way to toggle the drawer, the pinned mode can be used to achieve either permanent or persistent behavior. Note By default the Navigation Drawer is responsive, actively changing between unpinned and pinned mode based on screen size. This behavior is controlled by the pinThreshold property and can be disabled by setting a falsy value (e.g. 0). Pinned (persistent) setup Pin changes the position of the drawer from fixed to relative to put it on the same flow as content. Therefore, the app styling should account for such layout, especially if the drawer needs to be toggled in this mode. While there's more than one way to achieve such fluid layout (including programmatically), the easiest way is using igxLayout and igxFlex directives. Here's how that would look applied to the previous example: <div class=\"content-wrap\" igxLayout igxLayoutDir=\"row\"> <igx-nav-drawer id=\"navigation\" #drawer [isOpen]=\"true\" [pin]=\"true\" [pinThreshold]=\"0\"> <!-- template(s) --> </igx-nav-drawer> <main igxFlex> <!-- content here --> </main> </div> .content-wrap { width: 100%; position: absolute; top: 0; right: 0; bottom: 0; left: 0; } Now the changed example should look like that: The drawer applies flex-basis on its host element, allowing the rest of the content to take up the remaining width. Alternatively, skipping using directives, manual styling can be applied similar to: .main { position: absolute; display: flex; flex-flow: row nowrap; top: 0; right: 0; bottom: 0; left: 0; width: 100%; } .main > * { width: 100%; } Mini variant With the mini variant, the Navigation Drawer changes its width instead of closing. Most commonly used to maintain quick selection available on the side at all times, leaving just the icons. This variant is enabled simply by the presence of an alternative mini template decorated with igxDrawerMini directive. The mini variant is commonly used in a persistent setup, so we've set pin and disabled the responsive threshold: <igx-nav-drawer id=\"navigation\" [pin]=\"true\" [pinThreshold]=\"0\"> <ng-template igxDrawer> <span *ngFor=\"let item of navItems\" igxDrawerItem [active]=\"item.text === selected\" igxRipple (click)=\"navigate(item)\"> <igx-icon fontSet=\"material\">{{ item.name }}</igx-icon> <span>{{ item.text }}</span> </span> </ng-template> <ng-template igxDrawerMini> <span *ngFor=\"let item of navItems\" igxDrawerItem [active]=\"item.text === selected\" igxRipple (click)=\"navigate(item)\"> <igx-icon fontSet=\"material\">{{ item.name }}</igx-icon> </span> </ng-template> </igx-nav-drawer> Using Angular Router To use the Angular Router, first, we need to import git from @angular/router and create an instance of the router in our constructor. Then we have to define our navigation items using the router for their link values. /* app.component.ts */ ... export class AppComponent { public componentLinks = [ { link: 'avatar', name: 'Avatar' }, { link: 'badge', name: 'Badge' }, { link: 'button-group', name: 'Button Group' } ]; } You can use routerLinkActive where it's assigned to a template variable and its isActive property can be used for binding to the active input on the igxDrawerItem. The <igx-nav-drawer> template would look like this: /* app.component.html */ <!-- ... --> <ng-template igxDrawer> <nav> <span igxDrawerItem [isHeader]=\"true\">Components</span> <span *ngFor=\"let item of componentLinks\" routerLink=\"{{item.link}}\" routerLinkActive #rla=\"routerLinkActive\" igxDrawerItem igxRipple [active]=\"rla.isActive\"> {{item.name}} </span> </nav> </ng-template> <!-- ... --> Finally, import the RouterModule along with the items' routes in your app.module.ts file: /*app.module.ts*/ import { RouterModule } from '@angular/router'; @NgModule([ imports: [ RouterModule, RouterModule.forRoot([ {path: 'avatar', component: NavDrawerRoutingComponent}, {path: 'badge', component: NavDrawerRoutingComponent}, {path: 'button-group', component: NavDrawerRoutingComponent} ]) ] ]) After all the steps above are completed, your app should look like that: Hierarchical Navigation To create a multi-level hierarchical navigation using the IgxNavigationDrawerComponent, you can use the IgxTreeComponent in the igxDrawer template. The tree can be constructed directly from your application Routes object. Here's how this can be achieved: <igx-nav-drawer [isOpen]=\"true\" [enableGestures]=\"true\" width=\"280px\"> <ng-template igxDrawer> <igx-tree> <igx-tree-node *ngFor=\"let route of routes\"> <a igxTreeNodeLink [routerLink]=\"route.path\" routerLinkActive=\"route-selected-class\">{{ route.data?.displayName }}</a> <igx-tree-node *ngFor=\"let child of route.children\"> <a igxTreeNodeLink [routerLink]=\"[route.path, child.path]\" routerLinkActive=\"route-selected-class\">{{ child.data?.displayName }}</a> </igx-tree-node> </igx-tree-node> </igx-tree> </ng-template> </igx-nav-drawer> Note In this example, we're not using the igxDrawerItem, instead we're populating directly with custom igxDrawer content, in this case using an igx-tree. import { menusRoutes } from '../../menus-routing.module'; @Component({ selector: 'app-nav-drawer-hierarchical', templateUrl: './nav-drawer-hierarchical.component.html', styleUrls: ['./nav-drawer-hierarchical.component.scss'] }) export class NavDrawerHierarchicalComponent { public routes = menusRoutes; } In this example, we're populating the routes with custom routing data, which contains a displayName property, used to visualize the link text in the igx-tree nodes. A sample Route looks like this: export const menusRoutes: Routes = [ { component: NavDrawerHierarchicalComponent, path: 'navigation-drawer-hierarchical', data: { displayName: 'Hierarchical Drawer Menu' } } ]; There's also child routing extracted from the children property of the routes. The sample shows two levels of hierarchy, but if your routing has more, then all you need to do is define the levels below the second one in the tree node templates. Note Keep in mind that some routes, like empty route redirect, error route, page not found, etc., might not be suitable for visualization directly. Before binding the tree to the routing object, you can strip those routes out of your object in your component logic. The example below presents the capabilities of a hierarchical structure by using predefined data with topic names and links. The structure allows users to easily generate functional and detailed navigations and to have the ability to define each element whether to be displayed as a link or as an indicator. Styling To get started with styling the navigation drawer, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the navdrawer-theme and accepts a few parameters that style the navdrawer's items: $custom-theme: navdrawer-theme( $background: #2d313a, $item-active-background: #ecc256, $item-header-text-color: #ecc256 ); As seen, the navdrawer-theme exposes some useful parameters for basic styling of its items. Including themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include navdrawer($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include navdrawer($custom-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-theme); } API and Style References IgxNavigationDrawerComponent API IgxNavigationDrawerComponent Styles View page on GitHub"
  },
  "components/nuget-feed.html": {
    "href": "components/nuget-feed.html",
    "title": "Infragistics NuGet Feed",
    "keywords": "Infragistics NuGet Feed Infragistics provides a private NuGet feed for licensed users to consume and add licensed Ignite UI for Blazor NuGet packages to their applications via the NuGet Package Manager. This topic contains the following sections: Adding the Infragistics NuGet Feed with Visual Studio Adding the Infragistics NuGet Feed with the NuGet CLI Adding with Visual Studio 1 - In Visual Studio, select Tools → NuGet Package Manager → Package Manager Settings. 2 - In the Package Sources section, add a new package source by clicking the plus icon in the top right corner of the dialog. Set the Name to Infragistics Set the Source to https://packages.infragistics.com/nuget/licensed Click the Update button, and then click OK to close the dialog. Note When adding a NuGet package from this source for the first time, you will be prompted for your Infragistics credentials. Adding with the NuGet CLI 1 - Download the latest Nuget executable. Instruct your browser to save the file to a folder of your choice. The file is not an installer; you won't see anything if you run it directly from the browser. 2 - Open a command prompt in the folder path of the nuget.exe file you just downloaded. 3 - Execute the following command nuget sources add -name \"Infragistics\" -source \"https://packages.infragistics.com/nuget/licensed\" -username \"your login email\" -password \"your password\" Note The password will be stored encrypted in the NuGet config file and can only be decrypted in the same user context as it was encrypted. The default location of the config file can be found here %AppData%\\NuGet\\NuGet.config View page on GitHub"
  },
  "components/overlay.html": {
    "href": "components/overlay.html",
    "title": "Angular Overlay Service – Ignite UI for Angular | Infragistics",
    "keywords": "Overlay The overlay service provides an easy and quick way to dynamically render content in the foreground of an app. The content to be rendered, also the way it renders (e.g. placement, animations, scroll and click behaviors) are highly configurable and able to match all of the possible scenarios. The overlay service is fully integrated in the toggle directive. Angular Overlay Example Getting Started First we need to import the IgxOverlayService in the component and inject a reference to it in the component's constructor: import { Inject } from '@angular/core' import { IgxOverlayService } from `igniteui-angular`; ... export class MyOverlayComponent { constructor( @Inject(IgxOverlayService) private overlayService: IgxOverlayService ) {} } ... Displaying Content The overlay service can be used to dynamically display an HTMLNode or even an Angular Component by attaching it to the overlay DOM. After a reference to the Overlay service is established, it can be used to dynamically show/hide content. For example, we can pass an Angular Component in the attach method. This will generate a unique ID, which we can pass to the show method to display the component. When displaying an Angular Component a second mandatory parameter ViewContainerRef should be passed in the attach method. // my-overlay-component.component.ts import { MyDynamicComponent } from '../my-dynamic-component/my-dynamic-component.component'; @Component({...}) export class MyOverlayComponent { private _overlayId = ''; // The unique identifier assigned to the component by the Overlay service constructor( @Inject(IgxOverlayService) private overlayService: IgxOverlayService, private viewContainerRef: ViewContainerRef ) {} public showInOverlay() { if (!this._overlayId) { this._overlayId = this.overlayService.attach(MyDynamicComponent, this.viewContainerRef); } this.overlayService.show(this._overlayId); } } <!-- my-overlay-component.component.html --> <div class='content'> ... <button (click)=\"showInOverlay()\">Show Overlay</button> </div> If we want to pass an already existing ElementRef from the page to the IgxOverlayService, we can do it as follows: <!-- my-overlay-component.component.html --> <div class='content'> <button (click)=\"showInOverlay()\">Show Overlay</button> </div> <div> <img #exampleImage width='200px' src='../assets/example.png' title='Click Me!'> </div> // my-overlay-component.component.ts import { Inject, ViewChild } from '@angular/core' @Component({...}) export class MyOverlayComponent { private _overlayId = ''; // The unique identifier assigned to the component by the Overlay service @ViewChild('exampleImage', {read: ElementRef}) private exampleImage: ElementRef; public showInOverlay() { if (!this._overlayId) { this._overlayId = this.overlayService.attach(this.exampleImage); } this.overlayService.show(this._overlayId); } } The Overlay Service's attach() method has two overloads: attach(element, settings?) attach(component, viewContainerRef, settings?) The first parameter in both overloads is mandatory and represents the content that will be shown in the overlay. There are a couple of different scenarios how the content can be passed: A component definition - When passing a component in as the first argument, the overlay service creates a new instance of that component and dynamically attaches its ElementRef to the overlay DOM. This method also accepts a second mandatory parameter ViewContainerRef which is a reference to the container where the created component's host view will be inserted. An ElementRef to an existing DOM element (illustrated in the sample above) - Any view that is already rendered on the page can be passed through the overlay service and be rendered in the overlay DOM. In both cases the attach() method will: Get the reference to the passed view from Angular Detach the view from the DOM and leave an anchor in its place Re-attach the view to the overlay using the provided OverlaySettings or falling back to the default overlay ones Calling then show(id) will play the open animation, if there is any, and will show the attached content. Calling hide(id) will play close animation, if there is any, and will hide the attached content. Finally calling detach(id) method will re-attach the view back to its original location in the DOM. If a component was provided to the attach() method calling detach(id) will destroy the created instance. Attaching Components In the below demo, we can pass the IgxCard component through the Overlay Service's attach() method to generate an ID. Then we call the show() method with the provided ID to dynamically attach the card to the DOM in a modal container. Overlay Settings The attach() method also accepts an object of the OverlaySettings type, which configures the way the content is shown. If no such object is provided, the Overlay Service will use its default settings to render the passed content. For example, if we want the content to be positioned relative to an element, we can pass a different target and positioningStrategy to the attach() method, e.g. ConnectedPositioningStrategy. In order to configure how the component is shown, we need to create an OverlaySettings object first: // my-overlay-component.component.ts // import the ConnectedPositioningStategy class import { ConnectedPositioningStrategy } from 'igniteui-angular'; // import { ConnectedPositioningStrategy } from '@infragistics/igniteui-angular'; for licensed package ... export class MyOverlayComponent { @ViewChild(`myAnchorButton`) private myAnchorButton: ElementRef; private _overlayId = ''; // The unique identifier assigned to the component by the Overlay service public showInOverlay() { if (!this._overlayId) { this._overlayId = this.overlayService.attach(MyDynamicComponent, this.viewContainerRef, { target: this.myAnchorButton.nativeElement, positionStrategy: new ConnectedPositioningStrategy() }); } this.overlayService.show(this._overlayId); } } <!-- my-overlay-component.component.html --> <div class='content'> ... <button #myAnchorButton (click)=\"showInOverlay()\">Show Overlay</button> </div> Clicking on the button will now show MyDynamicComponent positioned relative to the button. Preset Overlay Settings The IgxOverlayService.createAbsolutePositionSettings() and IgxOverlayService.createRelativePositionSettings() methods provide an easy way to create an OverlaySettings based on a predefined settings sets. The IgxOverlayService.createAbsolutePositionSettings() method creates non-modal OverlaySettings with GlobalPositionStrategy or ContainerPositionStrategy in case the outlet parameter is provided. The AbsolutePosition enumeration defines the possible positions to choose from: Center, Top or Bottom. The default position is Center. const globalOverlaySettings = IgxOverlayService.createAbsoluteOverlaySettings(AbsolutePosition.Top); The IgxOverlayService.createRelativePositionSettings() method creates OverlaySettings with AutoPositionStrategy, ConnectedPositioningStrategy or ElasticPositionStrategy. Accepts target, position and strategy. The target is the attaching point or element for the component to show. The position is a RelativePosition enumeration with the following options: Above, Below, Before, After and Default. The Default option positions the element below the target, left aligned. The position strategy can be set through the RelativePositionStrategy enumeration, which default value is Auto. const targetElement = this.myAnchorButton.nativeElement; const connectedOverlaySettings = IgxOverlayService.createRelativeOverlaySettings( targetElement, RelativePosition.Above, RelativePositionStrategy.Connected); Demo Hiding the Overlay The hide(id) hides the overlay content. All of the elements rendered by the overlay service have a unique ID, assigned to them by the service. The attach() method returns the identifier of the rendered content. To hide the content this ID needs to be passed to the overlay's hide(id) method. To hide all overlays hideAll() method could be called. When rendered content is not needed anymore detach(id) method should be called. This method removes the content from the overlay and, if applicable, re-attaches it to its original location in the DOM. detach(id) method also accepts as mandatory parameter the ID generated from attach() method. To remove all the overlays detachAll() method could be called. We can modify the previously defined overlay method to not only show but also hide the overlay element // my-overlay-component.component.ts // add an import for the definion of ConnectedPositioningStategy class import { ConnectedPositioningStrategy } from 'igniteui-angular'; // import { ConnectedPositioningStrategy } from '@infragistics/igniteui-angular'; for licensed package @Component({...}) export class MyOverlayComponent implements OnDestroy { private _overlayId = ''; // The unique identifier assigned to the component by the Overlay service private _overlayShown = false; // Is the component rendered in the Overlay? @ViewChild(`myAnchorButton`) private myAnchorButton: ElementRef; public toggleOverlay() { if (!this._overlayShown) { // If the element is not visible, show it // generate ID if (!this._overlayId) { this._overlayId = this.overlayService.attach(MyDynamicComponent, this.viewContainerRef, { target: this.myAnchorButton.nativeElement, positionStrategy: new ConnectedPositioningStrategy({ closeOnOutsideClick: false, // overlay will not close on outside clicks modal: false // overlay content will not be rendered in a modal dialog }) // The attach method returns an ID that can be used to reference the shown content }); } this.overlayService.show(this._overlayId); } else { this.overlayService.hide(this._overlayId); // If element if visible, hide it } this._overlayShown = !this._overlayShown; } // finally detach overlay content public ngOnDestroy(): void { if (this._overlayId) { this.overlayService.detach(this._overlayId); delete this._overlayId; } } } <!-- my-overlay-component.component.html --> <div class='content'> ... <button #myAnchorButton (click)=\"toggleOverlay()\">Toggle Overlay</button> </div> Attaching Settings Using the overlaySettings parameter of the attach() method, we can change how the content is shown - e.g. where the content is positioned, how the scroll should behave and if the container is modal or not If no overlaySettings are configured, the toggled element gets the default display settings: defaultOverlaySettings = { positionStrategy: new GlobalPositionStrategy(), scrollStrategy: new NoOpScrollStrategy(), modal: true, closeOnOutsideClick: true, closeOnEscape: false }; Integration with igxToggle The IgxToggleDirective is fully integrated with the IgxOverlayService. As such, the Toggle Directive's toggle() method allows for custom overlay settings to be passed when toggling the content. An example of how to pass configuration settings to the toggle's method is shown below: <!-- In example.component.html --> <div> <button igxToggle (click)=\"callToggle()\">Click me!</button> <div [style.visibility]=\"collapsed ? 'hidden ' : 'visible'\"> This content is toggle-able! </div> </div> // example.component.ts @Component({ selector: `example-component`, template: `example.component.html` }) export class ExampleComponent { @ViewChild(IgxToggleDirective) private toggleDirective: IgxToggleDirective; public get collapsed(): boolean { return this.toggleDirective.collapsed; } public callToggle(): void { const overlaySettings: OverlaySettings = { positionStrategy: new AutoPositionStrategy(), scrollStrategy: new BlockScrollStrategy(), modal: true, closeOnOutsideClick: false } this.toggleDirective.toggle(overlaySettings) } } Assumptions and Limitations If you show the overlay in an outlet, and if the outlet is a child of an element with transform, perspective or filter set in the CSS you won't be able to show the modal overlay. The reason for this is if one of the above mentioned CSS properties is set, the browser creates a new containing block and the overlay is limited to this containing block, as described here. API References IgxOverlayService IgxOverlay Styles Additional Resources Position Strategies Scroll Strategies Styling Topic View page on GitHub"
  },
  "components/overlay-position.html": {
    "href": "components/overlay-position.html",
    "title": "Angular Overlay Service - Positioning Strategies",
    "keywords": "Positioning Strategies Position strategies determine where the content is displayed in the provided IgxOverlayService. By default, the content is positioned in the middle of the screen. Angular Positioning Strategies Example Strategies Overview There are five positioning strategies: Global Positions the content, based on the directions passed in through positionSettings. These are Left/Center/Right for horizontalDirection and Top/Middle/Bottom for verticalDirection. Defaults are: horizontalDirection verticalDirection HorizontalAlignment.Center VerticalAlignment.Middle Container Positions the content as GlobalPositionStrategy. Instead of position related to the screen ContainerPositionStrategy positions the content related to the provided in OverlaySettings outlet. Defaults are: horizontalDirection verticalDirection HorizontalAlignment.Center VerticalAlignment.Middle Connected Positions the element based on the start point from overlaySettings and directions passed in through positionSettings. It is possible to either pass a start point (type Point) or an HTMLElement as a positioning base. Defaults are: target horizontalDirection verticalDirection horizontalStartPoint verticalStartPoint new Point(0, 0) HorizontalAlignment.Right VerticalAlignment.Bottom HorizontalAlignment.Left VerticalAlignment.Bottom Auto Positions the element the same way as the Connected positioning strategy. It also calculates a different starting point in case the element goes partially out of the viewport. The Auto strategy will initially try to show the element like the Connected strategy does. If the element goes out of the viewport Auto will flip the starting point and the direction, i.e. if the direction is 'bottom', it will switch it to 'top' and so on. After flipped, if the element is still out of the viewport, Auto will use the initial directions and the starting point, to push the element into the viewport. For example - if the element goes out of the right side of the viewport, by 50px, Auto will push it by 50px to the left. Afterwards, if the element is partially out of the viewport, then its height or width were greater than the viewport's, Auto will align the element's left/top edge with the viewport's left/top edge. Defaults are: target horizontalDirection verticalDirection horizontalStartPoint verticalStartPoint new Point(0, 0) HorizontalAlignment.Right VerticalAlignment.Bottom HorizontalAlignment.Left VerticalAlignment.Bottom Elastic Positions the element like the Connected positioning strategy and re-sizes the element to fit inside the view port (re-calculating width and/or height) in case the element is partially out of view. minSize can be passed in positionSettings to prevent resizing if it would put the element's dimensions below a certain threshold. Defaults are: target horizontalDirection verticalDirection horizontalStartPoint verticalStartPoint minSize new Point(0, 0) HorizontalAlignment.Right VerticalAlignment.Bottom HorizontalAlignment.Left VerticalAlignment.Bottom { width: 0, height: 0 } Note It won't try to resize the element if the strategy is using HorizontalDirection = Center / VerticalDirection = Middle. Note The overlay element will be resized, but the positioning strategy does not handle overflow. For example, if the element needs to have overflow-y when resized, incorporate the appropriate style to provide that. Usage Position strategies allow you to display content in the overlay in various combinations. To start using different position strategies, you should first include the necessary dependencies for each strategy used like this: import { AutoPositionStrategy, ConnectedPositioningStrategy, ContainerPositionStrategy, ElasticPositionStrategy, GlobalPositionStrategy } from 'igniteui-angular'; // import { AutoPositionStrategy, // ConnectedPositioningStrategy, // ContainerPositionStrategy, // ElasticPositionStrategy, // GlobalPositionStrategy } from '@infragistics/igniteui-angular'; for licensed package Then specify the positioning strategy to be used by the overlay. The position strategy is passed in as a property in the overlaySettings parameter when the overlay.attach() method is called. In the example below we are changing the default GlobalPositionStrategy with ConnectedPositionStrategy: // Initialize and use overlay settings const overlaySettings: OverlaySettings = { // Set the target where content should be shown target: this.buttonElement.nativeElement, // Pass in the positioning strategy positionStrategy: new ConnectedPositioningStrategy() }; this._overlayId = this.overlayService.attach(MyDynamicCardComponent, this.viewContainerRef, overlaySettings); Positioning Settings Each positioning strategy has its own positioning settings. These settings determine how the content will be shown. In the example below, we are creating a new PositionSettings object. Using it we force the overlay to show the content starting from the top right point of the provided target - the buttonElement. The direction in which the content is shown is set to top-left. Then we create a new ConnectedPositionStrategy and pass it the positionSettings. const positionSettings: PositionSettings = { horizontalStartPoint: HorizontalAlignment.Right, verticalStartPoint: VerticalAlignment.Top, horizontalDirection: HorizontalAlignment.Left, verticalDirection: VerticalAlignment.Top }; const strategy = new ConnectedPositioningStrategy(positionSettings); // Initialize and use overlay settings const overlaySettings: OverlaySettings = { target: buttonElement.nativeElement, // Pass in the positioning strategy positionStrategy: strategy }; this._overlayId = this.overlayService.attach(MyDynamicCardComponent, this.viewContainerRef, overlaySettings); Changing Strategies You can also change the positioning strategy, used by the overlay, by overriding the positionStrategy property of the overlaySettings object that is passed to the overlay: const myPositionStrategy = new AutoPositionStrategy(); overlay.attach(element, { positionStrategy: myPositionStrategy }); Changing Settings To change the position settings of an already existing strategy, override any of the settings in it. If a strategy was already attached you should detach the previously generated ID: // overlaySettings is an existing object of type OverlaySettings // overlaySettings.positionStrategy is an existing PositionStrategy with settings of type PositionSettings Object.assign(overlaySettings.positionStrategy.settings, { horizontalStartPoint: HorizontalAlignment.Left, horizontalDirection: HorizontalAlignment.Left }); overlaySettings.target = dummyHTMLElement; // the element will now start to the left of the target (dummyHTMLElement) // and will align itself to the left const overlayId = overlay.attach(overlayId, overlaySettings); overlay.show(overlayId); Offsetting Content To offset the content along the corresponding axis by a provided amount: // deltaX and deltaY determine by how much the content will be offset compared to its' previous position const deltaX: number = 30; const deltaY: number = 15; overlay.setOffset(this._overlayId, deltaX, deltaY); API References IPositionStrategy Additional Resources Overlay Main Topic Scroll Strategies Styling Topic IgxOverlayService IgxOverlay Styles View page on GitHub"
  },
  "components/overlay-scroll.html": {
    "href": "components/overlay-scroll.html",
    "title": "Angular Overlay Service - Scroll Strategies",
    "keywords": "Scroll Strategies The scroll strategy determines how the scrolling is handled in the provided IgxOverlayService. There are four scroll strategies: NoOperation - does nothing. Block - the event is canceled and the component does not scroll with the window. Close - uses a tolerance and closes an expanded component upon scrolling if the tolerance is exceeded. Absolute - scrolls everything. Usage Every scroll strategy has the following methods: initialize - initializes the scroll strategy. It needs a reference of the document, the overlay service and the id of the component rendered attach - attaches the scroll strategy to the specified element or to the document detach - detaches the scroll strategy this.scrollStrategy.initialize(document, overlayService, id); this.scrollStrategy.attach(); this.scrollStrategy.detach(); Getting Started The scroll strategy is passed as a property in the overlaySettings parameter when the overlay.attach() method is called: // Initializing and using overlay settings const overlaySettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy(), scrollStrategy: new AbsoluteScrollStrategy(), //Passes the scroll strategy modal: true, closeOnOutsideClick: true } const overlayId = overlay.attach(dummyElement, overlaySettings); To change the scrolling strategy, used by the overlay, override the scrollStrategy property of the overlaySettings object passed to the overlay. If a strategy was already attached you should detach the previously generated ID: // overlaySettings is an existing object of type OverlaySettings // to override the scroll strategy const newOverlaySettings = Object.assing({}, overlaySettings); Object.assing(newOverlaySettings, { scrollStrategy: new CloseScrollStrategy() }) const overlayId = overlay.attach(dummyElement, newOverlaySettings); overlay.show(overlayId); Dependencies To use the any of the scroll strategies, import it like this: import { NoOpScrollStrategy } from \"./scroll/NoOpScrollStrategy\"; Scroll Strategies The scroll strategies can be passed to the overlaySettings object to determine how the overlay should handle scrolling. The demo below illustrates the difference between the separate scrollStrategies: Modal The overlaySettings object also allows a boolean property (modal) to be passed. This controls how the overlay will be displayed: If the modal property is false, the element will be attached to the DOM foreground but everything will still be active and interactable - e.g. scrolling, clicking, etc. If the modal property is true, the element will be attached to the DOM foreground and an overlay blocker will wrap behind it, stopping propagation of all events: API References IScrollStrategy Additional Resources Overlay Main Topic Position strategies Styling Topic IgxOverlayService IgxOverlay Styles View page on GitHub"
  },
  "components/overlay-styling.html": {
    "href": "components/overlay-styling.html",
    "title": "Angular Overlay Styling",
    "keywords": "Overlay Styling IgxOverlayService is used to display content above the page content. A lot of Ignite UI for Angular components use the overlay - Drop Down, Combo, Date Picker and more - so it is important to understand how the overlay displays content. To display the content above other elements, the service moves it into a special outlet container (attached at the end of the document's body, by default). This behavior can affect styles scoped to specific container. Styling Overlay Components In most cases global theme styles are not affected by the overlay outlets. For example, let's take a look at a Drop Down, styled by the global css-vars mixin: <!-- overlay-styling.component.html --> <igx-drop-down #customDropDown height=\"350px\"> <igx-drop-down-item *ngFor=\"let item of items\" [value]=\"item.id\"> {{ item.name }} </igx-drop-down-item> </igx-drop-down> @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $my-drop-down-theme: drop-down-theme( $palette: $my-custom-palette ); @include css-vars($my-drop-down-theme); The global styles are not generated under a scoped rule and are not affected by any encapsulation, and thus can match any element on the page, including igx-drop-down-item the service moved to the overlay outlet. Scoped Component Styles When scoping styles for elements that are displayed in the overlay, we need to specify to the position of the overlay outlet in the DOM. CSS rules that are scoped require a specific hierarchical structure of the elements - we need to make sure the overlay content is displayed in the correct context of the styles we want to apply. For example, let's take the igx-combo - its item styles use the igx-drop-down theme, because the combo defines its content inside of its own view. Note Always scope your styles in a :host selector to prevent the styles from leaking. // overlay-styling.component.scss :host { @include css-vars($my-drop-down-theme); } If the $legacy-support variable in your theme is set to true, you have to style your component, using the component's theme function. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep // overlay-styling.component.scss :host { ::ng-deep{ @include drop-down($my-drop-down-theme); } } The items in our combo's list are not descendants of our component host - they are currently being displayed in the default overlay outlet, at the end of the document's body. You can change this by using the outlet property in the overlaySettings. The outlet controls where the overlay container should be rendered. Here, we can pass a reference to the element where we'd like our container to be: <igx-combo [data]=\"items\" valueKey=\"name\" displayKey=\"name\" [overlaySettings]=\"{ outlet: element, modal: true }\"> </igx-combo> export class OverlayStylingComponent { ... constructor(public element: ElementRef) { } } Now, the combo's list of items are properly rendered inside of our component's host, which means that our custom theme will take effect: Styling The Overlay Now that we've covered how ViewEncapsulation works along with the overlay's outlet property, we can take a look at how we can style the overlay's wrapper itself. The overlay-theme exposes a single property - $background-color, which affects the color of the backdrop when the overlay is set to modal: true. Global Styles The easiest way to style the overlay modal is to include its theme in our app's global styles: // styles.scss $my-overlay-theme: overlay-theme( $background-color: rgba(0, 153, 255, 0.3) ); @include css-vars($my-overlay-theme); If the $legacy-support variable in your theme is set to true, you have to style your component, using the overlay's theme function. // styles.scss ... @include overlay($my-overlay-theme); Now all modal overlays will have a purple tint to their background. Scoped Overlay Styles If we want our overlay to have a specific background only under a certain component, we can scope the theme. When scoping a modal overlay, you need to move the overlay outlet, which has some limitations. In order to minimize the risks of overflow clipping, z-index and viewport issues, we recommend using outlets for modal overlays only in higher level components: // styles.scss ... .purple { @include css-vars($my-overlay-theme); } To make sure the theme does not affect other components in our app, use the :host selector. // overlay-styling.component.scss @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; ... :host { @include css-vars($my-overlay-theme); } Note If the component is using an Emulated ViewEncapsulation and the $legacy-support is set to true, use the overlay's theme function and penetrate the encapsulation using ::ng-deep API References IgniteUI for Angular - Theme Library IgxOverlay Styles Additional Resources IgniteUI for Angular - Theme Library Overlay Main Topic Position strategies Scroll strategies View page on GitHub"
  },
  "components/paginator.html": {
    "href": "components/paginator.html",
    "title": "Angular Paginator Example – Ignite UI for Angular",
    "keywords": "Angular Paginator Component Overview Pagination in Angular is an optimization technique when working with huge data sets. The purpose of Angular Paginator is to provide UI and API to split and distribute a high volumes of data into equally sized pages, which can be navigated by the end-user. The Angular Paginator component displays to the end-user the page they are viewing, the size of the page, the total number of pages and UI elements for quick navigation between pages. Ignite UI for Angular Paginator allows you to divide a set of data into a number of similar pages. This method of pagination is particularly well-suited for large data-sets which are difficult to display and view all at once, that is why the paginator is typically used together with a list of items or data table. The Paginator in Angular enables the user to select a specific page from a range of pages and to determine how many records they should see on each page. Angular Paginator Example The following Angular Pagination example shows a Paginator template demonstrating how users can navigate through 4 pages with different items and select the number of items to be displayed from a drop-down menu. Getting Started with Ignite UI for Angular Paginator To get started with the Ignite UI for Angular Paginator component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxPaginatorModule in the app.module.ts file. // app.module.ts import { IgxPaginatorModule } from 'igniteui-angular'; // import { IgxPaginatorModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxPaginatorModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxPaginatorComponent as a standalone dependency, or use the IGX_PAGINATOR_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { NgFor } from '@angular/common'; import { HammerModule } from '@angular/platform-browser'; import { IGX_PAGINATOR_DIRECTIVES, IGX_LIST_DIRECTIVES } from 'igniteui-angular'; // import { IGX_PAGINATOR_DIRECTIVES, IGX_LIST_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-list> <igx-list-item *ngFor=\"let item of pagedData\">{{item.text}}</igx-list-item> </igx-list> <igx-paginator [totalRecords]=\"products.length\" [perPage]=\"perPage\"></igx-paginator> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_PAGINATOR_DIRECTIVES, IGX_LIST_DIRECTIVES, HammerModule, NgFor] /* or imports: [IgxPaginatorComponent, IgxListComponent, IgxListItemComponent, HammerModule, NgFor] */ }) export class HomeComponent { public products: Product []; public perPage = 10; public pagedData: Product []; } Now that you have the Ignite UI for Angular Paginator module or directives imported, you can start using the igx-paginator component. Using the Angular Paginator Each paginator instance requires: The number of items per page (default set to 15) The total number of items being paged Also by default the current page is set to 0 when the Angular paginator component is initialized but this can be changed through page property. <igx-paginator #paginator [totalRecords]=\"120\" [perPage]=\"25\"> </igx-paginator> Angular Pagination Template Default pagination template is consisted of two main parts. The first is a drop-down, which allows you define the number of items that are displayed on each page and the second are the navigation buttons which allows you to easily navigate through out the pages. Also, the paging area supports adding custom template by the user, if a igx-paginator-content reference is defined within the igx-paginator: <igx-paginator #paginator> <igx-paginator-content> ... </igx-paginator-content> </igx-paginator> In addition, IgxPageSizeSelectorComponent and IgxPageNavigationComponent were introduced and now the paginator components allows a custom content to be defined, as it is shown in the example below. The first will add the dropdown element and label corresponding for the page size and the latter will handle the page navigation with all action buttons. <igx-paginator #paginator> <igx-paginator-content> <igx-page-size></igx-page-size> <igx-page-nav></igx-page-nav> </igx-paginator-content> </igx-paginator> Paging can also be done programmatically through the Paging API /which is described in more details in the section below/ using the paginate, previousPage, nextPage methods and the inputs page, perPage and totalRecords. Where page allows you to set the current page, perPage - the number of items that are displayed at one page and totalRecords - the number of the records that are in the grid. TotalRecords property is useful when you have paging with remote data and you want to alter the page count based on total remote records. Keep in mind that If you are using paging and all the data is passed to the grid, the value of totalRecords property will be set by default to the length of the provided data source. If totalRecords is set, it will take precedence over the default length based on the data source. Paging API Input Description page Gets/Sets the current page. perPage Gets/Sets the number of visible items per page. selectOptions Gets/Sets custom options in the Select element of the paginator. Default select values [5, 10, 15, 25, 50, 100, 500] totalRecords Gets/Sets the total records count. totalPages Gets/Sets the total Pages count. resourceStrings Gets/Sets the resource strings. By default it uses EN resource strings. overlaySettings Gets/Sets a custom OverlaySettings. Output Description perPageChange Emitted when perPage property value of the paginator is changed. pageChange Emitted after the current page is changed. paging Emitted before paging is performed. Cancelable. pagingDone Emitted after paging is performed. Angular Paginator Localization With only a few lines of code you can easily localize all strings part of the Paging component. In order to localize a given Paging instance use the input property resourceStrings. You can use this Step 1 - Import IPaginatorResourceStrings interface and changei18n function: import { IPaginatorResourceStrings, changei18n } from \"igniteui-angular\"; Step 2 - Define the Paging resource strings: private paginatorResourceStrings: IPaginatorResourceStrings = { igx_paginator_label: 'Records per page:', igx_paginator_first_page_button_text: 'Custom first page text', igx_paginator_last_page_button_text: 'Custom last page text', igx_paginator_next_page_button_text: 'Custom next page text', igx_paginator_previous_page_button_text: 'Custom previous page text', igx_paginator_pager_text: 'out of' }; Step 3 - Pass the object to the changei18n function as a parameter in order to change the global i18n for the component on app.module level. This will change the resource string of all Paging components part of your application: public ngOnInit(): void { changei18n(this.paginatorResourceStrings as any); } In order to change the resource string to a specific Paging component, you can use a @ViewChild and set the desired resourceStrings within a requestAnimationFrame method with a callback, that will be invoked before the page repaint. Setting a newly instantiated object to the resourceStrings property will localize only that given component's instance. @ViewChild('paginator', { read: IgxPaginatorComponent, static: false }) public paginator: IgxPaginatorComponent; ... public ngOnInit(): void { requestAnimationFrame(() => { this.paginator.resourceStrings = this.paginatorResourceStrings; }); } API References IgxPaginator API IgxPaginator Styles Additional Resources Grid Virtualization and Performance Filtering Sorting Summaries Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pie-chart.html": {
    "href": "components/pie-chart.html",
    "title": "Angular Pie Chart | Data Visualization Tool | Infragistics",
    "keywords": "Angular Pie Chart Overview The Ignite UI for Angular pie chart component is a specialized component that renders a pie chart, consisting of a circular area divided into sections. Each section has arc length proportional to its underlying data value. This control is used for representing categorical data. It is most effective when there are only a few categories, and when each category makes up a relatively large percentage of the data as a whole. Angular Pie Chart Example Dependencies When installing the charts component, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-charts Required Modules The IgxPieChartComponent requires the following modules: // app.module.ts import { IgxPieChartModule } from 'igniteui-angular-charts'; @NgModule({ imports: [ // ... IgxPieChartModule, // ... ] }) export class AppModule {} Usage Now that the pie chart module is imported, next step is to bind it to data. In order to create a pie chart, you must first have data to bind it to. The following code snippet demonstrates how to create a simple data source. var data = [ { MarketShare: 30, Company: \"Google\", }, { MarketShare: 30, Company: \"Apple\", }, { MarketShare: 15, Company: \"Microsoft\", }, { MarketShare: 15, Company: \"Samsung\", }, { MarketShare: 10, Company: \"Other\", }, ]; The following code demonstrates how to bind the pie chart to the above data. <igx-pie-chart [dataSource]=\"data\" width=\"100%\" height=\"100%\" labelMemberPath=\"Company\" valueMemberPath=\"MarketShare\"> </igx-pie-chart> Legend In order to display a legend next to the pie chart component an ItemLegend needs to be created and assigned to the IgxLegendComponent property. The legendLabelMemberPath can then be used to specify which property on your data model it will use to display inside the legend for each pie slice. Additionally you can use the legendItemTemplate and legendItemBadgeTemplate properties and the various font properties on ItemLegend to further customize the look of the legend items. <igx-pie-chart [dataSource]=\"data\" width=\"100%\" height=\"100%\" valueMemberPath=\"MarketShare\" labelMemberPath=\"Company\" legendLabelMemberPath=\"Company\" [legend]=\"PieChartLegend\"> </igx-pie-chart> Others Category Sometimes, the underlying data for the pie chart component will contain many items with small values. In this case, the Others category will permit automatic aggregation of several data values into a single slice In the sample below, the othersCategoryThreshold is set to 2, and othersCategoryType is set to Number. Therefore, items with value less than or equal to 2 will be assigned to the “Others” category. If you set othersCategoryType to Percent, then othersCategoryThreshold will be interpreted as a percentage rather than as a value, i.e. items whose values are less than 2% of the sum of all item values would be assigned to the Others category. You can use whichever othersCategoryType is most appropriate for your application. <igx-pie-chart [dataSource]=\"data\" width=\"100%\" height=\"100%\" labelMemberPath=\"Company\" valueMemberPath=\"MarketShare\" othersCategoryThreshold=\"2\" othersCategoryType=\"Number\" othersCategoryText=\"Others\"> </igx-pie-chart> Explosion The pie chart component supports explosion of individual pie slices as well as a SliceClick event that allows you to modify selection states and implement custom logic <igx-pie-chart [dataSource]=\"data\" width=\"100%\" height=\"100%\" allowSliceExplosion=\"true\" sliceClick=\"piechart_SliceClick\"> </igx-pie-chart> Selection The pie chart supports slice selection by mouse click as the default behavior. You can determine the selected slices by using the selectedItems property. The selected slices are then highlighted. There is a property called selectionMode which is how you set what mode you want the pie chart to use. The default value is Single. In order to disable selection, set the property to Manual. The pie chart component supports three different selection modes. Single - When the mode is set to single, only one slice can be selected at a time. When you select a new slice the previously selected slice will be deselected and the new one will become selected. Multiple - When the mode is set to Multiple, many slices can be selected at once. If you click on a slice, it will become selected and clicking on a different slice will also select that slice leaving the previous slice selected. Manual - When the mode is set to Manual, selection is disabled. The pie chart component has 4 events associated with selection: SelectedItemChanging SelectedItemChanged SelectedItemsChanging SelectedItemsChanged The events that end in “Changing” are cancelable events which means you can stop the selection of a slice by setting the event argument property Cancel to true. When set to true the associated property will not update and the slice will not become selected. This is useful for scenarios where you want to keep users from being able to select certain slices based on the data inside it. For scenarios where you click on the Others slice, the pie chart will return an object called IgxPieSliceOthersContext. This object contains a list of the data items contained within the Others slice. <igx-pie-chart [dataSource]=\"data\" width=\"100%\" height=\"100%\" selectionMode=\"multiple\" selectedSliceStroke = \"white\" selectedSliceFill= \"rgb(143,143,143)\" selectedSliceOpacity =1.0 selectedSliceStrokeThickness=2> </igx-pie-chart> Animation You can animate the pie chart smoothly by setting the radiusFactor property, which will scale the chart's radius. Also set the startAngle property to angle the chart such that it keep increasing the chart angle while rotating. In the code below, the radiusFactor is increasing the chart by 0.25% of the size, and startAngle is rotating the chart by 1 degree. When radiusFactor and startAngle reached to its maximum limit the animation is stopped by reset the animation flag and clear the interval. window.setInterval(() => this.tick(), 15); public tick(): void { if (this.isAnimating) { if (this.chart.radiusFactor < 1.0) this.chart.radiusFactor += 0.0025; if (this.chart.startAngle < 360) this.chart.startAngle++; if (this.chart.radiusFactor >= 1.0 && this.chart.startAngle >= 360) { this.isAnimating = false; window.clearInterval(this.interval); } } } View page on GitHub"
  },
  "components/pivotGrid/advanced-filtering.html": {
    "href": "components/pivotGrid/advanced-filtering.html",
    "title": "Advanced Filtering in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Pivot Grid Advanced Filtering The Advanced filtering provides a dialog which allows the creation of groups with filtering conditions across all columns for any Angular table like the Pivot Grid. Angular Pivot Grid Advanced Filtering Example Interaction In order to open the advanced filtering dialog, the Advanced Filtering button in the grid toolbar should be clicked. The dialog is using the IgxQueryBuilder component to generate,display and edit the filtering logic. You can have a look at the Query Builder topic for details on the interaction process. In order to filter the data once you are ready with creating the filtering conditions and groups, you should click the Apply button. If you have modified the advanced filter, but you don't want to preserve the changes, you should click the Cancel button. You could also clear the advanced filter by clicking the Clear Filter button. Usage To enable the advanced filtering, the allowAdvancedFiltering input property should be set to true. The advanced filtering generates a FilteringExpressionsTree which is stored in the advancedFilteringExpressionsTree input property. You could use the advancedFilteringExpressionsTree property to set an initial state of the advanced filtering. ngAfterViewInit(): void { const tree = new FilteringExpressionsTree(FilteringLogic.And); tree.filteringOperands.push({ fieldName: 'ID', condition: IgxStringFilteringOperand.instance().condition('contains'), searchVal: 'a', ignoreCase: true }); const subTree = new FilteringExpressionsTree(FilteringLogic.Or); subTree.filteringOperands.push({ fieldName: 'ContactTitle', condition: IgxStringFilteringOperand.instance().condition('doesNotContain'), searchVal: 'b', ignoreCase: true }); subTree.filteringOperands.push({ fieldName: 'CompanyName', condition: IgxStringFilteringOperand.instance().condition('startsWith'), searchVal: 'c', ignoreCase: true }); tree.filteringOperands.push(subTree); this.pivotGrid.advancedFilteringExpressionsTree = tree; } In case you don't want to show the Pivot Grid toolbar, you could use the openAdvancedFilteringDialog and closeAdvancedFilteringDialog methods to open and close the advanced filtering dialog programmatically. Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Pivot Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Pivot Grid is the intersection between the results of the two filters. External Advanced filtering As you see the demo above the Advanced filtering dialog is hosted in an overlay on top of the Pivot Grid. When the setup in the dialog is ready, the apply or close actions would hide that dialog. There is a way to make that dialog stay always visible - be used as a standalone component. In the demo below, the advanced filtering dialog is declared separately of the Pivot Grid. Demo Usage It's super easy to configure the advanced filtering to work outside of the Pivot Grid. All you need to do is to create the dialog and set its grid property: You can also see how our drag and drop App Builder™ can streamline the entire design-to-Angular-code story. Styling To get started with styling the Advanced Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The advanced filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); Since we have other components inside the advanced filtering dialog, such as buttons, chips, dropdowns and inputs, we need to create a separate theme for each one: $custom-button: button-theme( $disabled-color: gray, ... ); $custom-button-group: button-group-theme( $item-background: #292826, ... ); $custom-input-group: input-group-theme( $box-background: #4a4a4a, ... ); $custom-chip: chip-theme( $background: #FFCD0F, ... ); $custom-drop-down: drop-down-theme( $background-color: #292826, ... ); In this example we only changed some of the parameters for the listed components, but the button-theme, button-group-theme, chip-theme, drop-down-theme, input-group-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also add some styles for other elements inside the advanced filtering dialog. @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); @include drop-down($custom-drop-down); .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } .igx-input-group__input::placeholder { color: gray; } } Note We scope most of the components' mixins within igx-advanced-filtering-dialog, so that these custom themes will affect only components nested in the advanced filtering dialog. Otherwise, other buttons, chips, inputs and dropdowns in the application would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); .igx-input-group__input::placeholder { color: gray; } .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: color($dark-palette, \"secondary\", 400) ); $custom-button: button-theme( $disabled-color: color($dark-palette, \"secondary\", 100), ... ); $custom-button-group: button-group-theme( $item-background: color($dark-palette, \"secondary\", 400), ... ); $custom-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 200), ... ); $custom-chip: chip-theme( $background: color($dark-palette, \"primary\", 400), ... ); $custom-drop-down: drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), ... ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-button, light-button-group, light-chip, light-input-group and light-drop-down schemas: $grid-dark-palette: palette($primary: #11bd7b, $secondary: #e32057, $info: $black-color); $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"info\") ) ) ); $custom-button-schema: extend($_light-button, ( disabled-color:( color: (\"secondary\", 100) ), ... ) ); $custom-button-group-schema: extend($_light-button-group, ( item-background:( color: (\"secondary\", 400) ), ... ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 200) ), ... ) ); $custom-chip-schema: extend($_light-chip, ( background:( color: (\"primary\", 400) ), ... ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), ... ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-button: $custom-button-schema, igx-button-group: $custom-button-group-schema, igx-input-group: $custom-input-group-schema, igx-chip: $custom-chip-schema, igx-drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $grid-dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button-group: button-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-chip: chip-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Filtering Excel Style Filtering Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/batch-editing.html": {
    "href": "components/pivotGrid/batch-editing.html",
    "title": "Batch Editing and Transactions in Angular Pivot Grid Grid - Infragistics",
    "keywords": "Angular Pivot Grid Batch Editing and Transactions Below is a detailed example of how is Batch Editing enabled for the Pivot Grid component. Angular Pivot Grid Batch Editing and Transactions Example The following sample demonstrates a scenario, where the pivotGrid has batchEditing enabled and has row editing enabled. The latter will ensure that transaction will be added after the entire row edit is confirmed. Note Transaction state consists of all the updated, added and deleted rows, and their last states. Usage To get started import the IgxPivotGridModule in the app.module.ts file: // app.module.ts ... import { IgxPivotGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxPivotGridModule], ... }) export class AppModule {} Then, all you need to do is enable batchEditing from your Pivot Grid: <igx-pivot-grid [data]=\"data\" [batchEditing]=\"true\"> ... </igx-pivot-grid> This will ensure a proper instance of Transaction service is provided for the igx-pivot-grid. The proper TransactionService is provided through a TransactionFactory. You can learn more about this internal implementation in the transactions topic. After batch editing is enabled, define a IgxPivotGrid with bound data source and rowEditable set to true and bind: Note The transactions API won't handle end of edit and you'd need to do it by yourself. Otherwise, Pivot Grid would stay in edit mode. One way to do that is by calling endEdit in the respective method. Note Disabling rowEditable property will modify Pivot Grid to create transactions on cell change and will not expose row editing overlay in the UI. API References Additional Resources Build CRUD operations with igxGrid Pivot Grid Overview Pivot Grid Editing Pivot Grid Row Editing Pivot Grid Row Adding Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/cascading-combos.html": {
    "href": "components/pivotGrid/cascading-combos.html",
    "title": "Cascading combos in Angular Pivot Grid Grid - Infragistics",
    "keywords": "Angular Grid with Cascading Combos The Grid's Editing functionality provides with the opportunity to use Cascading Combos. By selecting the value in any preceding Combos, the users will receive only the data that is relevant to their selection within the next Combo. Angular Grid with Cascading Combos Sample Overview The sample below demonstrates how Grid works with nested Cascading Combos. Setup In order enable column editing, make sure editable property is set to true. Once the column editig is enabled, you can start by adding your Single Select ComboBox. Please note that here in order to have only one single selection available, you will need to use igxSimpleCombo instead of modifying the igxCombo. To get started with the Simple ComboBox component, first you need to import the IgxSimpleComboModule in your app.module.ts file: import { IgxSimpleComboModule } from 'igniteui-angular'; @NgModule({ imports: [ ... IgxSimpleComboModule, ... ] }) export class AppModule {} Then, in the template, you should bind the combos igx-simple-combo to some data. displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the simple combobox will use the specified valueKey (if any). export class MySimpleComboComponent implements OnInit { public countriesData: Country[]; public selectedCountry: Country; public selectedCity: City; public ngOnInit() { this.countriesData = getCountries([ 'United States', 'Japan', 'United Kingdom' ]); } } In order to handle the selection change, we need selectionChanging(). The emitted event arguments, IComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the items that were added or removed. Therefore, it will filter the values based on the selection of the previous combo. <igx-combo [data]=\"countriesData\" (selectionChanging)=\"countryChanging($event)\"></igx-combo> public countryChanging(event: IComboSelectionChangeEventArgs) { if (event.added.length) { event.newSelection = event.added; } } And lastly, adding the Linear Progress, which is required while loading the list of data. The id is necessary to set the value of id attribute. <igx-linear-bar [id]=\"'region-progress-' + cell.row.data.ID\" [style.visibility]=\"'hidden'\" type=\"info\" [indeterminate]=\"true\"> </igx-linear-bar> API Summary IgxSimpleComboComponent IgxComboComponent Styles IgxLinearProgressBarComponent IgxLinearProgressBarComponent Styles Additional Resources Pivot Grid Editing Single Select ComboBox Cascading Combos Linear Progress View page on GitHub"
  },
  "components/pivotGrid/cell-editing.html": {
    "href": "components/pivotGrid/cell-editing.html",
    "title": "Angular Pivot Grid Cell Editing",
    "keywords": "Angular Pivot Grid Cell Editing Ignite UI for Angular Pivot Grid component provides a great data manipulation capabilities and powerful API for Angular CRUD operations. By default the Pivot Grid is using in cell editing and different editors will be shown based on the column data type, thanks to the default cell editing template. In addition, you can define your own custom templates for update-data actions and to override the default behavior for committing and discarding any changes. Angular Pivot Grid cell editing and edit templates Example Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. Cell Editing Editing through UI You can enter edit mode for specific cell, when an editable cell is focused in one of the following ways: on double click; on single click - Single click will enter edit mode only if the previously selected cell was in edit mode and currently selected cell is editable. If the previously selected cell was not in edit mode, single click will select the cell without entering edit mode; on key press Enter; on key press F2; You can exit edit mode without committing the changes in one of the following ways: on key press Escape; when you perform sorting, filtering, searching and hiding operations; You can exit edit mode and commit the changes in one of the following ways: on key press Enter; on key press F2; on key press Tab; on single click to another cell - when you click on another cell in the Pivot Grid, your changes will be submitted. operations like paging, resize, pin or move will exit edit mode and changes will be submitted. Note The cell remains in edit mode when you scroll vertically or horizontally or click outside the Pivot Grid. This is valid for both cell editing and row editing. Editing through API You can also modify the cell value through the IgxPivotGrid API but only if primary key is defined: Another way to update cell is directly through update method of IgxGridCell: Cell Editing Templates You can see and learn more for default cell editing templates in the general editing topic. If you want to provide a custom template which will be applied when a cell is in edit mode, you can make use of the igxCellEditor directive. To do this, you need to pass an ng-template marked with the igxCellEditor directive and properly bind your custom control to the cell.editValue: <igx-column field=\"class\" header=\"Class\" [editable]=\"true\"> <ng-template igxCellEditor let-cell=\"cell\" let-value> <igx-select class=\"cell-select\" [(ngModel)]=\"cell.editValue\" [igxFocus]=\"true\"> <igx-select-item *ngFor=\"let class of classes\" [value]=\"class\"> {{ class }} </igx-select-item> </igx-select> </ng-template> </igx-column> This code is used in the sample below which implements an IgxSelectComponent in the cells of the Race, Class and Alignment columns. Note Any changes made to the cell's editValue in edit mode, will trigger the appropriate editing event on exit and apply to the transaction state (if transactions are enabled). Note The cell template igxCell controls how a column's cells are shown when outside of edit mode. The cell editing template directive igxCellEditor, handles how a column's cells in edit mode are displayed and controls the edited cell's edit value. Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. For more information on how to configure columns and their templates, you can see the documentation for Grid Columns configuration. CRUD operations Note Please keep in mind that when you perform some CRUD operation all of the applied pipes like filtering, sorting and grouping will be re-applied and your view will be automatically updated. The IgxPivotGridComponent provides a straightforward API for basic CRUD operations. Adding a new record The Pivot Grid component exposes the addRow method which will add the provided data to the data source itself. Updating data in the Pivot Grid Updating data in the Pivot Grid is achieved through updateRow and updateCell methods but only if primary key for the grid is defined. You can also directly update a cell and/or a row value through their respective update methods. Deleting data from the Pivot Grid Please keep in mind that deleteRow() method will remove the specified row only if primary key is defined. These can be wired to user interactions, not necessarily related to the igx-pivot-grid; for example, a button click: <button igxButton igxRipple (click)=\"deleteRow($event)\">Delete Row</button> Cell validation on edit event Using the grid's editing events we can alter how the user interacts with the grid. In this example, we'll validate a cell based on the data entered in it by binding to the cellEdit event. If the new value of the cell does not meet our predefined criteria, we'll prevent it from reaching the data source by cancelling the event (event.cancel = true). We'll also display a custom error message using IgxToast. The first thing we need to is bind to the grid's event: <igx-pivot-grid (cellEdit)=\"handleCellEdit($event)\" ...> ... </igx-pivot-grid> The cellEdit emits whenever any cell's value is about to be committed. In our handleCellEdit definition, we need to make sure that we check for our specific column before taking any action: The result of the above validation being applied to our igx-pivot-grid can be seen in the below demo: Styling The IgxPivotGrid allows for its cells to be styled through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide range of properties, which allow users to style many different aspects of the grid. In the below steps, we are going to go over how you can style the grid's cell in edit mode and how you can scope those styles. In order to use the Ignite UI Theming Library, we must first import the theme index file in our global styles: Importing style library @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Now we can make use of all of the functions exposed by the Ignite UI for Angular theme engine. Defining a palette After we've properly imported the index file, we create a custom palette that we can use. Let's define two colors that we like and use them to build a palette with igx-palette: $white: #fff; $blue: #4567bb; $color-palette: palette($primary: $white, $secondary: $blue); Defining themes We can now define the theme using our palette. The cells are styled by the grid-theme, so we can use that to generate a theme for our IgxPivotGrid: $custom-grid-theme: grid-theme( $cell-editing-background: $blue, $cell-edited-value-color: $white, $cell-active-border-color: $white, $edit-mode-color: color($color-palette, \"secondary\", 200) ); Applying the theme The easiest way to apply our theme is with a sass @include statement in the global styles file: @include grid($custom-grid-theme); This way, the theme will apply to all grids in our application. If we wish to apply this custom styling only to a specific component, we need to scope the theme. Scoped component theme In order for the custom theme to affect only our specific component, we can move all of the styles we just defined from the global styles file to our custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, our styles will be applied only to our custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-grid-theme); } } } Styling Demo In addition to the steps above, we can also style the controls that are used for the cells' editing templates: igx-input-group, igx-datepicker & igx-checkbox Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridCell IgxPivotGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Build CRUD operations with igxGrid Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/pivotGrid/cell-selection.html": {
    "href": "components/pivotGrid/cell-selection.html",
    "title": "Angular Cell Selection",
    "keywords": "Angular Cell Selection The selection feature enables rich data select capabilities in the Material UI based Pivot Grid. Variety of events and single select actions are available thanks to the powerful API and easy to use methods. The Pivot Grid now supports three modes for cell selection, and you can easily switch between them by changing cellSelection property. You can disable cell selection, you can select only one cell within the grid or to select multiple cells in the grid, which is provided as default option. But let's dive deeper in each of these options. Angular Cell Selection Example The sample below demonstrates the three types of Pivot Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Selection types Pivot Grid Multiple-cell Selection How to select cells: By Mouse drag - Rectangular data selection of cells would be performed. By Ctrl key press + Mouse drag - Multiple range selections would be performed. Any other existing cell selection will be persisted. Instant multi-cell selection by using Shift key. Select single cell and select another single cell by holding the Shift key. Cell range between the two cells will be selected. Keep in mind that if another second cell is selected while holding Shift key the cell selection range will be updated based on the first selected cell position (starting point). Keyboard multi-cell selection by using the Arrow keys while holding Shift key. Multi-cell selection range will be created based on the focused cell. Keyboard multi-cell selection by using the Ctrl + Arrow keys and Ctrl + Home/End while holding Shift key. Multi-cell selection range will be created based on the focused cell. Clicking with the Left Mouse key while holding Ctrl key will add single cell ranges into the selected cells collection. Continuous multiple cell selection is available, by clicking with the mouse and dragging. Pivot Grid Single Selection When you set the [cellSelection]=\"'single'\", this allows you to have only one selected cell in the grid at a time. Also the mode mouse drag will not work and instead of selecting a cell, this will make default text selection. Note When single cell is selected selected event is emitted, no matter if the selection mode is single or multiple. In multi-cell selection mode when you select a range of cells rangeSelected event is emitted. Pivot Grid None selection If you want to disable cell selection you can just set [cellSelection]=\"'none'\" property. In this mode when you click over the cell or try to navigate with keyboard, the cell is not selected, only the activation style is applied and it is going to be lost when you scroll or click over other element on the page. The only way for you to define selection is by using the API methods that are described below. Keyboard navigation interactions While Shift key is pressed Shift + Arrow Up to add above cell to the current selection. Shift + Arrow Down to add below cell to the current selection. Shift + Arrow Left to add left cell to the current selection. Shift + Arrow Right to add right cell to the current selection. While Ctrl + Shift keys are pressed Ctrl + Shift + Arrow Up to select all cells above the focused cell in the column. Ctrl + Shift + Arrow Down to select all cells below the focused cell in the column. Ctrl + Shift + Arrow Left to select all cells till the start of the row. Ctrl + Shift + Arrow Right to select all cells till the end of the row. Ctrl + Shift + Home to select all cells from the focused cell till the first-most cell in the grid Ctrl + Shift + End to select all cells from the focused cell till the last-most cell in the grid Note Continuous scroll is possible only within Grid's body. Api usage Below are the methods that you can use in order to select ranges, clear selection or get selected cells data. Select range const range = { rowStart: 2, rowEnd: 2, columnStart: 1, columnEnd: 1 }; this.grid1.selectRange(range); ... const range = { rowStart: 0, rowEnd: 2, columnStart: 'Name', columnEnd: 'ParentID' }; this.grid1.selectRange(range); Note Select range is additive operation. It will not clear your previous selection. Clear cell selection Get selected data If three different single cells are selected: expectedData = [ { CompanyName: 'Infragistics' }, { Name: 'Michael Langdon' }, { ParentID: 147 } ]; If three cells from one column are selected: expectedData = [ { Address: 'Obere Str. 57'}, { Address: 'Avda. de la Constitución 2222'}, { Address: 'Mataderos 2312'} ]; If three cells are selected with mouse drag from one row and three columns: expectedData = [ { Address: 'Avda. de la Constitución 2222', City: 'México D.F.', ContactTitle: 'Owner' } ]; If three cells are selected with mouse drag from two rows and three columns: expectedData = [ { ContactTitle: 'Sales Agent', Address: 'Cerrito 333', City: 'Buenos Aires'}, { ContactTitle: 'Marketing Manager', Address: 'Sierras de Granada 9993', City: 'México D.F.'} ]; If two different ranges are selected: expectedData = [ { ContactName: 'Martín Sommer', ContactTitle: 'Owner'}, { ContactName: 'Laurence Lebihan', ContactTitle: 'Owner'}, { Address: '23 Tsawassen Blvd.', City: 'Tsawassen'}, { Address: 'Fauntleroy Circus', City: 'London'} ]; If two overlapping ranges are selected, the format would be: expectedData = [ { ContactName: 'Diego Roel', ContactTitle: 'Accounting Manager', Address: 'C/ Moralzarzal, 86'}, { ContactName: 'Martine Rancé', ContactTitle: 'Assistant Sales Agent', Address: '184, chaussée de Tournai', City: 'Lille'}, { ContactName: 'Maria Larsson', ContactTitle: 'Owner', Address: 'Åkergatan 24', City: 'Bräcke'}, { ContactTitle: 'Marketing Manager', Address: 'Berliner Platz 43', City: 'München'} ]; Features integration The multi-cell selection is index based (DOM elements selection). Sorting - When sorting is performed selection will not be cleared. It will leave currently selected cells the same while sorting ascending or descending. Paging - On paging selected cells will be cleared. Selection wont be persisted across pages. Filtering - When filtering is performed selection will not be cleared. If filtering is cleared it will return - the initially selected cells. Resizing - On column resizing selected cells will not be cleared. Hiding - It will not clear the selected cells. If column is hidden, the cells from the next visible column will be selected. Pinning - Selected cell will not be cleared. Same as hiding Group by - On column grouping selected cells will not be cleared. Styling Guidelines The theme engine exposes properties that allows us to style the range of selected cells. Import theme To get started with styling the selection, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Define colors Once done, we can make use of the igx-contrast-color and igx-color functions. With them, we define the colors we would like to use for our selection range: $text-color:contrast-color($default-palette, 'primary', 900); $background-color: color($default-palette, \"primary\", 900); $border-yellow: #f2c43c; Create custom theme Next we create a new theme that extends the grid-theme passing our text-color, background-color and border-yellow variables as $cell-selected-text-color, $cell-selected-background and $cell-active-border-color, respectively: $custom-grid-theme: grid-theme( $cell-selected-text-color: $text-color, $cell-active-border-color: $border-yellow, $cell-selected-background: $background-color ); Apply theme Afterwards, all we need to do is include the mixin in our component's style (could also be in the app styles), so that our igx-pivot-grid uses the newly created theme instead of the default one: @include grid($custom-grid-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. We scope the style under :host selector so as not to affect any other grids we might have in our application. :host { ::ng-deep { @include grid($custom-grid-theme); } } With the custom theme applied, the selected grid cells are highlighted with our selected colors: Note The sample will not be affected by the selected global theme from Change Theme. API References IgxPivotGridComponent API IgxGridRow API IgxGridCell API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Selection Row selection Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/clipboard-interactions.html": {
    "href": "components/pivotGrid/clipboard-interactions.html",
    "title": "Angular Pivot Grid Clipboard Interactions",
    "keywords": "Angular Pivot Grid Clipboard Interactions Copy to clipboard operations are now available in the Pivot Grid. This functionality provides a fast, easy and customizable way to copy data of the Angular Data Grid through the current multi cell data select. System Clipboard behavior gives the user ability to copy data from the Pivot Grid into Excel or other external programs. Angular Pivot Grid Clipboard Interactions Example Functionality Copy behavior is working with the default interaction defined by the browser and operating system. Thus for the copy and paste behaviors, these are: Windows/Unix based Ctrl + C / Ctrl + Ins as a keyboard shortcut Ctrl + V / Shift + Ins as a keyboard shortcut Copy action through the browser menu macOS ⌘ Cmd + C as a keyboard shortcut ⌘ Cmd + V as a keyboard shortcut Copy action through the browser menu Limitations Both the cut and copy events are not natively supported in Internet Explorer. The exception is the paste event (IE 11) which is emitted but does not expose the clipboardData property in the event. Note In order to copy cells in IE 11, you can use the keyboard selection. Hold the shift key in order to make a multi-cell selection, press Ctrl + C in order to copy. The copy behavior is disabled while the grid is in edit mode. The current version of this feature covers only the copy from grid behavior. Later on we plan to expose paste within grid behavior. API Usage We expose clipboardOptions @Input property, which handles the following options: enabled Enables/disables copying of selected cells. copyHeaders Include the associated headers when copying. copyFormatters Apply any existing column formatters to the copied data. separator The string separator to use the for formatting the data in the clipboard. Default is /t Note Excel can automatically detect text that is separated by tabs (tab-delimited /t) and properly paste the data into separate columns. When the paste format doesn't work, and everything you paste appears in a single column, then Excel's delimiter is set to another character, or your text is using spaces instead of tabs. gridCopy Emitted when a copy operation is executed. Fired only if copy behavior is enabled through the clipboardOptions Additional Resources Pivot Grid overview Paging Filtering Sorting Summaries Column Pinning Selection Virtualization and Performance Multi-column headers Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/collapsible-column-groups.html": {
    "href": "components/pivotGrid/collapsible-column-groups.html",
    "title": "Collapsible Column Groups in Angular Pivot Grid - Infragistics",
    "keywords": "Collapsible Column Groups in Angular Data Grid Multi-column headers allow you to have multiple levels of nested columns and column groups. They also provide the ability to mark each column group as collapsible. Collapsible multi-column headers make it possible to collapse/expand, i.e. to show and hide the nested headers under the current one, which will give you a shortened/summarized information for example. Angular Grid Collapsible Column Groups Overview Example Setup To get started with the IgxPivotGrid and the Collapsible multi-column headers , first you need to install Ignite UI for Angular by typing the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxPivotGridModule in the app.module.ts file. Also, we strongly suggest that you take a brief look at multi-column groups topic, to see more detailed information on how to setup the column groups in your grid. Usage Collapsible Column Groups is a part of the multi-column headers feature which provides a way to collapse/expand a column group to a smaller set of data. When a column group is collapsed, a subset of the columns will be shown to the end-user and the other child columns of the group will hide. Each collapsed/expanded column can be bound to the grid data source, or it may be unbound, thus calculated. In order to define a column group as collapsible, you need to set the property to [collapsible]=\"true\" and also keep in mind that you need to define the property visibleWhenCollapsed to at least two child columns: at least one column must be visible when the group is collapsed ([visibleWhenCollapsed]=\"true\") and at least one column must be hidden when the group is expanded ([visibleWhenCollapsed]=\"false\"), otherwise the collapsible functionality will be disabled. If visibleWhenCollapsed is not specified for some of the child columns, then this column will be always visible no matter whether the parent state is expanded or collapsed. So let's see the markup below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <!-- Initially the column groups will be expanded---> <!--The column below will be visible when its parent is collapsed--> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <!--The three columns below will be visible when its parent is expanded--> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column field=\"FirstName\" header=\"First Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column field=\"LastName\" header=\"Last Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column-group header=\"Customer Address\"> <!--This column visibility will not be changed based on parent expand/collapsed state--> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> </igx-column-group> </igx-column-group> And now let's sum up: every child column has three states: Can be always visible, no matter the expanded state of its parent; Can be visible, when its parent is collapsed; Can be hidden, when its parent is collapsed; The initial state of the column group which is specified as collapsible is [expanded]=\"true\". But you can easily change this behavour by setting the property [expanded]=\"false\". Expand/Collapse indicator template Default expand indicator for the igxGrid is the following: Default collapse indicator for the igxGrid is the following: Also, if you need to change the default expand/collapse indicator, we provide two easy ways to do so - via an input property or through a directive. Using an input property You can define custom expand/collapse template and provide it to each of the collapsible column groups using collapsibleIndicatorTemplate input property. Check the markup below: <ng-template #indTemplate let-column=\"column\"> <igx-icon [attr.draggable]=\"false\" >{{column.expanded ? 'remove' : 'add'}} </igx-icon> </ng-template> <igx-column-group header=\"Customer Information\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Using igxCollapsibleIndicator directive Another way to achieve this behavior is to use the igxCollapsibleIndicator directive as shown in the example below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <ng-template igxCollapsibleIndicator let-column=\"column\"> <igx-icon [attr.draggable]=\"false\">{{column.expanded ? 'remove' : 'add'}} </<igx-icon> </ng-template> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Note Please keep in mind that initially collapse group option takes precedence over column hidden - If you declared your column to be hidden using the property hidden and you have a group defined where the same column should be shown, the column will be shown. API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-hiding.html": {
    "href": "components/pivotGrid/column-hiding.html",
    "title": "Angular Pivot Grid Column Hiding",
    "keywords": "Angular Pivot Grid Column Hiding The Ignite UI for Angular Pivot Grid provides an IgxColumnActionsComponent with an IgxColumnHidingDirective which allows users to perform column hiding directly through the user interface or by using the Angular component. The Material UI Grid has a built-in column hiding UI, which can be used through the Pivot Grid's toolbar to change the visible state of the columns. In addition, developers can always define the column hiding UI as a separate component and place it anywhere they want on the page. Angular Pivot Grid Column Hiding Example Pivot Grid Setup Let's start by creating our Pivot Grid and binding it to our data. We will also enable both filtering and sorting for the columns. Toolbar's Column Hiding UI The built-in Column Hiding UI is placed inside an IgxDropDownComponent in the Pivot Grid's toolbar. We can show/hide the Column Hiding UI by using this exact dropdown. For this purpose all we have to do is set both the IgxGridToolbarActionsComponent and the IgxGridToolbarHidingComponent inside of the Pivot Grid. We will also add a title to our toolbar by using the IgxGridToolbarTitleComponent and a custom style for our Pivot Grid's wrapper. The Pivot Grid provides us with some useful properties when it comes to using the toolbar's column hiding UI. By using the igx-grid-toolbar-hiding title property, we will set the title that is displayed inside the dropdown button in the toolbar. By using the columnsAreaMaxHeight property of the IgxGridToolbarHidingComponent, we can set the maximum height of the area that contains the column actions. This way if we have a lot of actions and not all of them can fit in the container, a scrollbar will appear, which will allow us to scroll to any action we want. // columnHiding.component.ts public ngAfterViewInit() { this.hidingActionRef.columnsAreaMaxHeight = \"200px\"; } In order to use the expanded set of functionalities for the column hiding UI, we can use the IgxColumnActionsComponent's columnsAreaMaxHeight property. This way we can use it according to our application's requirements. You can see the result of the code from above at the beginning of this article in the Angular Column Hiding Example section. Custom Column Hiding UI Let's say we want to manually define our IgxColumnActionsComponent, add the IgxColumnHidingDirective so that it knows what its purpose would be and put it anywhere on the page. First, however, we need to import the IgxColumnActionsModule. // app.module.ts ... import { ... IgxColumnActionsModule } from 'igniteui-angular'; // import { ..., IgxColumnActionsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxColumnActionsModule], }) export class AppModule {} Now let's create our IgxColumnActionsComponent. In our application, we will place it next to the grid (which is not the case with the toolbar's column hiding UI, where the component is inside a dropdown by design). We will also set the columns property of the component to the columns of our Pivot Grid and include some custom styles to make our application look even better! Add title and filter prompt A couple more things we can do in order to enrich the user experience of our column hiding component is to set the title and the filterColumnsPrompt properties. The title is displayed on the top and the filterColumnsPrompt is the prompt text that is displayed in the filter input of our column hiding UI. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> <igx-column-actions igxColumnHiding #columnHidingUI [columns]=\"pivotGrid.columns\" title=\"Column Hiding\" filterColumnsPrompt=\"Type here to search\"> </igx-column-actions> </div> Add column display order options We can also allow the user to choose the display order of the columns in the column hiding UI. For this purpose we will use the columnDisplayOrder property, which is an enumeration type property and has the following options: Alphabetical (order the columns alphabetically) DisplayOrder (order the columns according to the way they are displayed in the Pivot Grid) Let's create a couple of nicely designed radio buttons for our options! We just have to go ahead and get the IgxRadio module. // app.module.ts ... import { ... IgxRadioModule } from 'igniteui-angular'; // import { ..., IgxRadioModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxRadioModule], }) export class AppModule {} Now all we have to do is bind the checked property of both radio buttons respectively with different conditions and handle their click events. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> ... <div class=\"columnsOrderOptionsContainer\"> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'Alphabetical'\" (click)=\"columnHidingUI.columnDisplayOrder = 'Alphabetical'\"> Alphabetical order </igx-radio> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'DisplayOrder'\" (click)=\"columnHidingUI.columnDisplayOrder = 'DisplayOrder'\"> Display order </igx-radio> </div> </div> Disable hiding of a column We can easily prevent the user from being able to hide columns through the column hiding UI by simply setting their disableHiding property to true. If all went well, this is how our column hiding UI component should look like: Styling To get started with styling the column actions component, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; By using the simplest approach, we create a new theme that extends the column-actions-theme and accepts the $title-color and the $background-color parameters. $custom-column-actions-theme: column-actions-theme( $background-color: steelblue, $title-color: gold ); As seen, the column-actions-theme only controls colors for the column actions container, but does not affect the buttons, checkboxes and the input-group inside of it. Let's say we want to style the buttons as well, so we will create a new button theme: $custom-button: button-theme($flat-text-color: gold, $disabled-color: black); In this example we only changed the text-color of the flat buttons and the button disabled color, but the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } Note We scope the igx-button mixin within .igx-column-actions, so that only the column hiding buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: gold; $blue-color: steelblue; $custom-palette: palette($primary: $blue-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $title-color: color($custom-palette, \"secondary\", 400), $background-color: color($custom-palette, \"primary\", 200) ); $custom-button: button-theme( $palette: $custom-palette, $flat-text-color: color($custom-palette, \"secondary\", 400), $disabled-color: black ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. // Extending the dark column actions schema $custom-column-actions-schema: extend($_dark-column-actions, ( title-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ) ) ); // Extending the dark button schema $custom-button-schema: extend($_dark-button, ( flat-text-color:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-column-actions: $custom-column-actions-schema, igx-button: $custom-button-schema )); // Defining column-actions-theme with the global dark schema $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $custom-button: button-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References In this article we learned how to use the built-in column hiding UI in the Pivot Grid's toolbar and we defined it as a separate component as well. We introduced a UI that allows the user to choose between different column orders and we set our own custom title and filter prompt texts. We also used an additional Ignite UI for Angular component - the IgxRadio button. The column hiding UI has a few more APIs to explore, which are listed below. IgxColumnActionsComponent IgxColumnActionsComponent Styles Additional components and/or directives with relative APIs that were used: IgxPivotGridComponent properties: hiddenColumnsCount IgxColumnComponent properties: disableHiding IgxGridToolbarComponent properties: showProgress IgxGridToolbarComponent components: IgxGridToolbarTitleComponent IgxGridToolbarActionsComponent IgxGridToolbarComponent methods: IgxPivotGridComponent events: columnVisibilityChanged IgxRadioComponent Styles: IgxPivotGridComponent Styles IgxRadioComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-moving.html": {
    "href": "components/pivotGrid/column-moving.html",
    "title": "Pivot Grid Column Reordering & Moving",
    "keywords": "Pivot Grid Column Reordering & Moving The Pivot Grid component in Ignite UI for Angular provides the Column Moving feature to allow columns reordering via standard drag/drop mouse or touch gestures, or by using the Column Moving API. Column moving works both with pinned and unpinned columns and with Multi-column Headers. Moving a column into the pinned area pins the column and vice versa, moving a column outside of the pinned area unpins the column. Note Reordering between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. Moving is allowed between columns/column-groups, if they are top level columns. Note If a column header is templated and the Column Moving is enabled or the corresponding column is groupable, then the templated elements need to have the draggable attribute set to false! This allows to attach handlers for any event emitted by the element, otherwise the event is consumed by the igxDrag directive. Note If the pinned area exceeds its maximum allowed width (80% of the total Pivot Grid width), a visual clue notifies the end user that the drop operation is forbidden and pinning is not possible. This means you won't be allowed to drop a column in the pinned area. <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> Angular Pivot Grid Column Moving Overview Example Overview Column moving feature is enabled on a per-grid level, meaning that the igx-pivot-grid could have either movable or immovable columns. This is done via the moving input of the igx-grid. API In addition to the drag and drop functionality, the Column Moving feature also provides two API methods to allow moving a column/reordering columns programmatically: moveColumn - Moves a column before or after another column (a target). The first parameter is the column to be moved, and the second parameter is the target column. Also accepts an optional third parameter position (representing a DropPosition value), which determines whether to place the column before or after the target column. // Move the ID column after the Name column const idColumn = grid.getColumnByName(\"ID\"); const nameColumn = grid.getColumnByName(\"Name\"); grid.moveColumn(idColumn, nameColumn, DropPosition.AfterDropTarget); move - Moves a column to a specified visible index. If the passed index parameter is invalid (is negative, or exceeds the number of columns), or if the column is not allowed to move to this index (if inside another group), no operation is performed. // Move the ID column at 3rd position. const idColumn = grid.getColumnByName(\"ID\"); idColumn.move(3); Note that when using the API, only the columnMovingEnd event will be emitted, if the operation was successful. Also note that in comparison to the drag and drop functionality, using the API does not require setting the moving property to true. Events There are several events related to the column moving to provide a means for tapping into the columns' drag and drop operations. These are columnMovingStart, columnMoving and columnMovingEnd. You can subscribe to the columnMovingEnd event of the igx-pivot-grid to implement some custom logic when a column is dropped to a new position. For example, you can cancel dropping the Category after the Change On Year(%) column. Styling To get started with styling the Pivot Grid column moving headers, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $ghost-header-background, $ghost-header-text-color and the $ghost-header-icon-color parameters. // Define dark theme for the column moving $dark-grid-column-moving-theme: grid-theme( $ghost-header-text-color: #F4D45C, $ghost-header-background: #575757, $ghost-header-icon-color: #f4bb5c ); The last step is to include the component mixins with its respective theme: @include grid($dark-grid-column-moving-theme); Note Depending on the component View Encapsulation strategy, it may be necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include grid($dark-grid-column-moving-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #575757; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the pallete. $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $ghost-header-text-color: color($dark-palette, \"primary\", 400), $ghost-header-background: color($dark-palette, \"secondary\", 200), $ghost-header-icon-color: color($dark-palette, \"primary\", 500) ); Note The color and palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid. // Extending the dark grid schema $dark-grid-column-moving-schema: extend($_light-grid, ( ghost-header-text-color:( color: (\"primary\", 400) ), ghost-header-background:( color: (\"secondary\", 200) ), ghost-header-icon-color:( color:( \"primary\", 500) ) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global dark-schema $custom-light-schema: extend($light-schema,( igx-grid: $dark-grid-column-moving-schema, )); // Defining dark-grid-theme with the global dark schema $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References ColumnComponent IgxPivotGridComponent IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-pinning.html": {
    "href": "components/pivotGrid/column-pinning.html",
    "title": "Angular Pivot Grid Column Pinning",
    "keywords": "Angular Pivot Grid Column Pinning A column or multiple columns can be pinned to the left or right side of the Angular UI Grid. Column Pinning in Ignite UI for Angular allows the end users to lock column in a particular column order, this will allow them to see it while horizontally scrolling the Pivot Grid. The Material UI Grid has a built-in column pinning UI, which can be used through the Pivot Grid's toolbar to change the pin state of the columns. In addition, you can define a custom UI and change the pin state of the columns via the Column Pinning API. Angular Pivot Grid Column Pinning Example Column Pinning API Column pinning is controlled through the pinned input of the igx-column. Pinned columns are rendered on the left side of the Pivot Grid by default and stay fixed through horizontal scrolling of the unpinned columns in the Pivot Grid body. You may also use the Pivot Grid's pinColumn or unpinColumn methods of the IgxPivotGridComponent to pin or unpin columns by their field name: Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the column is already in the desired state. A column is pinned to the right of the rightmost pinned column. Changing the order of the pinned columns can be done by subscribing to the columnPin event and changing the insertAtIndex property of the event arguments to the desired position index. Pinning Position You can change the column pinning position via the pinning configuration option. It allows you to set the columns position to either Start or End. When set to End the columns are rendered at the end of the grid, after the unpinned columns. Unpinned columns can be scrolled horizontally, while the pinned columns remain fixed on the right. public pinningConfig: IPinningConfig = { columns: ColumnPinningPosition.End }; Demo Custom Column Pinning UI You can define your custom UI and change the pin state of the columns via the related API. Let's say that instead of a toolbar you would like to define pin icons in the column headers that the end user can click to change the particular column's pin state. This can be done by creating a header template for the column with a custom icon. On click of the custom icon the pin state of the related column can be changed using the column's API methods. public toggleColumn(col: ColumnType) { col.pinned ? col.unpin() : col.pin(); } Demo Pinning Limitations Setting column widths in percentage (%) explicitly makes the Pivot Grid body and header content to be misaligned when there are pinned columns. For column pinning to function correctly the column widths should be in pixels (px) or auto-assigned by the Pivot Grid. API References IgxPivotGridComponent IgxColumnComponent Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-resizing.html": {
    "href": "components/pivotGrid/column-resizing.html",
    "title": "Angular Pivot Grid Column Resizing",
    "keywords": "Angular Pivot Grid Column Resizing With deferred grid column resizing, the user will see a temporary resize indicator while the Angular drag resizing operation is in effect. The new grid column width is applied once the drag operation has ended. Angular Pivot Grid Column Resizing Example Column resizing is also enabled per-column level, meaning that the igx-pivot-grid can have a mix of resizable and non-resizable columns. This is done via the resizable input of the igx-column. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\"></igx-column> You can subscribe to the columnResized event of the igx-pivot-grid to implement some custom logic when a column is resized. Both, previous and new column widths, as well as the IgxColumnComponent object, are exposed through the event arguments. Resizing columns in pixels/percentages Depending on the user scenario, the column width may be defined in pixels, percentages or a mix of both. All these scenarios are supported by the Column Resizing feature. By default if a column does not have width set, it fits the available space with width set in pixels. This means that the following configuration is possible: Note There is a slight difference in the way resizing works for columns set in pixels and percentages. Pixels Resizing columns with width in pixels works by directly adding or subtracting the horizontal amount of the mouse movement from the size of the column. Percentages When resizing columns with width in percentages, the horizontal amount of the mouse movement in pixels translates roughly to its percentage amount relative to the grid width. The columns remain responsive and any future grid resizing will still reflect on the columns as well. Restrict column resizing You can also configure the minimum and maximum allowable column widths. This is done via the minWidth and maxWidth inputs of the igx-column. In this case the resize indicator drag operation is restricted to notify the user that the column cannot be resized outside the boundaries defined by minWidth and maxWidth. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> Mixing the minimum and maximum column width value types (pixels or percentages) is allowed. If the values set for minimum and maximum are set to percentages, the respective column size will be limited to those exact sizes similar to pixels. This means the following configurations are possible: <igx-column [field]=\"'ID'\" width=\"10%\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> or <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'5%'\" [maxWidth]=\"'15%'\"></igx-column> Auto-size columns on double click Each column can be auto sized by double clicking the right side of the header - the column will be sized to the longest currently visible cell value, including the header itself. This behavior is enabled by default, no additional configuration is needed. However, the column will not be auto-sized in case maxWidth is set on that column and the new width exceeds that maxWidth value. In this case the column will be sized according to preset maxWidth value. You can also auto-size a column dynamically using the exposed autosize() method on IgxColumnComponent. @ViewChild('pivotGrid') pivotGrid: IgxPivotGridComponent; let column = this.pivotGrid.columnList.filter(c => c.field === 'ID')[0]; column.autosize(); Auto-size columns on initialization Each column can be set to auto-size on initialization by setting width to 'auto': <igx-column width='auto'>... When the column is first initialized in the view it resolves its width to the size of the longest visible cell or header. Note that cells that are outside of the visible rows are not included. This approach is more performance optimized than auto-sizing post initialization and is recommended especially in cases where you need to auto-size a large number of columns. Styling To get started with the styling of the Pivot Grid column resize line, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The simplest approach to achieve this is to create a new theme that extends the grid-theme and accepts many parameters as well as the $resize-line-color parameter. $custom-grid-theme: grid-theme( $resize-line-color: #0288D1 ); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. :host { ::ng-deep { @include grid($custom-grid-theme); } } Defining a color palette Instead of hard-coding the color values, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the specified primary and secondary color: $primary-color: #0288D1; $secondary-color: #BDBDBD; $custom-theme-palette: palette($primary: $primary-color, $secondary: $secondary-color); And then, with igx-color, we can easily retrieve the color from the palette. $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $resize-line-color: color($custom-theme-palette, 'secondary', 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please, refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend the predefined schema provided for every component, in this case - light-grid schema: // Extending the light grid schema $light-grid-schema: extend($_light-grid, ( resize-line-color: ( color: ('secondary', 500) ), header-background: ( color: (\"primary\", 100) ), header-text-color: ( color: (\"primary\", 600) ) ) ); In order to apply our custom schema, we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global light-schema $custom-light-grid-schema: extend($light-schema,( igx-grid: $light-grid-schema )); // Specifying the palette and schema of the custom grid theme $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $schema: $custom-light-grid-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxPivotGridComponent IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-selection.html": {
    "href": "components/pivotGrid/column-selection.html",
    "title": "Angular Pivot Grid Column Selection",
    "keywords": "Angular Pivot Grid Column Selection The Column selection feature provides an easy way to select an entire column with a single click. It emphasizes the importance of a particular column by focusing the header cell(s) and everything below. The feature comes with a rich API that allows for manipulation of the selection state, data extraction from the selected fractions and data analysis operations and visualizations. Angular Column Selection Example The sample below demonstrates the three types of Pivot Grid's column selection behavior. Use the column selection dropdown below to enable each of the available selection modes. Basic usage The column selection feature can be enabled through the columnSelection input, which takes GridSelectionMode values. Interactions The default selection mode is none. If set to single or multiple all of the presented columns will be selectable. With that being said, in order to select a column, we just need to click on one, which will mark it as selected. If the column is not selectable, no selection style will be applied on the header, while hovering. Note Multi-column Headers don't reflect on the selectable input. The IgxColumnGroupComponent is selectable, if at least one of its children has the selection behaviour enabled. In addition, the component is marked as selected if all of its selectable descendents are selected. Keyboard combinations Note The keyboard combinations are available only when the grid columnSelection input is set to multiple. There are two scenarios for keyboard navigation of the Column Selection feature: Multi-column selection - holding ctrl + click on every selectable header cell. Range column selection - holding shift + click selects all selectable columns in between. API manipulations The API provides some additional capabilities when it comes to the non-visible columns such that, every hidden column could be marked as selected by setting the corresponding setter. Note The above statement also applies to the IgxColumnGroupComponent, except that when the selected property is changed it changes the state of its descendants. More information regarding the API manipulations could be found in the API References section. Styling Before diving into the styling options, the core module and all component mixins need to be imported. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Note Please note that row selection and column selection can't be manipulated independently. They depend on the same variables. With that being said, let's move on and change the selection and hover styles. Following the simplest approach, let's define our custom theme. $custom-grid-theme: grid-theme( $row-selected-background: #011627, $row-selected-text-color: #ECAA53, $row-selected-hover-background: #011627, $header-selected-text-color: #ECAA53, $header-selected-background: #011627 ); grid-theme accepts several parameters but those are the five responsible for changing the appearance of all selected columns: $row-selected-background - sets the background of the selected fraction. $row-selected-text-color - sets the text color of the selected fraction $row-selected-hover-background - sets the color of the hovered cell or bunch of cells. $header-selected-text-color - sets the text color of the selected column header $header-selected-background - sets the background color of the selected column header. Using CSS Variables The last step is to include the custom igx-grid theme. @include css-vars($custom-grid-theme) Overriding the Base Theme In order to style components for Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. Note If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. In order to prevent the custom theme from leaking into other components, be sure that you have included the :host selector before ::ng-deep. :host { ::ng-deep { @include grid($custom-column-selection-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References The column selection UI has a few more APIs to explore, which are listed below. IgxPivotGridComponent IgxColumnComponent IgxColumnGrpupComponent IgxPivotGridComponent Styles IgxPivotGridComponent properties: columnSelection selectedColumns selectColumns deselectColumns selectAllColumns deselectAllColumns IgxColumnComponent properties: selectable selected IgxColumnGrpupComponent properties: selectable selected IgxPivotGridComponent events: onColumnsSelectionChange Additional Resources Pivot Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/column-types.html": {
    "href": "components/pivotGrid/column-types.html",
    "title": "Angular Pivot Grid Column Types",
    "keywords": "Angular Pivot Grid Column Types Ignite UI for Angular Pivot Grid provides a default handling of number, string, date, boolean, currency and percent column data types, based on which the appearance of the default and editing templates will be present. Default template If you want to enable a data type-specific template, you should set the column dataType input otherwise the column will be treated as a string column since that is the default value for column dataType. Let's see what are the default templates for each type. String This column dataType is not changing the appearance or format of the cell value. Number If the dataType is set to number, the cell value will be formatted based on application or grid's locale settings, as well as when pipeArgs property is specified. Then the number format will be changed based on them, for example it might change the: Number of digits after the decimal point Decimal separator with , or . public options = { digitsInfo: '1.4-4', }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatOptions\" [dataType]=\"'number'\"> </igx-column> DateTime, Date and Time The appearance of the date portions will be set (e.g. day, month, year) based on locale format or pipeArgs input. The pipe arguments can be used to specify a custom date format or timezone: format - The default value for formatting the date is 'mediumDate'. Other available options are 'short', 'long', 'shortDate', 'fullDate', 'longTime', 'fulLTime' and etc. This is a full list of all available pre-defined format options. timezone - The user's local system timezone is the default value. The timezone offset or standard GMT/UTC or continental US timezone abbreviation can also be passed. Different timezone examples which will display the corresponding time of the location anywhere in the world: public formatDateOptions = { /** The date/time components that a date column will display, using predefined options or a custom format string. */ /** e.g 'dd/mm/yyyy' or 'shortDate' **/ format: 'longDate', /** A timezone offset (such as '+0430'), or a standard UTC/GMT or continental US timezone abbreviation. */ timezone: 'GMT' }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatDateOptions\" [dataType]=\"'date'\"> </igx-column> Available timezones: Timezone Value Alpha Time Zone ‘UTC+1’ Australian Central Time ‘UTC+9:30/ +10:30’ Arabia Standard Time ‘UTC+3’ Central Standard Time ‘UTC-6’ China Standard Time ‘UTC+8’ Delta Time Zone ‘UTC+4’ Greenwich Mean Time ‘UTC+0’ Gulf Standard Time ‘UTC+4’ Hawaii Standard Time ‘UTC-10’ India Standard Time ‘UTC+4’ The Pivot Grid accepts date values of type Date object, Number (milliseconds), An ISO date-time string. This section shows how to configure a custom display format. As you can see in the sample, we specify a different format options in order to showcase the available formats for the specific column type. For example, below you can find the format options for the time portion of the date object: // Time format with equivalent example public timeFormats = [ { format: 'shortTime', eq: 'h:mm a' }, { format: 'mediumTime', eq: 'h:mm:ss a' }, { format: 'longTime', eq: 'h:mm:ss a z' }, { format: 'fullTime', eq: 'h:mm:ss a zzzz' }, ]; Cell editing When it comes to cell editing based on the column type a different editor will appear: dateTime - IgxDateTimeEditor directive will be used. This editor will give you a mask directions for the input elements part of the DateTime object. date - IgxDatePicker component will be used. time - IgxTimePicker component will be used. Filtering The same editors listed above will be used when it comes to Quick Filtering/Excel-style Filtering. These are the following filtering operands that each type exposes: dateTime and date - Equals, Does Not Equal, Before, After, Today, Yesterday, This Month, Last Month, Next Month, This Year, Last Year, Next Year, Empty, Not Empty, Null, Not Null; time - At, Not At, Before, After, At or Before, At or After, Empty, Not Empty, Null, Not Null; Summaries The available Summary operands will be Count, Earliest (date/time) and Latest (date/time). Sorting Time type column sorts based on the time portion of the object, ms will be disregarded. Date type column sorts based on the date portion, disregards the time portion. DateTime column sorts based on the full date Boolean The default template is using material icons for visualization of boolean values - 'clear' icon for false values and 'check' icon for true values. As for the editing template, it is using igx-checkbox component. <igx-column [dataType]=\"'boolean'\"> </igx-column> Currency Default template The default template will show a numeric value with currency symbol that would be either prefixed or suffixed. Both currency symbol location and number value formatting is based on the provided Application LOCALE_ID or Pivot Grid locale. By using LOCALE_ID import { LOCALE_ID } from '@angular/core'; ... @Component({ selector: 'app-component.sample', templateUrl: 'grid-component.sample.html', providers: [{provide: LOCALE_ID, useValue: 'fr-FR' }] }) By using Grid's locale <igx-grid [locale]=\"'fr-FR'\" [data]=\"data\"> </igx-grid> By using the pipeArgs input the end-user can customize the number format by decimal point, currencyCode and display. public options = { digitsInfo: '3.4-4', currencyCode: 'USD', display: 'symbol-narrow' }; public formatOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatOptions\" [dataType]=\"'currency'\"> </igx-column> Parameter Description digitsInfo Represents Decimal representation of currency value currencyCode ISO 4217 currency code display* Displays the value by narrow or wide symbol *display - for the default en-US locale, the code USD can be represented by the narrow symbol $ or the wide symbol US$. Upon editing of cell's value the currency symbol will be visible as suffix or prefix. More about that could be found in the official Cell editing topic. Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Percent Default template is showing the percent equivalent of the underlying numeric value. The displayed cell value is a multiplied result by display factor of '100' - for example, as the default factor is 100 and the \"value\" passed to the cell is 0.123, then the displayed cell value will be \"12.3%\". When it comes to cell editing, the value will be the same as the data source value - the display factor is '1'. Upon editing of the cell a preview of the percent value will be shown as a suffix element.For example, while editing '0.0547' the preview element will show '5.47%'. public options = { /** * Decimal representation options, specified by a string in the following format: * `{minIntegerDigits}`.`{minFractionDigits}`-`{maxFractionDigits}`. * `minIntegerDigits`: The minimum number of integer digits before the decimal point. Default is 1. * `minFractionDigits`: The minimum number of digits after the decimal point. Default is 0. * `maxFractionDigits`: The maximum number of digits after the decimal point. Default is 3. */ digitsInfo: '2.2-3' }; public formatPercentOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatPercentOptions\" [dataType]=\"'percent'\"> </igx-column> Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Image Default template is using the value coming from the data as an image source to a default image template. The default image template will extract the name of the image file and set it as alt attribute of the image to meet the accessibility requirement. The displayed cell size is adjusted to the sizes of the images rendered, so keep in mind that large images will still be rendered and the grid rows will become as large as the images in the image column. Filtering, sorting and grouping will be turned off by default for image type columns. If you want to enable them, you need to provide custom strategies which perform the data operations. <igx-column [dataType]=\"'image'\"> </igx-column> When auto-generating columns, the grid analyses the values in the first data record. If a value is of type string and matches the pattern of a url ending in an image extension (gif, jpg, jpeg, tiff, png, webp, bmp) then the column will automatically be marked as dataType === GridColumnDataType.Image and a default image template will be rendered. Default editing template See the editing templates part of Pivot Grid Editing topic Custom editing template and formatter Custom template and column formatter definition will always take precedence over the column data type set: Custom template <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"false\"> <igx-column [field]=\"'UnitsInStock'\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [editable]=\"true\"> <ng-template igxCellEditor let-value> {{ value | currency:'USD':'symbol':'1.0-0'}} </ng-template> </igx-column> </igx-grid> Column formatter // Through column formatter property public formatCurrency(value: number) { return `Dollar sign ${value.toFixed(0)}`; } public init(column: IgxColumnComponent) { switch (column.field) { case 'UnitsInStock': column.formatter = this.formatCurrency; break; default: return; } API References IgxGridCell Column pipeArgs Pivot Grid locale Column dataType Additional Resources For custom templates you can see cell editing topic Pivot Grid overview topic Editing topic Summaries topic View page on GitHub"
  },
  "components/pivotGrid/conditional-cell-styling.html": {
    "href": "components/pivotGrid/conditional-cell-styling.html",
    "title": "Angular Pivot Grid Conditional Styling",
    "keywords": "Angular Pivot Grid Conditional Styling If you need to provide any custom styling in the IgxPivotGrid component, you can do it on either row or cell level. Pivot Grid Conditional Row Styling The IgxPivotGrid component in Ignite UI for Angular provides two ways to conditional styling of rows based on custom rules. Further in this topic wi will cover both of them in more details. Using rowClasses // sample.component.ts public rowClasses = { activeRow: this.activeRowCondition }; public activeRowCondition = (row: RowType) => this.grid?.navigation.activeNode?.row === row.index; // sample.component.scss ::ng-deep { .activeRow { border: 2px solid #fc81b8; border-left: 3px solid #e41c77; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo Using rowStyles Columns now expose the rowStyles property which allows conditional styling of the data rows. Similar to rowClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling (without any conditions). The callback signature for both rowStyles and rowClasses is: (row: RowType) => boolean Let's define our styles: Demo Pivot Grid Conditional Cell Styling Overview The IgxPivotGrid component in Ignite UI for Angular provides two ways to conditional styling of cells based on custom rules. By setting the IgxColumnComponent input cellClasses to an object literal containing key-value pairs. The key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. The result is a convenient material styling of the cell. // component.ts file public beatsPerMinuteClasses = { downFont: this.downFontCondition, upFont: this.upFontCondition }; ... private downFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 95; } // component.scss file .upFont { color: red; } .downFont { color: green; } Using cellClasses You can conditionally style the IgxPivotGrid cells by setting the IgxColumnComponent cellClasses input and define custom rules. The cellClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo By using the IgxColumnComponent input cellStyles which accepts an object literal where the keys are style properties and the values are expressions for evaluation. public styles = { 'background': 'linear-gradient(180deg, #dd4c4c 0%, firebrick 100%)', 'text-shadow': '1px 1px 2px rgba(25,25,25,.25)', 'animation': '0.25s ease-in-out forwards alternate popin' }; The callback signature for both cellStyles and cellClasses is now changed to: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Using cellStyles Columns now expose the cellStyles property which allows conditional styling of the column cells. Similar to cellClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling with ease (without any conditions). In the sample above we've created: Two different styles that will be applied based on the column index. You will also change the text color based on even/odd rows. The callback signature for both cellStyles is: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Let's define our styles: // component.ts public oddColStyles = { background: 'linear-gradient(to right, #b993d6, #8ca6db)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'white' : 'gray', animation: '0.75s popin' }; public evenColStyles = { background: 'linear-gradient(to right, #8ca6db, #b993d6)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'gray' : 'white', animation: '0.75s popin' }; On ngOnInit we will add the cellStyles configuration for each column of the predefined columns collection, which is used to create the IgxPivotGrid columns dynamically. // component.ts public ngOnInit() { this.data = athletesData; this.columns = [ { field: 'Id' }, { field: 'Position' }, { field: 'Name' }, { field: 'AthleteNumber' }, { field: 'CountryName' } ]; this.applyCSS(); } public applyCSS() { this.columns.forEach((column, index) => { column.cellStyles = (index % 2 === 0 ? this.evenColStyles : this.oddColStyles); }); } public updateCSS(css: string) { this.oddColStyles = {...this.oddColStyles, ...JSON.parse(css)}; this.evenColStyles = {...this.evenColStyles, ...JSON.parse(css)}; this.applyCSS(); } // component.html <igx-grid #grid1 [data]=\"data\" primaryKey=\"ID\" width=\"80%\" height=\"300px\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\" [cellStyles]=\"c.cellStyles\"> </igx-column> </igx-grid> Define a popin animation // component.scss @keyframes popin { 0% { opacity: 0.1; transform: scale(.75, .75); filter: blur(3px) invert(1); } 50% { opacity: .5; filter: blur(1px); } 100% { transform: scale(1, 1); opacity: 1; filter: none; } } Demo Known issues and limitations If there are cells bind to the same condition (from different columns) and one cell is updated, the other cells won't be updated based on the new value, if the condition is met. A pipe check should be performed in order to apply the changes to the rest of the cells. The example below shows how to do that with a spread operator ... on onCellEdit event. This will copy the original object with a new instance, and lead pure pipe to be fired. public backgroundClasses = { myBackground: (rowData: any, columnKey: string) => { return rowData.Col2 < 10; } }; ... editDone(evt) { this.backgroundClasses = {...this.backgroundClasses}; } <igx-grid #grid1 [data]=\"data\" height=\"500px\" width=\"100%\" (onCellEdit)=\"editDone($event)\"> <igx-column field=\"Col1\" dataType=\"number\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col2\" dataType=\"number\" [editable]=\"true\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col3\" header=\"Col3\" dataType=\"string\" [cellClasses]=\"backgroundClasses\"></igx-column> </igx-grid> API References IgxColumnComponent IgxPivotGridComponent IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Column Hiding Selection Searching Toolbar Multi-column Headers Size (Display Density) Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/display-density.html": {
    "href": "components/pivotGrid/display-density.html",
    "title": "Angular Pivot Grid Size",
    "keywords": "Angular Pivot Grid Size IgxPivotGrid design is based on Material Design Guidelines. We currently provide an option to choose between predefined set of size options that will bring a small, medium, or large view respectively. By selecting the right size for your Material UI table / Material UI grid you can significantly improve the user experience when interacting with large amounts of content. Angular Pivot Grid Size Example Usage As you can see in the demo above, the IgxPivotGrid provides three size options: small, medium and large. The code snippet below shows how to set size: <igx-pivot-grid #pivotGrid [data]=\"data\" style=\"--ig-size: var(--ig-size-small)\"> </igx-pivot-grid> And now let's see in details how each option reflects on the Pivot Grid component. When you switch between different sizes the height of each Pivot Grid element and the corresponding paddings will be changed. Also if you want to apply custom column width, please consider the fact that it must be bigger than the sum of left and right padding. --ig-size-large - this is the default Pivot Grid size with the lowest intense and row height equal to 50px. Left and Right paddings are 24px; Minimal column width is 80px; --ig-size-medium - this is the middle size with 40px row height. Left and Right paddings are 16px; Minimal column width is 64px; --ig-size-small - this is the smallest size with 32px row height. Left and Right paddings are 12px; Minimal column width is 56px; Note Please keep in mind that currently you can not override any of the sizes. Let's now continue with our sample and see in action how each size is applied. Let's first add a button which will help us to switch between each size: <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\"></igx-buttongroup> </div> @ViewChild(IgxButtonGroupComponent) public buttonGroup: IgxButtonGroupComponent; public size = 'small'; public sizes; public ngOnInit() { this.sizes = [ { label: 'small', selected: this.size === 'small', togglable: true }, { label: 'medium', selected: this.sie === 'medium', togglable: true }, { label: 'large', selected: this.size === 'large', togglable: true } ]; } Now we can add the markup. Finally, let's provide the necessary logic in order to actually apply the size: @ViewChild('pivotGrid', { read: IgxPivotGridComponent }) public pivotGrid: IgxPivotGridComponent; public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } Another option that IgxPivotGrid provides for you, in order to be able to change the height of the rows in the Pivot Grid, is the property rowHeight. So let's see in action how this property affects the Pivot Grid layout along with the --ig-size CSS variable. Please keep in mind the following: --ig-size CSS variable will have NO impact on row height if there is rowHeight specified; --ig-size will affect all of the rest elements in the Pivot Grid, as it has been described above; And now we can extend our sample and add rowHeight property to the Pivot Grid: <igx-pivot-grid #pivotGrid [data]=\"data\" [rowHeight]=\"'80px'\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> .............. </igx-pivot-grid> API References IgxPivotGridComponent IgxPivotGridComponent Styles IgxColumnComponent Additional Resources Pivot Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/editing.html": {
    "href": "components/pivotGrid/editing.html",
    "title": "Angular Pivot Grid Editing",
    "keywords": "/* Fix for the overlapping right side-affix when the screen is shrinked */ .table-responsive { width:63vw; } Angular Pivot Grid Editing Ignite UI for Angular Pivot Grid component provides an easy way to perform data manipulation operations like creating, updating, and deleting records. The data manipulation phases are: Cell Editing, Row Editing, and Batch Editing. The Pivot Grid gives you a powerful public API which allows you to customize the way these operations are performed. Additionally, Cell editing exposes several default editors based on the column data type, that could be easily customized via igxCellEditor directive or igxRow directives. Setup In order to specify which edit mode should be enabled, the Pivot Grid exposes the following boolean properties - editable and rowEditable. Property editable enables you to specify the following options: false - the editing for the corresponding column will be disabled; /default value/ true - the editing for the corresponding column will be enabled; Keep in mind that if the column is not editable, you can still modify its value through the public API exposed by the Pivot Grid. Property rowEditable enables you to specify the following options: false - the row editing in the corresponding grid will be disabled; /default value/ true - the row editing in the corresponding grid will be enabled; In the Pivot Grid if you set rowEditable property to true, and editable property is not explicitly defined for any column, the editing will be enabled for all the columns except the primary key. Batch editing in the grid can be enabled for both cell editing and row editing modes. In order to set up batch editing it is necessary to provide to the grid a TransactionService. Cell and Batch Editing - in this scenario every singe modification of each cell is preserved separately and undo/ redo operations are available on cell level; Row and Batch Editing - in this scenario the modifications are preserved on row level so undo/ redo operations will not be working for each cell that is modified but for the bunch of cell from each row. Editing Templates If you want to use a data type specific edit templates, you should specify the column dataType property. So let's now see what are the default templates for each type: For string data type, default template is using igxInput For number data type, default template is using igxInput type=\"number\", so if you try to update cell to a value which can not be parsed to a number your change is going to be discarded, and the value in the cell will be set to 0. For date data type, default template is using igxDatePicker For dateTime data type, default template is using IgxDateTimeEditor directive. This editor will give you a mask directions for the input elements part of the DateTime object. For date data type, default template is using IgxDatePicker component. For time - data type, default template is using IgxTimePicker component. For boolean data type, default template is using igxCheckbox For currency data type, default template is using IgxInputGroup with prefix/suffix configuration based on application or grid locale settings. For percent data type, default template is using IgxInputGroup with suffix element that shows a preview of the edited value in percents. For custom templates you can see Cell Editing topic All available column data types could be found in the official Column types topic. Event arguments and sequence The grid exposes a wide array of events that provide greater control over the editing experience. These events are fired during the Row Editing and Cell Editing lifecycle - when starting, committing or canceling the editing action. Event Description Arguments Cancellable rowEditEnter If rowEditing is enabled, fires when a row enters edit mode IGridEditEventArgs true cellEditEnter Fires when a cell enters edit mode (after rowEditEnter) IGridEditEventArgs true cellEdit If value is changed, fires just before a cell's value is committed (e.g. by pressing Enter) IGridEditEventArgs true cellEditDone If value is changed, fires after a cell has been edited and cell's value is committed IGridEditDoneEventArgs false cellEditExit Fires when a cell exits edit mode IGridEditDoneEventArgs false rowEdit If rowEditing is enabled, fires just before a row in edit mode's value is committed (e.g. by clicking the Done button on the Row Editing Overlay) IGridEditEventArgs true rowEditDone If rowEditing is enabled, fires after a row has been edited and new row's value has been committed. IGridEditDoneEventArgs false rowEditExit If rowEditing is enabled, fires when a row exits edit mode IGridEditDoneEventArgs false Event cancelation RowEditEnter - Neither Row nor Cell will enter edit mode. CellEditEnter - Prevents entering cell edit. If rowEditable is enabled, row edit will be triggered, although cell edit will remain forbidden. CellEdit - Allowed Cell/Row edit, hitting Done button or Enter won't commit the value or row transaction. Cell editing and Row editing won't be closed until Cancel button is clicked. RowEdit - Committing cell is possible, but not the whole row. The row will stay in edit mode and the row transaction will be considered open. Hitting Done does not commit or close the row. Cancel button closes the editing process and the transaction without committing the changes. The following sample demonstrates the editing execution sequence in action: Features integration While a cell/row is in edit mode, a user may interact with the grid in many ways. The following table specifies how a certain interaction affects the current editing: Pivot Grid Filtering Sorting Paging Moving Pinning Hiding GroupBy Resizing Escape Enter F2 Tab Cell Click Add new row/Delete/Edit Keep edit mode ✔ Exit edit mode ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ Commit ✔ ✔ ✔ ✔ ✔ Discard ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ As seen from the table, all interactions, except resizing a column, will end the editing and will discard the new values. Should the new value be committed, this can be done by the developer in the corresponding feature \"-ing\" event. Example how to commit new values, if user tries to sort the column while a cell/row is in edit mode: <igx-grid #grid [data]=\"localData\" [primaryKey]=\"'ProductID'\" (sorting)=\"onSorting($event)\"> ... </igx-grid> public onSorting(event: ISortingEventArgs) { this.grid.endEdit(true); // (event.owner as IgxGridComponent).endEdit(true); } API References IgxGridCell IgxPivotGridComponent Styles IgxGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Pivot Grid overview Build CRUD operations with igxGrid Column Data Types Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/pivotGrid/excel-style-filtering.html": {
    "href": "components/pivotGrid/excel-style-filtering.html",
    "title": "Excel Style Filtering in Angular Pivot Grid - Ignite UI for Angular",
    "keywords": "Excel Filtering in Angular Pivot Grid The grid Excel filtering provides an Excel like filtering UI for any Angular table like the Pivot Grid. Angular Pivot Grid Excel Style Filtering Example Usage To turn on the grid excel filtering, two inputs should be set. The allowFiltering should be set to true and the filterMode should be set to excelStyleFilter. Interactions In order to open the filter menu for a particular column, the Angular filter icon in the header should be clicked. Additionally, you can use the Ctrl + Shift + L combination on a selected header. If the column can be sorted, pinned, moved, selected or hidden along with the filtering functionality, there will be buttons available for the features that are turned on. If no filter is applied, all the items in the list will be selected. They can be filtered from the input above the list. In order to filter the data, you can select/deselect the items in the list and either click the Apply button, or press Enter. The filtering applied through the list items creates filter expressions with equals operator and the logic operator between the expressions is OR. If you type something in the search box and apply the filter, only the items that match the search criteria will be selected. If you want to add items to the currently filtered ones, however, you should select the option Add current selection to filter. If you want to clear the filter, you can check the Select All option and then click the Apply button. To apply a filter with different expressions, you can click the Text filter, which will open a sub menu with all available filter operators for the particular column. Selecting one of them will open the custom filter dialog, where you can add as many expressions as you want with different filter and logic operators. There is also a clear button, which can clear the filter. Configure Menu Features Sorting, pinning and hiding features can be removed from the filter menu using the corresponding inputs: sortable, selected, disablePinning, disableHiding. Templates If you want to further customize the Excel style filter menu without disabling the column features you could use custom templates. The Excel Style filter menu provides two directives for templating: IgxExcelStyleColumnOperationsTemplateDirective - re-templates the area with all column operations like sorting, pinning, etc. IgxExcelStyleFilterOperationsTemplateDirective - re-templates the area with all filter specific operations. You could either re-template only one of those areas or both of them. You could put any custom content inside those directives or you could use any of our built-in Excel style filtering components. The following code demonstrates how to define a custom Excel style filter menu using the igx-excel-style-header, igx-excel-style-sorting and igx-excel-style-search components. You could also re-template the Excel style filtering icon in the column header using the igxExcelStyleHeaderIcon directive: <igx-pivot-grid ...> <ng-template igxExcelStyleHeaderIcon> <igx-icon>filter_alt</igx-icon> </ng-template> </igx-pivot-grid> Here is the full list of Excel style filtering components that you could use: igx-excel-style-header igx-excel-style-sorting igx-excel-style-moving igx-excel-style-pinning igx-excel-style-hiding igx-excel-style-selecting igx-excel-style-clear-filters igx-excel-style-conditional-filter igx-excel-style-search Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. These values can be provided manually and loaded on demand, which is demonstrated in the Pivot Grid Remote Data Operations topic. Formatted Values Filtering Strategy By default, the Pivot Grid component filters the data based on the original cell values, however in some cases you may want to filter the data based on the formatted values. The following sample demonstrates how to format the numeric values of a column as strings and filter the Pivot Grid based on the string values: Note The formatted values filtering strategy won't work correctly if you have more than one column bound to the same field from your data and one of the columns has a formatter. External Excel Style filtering As you see at the demos above the default appearance of the Excel Style filtering dialog is inside the Pivot Grid. So this dialog is only visible when configuring the filters. There is a way to make that dialog stay always visible - it can be used outside of the grid as a standalone component. In the demo below, the Excel style filtering is declared separately of the Pivot Grid. Demo Usage In order to configure the Excel style filtering component, you should set its column property to one of the Pivot Grid's columns. In the sample above, we have bound the column property to the value of an IgxSelectComponent that displays the Pivot Grid's columns. External Outlet The Pivot Grid's z-index creates separate stacking context for each grid in the DOM. This ensures that all descendant elements of the grid will render as intended, without overlapping one another. However, elements that go outside of the grid (e.g. Excel Style filter) will conflict with outside elements with the same z-index (e.g. having two grids one under another) resulting in false rendering. The solution for this issue is to set the outlet property to an external outlet directive which allows the overlay elements to always appear on top. Demo Styling To get started with styling the Excel Style Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The excel style filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); We obviously have a lot more components inside the excel like filtering dialog, such as buttons, checkboxes, a list and even a drop-down. In order to style them, we need to create a separate theme for each one: $dark-button: button-theme( $background: #FFCD0F, $foreground: #292826, $hover-background: #292826, $hover-foreground: #FFCD0F ); $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $custom-list: list-theme( $background: #FFCD0F ); $custom-checkbox: checkbox-theme( $empty-color: #292826, $fill-color: #292826, $tick-color: #FFCD0F, $label-color: #292826 ); $custom-drop-down: drop-down-theme( $background-color: #FFCD0F, $item-text-color: #292826, $hover-item-background: #292826, $hover-item-text-color: #FFCD0F ); In this example we only changed some of the parameters for the listed components, but the button-theme, checkbox-theme, drop-down-theme, input-group-theme, list-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope most of the components' mixins within .igx-excel-filter and .igx-excel-filter__secondary, so that these custom themes will affect only components nested in the excel style filtering dialog and all of its sub-dialogs. Otherwise other buttons, checkboxes, input-groups and lists would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); $dark-button: button-theme( $background: color($dark-palette, \"secondary\", 400), $foreground: color($dark-palette, \"primary\", 400), $hover-background: color($dark-palette, \"primary\", 400), $hover-foreground: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $custom-list: list-theme( $background: color($dark-palette, \"secondary\", 400) ); $custom-checkbox: checkbox-theme( $empty-color: color($dark-palette, \"primary\", 400), $fill-color: color($dark-palette, \"primary\", 400), $tick-color: color($dark-palette, \"secondary\", 400), $label-color: color($dark-palette, \"primary\", 400) ); $custom-drop-down:drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), $item-text-color: color($dark-palette, \"primary\", 400), $hover-item-background: color($dark-palette, \"primary\", 400), $hover-item-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group, light-button, light-list, light-checkbox and light-drop-down schemas: $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"secondary\", 400) ) ) ); $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ), contained-background:( color: (\"secondary\", 400) ), contained-text-color:( color: (\"primary\", 400) ), contained-hover-background:( color: (\"primary\", 400) ), contained-hover-text-color:( color: (\"secondary\", 400) ) ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); $custom-list-schema: extend($_light-list, ( background:( color: (\"secondary\", 400) ) ) ); $custom-checkbox-schema: extend($_light-checkbox, ( empty-color:( color: (\"primary\", 400) ), fill-color:( color: (\"primary\", 400) ), tick-color:( color: (\"secondary\", 400) ), label-color:( color: (\"primary\", 400) ) ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), item-text-color:( color: (\"primary\", 400) ), hover-item-background:( color: (\"primary\", 400) ), hover-item-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( grid: $custom-grid-schema, button: $custom-button-schema, input-group: $custom-input-group-schema, list: $custom-list-schema, checkbox: $custom-checkbox-schema, drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-list: list-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-checkbox: checkbox-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/export-excel.html": {
    "href": "components/pivotGrid/export-excel.html",
    "title": "Angular Pivot Grid Export to Excel - Ignite UI for Angular",
    "keywords": "Angular Pivot Grid Export to Excel Service The Excel Exporter service can export data to excel from the IgxPivotGrid. The data export functionality is encapsulated in the IgxExcelExporterService class. To trigger the process, you need to invoke the IgxExcelExporterService's export method and pass the IgxPivotGrid component as the first argument. Angular Excel Exporter Example Exporting Pivot Grid's Data To start using the IgniteUI Excel Exporter first import the IgxExcelExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts import { IgxExcelExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxExcelExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <igx-pivot-grid #pivotGrid [data]=\"localData\" [autoGenerate]=\"true\"></igx-pivot-grid> <button (click)=\"exportButtonHandler()\">Export IgxPivotGrid to Excel</button> You may access the exporter service by defining an argument of type IgxExcelExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in MS Excel format you need to invoke the exporter service's export method and pass the IgxPivotGrid component as first argument. Here is the code which will execute the export process in the component's typescript file: // component.ts import { IgxExcelExporterService, IgxExcelExporterOptions } from 'igniteui-angular'; import { IgxPivotGridComponent } from 'igniteui-angular'; @ViewChild('pivotGrid') public pivotGrid: IgxPivotGridComponent; constructor(private excelExportService: IgxExcelExporterService) { } public exportButtonHandler() { this.excelExportService.export(this.pivotGrid, new IgxExcelExporterOptions('ExportedDataFile')); } If all went well, you should see the IgxPivotGrid component and a button under it. When pressing the button, it will trigger the export process and the browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the Pivot Grid component in MS Excel format. Note Expand/collapse indicators in Excel are shown based on the hierarchy of the last dimension of the Pivot Grid. Note The exported Pivot Grid will not be formatted as a table, since Excel tables do not support multiple row headers. Customizing the Exported Content In the above examples the Excel Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude all columns from the export if their header is \"Amount of Sale\": // component.ts this.excelExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Amount of Sale') { args.cancel = true; } }); this.excelExportService.export(this.pivotGrid, new IgxExcelExporterOptions('ExportedDataFile')); When you are exporting data from the Pivot Grid component, the export process takes in account features like row filtering and column hiding and exports only the data visible in the Pivot Grid. You can configure the exporter service to include filtered rows or hidden columns by setting properties on the IgxExcelExporterOptions object. Known Limitations Limitation Description Max worksheet size The maximum worksheet size supported by Excel is 1,048,576 rows by 16,384 columns. Cell Styling The excel exporter service does not support exporting a custom style applied to a cell component. In such scenarios we recommend using the Excel Library. API References The Excel Exporter service has a few more APIs to explore, which are listed below. IgxExcelExporterService API IgxExcelExporterOptions API Additional components that were used: IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/filtering.html": {
    "href": "components/pivotGrid/filtering.html",
    "title": "Angular Pivot Grid Filtering",
    "keywords": "Angular Pivot Grid Filtering IgniteUI for Angular Pivot Grid component provides three different filtering types - Quick filtering, Excel style filtering and Advanced filtering which enable you to display only the records that meet specified criteria. The Material UI grid component in Ignite UI provides angular filter capabilities and extensive filtering API through the Data Container to which the Pivot Grid is bound. Angular Pivot Grid Filtering Example The sample below demonstrates Pivot Grid's Quick filtering user experience. API filter() method is used to apply contains condition on the ProductName column through external igxInputGroup component. Setup In order to specify if filtering is enabled and which filtering mode should be used, the Pivot Grid exposes the following boolean properties - allowFiltering, allowAdvancedFiltering, filterMode and filterable. Property allowFiltering enables you to specify the following options: false - the filtering for the corresponding grid will be disabled; /default value/ true - the filtering for the corresponding grid will be enabled; Property allowAdvancedFiltering enables you to specify the following options: false - the advanced filtering for the corresponding grid will be disabled; /default value/ true - the advanced filtering for the corresponding grid will be enabled; Property filterMode enables you to specify the following options: quickFilter - a simplistic filtering UI; /default value/ excelStyleFilter - an Excel-like filtering UI; Property filterable enables you to specify the following options: true - the filtering for the corresponding column will be enabled; /default value/ false - the filtering for the corresponding column will be disabled; <igx-pivot-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"ProductName\"></igx-column> <igx-column field=\"Price\" [dataType]=\"'number'\" [filterable]=\"false\"> </igx-pivot-grid> To enable the Advanced filtering however, you need to set the allowAdvancedFiltering input properties to true. <igx-pivot-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> </igx-pivot-grid> Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Pivot Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Pivot Grid is the intersection between the results of the two filters. Interaction In order to open the filter row for a particular column, the 'Filter' chip below its header should be clicked. To add conditions you should choose filter operand using the dropdown on the left of the input and enter value. For number and date columns 'Equals' is selected by default, for string - 'Contains' and for boolean - 'All'. Pressing 'Enter' confirms the condition and you are now able to add another one. There is a dropdown, between 'condition' chips, which determines the logical operator between them, 'AND' is selected by default. To remove a condition you can click the 'X' button of the chip, and to edit it you should select the chip and the input will be populated with the chip's data. While filter row is opened you can click on any filterable column's header in order to select it and to be able to add filter conditions for it. While some filtering conditions have been applied to a column, and the filter row is closed, you can either remove the conditions by clicking the chip's close button, or you can open the filter row by selecting any of the chips. When there is not enough space to show all the conditions, a filter icon is shown with a badge that indicates how many more conditions there are. It can also be clicked in order to open the filter row. Usage There's a default filtering strategy provided out of the box, as well as all the standard filtering conditions, which the developer can replace with their own implementation. In addition, we've provided a way to easily plug in your own custom filtering conditions. The Pivot Grid currently provides not only a simplistic filtering UI, but also more complex filtering options. Depending on the set dataType of the column, the correct set of filtering operations is loaded inside the filter UI dropdown. Additionally, you can set the ignoreCase and the initial condition properties. Filtering feature is enabled for the Pivot Grid component by setting the allowFiltering input to true. The default filterMode is quickFilter and it cannot be changed run time. To disable this feature for a certain column – set the filterable input to false. Note If values of type string are used by a column of dataType Date, the Pivot Grid won't parse them to Date objects and using filtering conditions won't be possible. If you want to use string objects, additional logic should be implemented on the application level, in order to parse the values to Date objects. You can filter any column or a combination of columns through the Pivot Grid API. The Pivot Grid exposes several methods for this task - filter, filterGlobal and clearFilter. filter - filter a single column or a combination of columns. There are five filtering operand classes exposed: IgxFilteringOperand: this is a base filtering operand, which can be inherited when defining custom filtering conditions. IgxBooleanFilteringOperand defines all default filtering conditions for boolean type. IgxNumberFilteringOperand defines all default filtering conditions for numeric type. IgxStringFilteringOperand defines all default filtering conditions for string type. IgxDateFilteringOperand defines all default filtering conditions for Date type. // Single column filtering // Filter the `ProductName` column for values which `contains` the `myproduct` substring, ignoring case this.pivotGrid.filter('ProductName', 'myproduct', IgxStringFilteringOperand.instance().condition('contains'), true); The only required parameters are the column field key and the filtering term. Both the condition and the case sensitivity will be inferred from the column properties if not provided. In the case of multiple filtering, the method accepts an array of filtering expressions. Note The filtering operation DOES NOT change the underlying data source of the Pivot Grid. // Multi column filtering const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'ch' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); const priceFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'Price'); const priceExpression = { condition: IgxNumberFilteringOperand.instance().condition('greaterThan'), fieldName: 'UnitPrice', ignoreCase: true, searchVal: 20 }; priceFilteringExpressionsTree.filteringOperands.push(priceExpression); gridFilteringExpressionsTree.filteringOperands.push(priceFilteringExpressionsTree); this.pivotGrid.filteringExpressionsTree = gridFilteringExpressionsTree; filterGlobal - clears all existing filters and applies the new filtering condition to all Pivot Grid's columns. // Filter all cells for a value which contains `myproduct` this.pivotGrid.filteringLogic = FilteringLogic.Or; this.pivotGrid.filterGlobal('myproduct', IgxStringFilteringOperand.instance().condition('contains'), false); clearFilter - removes any applied filtering from the target column. If called with no arguments it will clear the filtering of all columns. // Remove the filtering state from the ProductName column this.pivotGrid.clearFilter('ProductName'); // Clears the filtering state from all columns this.pivotGrid.clearFilter(); Initial filtered state To set the initial filtering state of the Pivot Grid, set the IgxPivotGridComponent filteringExpressionsTree property to an array of IFilteringExpressionsTree for each column to be filtered. constructor(private cdr: ChangeDetectorRef) { } public ngAfterViewInit() { const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'ProductName', ignoreCase: true, searchVal: 'c' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); this.pivotGrid.filteringExpressionsTree = gridFilteringExpressionsTree; this.cdr.detectChanges(); } Filtering logic The filteringLogic property of the Pivot Grid controls how filtering multiple columns will resolve in the Pivot Grid. You can change it at any time through the Pivot Grid API, or through the Pivot Grid input property. import { FilteringLogic } from 'igniteui-angular'; // import { FilteringLogic } from '@infragistics/igniteui-angular'; for licensed package ... this.pivotGrid.filteringLogic = FilteringLogic.OR; The default value of AND returns only the rows that match all the currently applied filtering expressions. Following the example above, a row will be returned when both the 'ProductName' cell value contains 'myproduct' and the 'Price' cell value is greater than 55. When set to OR, a row will be returned when either the 'ProductName' cell value contains 'myproduct' or the 'Price' cell value is greater than 55. Custom Filtering Operands You can customize the filtering menu by adding, removing or modifying the filtering operands. By default, the filtering menu contains certain operands based on the column’s data type (IgxBooleanFilteringOperand, IgxDateFilteringOperand, IgxNumberFilteringOperand and IgxStringFilteringOperand). You can extend these classes or their base class IgxFilteringOperand to change the filtering menu items’ behavior. In the sample below, inspect the \"Product Name\" and \"Discontinued\" columns filters menus. For the \"Discontinued\" column filter, we have limited the number of operands to All, True and False. For the \"Product Name\" column filter – we have modified the Contains and Does Not Contain operands logic to perform case sensitive search and added also Empty and Not Empty operands. To do that, extend the IgxStringFilteringOperand and IgxBooleanFilteringOperand, modify the operations and their logic, and set the column filters input to the new operands. // grid-custom-filtering.component.ts export class GridCustomFilteringComponent { public caseSensitiveFilteringOperand = CaseSensitiveFilteringOperand.instance(); public booleanFilteringOperand = BooleanFilteringOperand.instance(); } export class CaseSensitiveFilteringOperand extends IgxStringFilteringOperand { private constructor() { super(); const customOperations = [ { iconName: 'contains', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) !== -1; }, name: 'Contains (case sensitive)' }, { iconName: 'does_not_contain', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) === -1; }, name: 'Does Not Contain (case sensitive)' } ]; const emptyOperators = [ // 'Empty' this.operations[6], // 'Not Empty' this.operations[7] ]; this.operations = customOperations.concat(emptyOperators); } } export class BooleanFilteringOperand extends IgxBooleanFilteringOperand { private constructor() { super(); this.operations = [ // 'All' this.operations[0], // 'TRUE' this.operations[1], // 'FALSE' this.operations[2] ]; } } Re-templating filter cell You can add a template marked with igxFilterCellTemplate in order to retemplate the filter cell. In the sample below, an input is added for the string columns and IgxDatePicker for the date column. When the user types or selects a value, a filter with contains operator for string columns and equals operator for date columns, is applied using grid's public API. Styling To get started with styling the filtering row, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $filtering-row-text-color, $filtering-row-background, $filtering-header-text-color and the $filtering-header-background parameters. $custom-grid: grid-theme( $filtering-row-text-color: #292826, $filtering-row-background: #FFCD0F, $filtering-header-text-color: #292826, $filtering-header-background: #FFCD0F ); As seen, the grid-theme only controls colors for the filtering row and the respective column header that is being filtered. We obviously have a lot more components inside the filtering row, such as an input group, chips, buttons and others. In order to style them, we need to create a separate theme for each one, so let's create a new input group theme and a new button theme: $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $dark-button: button-theme( $flat-background: #FFCD0F, $flat-text-color: #292826, $flat-hover-background: #292826, $flat-hover-text-color: #FFCD0F ); In this example we only changed some of the parameters for the input group and the button, but the input-group-theme and the button-theme provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope the igx-button and the igx-input-group mixins within .igx-grid__filtering-row, so that only the filtering row buttons and its input group would be styled. Otherwise other buttons and input groups in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-text-color: color($dark-palette, \"primary\", 400), $filtering-row-background: color($dark-palette, \"secondary\", 400), $filtering-header-text-color: color($dark-palette, \"primary\", 400), $filtering-header-background: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $dark-button: button-theme( $flat-background: color($dark-palette, \"secondary\", 400), $flat-text-color: color($dark-palette, \"primary\", 400), $flat-hover-background: color($dark-palette, \"primary\", 400), $flat-hover-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group and light-button schemas: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( filtering-row-text-color:( color: (\"primary\", 400) ), filtering-row-background:( color: (\"secondary\", 400) ), filtering-header-text-color:( color: (\"primary\", 400) ), filtering-header-background:( color: (\"secondary\", 400) ) ) ); // Extending the light input group schema $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); // Extending the light button schema $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-input-group: $custom-input-group-schema, igx-button: $custom-button-schema )); // Defining grid-theme with the global light schema $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining button-theme with the global light schema $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining input-group-theme with the global light schema $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Limitations Note Some browsers such as Firefox fail to parse regional specific decimal separators by considering them grouping separators, thus resulting in them being invalid. When inputting such values for a numeric column filter value, only the valid part of the number will be applied to the filtering expression. For further information, refer to the Firefox issue. Breaking Changes in 6.1.0 IgxPivotGrid filteringExpressions property is removed. Use filteringExpressionsTree instead. filter_multiple method is removed. Use filter method and filteringExpressionsTree property instead. The filter method has new signature. It now accepts the following parameters: name - the name of the column to be filtered. value - the value to be used for filtering. conditionOrExpressionTree (optional) - this parameter accepts object of type IFilteringOperation or IFilteringExpressionsTree. If only simple filtering is needed, a filtering operation could be passed as an argument. In case of advanced filtering, an expressions tree containing complex filtering logic could be passed as an argument. ignoreCase (optional) - whether the filtering is case sensitive or not. filteringDone event now have only one parameter of type IFilteringExpressionsTree which contains the filtering state of the filtered column. filtering operands: IFilteringExpression condition property is no longer a direct reference to a filtering condition method, instead it's a reference to an IFilteringOperation. IgxColumnComponent now exposes a filters property, which takes an IgxFilteringOperand class reference. Custom filters can be provided to the Pivot Grid columns by populating the operations property of the IgxFilteringOperand with operations of IFilteringOperation type. API References IgxColumnComponent IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/keyboard-navigation.html": {
    "href": "components/pivotGrid/keyboard-navigation.html",
    "title": "Angular Pivot Grid Keyboard Navigation",
    "keywords": "Angular Pivot Grid Keyboard Navigation Keyboard navigation in the IgxPivotGrid provides a rich variety of keyboard interactions for the user. It enhances the accessibility of the IgxPivotGrid and allows to navigate through any type of elements inside (cell, row, column header, toolbar, footer, etc.). This functionality is enabled by default, and the developer has the option to override any of the default behaviors in an easy way. The tabulations of the IgxPivotGrid has been reduced so that the navigation is compliant with W3C accesibility standards and convenient to use. Currently, the IgxPivotGrid introduces the following tab stops: GroupBy or Toolbar area (if enabled); IgxPivotGrid header; IgxPivotGrid body; Column summaries (if enabled); IgxPivotGrid paginator (if enabled); Note Due to this change, navigating between the cells with tab and Shift + Tab is no longer supported in the IgxPivotGrid. Pressing the Tab key now goes through the tab stops in the following order: GroupBy / Toolbar -> Headers -> Body -> Summaries -> Footer / Paginator. Note Exposing any focusable element into the IgxPivotGrid body via template may introduce side effects in the keyboard navigation, since the default browser behavior is not prevented. It is the developer's responsibility to prevent or modify it appropriately. Header Navigation A full keyboard navigation support in the IgxPivotGrid header is now introduced. Column headers can be easily traversed with the arrow keys. Additionally, there are a number of key combinations that trigger actions on the columns like filtering, sorting, grouping and etc. When the IgxPivotGrid header container is focused, the following key combinations are available: Key Combinations Arrow Up navigates one cell up in the headers (no looping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Down navigates one cell down in the headers (no wrapping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Left navigates one cell left (no looping) Arrow Right navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Home navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Ctrl + Arrow Right navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level End navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level Alt + L opens Advanced Filtering dialog if Advanced Filtering is enabled Ctrl + Shift + L opens the Excel Style Filter dialog or the default (row) filter if the column is filterable Ctrl + Arrow Up sorts the active column header in ASC order. If the column is already sorted in ASC, sorting state is cleared Ctrl + Arrow Down sorts the active column header in DSC order. If the column is already sorted in DSC, sorting state is cleared Space selects the column; If the column is already selected, selection is cleared Body navigation When the IgxPivotGrid body is focused, the following key combinations are available: Key Combination Arrow Up- navigates one cell up (no wrapping) Arrow Down navigates one cell down (no wrapping) Arrow Left navigates one cell left (no wrapping between lines) Arrow Right - navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row Ctrl + Arrow Right navigates to the rightmost cell in the row Ctrl + Arrow Up navigates to the first cell in the column Ctrl + Arrow Down navigates to the last cell in the column Home navigates to the leftmost cell in the row End navigates to the rightmost cell in the row Ctrl + Home navigates to the top leftmost data cell in the grid Ctrl + End navigates to the bottom rightmost data cell in the grid Page Up scrolls one page (view port) up Page Down scrolls one page (view port) down Enter enters edit mode F2 enters edit mode Esc exits edit mode Tab available only if there is a cell in edit mode; moves the focus to the next editable cell in the row; after reaching the last cell in the row, moves te focus to the first editable cell in the next row. When Row Editing is enabled, moves the focus from the right-most editable cell to the CANCEL and DONE buttons, and from DONE button to the left-most editable cell in the row Shift + Tab - available only if there is a cell in edit mode; moves the focus to the previous editable cell in the row; after reaching the first cell in the row, moves the focus to the last editable cell in the previous row. When Row Editing is enabled, moves the focus from the right-most editable cell to CANCEL and DONE buttons, and from DONE button to the right-most editable cell in the row Space - selects the row, if Row Selection is enabled Alt + Arrow Left or Alt + Arrow Up - Alt + Arrow Right or Alt + Arrow Down - Practice all of the above mentioned actions in the demo sample below. Focus any navigable grid element and a list with some of the available actions for the element will be shown to guide you through. Demo Custom keyboard navigation Overriding the default behavior for a certain key or keys combination is one of the benefits that the Keyboard Navigation feature provides. For example: press the Enter or Tab key to navigate to the next cell or the cell below. This or any other navigation scenario is easily achieved by the Keyboard Navigation API: Let's try the API to demonstrate how to achieve common scenarios like user input validation and custom navigation. First we need to register an event handler for the gridKeydown event: public customKeydown(args: IGridKeydownEventArgs) { const target: IgxGridCell = args.target as IgxGridCell; const evt: KeyboardEvent = args.event as KeyboardEvent; const type = args.targetType; if (type === 'dataCell' && target.inEditMode && evt.key.toLowerCase() === 'tab') { // 1. USER INPUT VALIDATON ON TAB } if (type === 'dataCell' && evt.key.toLowerCase() === 'enter') { // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS } } Based on the IGridKeydownEventArgs values we identified two cases, where to provide our own logic (see above). Now, using the methods from the API, let's perform the desired - if the user is pressing Tab key over a cell in edit mode, we will perform validation on the input. If the user is pressing Enter key over a cell, we will move focus to cell in the next row: Known Limitations Limitation Description Navigating inside а grid with scrollable parent container. If the grid is positioned inside a scrollable parent container and the user navigates to a grid cell that is out of view, parent container will not be scrolled. API References IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/live-data.html": {
    "href": "components/pivotGrid/live-data.html",
    "title": "Angular Pivot Grid Live Data Updates",
    "keywords": "Angular Pivot Grid Live Data Updates The Pivot Grid component is able to handle thousands of updates per second, while staying responsive for user interactions. Angular Live-data Update Example The sample below demonstrates the Pivot Grid performance when all records are updated multiple times per second. Use the UI controls to choose the number of records loaded and the frequency of updates. Feed the same data into the Line Chart to experience the powerful charting capabilities of Ignite UI for Angular. The Chart button will show Category Prices per Region data for the selected rows and the Chart column button will show the same for the current row. View page on GitHub"
  },
  "components/pivotGrid/multi-column-headers.html": {
    "href": "components/pivotGrid/multi-column-headers.html",
    "title": "Angular Pivot Grid Multi-column Headers Overview",
    "keywords": "Angular Pivot Grid Multi-column Headers Overview IgxPivotGrid supports multi-column headers which allows you to group columns by placing them under a common multi headers. Each multi-column headers group could be a representation of combinations between other groups or columns within the Material UI grid. Angular Pivot Grid Multi-column Headers Overview Example The declaration of Multi-column header could be achieved by wrapping a set of columns into igx-column-group component with header title passed. For achieving n-th level of nested headers, the declaration above should be followed. So by nesting igx-column-group leads to the desired result. Every igx-column-group supports moving, pinning and hiding. Note When there is a set of columns and column groups, pinning works only for top level column parents. More specifically pinning per nested column groups or columns is not allowed. Please note that when using Pinning with Multi-Column Headers, the entire Group gets pinned. Moving between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. When columns/column-groups are not wrapped by current group which means they are top level columns, moving is allowed between whole visible columns. Multi-column Header Template Each of the column groups of the grid can be templated separately. The column group expects ng-template tag decorated with the igxHeader directive. The ng-template is provided with the column group object as a context. ... <igx-column-group header=\"General Information\"> <ng-template igxHeader let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... </igx-column-group> ... If you want to re-use a single template for several column groups, you could set the headerTemplate property of the column group like this: <ng-template #columnGroupHeaderTemplate let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... <igx-column-group header=\"General Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> <igx-column-group header=\"Address Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> ... Note If a column header is retemplated and the grid moving is enabled, you have to set the draggable attribute of corresponding column to false on the templated elements, so that you can handle any of the events that are applied! <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> The following sample demonstrates how to implement collapsible column groups using header templates. Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $header-background, $header-text-color, $header-border-width, $header-border-style and $header-border-color parameters. $custom-theme: grid-theme( $header-background: #e0f3ff, $header-text-color: #e41c77, $header-border-width: 1px, $header-border-style: solid, $header-border-color: rgba(0, 0, 0, 0.08) ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $light-blue-color: #e0f3ff; $deep-pink-color: #e41c77; $custom-palette: palette($primary: $light-blue-color, $deep-pink-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $header-background: color($custom-palette, \"primary\", 500), $header-text-color: color($custom-palette, \"secondary\", 500), $header-border-width: 1px, $header-border-style: solid, $header-border-color: color($custom-palette, \"grays\", 200) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( header-background: (igx-color:('primary', 500)), header-text-color: (igx-color:('secondary', 500)), header-border-width: 1px, header-border-style: solid, header-border-color: (igx-color:('grays', 200)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations Using Pivot Grid with multi-column headers on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API References IgxPivotGridComponent IgxPivotGridComponent Styles IgxColumnGroupComponent Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/multi-row-layout.html": {
    "href": "components/pivotGrid/multi-row-layout.html",
    "title": "Angular Grid Multi-row Layout - Ignite UI for Angular",
    "keywords": "Angular Multi-row Layout Multi-row Layout extends the rendering capabilities of the igxGridComponent. The feature allows splitting a single data record into multiple visible rows. Angular Multi-row Layout Example The declaration of Multi-row Layout is achieved through igx-column-layout component. Each igx-column-layout component should be considered as a block, containing one or multiple igx-column components. Some of the grid features work on block level (those are listed in the \"Feature Integration\" section below). For example the virtualization will use the block to determine the virtual chunks, so for better performance split the columns into more igx-column-layout blocks if the layout allows it. There should be no columns outside of those blocks and no usage of IgxColumnGroupComponent when configuring a multi-row layout. Multi-row Layout is implemented on top of the grid layout specification and should conform to its requirements. IgxColumnComponent exposes four @Input properties to determine the location and span of each cell: colStart - column index from which the field is starting. This property is mandatory. rowStart - row index from which the field is starting. This property is mandatory. colEnd - column index where the current field should end. The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field. This property is optional. If not set defaults to colStart + 1. rowEnd - row index where the current field should end. The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field. This property is optional. If not set defaults to rowStart + 1. <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [rowEnd]=\"3\" field=\"ID\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"CompanyName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"2\" field=\"ContactName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"2\" [colEnd]=\"3\" field=\"ContactTitle\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"Country\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"3\" [colEnd]=\"5\" field=\"Region\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"5\" [colEnd]=\"7\" field=\"PostalCode\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"4\" field=\"City\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"4\" [colEnd]=\"7\" field=\"Address\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" field=\"Phone\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" field=\"Fax\"></igx-column> </igx-column-layout> The result of the above configuration can be seen on the screenshot below: Note rowStart and colStart properties must be set for each igx-column into igx-column-layout. The igxColumnLayout component is not verifying if the layout is correct and not throwing errors or warnings about that. The developers must make sure that the declaration of their layout is correct and complete, otherwise they may end up in broken layout with misalignments, overlaps and browser inconsistencies. Feature Integration Due to the completly different rendering approach of Multi-row Layout, some of the column features will work only on igx-column-layout component. Such features are Column Pinning and Column Hiding. Othes like - Sorting and Grouping will work in the same way - on igx-column component. Filtering - only Excel Style Filtering is supported. Setting filterMode explicitly to FilterMode.quickFilter has no effect. Paging - works on records, not visual rows. Group By - hideGroupedColumns option has no effect in Multi-row Layout. The grouped columns are always visible. The following features are currently not supported: Column Moving Multi-column Headers Export to Excel Summaries Keyboard Navigation IgxGridComponent with Multi-Row Layouts provides build-in keyboard navigation. Horizontal nagivation Arrow Left or Arrow Right - move to the adjacent cell on the left/right within the current row unaffected by the column layouts that are defined. If the current cell spans on more than one row, Arrow Left and Arrow Right should navigate to the first cell on the left and right with the same rowStart, unless you have navigated to some other adjacent cell before. The navigation stores the starting navigation cell and navigates to the cells with the same rowStart if possible. Ctrl + Arrow Left (HOME) or Ctrl + Arrow Right (END) - navigate to the start or end of the row and select the cell with accordance to the starting navigation cell. Vertical nagivation Arrow Up or Arrow Down - move to the cell above/below in relation to a starting position and is unaffected by the rows. If the current cell spans on more than one column the next active cell will be selected with accordance to the starting navigation cell. Ctrl + Arrow Up or Ctrl + Down - Navigate and apply focus on the same column on the first or on the last row. Ctrl + Home or Ctrl + End - Navigate to the first row and focus first cell or navigate to the last row and focus the last cell. Note Navigation through cells which span on multiple rows or columns is done with accordance to the starting navigation cell and will allow returning to the starting cell using the key for the opposite direction. The same approach is used when navigating through group rows. Note Selection and multi cell selection are working on layout, meaning that when a cell is active, its layout will be selected. Also all features of multiple selection like drag selection are applicable and will work per layout not per cell. Custom Keyboard Navigation The grid allows customizing the default navigation behavior when a certain key is pressed. Actions like going to the next cell or cell below could be handled easily with the powerful keyboard navigation API: gridKeydown is exposed. The event will emit IGridKeydownEventArgs. This event is available only through the keyboard key combinations mentioned above, for all other key actions you can use keydown event (keydown)=\"onKeydown($event)\" navigateTo - this method allows you to navigate to a position based on provided rowindex and visibleColumnIndex The demo below adds additional navigation down/up via the Enter and Shift + Enter keys, similar to the behavior observed in Excel. Demo Layout Configurator Sometimes when configuring a column layout it might be a challenge to calculate and set the proper colStart and colEnd or rowStart and rowEnd. Especially when there are a lot of columns in a single layout. That is why we have created a small configurator, so you can easily do that and have a similar preview of how it would look inside the igxGrid when applied. You can do the following interactions with it: Set number of rows for the whole configuration. All layouts must have the same amount of rows. Add/Remove column layouts by clicking the Add Layout chip or reordering them by dragging a layout chip left/right. Set specific settings for each layout as number of columns and how wide they will be. The setting refer to the currently selected layout. Resize column cells in the layout preview so they can span more columns/rows or clear them using the Delete button. Set columns in the preview by dragging a column chip in the place your will want it to be. Add/Remove new columns by using the Add Column chip. Get template output of the whole configuration ready to by placed inside an igxGrid or the JSON representation that can also be used and parsed in your template using NgForOf for example. By default we have set the same columns as our previous sample, but it can be cleared and configured to match your desired configuration. Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Multi-row Layout styling. Importing global theme To begin the customization of the Multi-row Layout feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the feature layout as desired. $custom-theme: grid-theme( $cell-active-border-color: #ffcd0f, $cell-selected-background: #6f6f6f, $row-hover-background: #fde069, $row-selected-background: #8d8d8d, $header-background: #494949, $header-text-color: #fff, $sorted-header-icon-color: #ffcd0f, $sortable-header-icon-hover-color: #e9bd0d ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #494949; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $cell-active-border-color: color($custom-palette, \"secondary\", 500), $cell-selected-background: color($custom-palette, \"primary\", 300), $row-hover-background: color($custom-palette, \"secondary\", 300), $row-selected-background: color($custom-palette, \"primary\", 100), $header-background: color($custom-palette, \"primary\", 500), $header-text-color:contrast-color($custom-palette, \"primary\", 500), $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"secondary\", 600) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 300)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('secondary', 600)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme do affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxPivotGridComponent IgxPivotGridComponent Styles IgxColumnLayoutComponent IgxColumnComponent Additional Resources Pivot Grid overview Virtualization and Performance Paging Sorting Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/paging.html": {
    "href": "components/pivotGrid/paging.html",
    "title": "Angular Grid Paging | Angular Pagination Table | Infragistics",
    "keywords": "Angular Pivot Grid Pagination Pagination is used to split a large set of data into a sequence of pages that have similar content. Angular table pagination improves user experience and data interaction. Pivot Grid pagination is configurable via a separate component projected in the grid tree by defining a igx-paginator tag, similar to adding of a column. As in any Angular Table, the pagination in the Pivot Grid supports template for custom pages. Angular Pagination Example The following example represents Pivot Grid pagination and exposes the options usage of items per page and how paging can be enabled. The user can also quickly navigate through the Pivot Grid pages via \"Go to last page\" and \"Go to first page\" buttons. Adding a igx-paginator component will control whether the feature is present, you can enable/disable it by using a simple *ngIf with a toggle property. The perPage input controls the visible records per page. Let’s update our Pivot Grid to enable paging: <igx-pivot-grid #pivotGrid [data]=\"data\" [height]=\"'500px'\" [width]=\"'100%'\"> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-pivot-grid> Example: <igx-paginator #paginator [totalRecords]=\"20\"> <igx-paginator-content> <div id=\"numberPager\" style=\"justify-content: center;\"> <button [disabled]=\"paginator.isFirstPage\" (click)=\"paginator.previousPage()\" igxButton=\"flat\"> PREV </button> <span> Page {{paginator.page}} of {{paginator.totalPages}} </span> <button [disabled]=\"paginator.isLastPage\" (click)=\"paginator.nextPage()\" igxButton=\"flat\"> NEXT </button> </div> </igx-paginator-content> </igx-paginator> Usage Paginator Component Demo Remote Paging Remote paging can be achieved by declaring a service, responsible for data fetching and a component, which will be responsible for the Grid construction and data subscription. For more detailed information, check the Pivot Grid Remote Data Operations topic. Pagination Styling in Angular To get started with styling the paginator, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the paginator-theme and accepts the $text-color, $background-color and the $border-color parameters. $dark-paginator: paginator-theme( $text-color: #F4D45C, $background-color: #575757, $border-color: #292826 ); As seen, the paginator-theme only controls colors for the paging container, but does not affect the buttons in the pager UI. To style those buttons, let's create a new button theme: $dark-button: button-theme( $icon-color: #FFCD0F, $icon-hover-color: #292826, $icon-hover-background: #FFCD0F, $icon-focus-color: #292826, $icon-focus-background: #FFCD0F, $disabled-color: #16130C ); In this example we only changed the icon color and background and the button disabled color, but the the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include grid-paginator($dark-grid-paginator); .igx-grid-paginator__pager { @include button($dark-button); } Note We scope the igx-button mixin within .igx-paginator__pager, so that only the paginator buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include paginator($dark-paginator); .igx-paginator__pager { @include button($dark-button); } } } Defining a Color Palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F9D342; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the pallette. $dark-paginator: paginator-theme( $palette: $dark-palette, $text-color: color($dark-palette, \"secondary\", 400), $background-color: color($dark-palette, \"primary\", 200), $border-color: color($dark-palette, \"primary\", 500) ); $dark-button: button-theme( $palette: $dark-palette, $icon-color: color($dark-palette, \"secondary\", 700), $icon-hover-color: color($dark-palette, \"primary\", 500), $icon-hover-background: color($dark-palette, \"secondary\", 500), $icon-focus-color: color($dark-palette, \"primary\", 500), $icon-focus-background: color($dark-palette, \"secondary\", 500), $disabled-color: color($dark-palette, \"primary\", 700) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-pagination and dark-button schemas: // Extending the dark paginator schema $dark-paginator-schema: extend($_dark-pagination, ( text-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ), border-color:( color:( \"primary\", 500) ) ) ); // Extending the dark button schema $dark-button-schema: extend($_dark-button, ( icon-color:( color:(\"secondary\", 700) ), icon-hover-color:( color:(\"primary\", 500) ), icon-hover-background:( color:(\"secondary\", 500) ), icon-focus-color:( color:(\"primary\", 500) ), icon-focus-background:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-paginator: $dark-paginator-schema, igx-button: $dark-button-schema )); // Definingpaginator-theme with the global dark schema $dark-paginator: paginator-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $dark-button: button-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. API References IgxPivotGridComponent API IgxPivotGridComponent Styles IgxGridPaginator Styles Additional Resources Pivot Grid overview Paginator Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/pivot-grid.html": {
    "href": "components/pivotGrid/pivot-grid.html",
    "title": "Angular Pivot Grid & Table – Ignite UI for Angular",
    "keywords": "Angular Pivot Grid Component Overview Ignite UI for Angular Pivot Grid is one of our best Angular Components, representing a table of grouped values and aggregates that lets you organize and summarize data in a tabular form. It is a data summarization tool that is used to reorganize and summarize selected columns and rows of data coming from a spreadsheet or database table to obtain a desired report. What is Angular Pivot Grid? The Angular Pivot Grid component presents data in a pivot table and helps perform complex analysis on the supplied data set. This sophisticated Pivot Grid control is used for organizing, summarizing, and filtering large volumes of data which is later displayed in a cross-table format. Key features of an Angular Pivot Grid are row dimensions, column dimensions, aggregations, and filters. The IgxPivotGridComponent gives the ability to users to configure and display their data in a multi-dimensional pivot table structure. The rows and columns represent distinct data groups, and the data cell values represent aggregations. This allows complex data analysis based on a simple flat data set. The IgxPivotGridComponent is a feature-rich pivot table that provides easy configuration of the different dimensions and values as well as additional data operations on them like filtering and sorting. Angular Pivot Grid Example The following is an Angular Pivot Grid example in combination with the Angular Pivot Data Selector Component. This way you can have more flexible runtime configuration options. Getting started with Ignite UI for Angular Pivot Grid To get started with the Ignite UI for Angular Pivot Grid component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxPivotGridModule in your app.module.ts file. // app.module.ts import { IgxPivotGridModule } from 'igniteui-angular'; // import { IgxPivotGridModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxPivotGridModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxPivotGridComponent as a standalone dependency, or use the IGX_PIVOT_GRID_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_PIVOT_GRID_DIRECTIVES } from 'igniteui-angular'; // import { IGX_PIVOT_GRID_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-pivot-grid [data]=\"data\" [pivotConfiguration]=\"pivotConfigHierarchy\"> </igx-pivot-grid> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_PIVOT_GRID_DIRECTIVES] /* or imports: [IgxPivotGridComponent] */ }) export class HomeComponent { public data: Transaction []; } Now that you have the Ignite UI for Angular Pivot Grid module or directives imported, you can start using the igx-pivot-grid component. Using the Angular Pivot Grid The Angular Pivot Grid Component can be configured via the pivotConfiguration property. <igx-pivot-grid #grid1 [data]=\"data\" [pivotConfiguration]=\"pivotConfigHierarchy\"> </igx-pivot-grid> It is defined by three main dimensions: rows, columns and values. The rows and columns define the grouped structure that is displayed in the rows and columns of the Angular grid. The values define the aggregation fields and the aggregation that will be used to calculate and display the related values of the groups. A filter can also be defined via the filters configuration property. It can be used for fields that you do not want to add as a dimension or a value but would like to filter their related member values via the UI. Dimensions configuration Each basic dimension configuration requires a memberName that matches a field from the provided data, or a memberFunction that extracts a value from the record in case of complex objects or other custom scenarios. Multiple sibling dimensions can be defined, which creates a more complex nested group in the related row or column dimension area. The dimensions can be reordered or moved from one area to another via their corresponding chips using drag & drop. A dimension can also describe an expandable hierarchy via the childLevel property, for example: { memberFunction: () => 'All', memberName: 'AllProducts', enabled: true, childLevel: { memberFunction: (data) => data.ProductCategory, memberName: 'ProductCategory', enabled: true } } In this case the dimension renders an expander in the related section of the grid (row or column) and allows the children to be expanded or collapsed as part of the hierarchy. By default the row dimensions are initially expanded. This behavior can be controlled with the defaultExpandState @Input of the pivot grid. Predefined dimensions As part of the pivot grid some additional predefined dimensions are exposed for easier configuration: IgxPivotDateDimension Can be used for date fields. Describes the following hierarchy by default: All Periods Years Quarters Months Full Date It can be set for rows or columns, for example: public pivotConfigHierarchy: IPivotConfiguration = { rows: [ new IgxPivotDateDimension({ memberName: 'Date', enabled: true }); ] } It also allows for further customization via the second option parameter in order to enable or disable a particular part of the hierarchy, for example: new IgxPivotDateDimension({ memberName: 'Date', enabled: true }, { total: true, years: true, months: true, fullDate: true, quarters: false }); Values configuration A value configuration requires a member that matches a field from the provided data, or it can define either an aggregatorName or custom aggregator function for more complex scenarios. Out of the box, there are 4 predefined aggregations that can be used depending on the data type of the data field: IgxPivotNumericAggregate - for numeric fields. Contains the following aggregation functions: SUM, AVG, MIN, MAX, COUNT. IgxPivotDateAggregate - for date fields. Contains the following aggregation functions: LATEST, EARLIEST, COUNT. IgxPivotTimeAggregate - for time fields. Contains the following aggregation functions: LATEST, EARLIEST, COUNT. IgxPivotAggregate - for any other data types. This is the base aggregation. Contains the following aggregation functions: COUNT. The current aggregation function can be changed at runtime using the value chip's drop-down. By default, it displays a list of available aggregations based on the field's data type. A custom list of aggregations can also be set via the aggregateList property, for example: public pivotConfigHierarchy: IPivotConfiguration = { values: [ { member: 'AmountOfSale', displayName: 'Amount of Sale', aggregate: { key: 'SUM', aggregator: IgxTotalSaleAggregate.totalSale, label: 'Sum of Sale' }, aggregateList: [{ key: 'SUM', aggregator: IgxTotalSaleAggregate.totalSale, label: 'Sum of Sale' }, { key: 'MIN', aggregator: IgxTotalSaleAggregate.totalMin, label: 'Minimum of Sale' }, { key: 'MAX', aggregator: IgxTotalSaleAggregate.totalMax, label: 'Maximum of Sale' }] } ] } public static totalSale: PivotAggregation = (members, data: any) => data.reduce((accumulator, value) => accumulator + value.UnitPrice * value.UnitsSold, 0); public static totalMin: PivotAggregation = (members, data: any) => { return data.map(x => x.UnitPrice * x.UnitsSold).reduce((a, b) => Math.min(a, b)); }; public static totalMax: PivotAggregation = (members, data: any) => { return data.map(x => x.UnitPrice * x.UnitsSold).reduce((a, b) => Math.max(a,b)); }; The pivot value also provides a displayName property. It can be used to display a custom name for this value in the column header. Note If you define both aggregatorName and aggregator function, aggregatorName takes precedence. If none is set then an error is thrown. Enable property IPivotConfiguration is the interface that describes the current state of the IgxPivotGrid component. With it the developer can declare fields of the data as rows, columns, filters or values. The configuration allows enabling or disabling each of these elements separately. Only enabled elements are included in the current state of the pivot grid. The IgxPivotDataSelector component utilizes the same configuration and shows a list of all elements - enabled and disabled. For each of them there is a checkbox in the appropriate state. End-users can easily tweak the pivot state by toggling the different elements using these checkboxes. The enable property controls if a given IPivotDimension or IPivotValue is active and takes part in the pivot view rendered by the pivot grid. Full configuration example Let's take a look at a basic pivot configuration: public pivotConfigHierarchy: IPivotConfiguration = { columns: [ { memberName: 'Product', memberFunction: (data) => data.Product.Name, enabled: true } ], rows: [ { memberName: 'Seller', memberFunction: (data) => data.Seller.Name, enabled: true, } ], values: [ { member: 'NumberOfUnits', aggregate: { aggregator: IgxPivotNumericAggregate.sum, key: 'sum', label: 'Sum' }, enabled: true }, { member: 'AmountOfSale', aggregate: { aggregatorName: 'SUM', key: 'sum', label: 'Sum' }, enabled: true } ] }; This configuration defines 1 row, 1 column and 1 aggregation that sums the values of each dimension groups. The members match fields available in the provided data source: public data = [ [ { Product: { Name: 'Clothing', UnitPrice: '12.814860936633712' }, Seller: { Name: 'Stanley Brooker', City: 'Seattle' }, Date: '2007-01-01T00:00:00', Value: '94.2652032683907', NumberOfUnits: '282' }, //... ]; Resulting in the following view, which groups the Product Categories unique columns, Sellers Countries in unique rows and displays the related aggregations for the number of units in the related cells: And if you want to streamline the entire app development process, you can try out our WYSIWYG App Builder™ for your next Angular app. Known Issues and Limitations Limitation Description Setting columns declaratively is not supported. The Pivot grid generates its columns based on the columns configuration, so setting them declaratively, like in the base grid, is not supported. Such columns are disregarded. Setting duplicate memberName or member property values for dimensions/values. memberName/member should be unique for each dimension/value. Duplication may result in loss of data from the final result. Row Selection is only supported in single mode. Multiple selection is currently not supported. Merging the dimension members is case sensitive The pivot grid creates groups and merges the same (case sensitive) values. But the dimensions provide memberFunction and this can be changed there, the result of the memberFunction are compared and used as display value. API References IgxPivotGridComponent IgxPivotDataSelectorComponent Additional Resources Angular Pivot Grid Features Angular Pivot Grid Custom Aggregations Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/pivot-grid-custom.html": {
    "href": "components/pivotGrid/pivot-grid-custom.html",
    "title": "Angular Pivot Grid Custom Remote | Pivot Tables | Infragistics",
    "keywords": "Angular Pivot Grid Remote Operations In scenarios where the pivot data is already grouped and aggregated from a remote service and there's no need for further processing on the client, the pivot grid can be configured to use a custom empty strategy that will skip data processing on the client and allow it to directly display the data as is: public pivotConfigHierarchy: IPivotConfiguration = { columnStrategy: NoopPivotDimensionsStrategy.instance(), rowStrategy: NoopPivotDimensionsStrategy.instance(), } The following example show how to handle scenarios, where the data is already aggregated and how its structure should look like: Users have the ability to achieve certain scenarios by feeding the pivot grid with already aggregated data. There are some requirements on how the data should look like and some specifics regarding hierarchies in the pivot view. For example, to declare hierarchy in rows dimension: rows: [ { memberName: 'AllProducts', memberFunction: () => 'All Products', enabled: true, childLevel: { memberName: 'ProductCategory', enabled: true } } ] And an example of the aggregated would be: public aggregatedData = [ { ProductCategory: 'All', AllProducts: 'All Products', All: 1000, 'All-Bulgaria': 774, 'All-USA': 829, 'All-Uruguay': 524, AllProducts_records: [ { ProductCategory: 'Clothing', 'All-Bulgaria': 774, 'All-USA': 296, 'All-Uruguay': 456 }, { ProductCategory: 'Bikes', 'All-Uruguay': 68 }, { ProductCategory: 'Accessories', 'All-USA': 293 }, { ProductCategory: 'Components', 'All-USA': 240 } ] } ]; The Pivot grid provides the object keys fields it uses to do its pivot calculations. children - Field that stores children for hierarchy building. It represents a map from grouped values and all the pivotGridRecords that are based on that value. It can be utilized in very specific scenarios, where there is a need to do something while creating the hierarchies. No need to change this for common usage. records - Field that stores reference to the original data records. Can be seen in the example from above - AllProducts_records. Avoid setting fields in the data with the same name as this property. If your data records has records property, you can specify different and unique value for it using the pivotKeys. aggregations - Field that stores aggregation values. It's applied while creating the hierarchies and also it should not be changed for common scenarios. level - Field that stores dimension level based on its hierarchy. Avoid setting fields in the data with the same name as this property. If your data records has level property, you can specify different and unique value for it using the pivotKeys. columnDimensionSeparator - Separator used when generating the unique column field values. It is the dash(-) from the example from above - All-Bulgaria. rowDimensionSeparator - Separator used when generating the unique row field values. It is the underscore(_) from the example from above - AllProducts_records. It's used when creating the records and level field. All of these are stored in the pivotKeys property which is part of the PivotConfiguration and can be used to change the default pivot keys. These defaults are: export const DEFAULT_PIVOT_KEYS = { aggregations: 'aggregations', records: 'records', children: 'children', level: 'level', rowDimensionSeparator: '_', columnDimensionSeparator: '-' }; Setting NoopPivotDimensionsStrategy for the columnStrategy and rowStrategy skips the data grouping and aggregation done by the data pipes, but the pivot grid still needs declarations for the rows, columns, values and filters in order to render the pivot view as expected: public pivotConfig: IPivotConfiguration = { rows: [ { memberName: 'AllProducts', memberFunction: () => 'All Products', enabled: true, childLevel: { memberName: 'ProductCategory', enabled: true } } ], columns: [ { memberName: 'All', enabled: true, childLevel: { memberName: 'Country', enabled: true } } ], values: [ { member: 'UnitsSold', aggregate: { aggregator: IgxPivotNumericAggregate.sum, key: 'sum', label: 'Sum' }, enabled: true }, ] } It is important for the data to match the configuration. For the best results no additional fields should be included into the aggregated data and no fields from the provided data should be left undeclared as rows or columns. The IgxPivotGrid component builds its data based on the PivotConfiguration and it is expected for the configuration and aggregated data to match accordingly. Similarly for other remote data operations like sorting and filtering, data processing can be skipped by setting the related empty strategies - filterStrategy, sortStrategy: <igx-pivot-grid [filterStrategy]=\"noopFilterStrategy\" [sortStrategy]=\"noopSortStrategy\" ...> </igx-pivot-grid> public noopFilterStrategy = NoopFilteringStrategy.instance(); public noopSortStrategy = NoopSortingStrategy.instance(); API References IgxPivotGridComponent IgxPivotDataSelectorComponent Additional Resources Angular Pivot Grid Features Angular Pivot Grid Overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/pivot-grid-features.html": {
    "href": "components/pivotGrid/pivot-grid-features.html",
    "title": "Angular Pivot Grid Features | Pivot Tables | Infragistics",
    "keywords": "Angular Pivot Grid Features The pivot and flat grid component classes inherit from a common base and thus share some functionality and features. Note Some features do not have meaningful behavior in the context of a pivot table and therefore cannot be enabled for IgxPivotGrid. These include: CRUD operations Grouping Row/Column Pinning Summaries Paging The Pivot Grid component has additional features and functionalities related to its dimensions as described below. Dimensions filtering All dimensions (filters, rows, columns) can be filtered via the chip UI or the API. This functionality is embedded and enabled by default. Note You can use the filtering dimension to filter out data values which are not a part of the pivot view. The filtering UI can be opened via the dimension chips filter icon and allows excel-style filtering of the unique dimension values. Note If there is not enough space for all of the filtering chips, the pivot grid will show the ones that were cut off into a dropdown. End-users can access and manipulate them there. Dimensions can also be filtered initially via the dimension configuration in pivotConfiguration with the dimension's filter property. It can be set to a new FilteringExpressionsTree with the related filter condition, for example: public filterExpTree = new FilteringExpressionsTree(FilteringLogic.And); constructor() { this.filterExpTree.filteringOperands = [ { condition: IgxStringFilteringOperand.instance().condition('equals'), fieldName: 'SellerName', searchVal: 'Stanley' } ]; } public pivotConfigHierarchy: IPivotConfiguration = { filters: [ { memberName: 'SellerName', enabled: true, filter: this.filterExpTree } ] } Dimensions sorting Dimension values in the rows or columns can be sorted via the related chip or the API. This functionality is embedded and enabled by default. The dimension is sorted on click of the related chip and as a result the dimension values are sorted in ascending/descending order. Sorting can also be applied initially via the sortDirection property of the dimension definition. public pivotConfigHierarchy: IPivotConfiguration = { rows: [ { memberName: 'SellerName', enabled: true, sortDirection: SortingDirection.Asc } ] } Dimensions resizing Row dimensions can be resized similarly to column resizing - via a resizing indicator that can be found on the right edge of the cells. They can also be auto-sized by double clicking the resize indicator, or by using the related API - autoSizeRowDimension. A different size can also be set initially with the width property available in the dimension definition: public pivotConfigHierarchy: IPivotConfiguration = { rows: [ { memberName: 'Country', enabled: true, width: '400px' } ] } Dimensions selection The Pivot Grid supports single selection which is enabled just like in the base grid. For example: <igx-pivot-grid #grid1 [rowSelection]=\"'single'\" [data]=\"data\" [pivotConfiguration]=\"pivotConfigHierarchy\"> </igx-pivot-grid> In case there are multiple row or column dimensions which would create groups that span multiple rows/columns, selection is applied to all cells that belong to the selected group. Super Compact Mode The IgxPivotGrid component provides a superCompactMode @Input. It is suitable for cases that require a lot of cells to be present on the screen at once. If enabled the option ignores the displayDensity option for the pivot grid. Enabling superCompactMode also sets the displayDensity input to compact for each child component(like IgxChip) that does not have the superCompactMode option. <igx-pivot-grid [superCompactMode]=\"true\"></igx-pivot-grid> Additional summary column When a column dimension defines a hierarchy, the pivot grid will render additional summary/total column, which accumulates the aggregations of all of the columns inside the group. When the group is collapsed only the summary column will remain. And when the group is expanded the additional summary column appears at the end of the group. Interactions Keyboard navigation Keyboard navigation in IgxPivotGrid works similarly to the one in IgxGrid. The pivot grid is split into three areas - rows, columns, values. The areas for rows and columns are considered headers for the purposes of navigation while the area for values is the body. The keyboard arrows allow navigating the active element within the current area only. Dimensions drag & drop The dimensions are represented by chips, which can be dragged & dropped. All chips can change their order within their area by drag & drop. The chips from rows, column, filter(dimension chips) can be moved from any of those areas to any other and at any place. Chips from these areas can not be moved to the values area and chips from the values area can not be moved to any of the dimension areas. Note The chips from the Pivot Grid can not be moved to the Pivot Data Selector and items from the Pivot Data Selector can not be moved to the Pivot Grid. API References IgxPivotGridComponent IgxPivotDataSelectorComponent Additional Resources Angular Pivot Grid Overview Angular Pivot Grid Custom Aggregations Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/remote-data-operations.html": {
    "href": "components/pivotGrid/remote-data-operations.html",
    "title": "Angular Pivot Grid Remote Data Operations",
    "keywords": "Angular Pivot Grid Remote Data Operations The Ignite UI for Angular Pivot Grid supports remote data operations such as remote virtualization, remote sorting, remote filtering and others. This allows the developer to perform these tasks on a server, retrieve the data that is produced and display it in the Pivot Grid. By default, the Pivot Grid uses its own logic for performing data operations. You can perform these tasks remotely and feed the resulting data to the Pivot Grid by taking advantage of certain inputs and events, which are exposed by the Pivot Grid. Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. The Pivot Grid generates these values based on its data source by default. In case of remote filtering, the grid data does not contain all the data from the server. In order to provide the unique values manually and load them on demand, we can take advantage of the Pivot Grid's uniqueColumnValuesStrategy input. This input is actually a method that provides three arguments: column - The respective column instance. filteringExpressionsTree - The filtering expressions tree, which is reduced based on the respective column. done - Callback that should be called with the newly generated column values when they are retrieved from the server. The developer can manually generate the necessary unique column values based on the information, that is provided by the column and the filteringExpressionsTree arguments and then invoke the done callback. Note When the uniqueColumnValuesStrategy input is provided, the default unique values generating process in the excel style filtering will not be used. In order to provide a custom loading template for the excel style filtering, we can use the igxExcelStyleLoading directive: <igx-pivot-grid [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... <ng-template igxExcelStyleLoading> Loading ... </ng-template> </igx-pivot-grid> Remote Paging Now we can choose between setting-up our own custom paging template or using the default one that the igx-paginator provides. Let's first take a look what is necessary to set-up remote paging by using the default paging template. Remote paging with default template If you want to use the default paging template you need to set the Paginator's totalRecords property, only then the grid will be able to calculate the total page number based on total remote records. When performing a remote pagination the Paginator will pass to the Grid only the data for the current page, so the grid will not try to paginate the provided data source. That's why we should set Grid's pagingMode property to GridPagingMode.remote. Also it is necessary to either subscribe to pagingDone or perPageChange events in order to fetch the data from your remote service, it depends on the use case which event will be used. public totalCount = 0; public data: Observable<any[]>; public mode = GridPagingMode.remote; public isLoading = true; @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; private _dataLengthSubscriber; public set perPage(val: number) { this._perPage = val; this.paginate(0); } public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data: any) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngAfterViewInit() { const skip = this.page * this.perPage; this.remoteService.getData(skip, this.perPage); } public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } Remote Paging with custom igx-paginator-content When we define a custom paginator content we need to define the content in a way to get the data only for the requested page and to pass the correct skip and top parameters to the remote service according to the selected page and items perPage. We are going to use the <igx-paginator> in order to ease our example configuration, along with the IgxPageSizeSelectorComponent and IgxPageNavigationComponent that were introduced - igx-page-size will add the per page dropdown and label and igx-page-nav will add the navigation action buttons and labels. Note In order the Remote Paging to be configured properly a GridPagingMode.Remote should be set: The last step will be to declare the paginator content based on your requirements. <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> After all the changes above, the following result will be achieved. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. API References IgxPaginatorComponent API IgxPivotGridComponent API IgxPivotGridComponent Styles Additional Resources Paging Pivot Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/row-actions.html": {
    "href": "components/pivotGrid/row-actions.html",
    "title": "Row actions in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Usage The first step is to import the IgxActionStripModule in our app.module.ts file: // app.module.ts ... import { IgxActionStripModule } from 'igniteui-angular'; // import { IgxActionStripModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxActionStripModule], ... }) The predefined actions UI components are: IgxGridEditingActionsComponent - includes functionality and UI specifically designed for the grid editing. It allows you to quickly toggle edit mode for cells or rows, depending on the rowEditable option and row deletion of the grid. IgxGridPinningActionsComponent - includes functionality and UI specifically designed for the grid row pinning. It allows you to quickly pin rows and navigate between pinned rows and their disabled counterparts. They are added inside the <igx-action-strip> and this is all needed to have an Action Strip providing default interactions. Note When IgxActionStripComponent is a child component of the grid, hovering a row will automatically show the UI. Custom implementation These components expose templates giving flexibility for customization. For instance, if we would like to use the ActionStrip for a Gmail scenario with row actions such as delete, edit and etc. You can simply create button component with igx-icon, add click event to it and insert it into the igx-action-strip component. <igx-grid> <igx-action-strip #actionstrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <button title=\"Edit\" igxIconButton=\"flat\" igxRipple (click)='startEdit(actionstrip.context)'> <igx-icon>edit</igx-icon> </button> <button title=\"Delete\" igxIconButton=\"flat\" igxRipple *ngIf='!isDeleted(actionstrip.context)' (click)='actionstrip.context.delete()'> <igx-icon>delete</igx-icon> </button> </igx-action-strip> </igx-grid> Note The predefined actions inherit IgxGridActionsBaseDirective and when creating a custom grid action component, it should also inherit IgxGridActionsBaseDirective. API References For more detailed information regarding the Action Strip API, refer to the following links: IgxActionStripComponent API Additional components and/or directives that can be used within the Action Strip: IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent IgxDividerDirective View page on GitHub"
  },
  "components/pivotGrid/row-adding.html": {
    "href": "components/pivotGrid/row-adding.html",
    "title": "Adding Rows in Angular Pivot Grid - Ignite UI for Angular",
    "keywords": "Adding Rows in Angular Pivot Grid The Pivot Grid provides a convenient way to perform data manipulations through inline row adding and a powerful API for Angular CRUD operations. Add an Action Strip component with editing actions enabled in the grid's template, hover a row and use the provided button or press ALT + + to spawn the row adding UI. Angular Pivot Grid Row Adding Example The following sample demonstrates how to enable native row adding in the Pivot Grid. Changing a cell value and then clicking or navigating to another cell on the same row doesn't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Row Adding Usage To get started import the IgxPivotGridModule in the app.module.ts file: // app.module.ts ... import { IgxPivotGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxPivotGridModule], ... }) export class AppModule {} Then define a Pivot Grid with bound data source and rowEditable set to true and an Action Strip component with editing actions enabled. The addRow input controls the visibility of the button that spawns the row adding UI. Note Setting primary key is mandatory for row adding operations. Note Every column excluding the primary key one is editable in the row adding UI by default. If you want to disable editing for a specific column, then you have to set the editable column's input to false. Note The IgxGridEditingActions input controlling the visibility of the add row button may use the action strip context (which is of type RowType) to fine tune which records the button shows for. The internal IgxBaseTransactionService is automatically provided for Pivot Grid. It holds pending cell changes until the row state is submitted or cancelled. Start Row Adding Programmatically Pivot Grid allows to programmatically spawn the add row UI by using two different public methods. One that accepts a row ID for specifying the row under which the UI should spawn and another that works by index. You can use these methods to spawn the UI anywhere within the current data view. Changing the page or specifying a row that is e.g. filtered out is not supported. Using beginAddRowById requires you to specify the row to use as context for the operation by its rowID (PK). The method then functions as though the end-user clicked on the add row action strip button for the specified row, spawning the UI under it. You can also make the UI spawn as the very first row in the grid by passing null for the first parameter. this.grid.beginAddRowById('ALFKI'); // spawns the add row UI under the row with PK 'ALFKI' this.grid.beginAddRowById(null); // spawns the add row UI as the first record The beginAddRowByIndex method works similarly but requires you to specify the index at which the UI should spawn. Allowed values range between 0 and the size of the data view - 1. this.grid.beginAddRowByIndex(10); // spawns the add row UI at index 10 this.grid.beginAddRowByIndex(0); // spawns the add row UI as the first record Positioning The Default position row add UI is below the row that the end user clicked the add row button for. The Pivot Grid scrolls to fully display the add row UI automatically. The overlay for the add row UI maintains its position during scrolling. Behavior The add row UI has the same behavior as the row editing one as they are designed to provide a consistent editing experience to end users. Please, refer to the Pivot Grid Row Editing topic for more information. After a new row is added through the row adding UI, its position and/or visibility is determined by the sorting, filtering and grouping state of the Pivot Grid. In a Pivot Grid that does not have any of these states applied, it appears as the last record. A snackbar is briefly displayed containing a button the end user may use to scroll the Pivot Grid to its position if it is not in view. Keyboard Navigation ALT + + - Enters edit mode for adding a row ESC exits row adding mode without submitting any changes TAB move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any row adding operation will stop if the data view of the Pivot Grid gets modified. Any changes made by the end user are submitted. Operations that change the data view include but are not limited to sorting, grouping, filtering, paging, etc. Summaries are updated after the row add operation finishes. The same is valid for the other data view dependant features such as sorting, filtering, etc. Customizing Row Adding Overlay Customizing Text Customizing the text of the row adding overlay is possible using the igxRowAddTextDirective. <ng-template igxRowAddText> Adding Row </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Note Using igxRowEditActions directive will change edit actions for both editing and adding overlay buttons. Remote scenarios In most remote data scenarios the Primary Key assignment happens on the create server request. In this case the added records on the client will not have the final primary key value until saved on the server's data base. In that case the recommended way to handle this update in the Pivot Grid is as follows: If the Pivot Grid does not use transactions. Once the create request is successfully completed and returns the added record data, you can replace that record's id in the local data record instance. If the Pivot Grid uses transactions. Once the create request or batch update request is successfully completed and returns the added record instances (with their db generated ids), the related ADD transactions should be cleared from the transaction log using the clear API method. This is necessary because the local transaction will have a generated id field, which may differ than the one created in the data base, so they should be cleared. You can then add the record(s) passed in the response to the local data instance. This will ensure that the remotely generated ids are always reflected in the local data, and subsequent update/delete operations target the correct record ids. Styling The row adding UI comprises the buttons in the IgxActionStrip editing actions, the editing editors and overlay, as well as the snackbar which allows end users to scroll to the newly added row. To style these components you may refer to these comprehensive guides in their respective topics: Pivot Grid Row Editing IgxSnackbar IgxActionStrip API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit primaryKey IgxPivotGridComponent IgxActionStripComponent IgxGridEditingActionsComponent Additional Resources Pivot Grid Overview Pivot Grid Editing Pivot Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/row-drag.html": {
    "href": "components/pivotGrid/row-drag.html",
    "title": "Row Dragging in Angular Pivot Grid",
    "keywords": "Row Dragging in Angular Pivot Grid In Ignite UI for Angular Pivot Grid, RowDrag is initialized on the root igx-pivot-grid component and is configurable via the rowDraggable input. Enabling row dragging provides users with a row drag-handle with which they can initiate dragging of a row. Angular Pivot Grid Row Drag Example Configuration In order to enable row-dragging for your igx-pivot-grid, all you need to do is set the grid's rowDraggable to true. Once this is enabled, a row-drag handle will be displayed on each row. This handle can be used to initiate row dragging. <igx-pivot-grid [rowDraggable]=\"true\"> ... </igx-pivot-grid> Clicking on the drag-handle and moving the cursor while holding down the button will cause the grid's rowDragStart event to fire. Releasing the click at any time will cause rowDragEnd event to fire. Below, you can find a walkthrough on how to configure an igx-pivot-grid to support row dragging and how to properly handle the drop event. Drop Areas Enabling row-dragging was pretty easy, but now we have to configure how we'll handle row-dropping. We can define where we want our rows to be dropped using the igxDrop directive. First we need to import the IgxDragDropModule in our app module: import { ..., IgxDragDropModule } from 'igniteui-angular'; // import { ..., IgxDragDropModule } from '@infragistics/igniteui-angular'; for licensed package ... @NgModule({ imports: [..., IgxDragDropModule] }) Then, in our template, we define a drop-area using the directive's selector: You may enable animation when a row is dropped on a non-droppable area using the animation parameter of the rowDragEnd event. If set to true, the dragged row will animate back to its' original position when dropped over a non-droppable area. You may enable animation like this: export class IgxPivotGridRowDragComponent { public onRowDragEnd(args) { args.animation = true; } } Drop Area Event Handlers Once we've defined our drop-area in the template, we have to declare our handlers for the igxDrop's enter, leave and dropped events in our component's .ts file. First, let's take a look at our enter and leave handlers. In those methods, we just want to change the icon of the drag's ghost so we can indicate to the user that they are above an area that allows them to drop the row: export class IgxPivotGridRowDragComponent { public onEnterAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.ALLOW); } public onLeaveAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.DEFAULT); } private changeGhostIcon(ghost, icon: string) { if (ghost) { const currentIcon = ghost.querySelector('.igx-grid__drag-indicator > igx-icon'); if (currentIcon) { currentIcon.innerText = icon; } } } } The changeGhostIcon private method just changes the icon inside of the drag ghost. The logic in the method finds the element that contains the icon (using the igx-grid__drag-indicator class that is applied to the drag-indicator container), changing the element's inner text to the passed one. The icons themselves are from the material font set and are defined in a separate enum: Next, we have to define what should happen when the user actually drops the row inside of the drop-area. Note When using row data from the event arguments (args.dragData.data) or any other row property, note that the entire row is passed in the arguments as a reference, which means that you must clone the data you need, if you want to distinguish it from the one in the source grid. Templating the drag ghost The drag ghost can be templated using the IgxRowDragGhost directive, applied to a <ng-template> inside of the igx-pivot-grid's body: <igx-pivot-grid> ... <ng-template igxRowDragGhost> <div> <igx-icon fontSet=\"material\">arrow_right_alt</igx-icon> </div> </ng-template> ... </igx-pivot-grid> The result of the configuration can be seem below in a igx-pivot-grid with row dragging and multiple selection enabled. The demo shows the count of the currently dragged rows: Example Demo Templating the drag icon The drag handle icon can be templated using the grid's dragIndicatorIconTemplate. In the example we're building, let's change the icon from the default one (drag_indicator) to drag_handle. To do so, we can use the igxDragIndicatorIcon to pass a template inside of the igx-pivot-grid's body: <igx-pivot-grid> ... <ng-template igxDragIndicatorIcon> <igx-icon>drag_handle</igx-icon> </ng-template> ... </igx-pivot-grid> Once we've set the new icon template, we also need to adjust the DEFAULT icon in our DragIcon enum, so it's properly change by the changeIcon method: enum DragIcon { DEFAULT = \"drag_handle\", ... } Example Demo Application Demo Row Reordering Demo With the help of the grid's row drag events and the igxDrop directive, you can create a grid that allows you to reorder rows by dragging them. Since all of the actions will be happening inside of the grid's body, that's where you have to attach the igxDrop directive: Note Make sure that there is a primaryKey specified for the grid! The logic needs an unique identifier for the rows so they can be properly reordered Once rowDraggable is enabled and a drop zone has been defined, you need to implement a simple handler for the drop event. When a row is dragged, check the following: Below, you can see this implemented in the component's .ts file: With these few easy steps, you've configured a grid that allows reordering rows via drag/drop! You can see the above code in action in the following demo. Limitations Currently, there are no known limitations for the rowDraggable directive. API References rowDraggable rowDragStart rowDragEnd IgxPivotGridComponent Additional Resources Pivot Grid Overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/row-editing.html": {
    "href": "components/pivotGrid/row-editing.html",
    "title": "Editing Rows in Angular Pivot Grid - Ignite UI for Angular",
    "keywords": "Angular Pivot Grid Row Editing The Pivot Grid provides a convenient way to perform data manipulations through inline editing and a powerful API for Angular CRUD operations. Click on a row and press Enter key or simply double click with the mouse on the row that needs to be modified. Angular Pivot Grid Row Editing Example The following sample demonstrates how to enable row editing in the Pivot Grid. Changing a cell value and then clicking or navigating to another cell on the same row won't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Note When a row is in edit mode, then clicking on a cell on another row will act like the Done button is pressed - submit all the changes of the previous row. If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. Row Editing Usage To get started import the IgxPivotGridModule in the app.module.ts file: // app.module.ts ... import { IgxPivotGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxPivotGridModule], ... }) export class AppModule {} Then define a Pivot Grid with bound data source and rowEditable set to true: Note Setting primary key is mandatory for row editing operations. Note It's not needed to enable editing for individual columns. Using the rowEditable property in the Pivot Grid, will mean that all rows, with defined field property, excluding primary one, will be editable. If you want to disable editing for specific column, then you set the editable column's input to false. Note The Pivot Grid uses internally a provider IgxBaseTransactionService that holds pending cell changes, until row state submitted or cancelled. Positioning Default position of the overlay will be below the row that is in edit mode If there is no space below the row then overlay will appear above the row. Once shown - top or bottom, overlay will maintain this position during scrolling, until the overlay is closed. Behavior If row is in edit mode, then editing will continue, if a cell from the same row is clicked. Clicking \"Done\" button will finish row editing and will submit changes either to the data source, or to a transaction if available. In addition row will exit edit mode. Clicking \"Cancel\" button will revert all current changes in the row and row will exit edit mode. If row is in edit mode, then clicking a cell from another row will finish the current row edit and will submit new row changes (the same behavior clicking \"Done\" button). If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. If row is in edit mode and Pivot Grid is scrolled so that row goes outside the visible area, the latter will be still in edit mode. When Pivot Grid is scrolled, so that the row is visible again, the row will be still in edit mode. When clicked outside the Pivot Grid, the cell will also stay in edit mode. When perform sorting, filtering, searching and hiding operations, will revert all current changes in the row and row will exit edit mode. When perform paging, resizing, pinning and moving operations, will exit edit mode and will submit latest value. Each modified cell gets edited style until row edit is finished. This is the behavior, when Pivot Grid is not provided with transactions. When transactions are available - then cell edit style is applied until all the changes are committed. Keyboard Navigation Enter and F2 enters row edit mode Esc exits row edit mode and doesn't submit any of the cell changes, made while the row was in edit mode. Tab move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any data changing operation will terminate row editing operations and will submit current row changes. This will include operations like sorting, changing grouping and filtering criteria, paging, etc. Summaries will be updated after row edit is finished. Same is valid for the other features like sorting, filtering, etc. Customizing Row Editing Overlay Customizing Text Customizing the text of the row editing overlay is possible using the igxRowEditTextDirective. The rowChangesCount property is exposed and it holds the count of the changed cells. <ng-template igxRowEditText let-rowChangesCount> Changes: {{rowChangesCount}} </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Styling Using the Ignite UI for Angular Theme Library, we can greatly alter the Row Editing overlay. The Row Editing overlay is a composite element - its UI is comprised of a couple of other components: - igx-banner in order to render its contents - igx-buttons are rendered in the default template (for the Done and Cancel buttons). In the below example, we will make use of those two components' styling options, ([button styling](../button.md#Angular Button Styling) & banner-styling), to customize the experience of our IgxPivotGrid's Row Editing. We will also style the current cell's editor and background to make it more distinct. You can learn more about cell styling here. Import theme The easiest way to style the Row Editing banner is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Once we've imported the themes file, we can create custom themes. Define the theme We can now define a custom banner theme that will affect our Row Editing background and make use of one of the predefined palettes namely $purple-palette : $my-light-gray: #e3e3e3; $my-banner-palette: $purple-palette; $banner-theme: banner-theme( $banner-background: $my-light-gray, $banner-message-color: color($my-banner-palette, \"secondary\", 600) ); Here we are using my-banner-palette in conjunction with igx-color (exposed by the theme library) for generating our colors. Include the theme All we have to do now is apply the theme with a Sass @include statement. We pass our newly defined $banner-theme through the igx-banner mixin: @include banner($banner-theme); This will apply our custom banner theme to the Row Editing overlay. However, since we defined these in the global styles file, these styles will also apply to all banners in our application. Component styles Since the Row Editing overlay makes use of a lot of other components' themes, styling it via the global styles can affect other parts of our application (e.g. banners, buttons, etc.). The best way to prevent that is to scope our banner theme. We can define our styles (including the theme/index import) in the component containing our igx-pivot-grid. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: // custom.component.scss :host { ::ng-deep { @include banner($banner-theme); } } With the above syntax, our custom banner theme properly applies to the grid's Row Editing overlay. Custom Templates To further customize our Row Editing overlay, we can pass a custom template so we can style the Done and Cancel buttons separately: <!-- in component.html --> <igx-pivot-grid> <ng-template igxRowEditActions let-endRowEdit> <div class=\"custom-buttons\"> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(false)\"> <igx-icon>clear</igx-icon> </button> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(true)\"> <igx-icon>check</igx-icon> </button> </div> </ng-template> </igx-pivot-grid> After we've defined our custom buttons, we can make use of the button-theme to style them. You can learn more about igx-button styling here. We can create a custom theme for our Done and Cancel: // custom.component.scss ... $button-theme: button-theme( $palette: $purple-palette ); ... .custom-buttons { @include button($button-theme); } We scope our @include statement in .custom-buttons so that it is only applied to the Doneand Cancel buttons. Demo After styling the banner and buttons, we also define a custom style for the cell in edit mode. The result of all the combined styles can be seen below: Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit field editable primaryKey IgxPivotGridComponent Additional Resources Build CRUD operations with igxGrid Pivot Grid Overview Pivot Grid Editing Pivot Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/row-pinning.html": {
    "href": "components/pivotGrid/row-pinning.html",
    "title": "Angular Pivot Grid Row Pinning",
    "keywords": "Angular Pivot Grid Row Pinning One or multiple rows can be pinned to the top or bottom of the Angular UI Grid. Row Pinning in Ignite UI for Angular allows end-users to pin rows in a particular order, duplicating them in a special area that is always visible even when they scroll the Pivot Grid vertically. The Material UI Grid has a built-in row pinning UI, which is enabled by initializing an igxActionStrip component in the context of Pivot Grid. In addition, you can define custom UI and change the pin state of the rows via the Row Pinning API. Angular Pivot Grid Row Pinning Example Row Pinning UI The built-in row pinning UI is enabled by adding an igxActionStrip component with the GridPinningActions component. The action strip is automatically shown when hovering a row and will display a pin or unpin button icon based on the state of the row it is shown for. An additional action allowing to scroll the copy of the pinned row into view is shown for each pinned row as well. Row Pinning API Row pinning is controlled through the pinned input of the row. Pinned rows are rendered at the top of the Pivot Grid by default and stay fixed through vertical scrolling of the unpinned rows in the Pivot Grid body. You may also use the Pivot Grid's pinRow or unpinRow methods of the IgxPivotGridComponent to pin or unpin records by their ID: Note that the row ID is the primary key value, defined by the primaryKey of the grid, or the record instance itself. Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the row is already in the desired state. A row is pinned below the last pinned row. Changing the order of the pinned rows can be done by subscribing to the rowPinning event and changing the insertAtIndex property of the event arguments to the desired position index. Pinning Position You can change the row pinning position via the pinning configuration option. It allows you to set the pin area position to either Top or Bottom. When set to Bottom pinned rows are rendered at the bottom of the grid, after the unpinned rows. Unpinned rows can be scrolled vertically, while the pinned rows remain fixed at the bottom. public pinningConfig: IPinningConfig = { rows: RowPinningPosition.Bottom }; Custom Row Pinning UI You can define your custom UI and change the pin state of the rows via the related API. Via extra column with icon Let's say that instead of an action strip you would like to show a pin icon in every row allowing the end-user to click and change a particular row's pin state. This can be done by adding an extra column with a cell template containing the custom icon. On click of the custom icon the pin state of the related row can be changed using the row's API methods. public togglePinning(row: IgxGridRow, event) { event.preventDefault(); if (row.pinned) { row.unpin(); } else { row.pin(); } } Demo Row Pinning Limitations Only records that exist in the data source can be pinned. The row pinning state is not exported to excel. The grid is exported as if no row pinning is applied. Because of how pinned rows are stored internally so that they may appear both in the pinned and unpinned areas of the grid, row pinning is not supported when records in the grid are fetched from a remote endpoint on demand (remote virtualization). The copies of pinned rows in the scrollable area of the grid are an integral part of how other grid features achieve their functionality in the presence of pinned rows and therefore their creation cannot be disabled nor can they be removed. As Row Selection works entirely with row Ids, selecting pinned rows selects their copies as well (and vise versa). Additionally, range selection (e.g. using Shift + click) within the pinned area works the same way as selecting a range of rows within the scrollable area. The resulting selection includes all rows in between even if they are not currently pinned. Getting the selected rows through the API only returns a single instance of each selected record. When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning Styling The IgxPivotGrid allows styling through the Ignite UI for Angular Theme Library. The Pivot Grid's theme exposes a wide variety of properties, which allow the customization of all the features of the Pivot Grid. Below, we are going through the steps of customizing the Pivot Grid's row pinning styling. Importing the Styling Library To begin the customization of the row pinning feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining a Theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the row pinning feature as desired. $custom-grid-theme: grid-theme( /* Pinning properties that affect styling */ $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: #FFCD0F, $cell-active-border-color: #FFCD0F /* add other features properties here... */ ); Using CSS variables The last step is to pass the custom grid theme: @include css-vars($custom-grid-theme); Using mixins In order to style components for Internet Explorer 11, you have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. However, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom grid theme to the `igx-grid` mixin @include grid($custom-grid-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxPivotGridComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow RowType IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/row-selection.html": {
    "href": "components/pivotGrid/row-selection.html",
    "title": "Angular Pivot Grid Row Selection",
    "keywords": "Angular Pivot Grid Row Selection With row selection in Ignite UI for Angular, there is row selector column that precedes all other columns within the row. When a user clicks on the row selector, the row will either become selected or deselected, enabling the user to select multiple rows of data. Angular Row Selection Example The sample below demonstrates the three types of Pivot Grid's row selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Use the switch button to hide or show the row selector checkbox. Setup In order to setup row selection in the igx-pivot-grid, you just need to set the rowSelection property. This property accepts GridSelectionMode enumeration. GridSelectionMode exposes the following three modes: none, single and multiple. Below we will take a look at each of them in more detail. None Selection In the igx-pivot-grid by default row selection is disabled, otherwise ([rowSelection]=\"'none'\"). So you can not select or deselect a row through interaction with the Pivot Grid UI, the only way to complete these actions is to use the provided API methods. Single Selection Single row selection can now be easily set up, the only thing you need to do, is to set [rowSelection] = '\"single\"' property. This gives you the opportunity to select only one row within a grid. You can select a row by clicking on a cell or pressing the space key when you focus on a cell of the row, and of course you can select a row by clicking on the row selector field. When row is selected or deselected rowSelectionChanging event is emitted. Multiple Selection To enable multiple row selection in the igx-pivot-grid just set the rowSelection property to multiple. This will enable a row selector field on each row and in the Pivot Grid header. The row selector allows users to select multiple rows, with the selection persisting through scrolling, paging, and data operations, such as sorting and filtering. The row also can be selected by clicking on a cell or by pressing the space key when a cell is focused. If you have selected one row and click on another while holding the shift key, this will select the whole range of rows. In this selection mode, when you click on a single row, the previous selected rows will be deselected. If you click while holding the ctrl key, the row will be toggled and the previous selection will be preserved. <!-- selectionExample.component.ts --> public handleRowSelection(event: IRowSelectionEventArgs) { // use event.newSelection to retrieve primary key/row data of latest selected row this.selectedRowsCount = event.newSelection.length; this.selectedRowIndex = event.newSelection[0]; } Notes In order to have proper row selection and cell selection, while Pivot Grid has remote virtualization, a primaryKey should be provided. When the Pivot Grid has remote virtualization, then clicking the header checkbox will select/deselect all records that are currently in the grid. When new data is loaded in the Pivot Grid on demand, newly added rows will not be selected and it is a limitation, so you should handle that behavior by yourself and you can select these rows by using the provided API methods. Row selection will trigger rowSelectionChanging event. This event gives you information about the new selection, old selection, the rows that have been added and removed from the old selection. Also the event is cancellable, so this allows you to prevent selection. When row selection is enabled row selectors are displayed, but if you don't want to show them, you can set [hideRowSelectors] = true. When you switch between row selection modes at runtime, this will clear the previous row selection state. API usage Select rows programmatically The code snippet below can be used to select one or multiple rows simultaneously (via primaryKey); Additionally, the second parameter of this method is a boolean property through which you may choose whether the previous row selection will be cleared or not. The previous selection is preserved by default. This will add the rows which correspond to the data entries with IDs 1, 2 and 5 to the Pivot Grid selection. Deselect rows If you need to deselect rows programmatically, you can use the deselectRows(rowIds: []) method. <!-- selectionExample.component.html --> <igx-pivot-grid ... [primaryKey]=\"'ID'\"> ... </igx-pivot-grid> ... <button (click)=\"this.pivotGrid.deselectRows([1,2,5])\">Deselect 1,2 and 5</button> Row selection event When there is some change in the row selection rowSelectionChanging event is emitted. rowSelectionChanging exposes the following arguments: oldSelection - array of row's data that contains the previous state of the row selection. newSelection - array of row's data that match the new state of the row selection. added - array of row's data that are currently added to the selection. removed - array of row's data that are currently removed according old selection state. event - the original event that triggered row selection change. cancel - allows you the prevent the row selection change. Row selection event in remote data scenarios In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. <!-- selectionExample.component.html --> <igx-pivot-grid (rowSelectionChanging)=\"handleRowSelectionChange($event)\"> ... </igx-pivot-grid> /* selectionExample.component.ts */ public handleRowSelectionChange(args) { args.cancel = true; // this will cancel the row selection } Select all rows Another useful API method that igx-pivot-grid provides is selectAll(onlyFilteredData). By default this method will select all data rows, but if filtering is applied, it will select only the rows that match the filter criteria. But if you call the method with false parameter, selectAll(false) will always select all data in the grid, even if filtering is applied. Note Keep in mind that selectAll() will not select the rows that are deleted. Deselect all rows igx-pivot-grid provides deselectAll(onlyFilteredData) method, which by default will deselect all data rows, but if filtering is applied will deselect only the rows that match the filter criteria. But if you call the method with false parameter, deselectAll(false) will always clear all row selection state even if filtering is applied. How to get selected rows If you need to see which rows are currently selected, you can get their row IDs with the selectedRows getter. public getSelectedRows() { const currentSelection = this.pivotGrid.selectedRows; // return array of row IDs } Additionally, assigning row IDs to selectedRows will allow you to change the grid's selection state. Row selector templates You can template header and row selectors in the Pivot Grid and also access their contexts which provide useful functionality for different scenarios. By default, the Pivot Grid handles all row selection interactions on the row selector's parent container or on the row itself, leaving just the state visualization for the template. Overriding the base functionality should generally be done using the rowSelectionChanging event. In case you implement a custom template with a click handler which overrides the base functionality, you should stop the event's propagation to preserve the correct row state. Row template To create a custom row selector template, within the igx-pivot-grid, declare an <ng-template> with igxRowSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the row's state. The selected property shows whether the current row is selected or not while the index property can be used to access the row index. <ng-template igxRowSelector let-rowContext> {{ rowContext.index }} <igx-checkbox [checked]=\"rowContext.selected\" [readonly]=\"true\" ></igx-checkbox> </ng-template> The rowID property can be used to get a reference of an igx-pivot-grid row. This is useful when you implement a click handler on the row selector element. <ng-template igxRowSelector let-rowContext> <igx-checkbox (click)=\"onSelectorClick($event, rowContext.key)\"></igx-checkbox> </ng-template> In the above example we are using an igx-checkbox and we bind rowContext.selected to its checked property. See this in action in our Row Numbering Demo. Header template To create a custom header selector template, within the Pivot Grid, declare an <ng-template> with igxHeadSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the header's state. The selectedCount property shows you how many rows are currently selected while totalCount shows you how many rows there are in the Pivot Grid in total. <ng-template igxHeadSelector let-headContext> {{ headContext.selectedCount }} / {{ headContext.totalCount }} </ng-template> The selectedCount and totalCount properties can be used to determine if the head selector should be checked or indeterminate (partially selected). Row Numbering Demo This demo shows the usage of custom header and row selectors. The latter uses rowContext.index to display row numbers and an igx-checkbox bound to rowContext.selected. Conditional Selection Demo This demo prevents some rows from being selected using the rowSelectionChanging event and a custom template with disabled checkbox for non-selectable rows. API References IgxPivotGridComponent API IgxGridRow API IgxGridCell API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/search.html": {
    "href": "components/pivotGrid/search.html",
    "title": "Angular Pivot Grid Search Filter",
    "keywords": "Angular Pivot Grid Search Filter Angular Pivot Grid search enables the process of finding values in the collection of data. We make it easier to setup this functionality and it can be implemented with search input box, buttons, keyboard navigation and other useful features for an even better user experience. While browsers natively provide content search functionality, most of the time the Pivot Grid virtualizes its columns and rows that are out of view. In these cases, the native grid search is unable to search data in the virtualized cells, since they are not part of the DOM. We have extended the Ignite UI for Angular table-based grid with a search API that allows you to search through the virtualized content of the Pivot Grid. Angular Search Example The following example represents Pivot Grid with search input box that allows searching in all columns and rows, as well as specific filtering options for each column. Angular Search Usage Grid setup Let's start by creating our grid and binding it to our data. We will also add some custom styles for the components we will be using! Great, and now let's prepare for the search API of our Pivot Grid! We can create a few properties, which can be used for storing the currently searched text and whether the search is case sensitive and/or by an exact match. // searchgrid.component.ts public searchText: string = ''; public caseSensitive: boolean = false; public exactMatch: boolean = false; Angular search box input Now let's create our search input! By binding our searchText as ngModel to our newly created input and subscribe to the ngModelChange event, we can detect every single searchText modification by the user. This will allow us to use the Pivot Grid's findNext and findPrev methods to highlight all the occurrences of the searchText and scroll to the next/previous one (depending on which method we have invoked). Both the findNext and the findPrev methods have three arguments: text: string (the text we are searching for) (optional) caseSensitive: boolean (should the search be case sensitive or not, default value is false) (optional) exactMatch: boolean (should the search be by an exact match or not, default value is false) When searching by an exact match, the search API will highlight as results only the cell values that match entirely the searchText by taking the case sensitivity into account as well. For example the strings 'software' and 'Software' are an exact match with a disregard for the case sensitivity. The methods from above return a number value (the number of times the Pivot Grid contains the given string). <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"pivotGrid.findNext(searchText, caseSensitive, exactMatch)\" /> Display results count Let's also display the position of the current occurrence, along with the total results count! We can do this by using the grid's lastSearchInfo property. This property is automatically updated when using the find methods. The pivotGrid.lastSearchInfo.matchInfoCache.length value will give us the total results count. The pivotGrid.lastSearchInfo.activeMatchIndex value will give us the index position of the current occurrence (match). <!--searchgrid.component.html--> <div class=\"resultsText\" *ngIf=\"pivotGrid.lastSearchInfo\"> <span *ngIf=\"pivotGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ pivotGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ pivotGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"pivotGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> Add search buttons In order to freely search and navigate among our search results, let's create a couple of buttons by invoking the findNext and the findPrev methods inside the buttons' respective click event handlers. <!--searchgrid.component.html--> <div class=\"searchButtons\"> <input type=\"button\" value=\"Previous\" (click)=\"pivotGrid.findPrev(searchText, caseSensitive, exactMatch)\" /> <input type=\"button\" value=\"Next\" (click)=\"pivotGrid.findNext(searchText, caseSensitive, exactMatch)\" /> </div> Add keyboard search We can also allow the users to navigate the results by using the keyboard's arrow keys and the Enter key. In order to achieve this, we can handle the keydown event of our search input by preventing the default caret movement of the input with the preventDefault() method and invoke the findNext/findPrev methods depending on which key the user has pressed. <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"pivotGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> // searchgrid.component.ts public searchKeyDown(ev) { if (ev.key === 'Enter' || ev.key === 'ArrowDown' || ev.key === 'ArrowRight') { ev.preventDefault(); this.pivotGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } else if (ev.key === 'ArrowUp' || ev.key === 'ArrowLeft') { ev.preventDefault(); this.pivotGrid.findPrev(this.searchText, this.caseSensitive, this.exactMatch); } } Case sensitive and Exact match Now let's allow the user to choose whether the search should be case sensitive and/or by an exact match. For this purpose we can use simple checkbox inputs by binding our caseSensitive and exactMatch properties to the inputs' checked properties respectively and handle their change events by toggling our properties and invoking the findNext method. <!--searchgrid.component.html--> <span>Case sensitive</span> <input type=\"checkbox\" [checked]=\"caseSensitive\" (change)=\"updateSearch()\"> <span>Exact match</span> <input type=\"checkbox\" [checked]=\"exactMatch\" (change)=\"updateExactSearch()\"> // searchgrid.component.ts public updateSearch() { this.caseSensitive = !this.caseSensitive; this.pivotGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } public updateExactSearch() { this.exactMatch = !this.exactMatch; this.pivotGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } Persistence What if we would like to filter and sort our Pivot Grid or even to add and remove records? After such operations, the highlights of our current search automatically update and persist over any text that matches the searchText! Furthermore, the search will work with paging and will persist the highlights through changes of the Pivot Grid's perPage property. Adding icons By using some of our other components, we can create an enriched user interface and improve the overall design of our entire search bar! We can have a nice search or delete icon on the left of the search input, a couple of chips for our search options and some material design icons combined with nice ripple styled buttons for our navigation on the right. We can wrap these components inside an input group for a more refined design. To do this, let's go and grab the IgxInputGroup, IgxIcon, IgxRipple, IgxButton and the IgxChip modules. // app.module.ts ... import { IgxPivotGridModule, IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule } from 'igniteui-angular'; // import { // IgxInputGroupModule, // IgxIconModule, // IgxRippleModule, // IgxButtonModule, // IgxChipsModule // } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule], }) export class AppModule {} Finally, let's update our template with the new components! We will wrap all of our components inside an IgxInputGroup. On the left we will toggle between a search and a delete/clear icon (depending on whether the search input is empty or not). In the center, we will position the input itself. In addition, whenever the delete icon is clicked, we will update our searchText and invoke the Pivot Grid's clearSearch method to clear the highlights. <!--searchgrid.component.html--> <igx-input-group type=\"search\" class=\"offset\"> <igx-prefix> <igx-icon *ngIf=\"searchText.length == 0\">search</igx-icon> <igx-icon *ngIf=\"searchText.length > 0\" (click)=\"clearSearch()\">clear</igx-icon> </igx-prefix> <input #search1 id=\"search1\" igxInput placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"pivotGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> <igx-suffix *ngIf=\"searchText.length > 0\"> ... </igx-suffix> </igx-input-group> // searchgrid.component.ts public clearSearch() { this.searchText = ''; this.pivotGrid.clearSearch(); } On the right in our input group, let's create three separate containers with the following purposes: For displaying the search results. <!--searchgrid.component.html--> <igx-suffix *ngIf=\"searchText.length > 0\"> <div class=\"resultsText\" *ngIf=\"pivotGrid.lastSearchInfo\"> <span *ngIf=\"pivotGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ pivotGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ pivotGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"pivotGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> </igx-suffix> For displaying a couple of chips that toggle the caseSensitive and the exactMatch properties. We have replaced the checkboxes with two stylish chips that change color based on these properties. Whenever a chip is clicked, we invoke its respective handler - updateSearch or updateExactSearch depending on which chip has been clicked. <!--searchgrid.component.html--> ... <div class=\"chips\"> <igx-chips-area> <igx-chip (click)=\"updateSearch()\" [color]=\"caseSensitive? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Case Sensitive</span> </igx-chip> <igx-chip (click)=\"updateExactSearch()\" [color]=\"exactMatch? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Exact Match</span> </igx-chip> </igx-chips-area> </div> ... For the search navigation buttons, we have transformed our inputs into ripple styled buttons with material icons. The handlers for the click events remain the same - invoking the findNext/findPrev methods. <!--searchgrid.component.html--> <igx-suffix> <div class=\"searchButtons\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"pivotGrid.findPrev(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"pivotGrid.findNext(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </div> </igx-suffix> Known Limitations Limitation Description Searching in cells with a template The search functionality highlights work only for the default cell templates. If you have a column with custom cell template, the highlights will not work so you should either use alternative approaches, such as a column formatter, or set the searchable property on the column to false. Remote Virtualization The search will not work properly when using remote virtualization Cells with cut off text When the text in the cell is too large to fit and the text we are looking for is cut off by the ellipsis, we will still scroll to the cell and include it in the match count, but nothing will be highlighted API References In this article we implemented our own search bar for the Pivot Grid with some additional functionality when it comes to navigating between the search results. We also used some additional Ignite UI for Angular components like icons, chips and inputs. The search API is listed below. IgxPivotGridComponent methods: findNext findPrev clearSearch refreshSearch IgxGridCell methods: IgxColumnComponent properties: searchable ISearchInfo Additional components and/or directives with relative APIs that were used: IgxInputGroupComponent IgxIconComponent IgxRippleDirective IgxButtonDirective IgxChipComponent Styles: IgxPivotGridComponent Styles IgxInputGroupComponent Styles IgxIconComponent Styles IgxRippleDirective Styles IgxButtonDirective Styles IgxChipComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/selection.html": {
    "href": "components/pivotGrid/selection.html",
    "title": "Angular Pivot Grid Selection",
    "keywords": "Angular Pivot Grid Selection With Ignite UI for Angular Pivot Grid you can easily select data by using variety of events, rich API or with simple mouse interactions like single select. Angular Grid Selection Example The sample below demonstrates the three types of Pivot Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Angular Grid Selection Options IgniteUI for Angular Pivot Grid component provides three different selection modes - Row selection, Cell selection and Column selection. By default only Multi-cell selection mode is enabled in the Pivot Grid. In order to change/enable selection mode you can use rowSelection, cellSelection or selectable properties. Angular Row Selection Property rowSelection enables you to specify the following options: none - Row selection would be disabled for the Pivot Grid single - Selection of only one row within the Pivot Grid would be available multiple - Multi-row selection would be available by using the Row selectors, with a key combination like ctrl + click, or by pressing the space key once a cell is focused Go to Row selection topic for more information. Angular Cell Selection Property cellSelection enables you to specify the following options: none - Cell selection would be disabled for the Pivot Grid single - Selection of only one cell within the Pivot Grid would be available. multiple - Currently, this is the default state of the selection in the Pivot Grid. Multi-cell selection is available by mouse dragging over the cells, after a left button mouse clicked continuously. Go to Cell selection topic for more information. Angular Column Selection The selectable property enables you to specify the following options for each column: false - the corresponding column selection will be disabled for the Pivot Grid true - the corresponding column selection will be enabled for the Pivot Grid This lead to the following three variations: Single selection - mouse click over the column cell. Multi column selection - holding ctrl + mouse click over the column cells. Range column selection - holding shift + mouse click selects everything in between. Go to Column selection topic for more information. Known Issues and Limitations Using the Pivot Grid with Selection enabled on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. IE11 is no longer supported as of version 13.0.0. import 'core-js/es7/array'; When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References IgxPivotGridComponent API IgxGridRow API IgxGridCell API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Row Selection Cell Selection Paging Filtering Sorting Summaries Column Moving Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/sizing.html": {
    "href": "components/pivotGrid/sizing.html",
    "title": "Angular Grid Sizing",
    "keywords": "Angular Grid Sizing There are many different ways to size the IgxPivotGrid in order to accommodate a lot of scenarios that the users can have. While some are straight forward, others might be more complex and that is why we will take each one and look into them in more depth. We will go through setting width and height separately since there are some differences e.g. when using percentages for each. When it comes to border and padding size for the IgxPivotGrid, they are taken into its width/height size calculations or also known as Border box sizing. It is applied in all scenarios. Note If the Border box sizing is overridden by the user we cannot guarantee that the IgxPivotGrid will size correctly. Width If the width input does not have value assigned, its default value is 100% and the IgxPivotGrid tries to fill the available space. You can check how the grid reacts to it in the Percentages section. Note Setting manually the width style of the IgxPivotGrid itself will result in an unexpected behavior. Null The grid's width can accepts value of null, which when set, renders all columns in the DOM. The grid sizes accordingly so there is no grid horizontal scrollbar since column virtualization is not applied. If there are 6 columns and none of them has width defined, the grid will have width of 816px, because each column by default have assigned width of 136px in this scenario. Same will happen if the columns have width in percentages. If vertical scrollbar is rendered or there are features that render additional columns their width will be added also. If there are 6 columns with column width set to 200px they will fit in our window and all will be visible: If there are more columns or ones with bigger width that go out of the browser's view, they will all still render. Let's have the same amount of columns but each with column width of 300px. Since they don't all fit in the browser view area, it will create a scrollbar natively. The next example displays this exact scenario: If the grid has a parent element of any sort and it doesn't have any overflow set, it will still render all columns visible. Otherwise if the parent element has overflow auto or scroll, a scrollbar for that parent element will be rendered natively. The parent has bigger height for easier visualization in the following example. Note Due to this behavior, if the grid data contains too many columns, it might have significant impact on the browser performance, since all columns would be rendered without virtualization. Pixels When the IgxPivotGrid width input is set to pixels it will set the whole grid size to that value and it will be static. It will not react to any browser resizing or changes in the DOM, although this is not the case for the grid content: When width is set in pixels in order for the grid to render horizontal scrollbar, its content width needs to exceed the specified grid width. Let's, for example, have the combined width of the columns exceed 1200px. In this case a horizontal scrollbar will be rendered. For scenarios where the grid has a parent element, it depends on the parent styling if it will render scrollbar or not. Everything else related to the grid itself is still retained. If the parent element width is smaller than the grid's width and has overflow style set to auto or scroll, it will render scrollbar natively. For example, if the parent has width set to 1000px and the IgxPivotGrid width is still 1200px, it will look similar to the following illustrations: Percentages When the width of the IgxPivotGrid is set to percentages it will size the grid according to the parent element's width. If the parent element does not have width specified the IgxPivotGrid will size relative to the browser window. For example, if we set the grid width input to 100% and there is no parent element it will fill 100% of the available width of the browser window. If it is resized the grid will resize as well accordingly. If we set grid's width to 100% and there is a parent element that has specific width of 1200px, this will mean that the grid will size relative to that element and his final width will be 1200px. If we have a parent element with width of 1000px and have the grid's width set to 150%, the calculated grid width will be 1500px. In this case the grid will still render fully visible but if we set overflow: auto of the parent, that parent will render scrollbar on its own. Height By default if no height is defined for the IgxPivotGrid, it will be set to 100%. You can check how the grid reacts depending on the DOM structure in the Percentages section. Note Setting manually the height style of the IgxPivotGrid itself will result in an unexpected behavior. Null The IgxPivotGrid height input can accept null value, which when set, displays all rows with no scrollbar no matter how many they are. In this case, there is no vertical virtualization since the grid renders all rows anyway. If we have data with 14 rows in this case the grid will render all 14 of them and size the grid so all are visible without any empty space inside the grid. If we have 24 rows instead, the grid will still render all rows but since they are too many, they exceed the browser boundaries. That's why the browser itself will render vertical scrollbar by default so the user can scroll down to the rest of the rows. If there is a parent element with defined height, the grid will still render all rows and not be affected. Let's say the parent has height of 650px. If he has overflow set to auto or scroll, it will render a vertical scrollbar but the grid will still be unaffected: Note Due to this behavior, if the grid data contains too many rows, it might have significant impact on the browser performance, since all rows would be rendered without virtualization. Pixels Setting the IgxPivotGrid height in pixels is more straightforward since the grid will size to that specific size in all occasions similarly to how width is set in pixels. If we set, for example, the height 500px with 4 rows for our data the grid will sit to that size and since 4 rows are not enough to fill the visible area it is expected to have some empty area. If the number of rows exceeds the visible area of the grid when height is set to pixels a vertical scrollbar will be rendered. For example, a grid with 500px height set and 14 rows will be rendered the following way: If there is a parent element with height defined, unless it has overflow set to auto or scroll, the grid will still be fully visible. Otherwise it will render a scrollbar. Percentages When the height input is set to percentages the IgxPivotGrid will size based on the parent element height. If the parent element has its height set in pixels or percentages, the grid will size relative to the size of the parent. When the parent element does not have defined height, the browser does not assign height to it initially and sizes it based on its children and their size. That is why there is no way for the grid to know what base height to use in order to apply percentage sizing based on it. For this reason, it will render a maximum of 10 rows and if they are more rows, a vertical scrollbar will be rendered. Otherwise, the grid will fit to number of rendered rows. We will look in this scenario in more detail in the next examples. Let's have width set to 1200px and the parent element not having any size applied to it: If there are less than 10 rows the grid will try to fit all rows in the `visible area without having an empty space between the last row and the bottom of the visible area. For example, let's have the grid data to consist of 7 rows. The grid will render all 7 rows without vertical scrollbar and without empty space inside the grid. If there are more than 10 rows a vertical scrollbar will be rendered for the rest of the rows and only 10 rows can be visible at any time. In the next example only the row number is increased to 14. If we set the parent element height to 800px and the IgxPivotGrid to 100% height this means that the grid will be sized to 100 percentages of 800px. If the IgxPivotGrid height is set to a number bigger than 100% and the parent element has height, for the parent to render scrollbar it again needs to have overflow set to auto or scroll. Otherwise the grid will be fully visibly and size relative to the parent size. If we want the grid to be sized to 100% from the browser window we would need to set both body and parent grid element heights to 100%. In this case, the parent element can be sized and the grid will size accordingly if the browser is resized. Column Sizing Depending on the grid size itself, the columns inside it can also be sized differently that could result in scenarios where the grid renders horizontal scrollbar or not. Columns can have width set in pixels, percentages or autosized when nothing is set. We will take a deeper look regarding these scenarios in this section. Default By default when a column doesn't have a specified width it will try to autosize, so that it fills if any empty space is available in the grid view area. Autosized columns have minimum width of 136px, so if the area available is less than 136px for that column, it will default to that size. When the grid is resized in these scenarios, the column width is also updated to reflect the changes, so it fills any new empty space available. If a column does not have specified width and the IgxPivotGrid has width set to null, it will be sized to the minimum of 136px. This means that for a grid with width null and 6 columns that don't have width, each column will be sized to 136px. When there are multiple autosized columns they will divide the available space between each other equally. This means that if we have 6 columns and there is empty area of 1200px, each will size to 200px. If there is available empty space, so that each autosized column will be less than 136px, all autosized columns will default to 136px and the grid will render horizontal scrollbar. In the next example let's have 12 autosized columns and the grid width set to 1000px. If a column does not have width specified, but all other columns have either width in pixels or percentages, that column will try to also fill the available space. For example, if we don't have width set to the first column and all other 5 have width of 100px, the first will fill the rest. Same applies if multiple columns does not have width specified, all will divide the available space between each other equally. In the next illustration the first column has width set to 100px. Note Feature columns like Row Selector checkbox column and etc. fill additional space that is taken into account when autosizing columns. Pixels When columns have set specific width in pixels, they stick to that size, unless they are resized manually. Since the combined width of the columns is static, it can be less than the IgxPivotGrid width or exceed it. If the combined width of all columns is less than the IgxPivotGrid width, there would be an empty are inside the grid that the columns wouldn't be able to fill. This is the expected behavior of the IgxPivotGrid. In the next example the columns have 150px width. If the combined width of all columns is bigger than the actual IgxPivotGrid width, a horizontal scrollbar will be rendered. In the next example each of the 6 columns have width of 300px and grid has width of 1200px, which means that the columns combined have excess of 600px that goes out of bounds. Auto When columns are set to auto their size adjusts to fit the longest word in the column. Empty areas are possible if there are cells with very short values, while other cells have very long ones. In this scenario, all cells in the column would adjust to take the width of the cell with the longest value. Percentages When columns have set width in percentages, their size is calculated relatively to the grid size. It is similar to how width in pixels works, but provides also responsiveness to the columns which means that when the grid is resized, the columns also will resize accordingly. If the combined width of all columns is less than 100%, similarly to when in pixels, there could be an empty area of the grid that the columns do not cover. If the combined width is exactly 100%, the columns will fill all available space of the grid. If the combined width exceeds 100% in order for the user to be able to see the columns out of view, a horizontal scrollbar is rendered. If columns are set in percentages and the grid width is set to null, it would applywidth of 136px to each column. That is because the columns cannot be sized relatively to the grid, since it doesn't have width itself and relies on its content to be sized when its width is null. In the following example all 6 columns have width set to 50%: API References IgxPivotGridComponent API IgxGridRow API IgxPivotGridComponent Styles Additional Resources Pivot Grid overview Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/sorting.html": {
    "href": "components/pivotGrid/sorting.html",
    "title": "Angular Pivot Grid Sorting",
    "keywords": "Angular Pivot Grid Sorting In Ignite UI for Angular Pivot Grid, data sorting is enabled on a per-column level, meaning that the igx-pivot-grid can have a mix of sortable and non-sortable columns. Performing angular sort actions enables you to change the display order of the records based on specified criteria. Note Up until now, grouping/sorting worked in conjuction with each other. In 13.2 version, a new behavior which decouples gropuing from sorting is introduced. For example - clearing the grouping will not clear sorting expressions in the grid or vice versa. Still, if a column is both sorted and grouped, grouped expressions take precedence. Angular Pivot Grid Sorting Overview Example This is done via the sortable input. With the Pivot Grid sorting, you can also set the sortingIgnoreCase property to perform case sensitive sorting: <igx-column field=\"ProductName\" header=\"Product Name\" [dataType]=\"'string'\" sortable=\"true\"></igx-column> Sorting Indicators Having a certain amount of sorted columns could be really confusing if there is no indication of the sorted order. The IgxPivotGrid provides a solution for this problem by indicating the index of each sorted column. Sorting through the API You can sort any column or a combination of columns through the Pivot Grid API using the Pivot Grid sort method: import { SortingDirection } from 'igniteui-angular'; // import { SortingDirection } from '@infragistics/igniteui-angular'; for licensed package // Perform a case insensitive ascending sort on the ProductName column. this.pivotGrid.sort({ fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }); // Perform sorting on both the ProductName and Price columns. this.pivotGrid.sort([ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]); Note Sorting is performed using our DefaultSortingStrategy algorithm. Any IgxColumnComponent or ISortingExpression can use a custom implementation of the ISortingStrategy as a substitute algorithm. This is useful when custom sorting needs to be defined for complex template columns, or image columns, for example. As with the filtering behavior, you can clear the sorting state by using the clearSort method: // Removes the sorting state from the ProductName column this.pivotGrid.clearSort('ProductName'); // Removes the sorting state from every column in the Pivot Grid this.pivotGrid.clearSort(); Note The sortStrategy of the Pivot Grid is of different type compared to the sortStrategy of the column, since they work in different scopes and expose different parameters. Note The sorting operation DOES NOT change the underlying data source of the Pivot Grid. Initial sorting state It is possible to set the initial sorting state of the Pivot Grid by passing an array of sorting expressions to the sortingExpressions property of the Pivot Grid. public ngOnInit() { this.pivotGrid.sortingExpressions = [ { fieldName: 'Name', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } public ngOnInit() { this.pivotGrid.sortingExpressions = [ { fieldName: 'ProductName', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'Price', dir: SortingDirection.Desc } ]; } Note If values of type string are used by a column of dataType Date, the Pivot Grid won't parse them to Date objects and using Pivot Grid sorting won't work as expected. If you want to use string objects, additional logic should be implemented on an application level, in order to parse the values to Date objects. Sorting Indicators Templates The sorting indicator icon in the column header can be customized using a template. The following directives are available for templating the sorting indicator for any sorting state (ascending, descending, none): IgxSortHeaderIconDirective – re-templates the sorting icon when no sorting is applied. <ng-template igxSortHeaderIcon> <igx-icon>unfold_more</igx-icon> </ng-template> IgxSortAscendingHeaderIconDirective – re-templates the sorting icon when the column is sorted in ascending order. <ng-template igxSortAscendingHeaderIcon> <igx-icon>expand_less</igx-icon> </ng-template> IgxSortDescendningHeaderIconDirective – re-templates the sorting icon when the column is sorted in descending order. <ng-template igxSortDescendingHeaderIcon> <igx-icon>expand_more</igx-icon> </ng-template> Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $sorted-header-icon-color and sortable-header-icon-hover-color parameters. $custom-theme: grid-theme( $sorted-header-icon-color: #ffb06a, $sortable-header-icon-hover-color: black ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $black-color: black; $orange-color: #ffb06a; $custom-palette: palette($primary: $black-color, $secondary: $orange-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"primary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('primary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Note The sample will not be affected by the selected global theme from Change Theme. API References IgxPivotGridComponent API IgxPivotGridComponent Styles ISortingExpression Additional Resources Pivot Grid overview Virtualization and Performance Paging Filtering Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/state-persistence.html": {
    "href": "components/pivotGrid/state-persistence.html",
    "title": "Angular Pivot Grid State Persistence - Ignite UI for Angular",
    "keywords": "Angular Pivot Grid State Persistence Тhe igxGridState directive allows developers to easily save and restore the grid state. When the IgxGridState directive is applied on the grid, it exposes the getState and setState methods that developers can use to achieve state persistence in any scenario. Supported Features IgxGridState directive supports saving and restoring the state of the following features: Sorting Filtering Cell Selection Row Selection Column Selection Expansion Pivot Configuration Pivot Configuration properties defined by the IPivotConfiguration interface. Pivot Dimension and Value functions are restored using application level code, see Restoring Pivot Configuration section. Pivot Row and Column strategies are also restored using application level code, see Restoring Pivot Strategies section. Usage getState - This method returns the grid state in a serialized JSON string, so developers can just take it and save it on any data storage (database, cloud, browser localStorage, etc). The method accepts first optional parameter serialize, which determines whether getState will return an IGridState object or a serialized JSON string. The developer may choose to get only the state for a certain feature/features, by passing in the feature name, or an array with feature names as a second argument. // get all features` state in a serialized JSON string const gridState = state.getState(); // get an `IGridState` object, containing all features original state objects, as returned by the grid public API const gridState: IGridState = state.getState(false); // get the sorting and filtering expressions const sortingFilteringStates: IGridState = state.getState(false, ['sorting', 'filtering']); setState - The setState method accepts the serialized JSON string or IGridState object as argument and will restore the state of each feature found in the object/JSON string. state.setState(gridState); state.setState(sortingFilteringStates) options - The options object implements the IGridStateOptions interface, i.e. for every key, which is the name of a certain feature, there is the boolean value indicating if this feature state will be tracked. getState method will not put the state of these features in the returned value and setState method will not restore state for it. public options = { cellSelection: false; sorting: false; } <igx-pivot-grid [igxGridState]=\"options\"></igx-pivot-grid> The simple to use single-point API's allows to achieve a full state persistence functionality in just a few lines of code. Copy paste the code from below - it will save the grid state in the browser sessionStorage object every time the user leaves the current page. Whenever the user returns to main page, the grid state will be restored. No more need to configure those complex advanced filtering and sorting expressions every time to get the data you want - do it once and have the code from below do the rest for your users: // app.component.ts @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public ngOnInit() { this.router.events.pipe(take(1)).subscribe((event: NavigationStart) => { this.saveGridState(); }); } public ngAfterViewInit() { this.restoreGridState(); } public saveGridState() { const state = this.state.getState() as string; window.sessionStorage.setItem('grid1-state', state); } public restoreGridState() { const state = window.sessionStorage.getItem('grid1-state'); this.state.setState(state); } Restoring Pivot Configuration IgxGridState will not persist pivot dimension functions, value formatters, etc. by default (see limitations). Restoring any of these can be achieved with code on application level. The IgxPivotGrid exposes two events which can be used to set back any custom functions you have in the configuration: dimensionInit and valueInit. Let's show how to do this: Assign event handlers for the dimensionInit and valueInit events: <igx-pivot-grid #grid1 [data]=\"data\" [pivotConfiguration]=\"pivotConfig\" [igxGridState]=\"options\" (valueInit)='onValueInit($event)' (dimensionInit)='onDimensionInit($event)'> </igx-pivot-grid> The dimensionInit and valueInit events are emitted for each value and dimension defined in the pivotConfiguration property. In the valueInit event handler set all custom aggregators, formatters and styles: public onValueInit(value: IPivotValue) { // Needed only for custom aggregators, formatter or styles. if (value.member === 'AmountofSale') { value.aggregate.aggregator = IgxTotalSaleAggregate.totalSale; value.aggregateList?.forEach((aggr: IPivotAggregator) => { switch (aggr.key) { case 'SUM': aggr.aggregator = IgxTotalSaleAggregate.totalSale; break; case 'MIN': aggr.aggregator = IgxTotalSaleAggregate.totalMin; break; case 'MAX': aggr.aggregator = IgxTotalSaleAggregate.totalMax; break; } }); } else if (value.member === 'Value') { value.formatter = (value) => value ? '$' + parseFloat(value).toFixed(3) : undefined; value.styles.upFontValue = (rowData: any, columnKey: any): boolean => parseFloat(rowData.aggregationValues.get(columnKey.field)) > 150 value.styles.downFontValue = (rowData: any, columnKey: any): boolean => parseFloat(rowData.aggregationValues.get(columnKey.field)) <= 150; } } In the dimensionInit event handler set all custom memberFunction implementations: public onDimensionInit(dim: IPivotDimension) { switch (dim.memberName) { case 'AllProducts': dim.memberFunction = () => 'All Products'; break; case 'ProductCategory': dim.memberFunction = (data) => data.Product.Name; break; case 'City': dim.memberFunction = (data) => data.Seller.City; break; case 'SellerName': dim.memberFunction = (data) => data.Seller.Name; break; } } Restoring Pivot Strategies IgxGridState will not persist neither remote pivot operations nor custom dimension strategies (For further information see Pivot Grid Remote Operations sample) by default (see limitations). Restoring any of these can be achieved with code on application level. The IgxGridState exposes an event called stateParsed which can be used to additionally modify the grid state before it gets applied. Let's show how to do this: stateParsed is only emitted when we are using setState with string argument. Set custom sorting strategy and custom pivot column and row dimension strategies: <igx-pivot-grid #grid [data]=\"data\" [pivotConfiguration]=\"pivotConfigHierarchy\" [defaultExpandState]='true' [igxGridState]=\"options\" [sortStrategy]=\"customStrategy\" [showPivotConfigurationUI]='false' [superCompactMode]=\"true\" [height]=\"'500px'\"> </igx-pivot-grid> @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public customStrategy = NoopSortingStrategy.instance(); public options: IGridStateOptions = {...}; public pivotConfigHierarchy: IPivotConfiguration = { columnStrategy: NoopPivotDimensionsStrategy.instance(), rowStrategy: NoopPivotDimensionsStrategy.instance(), columns: [...], rows: [...], values: [...], filters: [...] }; Restoring the state from the sessionStorage and applying the custom strategies looks like the following: public restoreState() { const state = window.sessionStorage.getItem('grid-state'); this.state.stateParsed.pipe(take(1)).subscribe(parsedState => { parsedState.sorting.forEach(x => x.strategy = NoopSortingStrategy.instance()); parsedState.pivotConfiguration.rowStrategy = NoopPivotDimensionsStrategy.instance(); parsedState.pivotConfiguration.columnStrategy = NoopPivotDimensionsStrategy.instance(); }); this.state.setState(state as string); } Limitations getState method uses JSON.stringify() method to convert the original objects to a JSON string. JSON.stringify() does not support Functions, thats why the IgxGridState directive will ignore the pivot dimension memberFunction, pivot values member, formatter, custom aggregate functions, styles and pivot configuration strategies: columnStrategy and rowStrategy. API References IgxPivotGridComponent IgxGridStateDirective Additional Resources Pivot Grid Overview Pivot Grid Remote Operations Pivot Grid Features View page on GitHub"
  },
  "components/pivotGrid/summaries.html": {
    "href": "components/pivotGrid/summaries.html",
    "title": "Angular Pivot Grid Summaries",
    "keywords": "Angular Pivot Grid Summaries The Angular UI grid in Ignite UI for Angular has a summaries feature that functions on a per-column level as group footer. Angular grid summaries is powerful feature which enables the user to see column information in a separate container with a predefined set of default summary items, depending on the type of data within the column or by implementing a custom angular template in the Pivot Grid. Angular Pivot Grid Summaries Overview Example Note The summary of the column is a function of all column values, unless filtering is applied, then the summary of the column will be function of the filtered result values Pivot Grid summaries can also be enabled on a per-column level in Ignite UI for Angular, which means that you can activate it only for columns that you need. Pivot Grid summaries gives you a predefined set of default summaries, depending on the type of data in the column, so that you can save some time: For string and boolean data types, the following function is available: count For number, currency and percent data types, the following functions are available: count min max average sum For date data type, the following functions are available: count earliest latest All available column data types could be found in the official Column types topic. Pivot Grid summaries are enabled per-column by setting hasSummary property to true. It is also important to keep in mind that the summaries for each column are resolved according to the column data type. In the igx-pivot-grid the default column data type is string, so if you want number or date specific summaries you should specify the dataType property as number or date. Note that the summary values will be displayed localized, according to the grid locale and column pipeArgs. The other way to enable/disable summaries for a specific column or a list of columns is to use the public method enableSummaries/disableSummaries of the igx-pivot-grid. Custom Pivot Grid Summaries If these functions do not fulfill your requirements you can provide a custom summary for the specific columns. In order to achieve this you have to override one of the base classes IgxSummaryOperand, IgxNumberSummaryOperand or IgxDateSummaryOperand according to the column data type and your needs. This way you can redefine the existing function or you can add new functions. IgxSummaryOperand class provides the default implementation only for the count method. IgxNumberSummaryOperand extends IgxSummaryOperand and provides implementation for the min, max, sum and average. IgxDateSummaryOperand extends IgxSummaryOperand and additionally gives you earliest and latest. import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from 'igniteui-angular'; // import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from '@infragistics/igniteui-angular'; for licensed package class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(data?: any[]): IgxSummaryResult[] { const result = super.operate(data); result.push({ key: 'test', label: 'Test', summaryResult: data.filter(rec => rec > 10 && rec < 30).length }); return result; } } As seen in the examples, the base classes expose the operate method, so you can choose to get all default summaries and modify the result, or calculate entirely new summary results. The method returns a list of IgxSummaryResult. interface IgxSummaryResult { key: string; label: string; summaryResult: any; } and take optional parameters for calculating the summaries. See Custom summaries, which access all data section below. Note In order to calculate the summary row height properly, the Pivot Grid needs the operate method to always return an array of IgxSummaryResult with the proper length even when the data is empty. Custom summaries, which access all data Now you can access all Pivot Grid data inside the custom column summary. Two additional optional parameters are introduced in the IgxSummaryOperand operate method. As you can see in the code snippet below the operate method has the following three parameters: columnData - gives you an array that contains the values only for the current column allGridData - gives you the whole grid data source fieldName - current column field class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(columnData: any[], allGridData = [], fieldName?): IgxSummaryResult[] { const result = super.operate(allData.map(r => r[fieldName])); result.push({ key: 'test', label: 'Total Discontinued', summaryResult: allData.filter((rec) => rec.Discontinued).length }); return result; } } Summary Template igxSummary targets the column summary providing as a context the column summary results. <igx-column ... [hasSummary]=\"true\"> <ng-template igxSummary let-summaryResults> <span> My custom summary template</span> <span>{{ summaryResults[0].label }} - {{ summaryResults[0].summaryResult }}</span> </ng-template> </igx-column> When a default summary is defined, the height of the summary area is calculated by design depending on the column with the largest number of summaries and the display density of the grid. Use the summaryRowHeight input property to override the default value. As an argument it expects a number value, and setting a falsy value will trigger the default sizing behavior of the grid footer. Note Column summary template could be defined through API by setting the column summaryTemplate property to the required TemplateRef. Formatting summaries By default, summary results, produced by the built-in summary operands, are localized and formatted according to the grid locale and column pipeArgs. When using custom operands, the locale and pipeArgs are not applied. If you want to change the default appearance of the summary results, you may format them using the summaryFormatter property. public dateSummaryFormat(summary: IgxSummaryResult, summaryOperand: IgxSummaryOperand): string { const result = summary.summaryResult; if(summaryOperand instanceof IgxDateSummaryOperand && summary.key !== 'count' && result !== null && result !== undefined) { const pipe = new DatePipe('en-US'); return pipe.transform(result,'MMM YYYY'); } return result; } <igx-column ... [summaryFormatter]=\"dateSummaryFormat\"></igx-column> Exporting Summaries There is an exportSummaries option in IgxExcelExporterOptions that specifies whether the exported data should include the grid's summaries. Default exportSummaries value is false. The IgxExcelExporterService will export the default summaries for all column types as their equivalent excel functions so they will continue working properly when the sheet is modified. Try it for yourself in the example below: The exported file includes a hidden column that holds the level of each DataRecord in the sheet. This level is used in the summaries to filter out the cells that need to be included in the summary function. In the table below, you can find the corresponding Excel formula for each of the default summaries. Data Type Function Excel Function string, boolean count =\"Count: \"&COUNTIF(start:end, recordLevel) number, currency, percent count =\"Count: \"&COUNTIF(start:end, recordLevel) min =\"Min: \"&MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)) max =\"Max: \"&MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)) average =\"Avg: \"&AVERAGEIF(start:end, recordLevel, rangeStart:rangeEnd) sum =\"Sum: \"&SUMIF(start:end, recordLevel, rangeStart:rangeEnd) date count =\"Count: \"&COUNTIF(start:end, recordLevel) earliest =\"Earliest: \"& TEXT(MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) latest =\"Latest: \"&TEXT(MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) Known Limitations Limitation Description Exporting custom summaries Custom summaries will be exported as strings instead of Excel functions. Exporting templated summaries Templated summaries are not supported and will be exported as the default ones. Keyboard Navigation The summary rows can be navigated with the following keyboard interactions: UP - navigates one cell up DOWN - navigates one cell down LEFT - navigates one cell left RIGHT - navigates one cell right CTRL + LEFT or HOME - navigates to the leftmost cell CTRL + RIGHT or END - navigates to the rightmost cell Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-summary-theme and accepts the $background-color, $focus-background-color, $label-color, $result-color, $pinned-border-width, $pinned-border-style and $pinned-border-color parameters. $custom-theme: grid-summary-theme( $background-color: #e0f3ff, $focus-background-color: rgba( #94d1f7, .3 ), $label-color: #e41c77, $result-color: black, $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: #e41c77 ); The last step is to include the component mixins: @include grid-summary($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-summary($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $blue-color: #7793b1; $green-color: #00ff2d; $my-custom-palette: palette($primary: $blue-color, $secondary: $green-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-summary-theme( $background-color: color($my-custom-palette, \"primary\", 700), $focus-background-color: color($my-custom-palette, \"primary\", 800), $label-color: color($my-custom-palette, \"secondary\", 500), $result-color: color($my-custom-palette, \"grays\", 900), $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: color($my-custom-palette, \"secondary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid-summary: // Extending the light grid summary schema $my-summary-schema: extend($_light-grid-summary, ( background-color: (igx-color: ('primary', 700)), focus-background-color: (igx-color: ('primary', 800)), label-color: (igx-color: ('secondary', 500)), result-color: (igx-color: ('grays', 900)), pinned-border-width: 2px, pinned-border-style: dotted, pinned-border-color: (igx-color: ('secondary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid-summary: $my-summary-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-summary-theme( $palette: $my-custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. API References IgxPivotGridComponent API IgxPivotGridComponent Styles IgxPivotGridSummaries Styles IgxSummaryOperand IgxNumberSummaryOperand IgxDateSummaryOperand IgxColumnGroupComponent IgxColumnComponent Additional Resources Pivot Grid overview Column Data Types Virtualization and Performance Paging Filtering Sorting Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/toolbar.html": {
    "href": "components/pivotGrid/toolbar.html",
    "title": "Angular Grid Toolbar - Ignite UI for Angular",
    "keywords": "Angular Pivot Grid Toolbar The Pivot Grid in Ignite UI for Angular provides an IgxGridToolbarComponent which is essentially a container for UI operations. The Angular toolbar is located at the top of the Angular component, i.e the Pivot Grid and it matches its horizontal size. The toolbar container can host predefined UI controls for the following Pivot Grid's features: Column Hiding Column Pinning Excel Exporting Advanced Filtering or just any other custom content. The toolbar and the predefined UI components support Angular events and expose API for developers. Angular Toolbar Grid Example The predefined actions and title UI components are added inside the <igx-grid-toolbar> and this is all needed to have a toolbar providing default interactions with the corresponding Grid features: Note: As seen in the code snippet above, the predefined actions UI components are wrapped in the <igx-grid-toolbar-actions> container. This way, the toolbar title is aligned to the left of the toolbar and the actions are aligned to the right of the toolbar. Of course, each of these UIs can be added independently of each other, or may not be added at all. This way the toolbar container will be rendered empty: For a comprehensive look over each of the default UI components, continue reading the Features section below. Features The toolbar is great at separating logic/interactions which affects the grid as a whole. As shown above, it can be configured to provide default components for controlling, column hiding, column pinning, advanced filtering and exporting data from the grid. These features can be enabled independently from each other by following a pattern similar to the card component of the Ignite UI for Angular suite. Listed below are the main features of the toolbar with example code for each of them. Title Setting a title for the toolbar in your grid is achieved by using the IgxGridToolbarTitleComponent. Users can provide anything from simple text to more involved templates. <igx-grid-toolbar> <igx-grid-toolbar-title>Grid toolbar title</igx-grid-toolbar-title> </igx-grid-toolbar> Actions The toolbar exposes a specific container where users can place actions/interactions in relation to the parent grid. As with the title portion of the toolbar, users can provide anything inside that template part, including the default toolbar interaction components. <igx-grid-toolbar> <igx-grid-toolbar-actions> <button igxButton>Action</button> <igx-select></igx-select> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> Each action now exposes a way to change the overlay settings of the actions dialog by using the overlaySettings input, example: <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning [overlaySettings]=\"overlaySettingsScaleCenter\"></igx-grid-toolbar-pinning> <igx-grid-toolbar-hiding [overlaySettings]=\"overlaySettingsAuto\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> public data: any[]; public positionStrategyScaleCenter = new GlobalPositionStrategy({ openAnimation: scaleInCenter, closeAnimation: scaleOutCenter }); public overlaySettingsScaleCenter = { positionStrategy: this.positionStrategyScaleCenter, scrollStrategy: new AbsoluteScrollStrategy(), modal: true, closeOnEscape: true }; public positionStrategyAuto = new AutoPositionStrategy(); public overlaySettingsAuto = { positionStrategy: this.positionStrategyAuto, scrollStrategy: new AbsoluteScrollStrategy(), modal: false, closeOnEscape: false }; constructor() { this.data = athletesData; } The default overlaySettings are using ConnectedPositionStrategy with Absolute scroll strategy, modal set to false, with enabled close on escape and close on outside click interactions. Column pinning Toolbar Pinning component provides the default UI for interacting with column pinning in the grid. The component is setup to work out of the box with the parent grid containing the toolbar as well as several input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning title=\"Grid pinned columns\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-pinning> </igx-grid-toolbar-actions> </igx-grid-toolbar> Column hiding Toolbar Hiding component provides the default UI for interacting with column hiding. Exposes the same input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding title=\"Grid column hiding\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> Advanced filtering Toolbar Advanced Filtering component provides the default UI for the Advanced Filtering feature. The component exposes a way to change the default text of the button. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering>Custom text for the toggle button</igx-grid-toolbar-advanced-filtering> </igx-grid-toolbar-actions> </igx-grid-toolbar> Data exporting As with the rest of the toolbar actions, exporting is provided through a Toolbar Exporter component out of the box. The exporting component is using the respective service for the target data format (Excel CSV). That means if the respective service is not provided through the dependency injection chain, the component won't be able to export anything. If you need a refresher on the DI in Angular, check the official guide. Here is a sample snippet showing how to enable all export services for your application. // app.module.ts import { IgxExcelExporterService, IgxCsvExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService, IgxCsvExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... providers: [IgxExcelExporterService, IgxCsvExporterService ] }) export class AppModule { ... } Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. The toolbar exporter component exposes several input properties for customizing both the UI and the exporting experience. These range from changing the display text, to enabling/disabling options in the dropdown to customizing the name of the generated file. For full reference, consult the API documentation for the toolbar exporter component. Here is a snippet showing some of the options which can be customized through the Angular template: <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-exporter <!-- If active, enables the csv export entry in the dropdown UI --> [exportCSV]=\"csvExportEnabled\" <!-- If active, enables the excel export entry in the dropdown UI --> [exportExcel]=\"excelExportEnabled\" <!-- The name of the generated export file without the file extension --> filename=\"exported_data\" > Custom text for the exporter button <span excelText>Custom text for the excel export entry</span> <span csvText>Custom text for the CSV export entry</span> </igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> In addition to changing the exported filename, the user can further configure the exporter options by waiting for the toolbarExporting event and customizing the options entry in the event properties. Note By default when exporting to CSV the exporter exports using a comma separator and uses a '.csv' extension for the output file. You can customize these exporting parameters by subscribing to events of the exporter or changing the values of the exporter options fields. You can also cancel the export process by setting the cancel field of the event args to true. The following code snippet demonstrates subscribing to the toolbar exporting event and configuring the exporter options: <igx-pivot-grid (toolbarExporting)=\"configureExport($event)\" ></igx-pivot-grid> configureExport(args: IGridToolbarExportEventArgs) { const options: IgxExporterOptionsBase = args.options; options.fileName = `Report_${new Date().toDateString()}`; if (options instanceof IgxExcelExporterOptions) { options.columnWidth = 10; } else { options.fileType = CsvFileTypes.TSV; options.valueDelimiter = '\\t'; } args.exporter.columnExporting.subscribe((columnArgs: IColumnExportingEventArgs) => { }); } The following sample demonstrates how to customize the exported files: Exporting Indicator When using the default toolbar exporter component, whenever an export operation takes place the toolbar will show a progress indicator while the operation is in progress. Moreover, users can set the toolbar showProgress property and use for their own long running operations or just as another way to signify an action taking place in the grid. The sample belows uses has significant amount of data, in order to increase the time needed for data export so the progressbar can be seen. Additionally it has another button that simulates a long running operation in the grid: Custom Content Note This replaces the old toolbar template directive. If you are migrating from a version before v11 our migrations will handle the moving of the template content. However, we do not handle the bindings in the template, so make sure to double check the modified template files after the migration completes. If the actions part of the toolbar component is not sufficient for a particular use case, the toolbar itself has a general content projection where users can provide additional UI. If the user needs the respective grid instance for API calls or bindings, they can create a template reference variable. Here is a sample snippet: <igx-pivot-grid #gridRef ...> ... <igx-grid-toolbar> <igx-grid-toolbar-title>{{ titleBinding }}</igx-grid-toolbar-title> <!-- Everything between the toolbar tags except the default toolbar components/directives will be projected as custom content. --> <button igxButton=\"flat\" igxRipple (click)=\"#gridRef.clearSort()\"> <igx-icon fontSet=\"material\">clear</igx-icon> Clear Sort </button> <igx-grid-toolbar-actions> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-pivot-grid> The following sample demonstrates how to add an additional button to the toolbar to clear the sorting set by clicking on the columns' headers: Styling To get started with styling the toolbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; First, let's create a new palette. $my-dark-palette: palette( $primary: #2466ff, $secondary: #FFCD0F, $surface: #2a2b2f, $grays: #fff, ); $my-dark-color: color($my-dark-palette, 'surface'); Now, create a new theme that extends the grid-toolbar-theme and modify the $background-color and the $title-text-color parameters. $dark-grid-toolbar-theme: grid-toolbar-theme( $palette: $my-dark-palette, $background-color: $my-dark-color, $title-text-color: color($my-dark-palette, 'secondary'), $dropdown-background: $my-dark-color, ); To theme the column actions menus of the toolbar, we have to change the theme of the column-actions-theme component. $dark-column-actions-theme: column-actions-theme( $palette: $my-dark-palette, $title-color: color($my-dark-palette, 'secondary'), $background-color: color($my-dark-palette, 'surface') ); Since the column actions are using other components - igx-button, igx-checkbox, and igx-input-group, we need to change their themes to match our new toolbar theme. $dark-button-theme: button-theme( $palette: $my-dark-palette, $outlined-background: color($my-dark-palette, 'secondary'), $outlined-hover-background: color($my-dark-palette, 'grays', 100), $outlined-hover-text-color: color($my-dark-palette, 'secondary') ); $dark-checkbox-theme: checkbox-theme( $palette: $my-dark-palette, $tick-color: $my-dark-color, ); $dark-input-group-theme: input-group-theme( $palette: $my-dark-palette ); The last step is to include the newly created themes. :host { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } Note If $legacy-support is set to false(default), include the component css variables like that: :host { @include css-vars($dark-grid-toolbar-theme); @include css-vars($dark-column-actions-theme); @include css-vars($dark-checkbox-theme); @include css-vars($dark-input-group-theme); @include css-vars($dark-button-theme); } Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } } Demo API References The Grid Toolbar service has a few more APIs to explore, which are listed below. IgxGridToolbarActionsComponent IgxGridToolbarAdvancedFilteringComponent IgxGridToolbarComponent IgxGridToolbarExporterComponent IgxGridToolbarHidingComponent IgxGridToolbarPinningComponent IgxGridToolbarTitleComponent IgxPivotGridComponent events: toolbarExporting Styles: IgxPivotGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/validation.html": {
    "href": "components/pivotGrid/validation.html",
    "title": "Editing and Validation in Angular Pivot Grid - Infragistics",
    "keywords": "Angular Pivot Grid Editing and Validation The Pivot Grid's editing exposes a built-in validation mechanism of user input when editing cells/rows. It extends the Angular Form validation functionality to allow easier integration with a well known functionality. When the state of the editor changes, visual indicators are applied to the edited cell. Configuration Configure via template-driven configuration We extend some of the Angular Forms validator directives to directly work with the IgxColumn. The same validators are available as attributes to be set declaratively in igx-column. The following validators are supported out-of-the-box: required min max email minlength maxlength pattern To validate that a column input would be set and the value is going to be formatted as an email, you can use the related directives: <igx-column [field]=\"email\" [header]=\"User E-mail\" required email></igx-column> The following sample demonstrates how to use the prebuilt required, email and min validator directives in a Pivot Grid. Configure via reactive forms We expose the FormGroup that will be used for validation when editing starts on a row/cell via a formGroupCreated event. You can modify it by adding your own validators for the related fields: You can decide to write your own validator function, or use one of the built-in Angular validator functions. Validation service API The grid exposes a validation service via the validation property. That service has the following public APIs: valid - returns if the grid validation state is valid. getInvalid - returns records with invalid states. clear - clears state for record by id or clears all state if no id is provided. markAsTouched - marks the related record/field as touched. Invalid states will persis until the validation errors in them are fixed according to the validation rule or they are cleared. Validation triggers Validation will be triggered in the following scenarios: While editing via the cell editor based on the grid's validationTrigger. Either on change while typing in the editor, or on blur when the editor loses focus or closes. When updating cells/rows via the API - updateRow, updateCell etc.. When using batch editing and the undo/redo API of the transaction service. Note: Validation will not trigger for records that have not been edited via user input or via the editing API. Visual indicators on the cell will only shown if the related input is considered touched - either via user interaction or via the markAsTouched API of the validation service. Angular Pivot Grid Validation Customization Options Set a custom validator You can define your own validation directive to use on a <igx-column> in the template. @Directive({ selector: '[phoneFormat]', providers: [{ provide: NG_VALIDATORS, useExisting: PhoneFormatDirective, multi: true }] }) export class PhoneFormatDirective extends Validators { @Input('phoneFormat') public phoneFormatString = ''; public validate(control: AbstractControl): ValidationErrors | null { return this.phoneFormatString ? phoneFormatValidator(new RegExp(this.phoneFormatString, 'i'))(control) : null; } } Once it is defined and added in your app module you can set it declaratively to a given column in the grid: <igx-column phoneFormat=\"\\+\\d{1}\\-(?!0)(\\d{3})\\-(\\d{3})\\-(\\d{4})\\b\" ...> Change default error template You can define your own custom error template that will be displayed in the error tooltip when the cell enters invalid state. This is useful in scenarios where you want to add your own custom error message or otherwise change the look or content of the message. <igx-column ... > <ng-template igxCellValidationError let-cell='cell' let-defaultErr=\"defaultErrorTemplate\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> <div *ngIf=\"cell.validation.errors?.['phoneFormat']\"> Please enter correct phone format </div> </ng-template> </igx-column> Prevent exiting edit mode on invalid state In some cases you may want to disallow submitting an invalid value in the data. In that scenarios you can use the cellEdit or rowEdit events and cancel the event in case the new value is invalid. Both events' arguments have a valid property and can be canceled accordingly. How it is used can be seen in the Cross-field Validation example public cellEdit(evt) { if (!evt.valid) { evt.cancel = true; } } Example The below example demonstrates the above-mentioned customization options. Cross-field validation In some scenarios validation of one field may depend on the value of another field in the record. In that case a custom validator can be used to compare the values in the record via their shared FormGroup. Cross-field example Styling Using the Ignite UI for Angular Theme Library, we can alter the default validation styles while editing. In the example below, we will make use of the exposed template for validation message, which pops out in a tooltip and overriding the error color to modify the default looks of the validation. We will also style the background of the invalid rows to make them more distinct. Import theme The easiest way to style and access css variables is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Include the styles In order to change the error color you can use the css variable --igx-error-500: --igx-error-500: 34, 80%, 63%; Custom Templates Changing the default error template allows setting custom classes and styles: <ng-template igxCellValidationError let-cell='cell' let-defaultErr='defaultErrorTemplate'> <div class=\"validator-container\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> </div> </ng-template> Invalid row and cell styles Rows and cells provide API for the developers to know if a row or cell is invalid and what kind of errors are active. Demo API References IgxBaseTransactionService IgxGridComponent IgxColumnComponent Known Issues and Limitations Limitation Description When validationTrigger is blur, editValue and validation will trigger only after editor is blurred. Reason is that this utilizes the formControl's updateOn property. This determines the event on which the formControl will update and trigger related validators. Additional Resources Build CRUD operations with igxGrid Pivot Grid Overview Pivot Grid Editing Pivot Grid Row Editing Pivot Grid Row Adding Pivot Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/pivotGrid/virtualization.html": {
    "href": "components/pivotGrid/virtualization.html",
    "title": "Angular Pivot Grid Virtualization and Performance",
    "keywords": "Angular Pivot Grid Virtualization and Performance In Ignite UI for Angular, the IgxPivotGrid control now utilizes the igxForOf directive and virtualizes its content both vertically and horizontally. Enabling Virtualization By utilizing the igxForOf directive the IgxPivotGrid now optimizes DOM rendering and memory consumption by rendering only what is currently visible in the view port and swapping the displayed data while the user scrolls the data horizontally/vertically. IgxPivotGrid's width and height defaults to 100% which will enable virtualization if the content displayed cannot fit inside the available space and scrollbars are required either vertically or horizontally. However, it is also possible to explicitly set the Pivot Grid's width and/or height to null which means that the related dimension will be determined by the total size of the items inside. No scrollbar will then be shown and all items will be rendered along the respective dimension (columns if width is null and rows if height is null). The size of the data chunks is determined by: The row height for the vertical (row) virtualization. This is determined by the rowHeight option and is 50(px) by default. The individual column widths in pixels for the horizontal (column) virtualization. They can be determined by either setting explicit width for each column component or setting the Pivot Grid's columnWidth option, which will be applied to all columns that don't have explicit width set. In most cases, letting the grid apply its default behavior by leaving dimensions unset will produce the desired layout. For column widths it is determined by the column count, the columns with set width, and the calculated width of the Pivot Grid's container. The grid will try to fit all columns inside the available space as long as the width it attempts to assign is not under 136(px). In such cases, columns with unassigned width will receive the minimum width of 136(px) and a horizontal scrollbar will be shown. The grid will be horizontally virtualized. Explicitly setting column widths in percentages (%) will, in most cases, create a grid that is not virtualized horizontally as it will not have a horizontal scrollbar. Virtualization Limitations On Mac OS horizontal scrollbar is not visible when \"Show scrollbars only when scrolling\" system option is set to true (which is the default value). This is because the Pivot Grid’s row container has an overflow set to hidden. Change the option to \"Always\" and the scrollbar will appear. FAQ Why having dimensions in the Pivot Grid is necessary for virtualization to work? Without information about the sizes of the container and the items before rendering them setting the width or height of a scrollbar or determining which of the items should be in the view when you scroll to a random location in the Pivot Grid is erroneous. Any assumptions on what the actual dimensions might be could lead to unnatural behavior of the scrollbar and ultimately suboptimal experience for the end-user. This is why setting the related dimensions is enforced in order for virtualization to take effect. API References IgxPivotGridComponent IgxPivotGridComponent Styles IgxColumnComponent IgxForOfDirective IForOfState Additional Resources Pivot Grid overview Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/query-builder.html": {
    "href": "components/query-builder.html",
    "title": "Angular Query Builder Component - Ignite UI for Angular",
    "keywords": "Angular Query Builder Component Overview Angular Query Builder is part of our Angular Components and it provides a rich UI that allows developers to build complex data filtering queries for a specified data set. With this component they can build a tree of expressions and set AND/OR conditions between them with editors and condition lists determined by each field's data type. The expression tree can then be easily transformed to a query in the format the backend supports. The IgxQueryBuilderComponent component provides a way to build complex queries through the UI. By specifying AND/OR operators, conditions and values the user creates an expression tree which describes the query. Angular Query Builder Example We’ve created this Angular Query Builder example to show you the default functionalities of the Angular Query Builder component. Click the plus button to add conditions, “and” group as well as “or” group. Navigate the side bars to ungroup or delete. Getting Started with Ignite UI for Angular Query Builder To get started with the Ignite UI for Angular Query Builder component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxQueryBuilderModule in the app.module.ts file. // app.module.ts import { IgxQueryBuilderModule } from 'igniteui-angular'; // import { IgxQueryBuilderModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxQueryBuilderModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxQueryBuilderComponent as a standalone dependency, or use the IGX_QUERY_BUILDER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_QUERY_BUILDER_DIRECTIVES, FilteringExpressionsTree, FieldType } from 'igniteui-angular'; // import { IGX_QUERY_BUILDER_DIRECTIVES, FilteringExpressionsTree, FieldType } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-query-builder #queryBuilder [fields]=\"fields\" [(expressionTree)]=\"expressionTree\" (expressionTreeChange)=\"onExpressionTreeChange()\"> </igx-query-builder> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_QUERY_BUILDER_DIRECTIVES] /* or imports: [IgxQueryBuilderComponent] */ }) export class HomeComponent { public expressionTree: FilteringExpressionsTree; public fields: FieldType []; public onExpressionTreeChange() { ... } } Now that you have the Ignite UI for Angular Query Builder module or directives imported, you can start using the igx-query-builder component. Using the Angular Query Builder If no expression tree is initially set, you start with creating a group of conditions linked with AND or OR. After that, conditions or sub-groups can be added. In order to add a condition, a field, an operand based on the field dataType and a value if the operand is not unary. Once the condition is committed, a chip with the condition information appears. By hovering or clicking the chip, you have the options to modify it or add another condition or group right after it. If you select more than one condition chip, a context menu appears with options to create a group or delete the queries. If you choose to create a group with the selected conditions, the newly created group will appear where the topmost selected condition was placed. In order to select a group, you can also click on its vertical line, which is colored based on the linking condition (AND or OR). If a single group is selected, you get a context menu with options to change its logic, ungroup or delete it. You can start using the component by setting the fields property to an array describing the field name and its data type. It will automatically assign the corresponding operands based on the data type. The Query Builder has the expressionTree input property. You could use it to set an initial state of the control and access the user-specified filtering logic. ngAfterViewInit(): void { const tree = new FilteringExpressionsTree(FilteringLogic.And); tree.filteringOperands.push({ fieldName: 'ID', condition: IgxStringFilteringOperand.instance().condition('contains'), searchVal: 'a', ignoreCase: true }); const subTree = new FilteringExpressionsTree(FilteringLogic.Or); subTree.filteringOperands.push({ fieldName: 'ContactTitle', condition: IgxStringFilteringOperand.instance().condition('doesNotContain'), searchVal: 'b', ignoreCase: true }); subTree.filteringOperands.push({ fieldName: 'CompanyName', condition: IgxStringFilteringOperand.instance().condition('startsWith'), searchVal: 'c', ignoreCase: true }); tree.filteringOperands.push(subTree); this.queryBuilder.expressionTree = tree; } The expressionTree is a two-way bindable property which means a corresponding expressionTreeChange output is implemented that emits when the end-user changes the UI by creating, editing or removing conditions. It can also be subscribed to separately to receive notifications and react to such changes. <igx-query-builder #queryBuilder [fields]=\"fields\" [(expressionTree)]=\"expressionTree\" (expressionTreeChange)=\"onExpressionTreeChange()\"> </igx-query-builder> Styling To get started with styling the Query Builder, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The Query Builder takes its background color from the its theme, using the background parameter. In order to change the background we need to create a custom theme: $custom-query-builder: query-builder-theme( $background: #FFCD0F ); Since we have other components inside the Query Builder, such as buttons, chips, dropdowns and inputs, we need to create a separate theme for each one: $custom-button: button-theme( $disabled-color: gray, ... ); $custom-button-group: button-group-theme( $item-background: #292826, ... ); $custom-input-group: input-group-theme( $box-background: #4a4a4a, ... ); $custom-chip: chip-theme( $background: #FFCD0F, ... ); $custom-drop-down: drop-down-theme( $background-color: #292826, ... ); In this example we only changed some of the parameters for the listed components, but the button-theme, button-group-theme, chip-theme, drop-down-theme, input-group-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also add some styles for other elements inside the query builder. @include query-builder($custom-query-builder); igx-query-builder { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); @include drop-down($custom-drop-down); .igx-filter-empty__title { color: #FFCD0F } .igx-query-builder__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } .igx-input-group__input::placeholder { color: gray; } } Note We scope most of the components' mixins within igx-query-builder, so that these custom themes will affect only components nested in the Query Builder. Otherwise, other buttons, chips, inputs and dropdowns in the application would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include query-builder($custom-query-builder); igx-query-builder { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); .igx-input-group__input::placeholder { color: gray; } .igx-filter-empty__title { color: #FFCD0F } .igx-query-builder__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-query-builder: query-builder-theme( $background: color($dark-palette, \"secondary\", 400) ); $custom-button: button-theme( $disabled-color: color($dark-palette, \"secondary\", 100), ... ); $custom-button-group: button-group-theme( $item-background: color($dark-palette, \"secondary\", 400), ... ); $custom-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 200), ... ); $custom-chip: chip-theme( $background: color($dark-palette, \"primary\", 400), ... ); $custom-drop-down: drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), ... ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-query-builder, light-button, light-button-group, light-chip, light-input-group and light-drop-down schemas: $query-builder-dark-palette: palette($primary: #11bd7b, $secondary: #e32057, $info: $black-color); $custom-query-builder-schema: extend($_light-query-builder, ( background:( color: (\"info\") ) ) ); $custom-button-schema: extend($_light-button, ( disabled-color:( color: (\"secondary\", 100) ), ... ) ); $custom-button-group-schema: extend($_light-button-group, ( item-background:( color: (\"secondary\", 400) ), ... ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 200) ), ... ) ); $custom-chip-schema: extend($_light-chip, ( background:( color: (\"primary\", 400) ), ... ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), ... ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( igx-query-builder: $custom-query-builder-schema, igx-button: $custom-button-schema, igx-button-group: $custom-button-group-schema, igx-input-group: $custom-input-group-schema, igx-chip: $custom-chip-schema, igx-drop-down: $custom-drop-down-schema )); $custom-query-builder: query-builder-theme( $palette: $query-builder-dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button-group: button-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-chip: chip-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. You can also streamline your Angular app development using WYSIWYG App Builder™ with real UI components. API References IgxQueryBuilderComponent API IgxQueryBuilderComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/radial-gauge.html": {
    "href": "components/radial-gauge.html",
    "title": "Angular Radial Gauge Chart | Data Visualization Tools | Infragistics",
    "keywords": "Angular Radial Gauge Overview The Angular radial gauge component provides a number of visual elements, like a needle, tick marks, ranges, and labels, in order to create a predefined shape and scale. The IgxRadialGaugeComponent also has built-in support for animated transitions. This animation is easily customizable by setting the transitionDuration property. Angular Radial Gauge Example The following sample demonstrates how setting multiple properties on the same IgxRadialGaugeComponent can transform it to completely different radial gauge. Dependencies When installing the gauge component, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-gauges Component Modules The IgxRadialGaugeComponent requires the following modules: // app.module.ts import { IgxRadialGaugeModule } from 'igniteui-angular-gauges'; @NgModule({ imports: [ // ... IgxRadialGaugeModule // ... ] }) export class AppModule {} Usage The following code demonstrates how create a radial gauge containing a needle and three comparative ranges on the scale. <igx-radial-gauge height=\"400px\" width=\"400px\" value=\"25\" interval=\"5\" minimumValue=\"0\" maximumValue=\"100\"> <igx-radial-gauge-range startValue=\"0\" endValue=\"30\" brush=\"red\"> </igx-radial-gauge-range> <igx-radial-gauge-range startValue=\"30\" endValue=\"60\" brush=\"yellow\"> </igx-radial-gauge-range> <igx-radial-gauge-range startValue=\"60\" endValue=\"100\" brush=\"green\"> </igx-radial-gauge-range> </igx-radial-gauge> Backing The radial gauge component comes with a backing shape drawn behind the scale that acts as a background for the radial gauge. The backing element represents background and border of the radial gauge component. It is always the first element rendered and all the rest of elements such as needle, labels, and tick marks are overlay on top of it. The backing can be circular or fitted. A circular shape creates a 360 degree circle gauge while a fitted shape creates a filled arc segment encompassing the scaleStartAngle and scaleEndAngle properties. This can be set by setting the backingShape property. <igx-radial-gauge backingShape=\"Fitted\" backingBrush=\"#fcfcfc\" backingOutline=\"DodgerBlue\" backingOversweep=5 backingCornerRadius=10 backingStrokeThickness=5 backingOuterExtent=0.8 backingInnerExtent=0.15 scaleStartAngle=135 scaleEndAngle=45 height=\"300px\" width=\"300px\" minimumValue=0 value=50 maximumValue=80 interval=10> </igx-radial-gauge> Scale The scale is visual element that highlights full range of values in the gauge which can be created by supplying minimumValue and maximumValue values. Together with backing, it defines overall shape of gauge. The scaleStartAngle and scaleEndAngle properties define bounds of arc of the scale. While, the scaleSweepDirection property specifies whether the scale sweeps in clockwise or counter-clockwise direction. You can customize appearance of the scale by setting scaleBrush, scaleStartExtent, and scaleEndExtent properties. <igx-radial-gauge scaleStartAngle=135 scaleEndAngle=45 scaleBrush=\"DodgerBlue\" scaleSweepDirection=\"Clockwise\" scaleOversweep=1 scaleOversweepShape=\"Fitted\" scaleStartExtent=0.45 scaleEndExtent=0.575 height=\"300px\" width=\"300px\" minimumValue=0 value=50 maximumValue=80 interval=10> </igx-radial-gauge> Labels The radial gauge labels are visual elements displaying numeric values at a specified interval between values of the minimumValue and maximumValue properties. You can position labels by setting the labelExtent property to a fraction, where 0 represents center of gauge and 1 represents outer extent of the gauge backing. Also, you can customize labels setting various styling properties such as fontBrush and font. <igx-radial-gauge labelExtent=0.65 labelInterval=10 font=\"11px Verdana\" fontBrush=\"DodgerBlue\" height=\"300px\" width=\"300px\" minimumValue=0 value=50 maximumValue=100 interval=10> </igx-radial-gauge> Optical Scaling The radial gauge's labels and titles can change it's scaling. To enable this, first set OpticalScalingEnabled to true. Then you can set OpticalScalingSize which manages the size at which labels have 100% optical scaling. Labels will have larger fonts when gauge's size is larger. For example, labels will have a 200% larger font size when this property is set to 500 and the gauge px size is doubled to eg. 1000. Tick Marks Tick marks are thin lines radiating from the center of the radial gauge. There are two types of tick marks: major and minor. Major tick marks are displayed at the interval between the minimumValue and maximumValue properties. Use the minorTickCount property to specify the number of minor tick marks displayed between each major tick mark. You can control the length of tick marks by setting a fraction (between 0 and 1) to tickStartExtent, tickEndExtent, minorTickStartExtent, and minorTickEndExtent properties. <igx-radial-gauge tickStartExtent=0.45 tickEndExtent=0.575 tickStrokeThickness=2 tickBrush=\"DodgerBlue\" minorTickCount=4 minorTickEndExtent=0.5 minorTickStartExtent=0.575 minorTickStrokeThickness=1 minorTickBrush=\"DarkViolet\" height=\"300px\" width=\"300px\" minimumValue=0 value=50 maximumValue=80 interval=10> </igx-radial-gauge> Ranges A range highlights a set of continuous values bound by a specified minimumValue and maximumValue properties. You can add multiple ranges to the radial gauge by specifying their starting and ending values. Each range has a few customization properties such as brush and outline. Alternatively, you can set rangeBrushes and rangeOutlines properties to a list of colors for the ranges. <igx-radial-gauge height=\"300px\" width=\"300px\" minimumValue=0 value=50 maximumValue=80 interval=10 rangeBrushes =\"red, yellow, green\" rangeOutlines=\"red, yellow, green\"> <igx-radial-gauge-range startValue=5 endValue=15 brush=\"red\"> </igx-radial-gauge-range> <igx-radial-gauge-range startValue=15 endValue=35 brush=\"yellow\"> </igx-radial-gauge-range> <igx-radial-gauge-range startValue=35 endValue=45 brush=\"green\"> </igx-radial-gauge-range> </igx-radial-gauge> Needle Radial gauge needles are visual elements used to signify a gauge set value. Needles are available in one of the several predefined shapes. The needle can have a pivot shape, which is placed in the center of the gauge. The pivot shape also takes one of the predefined shapes. Pivot shapes that include an overlay or an underlay can have a separate pivot brush applied to the shape. The supported needle shapes and caps are set using the needleShape and needlePivotShape properties. You can enable an interactive mode of the gauge (using isNeedleDraggingEnabled property) and the end-user will be able to change value by dragging the needle between values of minimumValue and maximumValue properties. <igx-radial-gauge value=50 isNeedleDraggingEnabled=true isNeedleDraggingConstrained=true needleShape=\"NeedleWithBulb\" needleBrush=\"DodgerBlue\" needleOutline=\"DodgerBlue\" needleEndExtent=0.475 needleStrokeThickness=1 needlePivotShape=\"CircleOverlay\" needlePivotBrush=\"#9f9fa0\" needlePivotOutline=\"#9f9fa0\" needlePivotWidthRatio=0.2 needlePivotStrokeThickness=1 height=\"300px\" width=\"300px\" minimumValue=0 maximumValue=80 interval=10> </igx-radial-gauge> Summary For your convenience, all above code snippets are combined into one code block below that you can easily copy to your project and see the radial gauge with all features and visuals enabled. <igx-radial-gauge height=\"300px\" width=\"300px\" minimumValue=0 maximumValue=80 scaleStartAngle=135 scaleEndAngle=45 scaleBrush=\"#c6c6c6\" scaleSweepDirection=\"Clockwise\" scaleOversweep=1 scaleOversweepShape=\"Fitted\" scaleStartExtent=0.45 scaleEndExtent=0.575 value=70 isNeedleDraggingEnabled=true isNeedleDraggingConstrained=true needleShape=\"NeedleWithBulb\" needleBrush=\"DodgerBlue\" needleOutline=\"DodgerBlue\" needleEndExtent=0.475 needleStrokeThickness=1 needlePivotShape=\"CircleOverlay\" needlePivotBrush=\"#9f9fa0\" needlePivotOutline=\"#9f9fa0\" needlePivotWidthRatio=0.2 needlePivotStrokeThickness=1 interval=10 tickStartExtent=0.45 tickEndExtent=0.575 tickStrokeThickness=2 tickBrush=\"Black\" minorTickCount=4 minorTickEndExtent=0.5 minorTickStartExtent=0.575 minorTickStrokeThickness=1 minorTickBrush=\"Black\" labelExtent=0.65 labelInterval=10 font=\"11px Verdana\" fontBrush=\"Black\" backingShape=\"Fitted\" backingBrush=\"#ededed\" backingOutline=\"Gray\" backingOversweep=5 backingCornerRadius=10 backingStrokeThickness=5 backingOuterExtent=0.8 backingInnerExtent=0.15 rangeBrushes =\"#a4bd29, #F86232\" rangeOutlines=\"#a4bd29, #F86232\"> <igx-radial-gauge-range startValue=20 endValue=40 innerStartExtent=0.45 innerEndExtent=0.45 outerStartExtent=0.57 outerEndExtent=0.57> </igx-radial-gauge-range> <igx-radial-gauge-range startValue=40 endValue=60 innerStartExtent=0.45 innerEndExtent=0.45 outerStartExtent=0.57 outerEndExtent=0.57> </igx-radial-gauge-range> </igx-radial-gauge> API References The following is a list of API members mentioned in the above sections: IgxRadialGaugeComponent IgxRadialGaugeRangeComponent Additional Resources You can find more information about other types of gauges in these topics: Bullet Graph Linear Gauge View page on GitHub"
  },
  "components/radio-button.html": {
    "href": "components/radio-button.html",
    "title": "Angular Radio and Radio Group – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Radio & Radio Group Component Overview Radio Button The Ignite UI for Angular Radio Button component allows the user to select a single option from an available set of options that are listed side by side. Angular Radio & Radio Group Example Getting Started with Ignite UI for Angular Radio Button To get started with the Ignite UI for Angular Radio Button component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxRadioModule in the app.module.ts file. // app.module.ts ... import { IgxRadioModule } from 'igniteui-angular'; // import { IgxRadioModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxRadioModule], ... }) export class AppModule { public selected: any; } Alternatively, as of 16.0.0 you can import the IgxRadioGroupDirective and IgxRadioComponent as standalone dependencies, or use the IGX_RADIO_GROUP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_RADIO_GROUP_DIRECTIVES } from 'igniteui-angular'; // import { IGX_RADIO_GROUP_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-radio-group> <igx-radio [(ngModel)]=\"selected\" value=\"London\">London</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"New York\">New York</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"Tokyo\">Tokyo</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"Sofia\">Sofia</igx-radio> </igx-radio-group> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_RADIO_GROUP_DIRECTIVES, FormsModule] /* or imports: [IgxRadioComponent, IgxRadioGroupDirective, FormsModule] */ }) export class HomeComponent { public selected: any; } Now that you have the Ignite UI for Angular Radio Button module or directives imported, you can start using the igx-radio-group directive and igx-radio component. Using the Angular Radio Button Radio buttons can be displayed using the following code inside the component template: <igx-radio [(ngModel)]=\"selected\" value=\"option1\">Option 1</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"option2\">Option 2</igx-radio> Label The labelPosition property can be used to change the default position of the label in the radio component. Users can choose between before and after. If not specified, the label will be placed after the radio button. <igx-radio [(ngModel)]=\"selected\" value=\"option1\" labelPosition=\"before\">Option 1</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"option2\" labelPosition=\"before\">Option 2</igx-radio> Properties Let's enhance the previous sample by adding four radio buttons, each responsible for applying a certain color as a background. We will bind the backgroundColor property of a div element to the component's selectedColor property. You will notice that selectedColor also participates in a two way binding relation through the NgModel directive, therefore its value is updated each time the user selects a different radio button (color). // radiogroup.component.ts ... public colors = [{ hex: '#f06a2f', name: 'Carrot' }, { hex: '#ff134a', name: 'Watermelon' }, { hex: '#7bc96f', name: 'Grass' }, { hex: 'transparent', name: 'No color' }]; public selectedColor: string = this.colors[3].hex; <!--radiogroup.component.html--> <igx-radio *ngFor=\"let color of colors\" name=\"color\" [value]=\"color.hex\" [(ngModel)]=\"selectedColor\"> {{color.name}} </igx-radio> <div [style.background-color]=\"selectedColor\"> ... </div> Pay attention that if you don't use the NgModel directive in a two-way data binding, you must import the FormsModule and add it to the NgModule's imports list. The final result would be something like that: Styling To get started with styling the radio buttons, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the radio-theme and accepts some of the default theme's parameters: $custom-radio-theme: radio-theme( $disabled-color: lightgray, $empty-color: #345779, $fill-color: #2dabe8, $fill-color-hover: #2dabe8, $fill-hover-border-color: #2dabe8 ); Using CSS variables The last step is to pass the custom radio theme in our application: @include css-vars($custom-radio-theme); Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include radio($custom-radio-theme); } } Radio Group The Ignite UI for Angular Radio Group directive provides a grouping container that allows better control over the child radio components and supports template-driven and reactive forms. Demo Usage The Radio Group Directive is exported as an NgModule, thus all you need to do in your application is to import the IgxRadioModule in the app.module.ts file: // app.module.ts ... import { IgxRadioModule } from 'igniteui-angular'; // import { IgxRadioModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxRadioModule], ... }) To get started, create an igxRadioGroup and add several igxRadio components. Note that, setting a name property for the radio group is mandatory. <!--radio-group.component.html--> <igx-radio-group name=\"fruitsRadioGroup\"> <igx-radio *ngFor=\"let fruit of fruits\" value=\"{{fruit}}\"> {{fruit}} </igx-radio> </igx-radio-group> // radio-group.component.ts public fruits = [\"Apple\", \"Mango\", \"Banana\", \"Orange\"]; Alignment Use the alignment input property to change the orientation of the igxRadio components in the radio group. Users can choose between horizontal and vertical. By default the radio group alignment is horizontal. //sample.component.ts import { RadioGroupAlignment } from \"igniteui-angular\"; ... public alignment = RadioGroupAlignment.vertical; ... <!-- sample.component.html --> <igx-radio-group [alignment]=\"alignment\"> <igx-radio [(ngModel)]=\"selected\" value=\"London\">London</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"New York\">New York</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"Tokyo\">Tokyo</igx-radio> <igx-radio [(ngModel)]=\"selected\" value=\"Sofia\">Sofia</igx-radio> </igx-radio-group> API References IgxRadioGroupDirective IgxRadioComponent IgxRadioComponent Styles Theming Dependencies IgxRipple Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/rating.html": {
    "href": "components/rating.html",
    "title": "Angular Star Rating Component – Ignite UI for Angular",
    "keywords": "Angular Star Rating Overview Rating in Angular represents a widget enabling users to quickly provide feedback and evaluate a product or a service on a web page by using a star rating system. Simple to use, the component lets developers configure the size and the number of the displayed star rating items. The Ignite UI Angular Star Rating component can be easily installed from the igniteui-webcomponents package. It provides an intuitive rating experience for end-users, allowing them to view products/services and rate them (usually having the option to choose from 0 to 5 stars in the most common scenarios). Angular Rating Example This Angular Star Rating example demonstrates how you can use Ignite UI Angular to build simple five-star rating widget, comparing and displaying the score of different products. Getting Started with Ignite UI for Angular Star Rating Ignite UI Rating is a standard web component and as such can be used in an Angular application. Follow the steps below to add the Ignite UI Web Components package to your Angular project and set it up in order to use the component. First, install the igniteui-webcomponents package npm install igniteui-webcomponents --save Next, you should call the defineCustomElements() function with IgcRatingComponent argument either in your main.ts file or in the component .ts file that is using IgcRating. import { defineComponents, IgcRatingComponent } from 'igniteui-webcomponents'; defineComponents(IgcRatingComponent); You also need to include the CUSTOM_ELEMENTS_SCHEMA schema in the AppModule: import { CUSTOM_ELEMENTS_SCHEMA, NgModule } from '@angular/core'; @NgModule({ schemas: [CUSTOM_ELEMENTS_SCHEMA] }) export class AppModule {} With these you can now add the Rating component in an Angular component template and use its inputs and outputs: <igc-rating value=\"ratingVal\" min=\"1\" max=\"5\" (igcChange)=\"ratingChanged($event);\"></igc-rating> Using Angular Star Rating in Forms In Angular forms, components often need to be able to bind their values with ngModel or use formControl which requires an implementation of Angular's ControlValueAccessor interface. Ignite UI for Angular package provides such implementation in the form of a directive that uses an element selector to attach to supported web components. Currently IgcRating is the only component that it supports. To use the directive you just need to import IgcFormsModule from the library. import { IgcFormsModule } from 'igniteui-angular'; // import { IgcFormsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ IgcFormsModule ] }) export class AppModule { } Note If you are importing IgcFormsModule and using either ngModel or formControl, you no longer need to include CUSTOM_ELEMENTS_SCHEMA as Angular will recognize the igc-rating tag by the custom ControlValueAccessor directive. Alternatively, as of 16.0.0 you can import the IgcFormControlDirective as a standalone dependency. // home.component.ts import { FormsModule } from '@angular/forms'; import { IgcFormControlDirective } from 'igniteui-angular'; // import { IgcFormControlDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igc-rating name=\"modelRating\" [(ngModel)]=\"product.Rating\" max=\"10\" label=\"Model Rating\"></igc-rating>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgcFormControlDirective, FormsModule] }) export class HomeComponent { public product: Product; } Add a rating with e.g. ngModel for value and it will two-way bind with your model without issues. <igc-rating name=\"modelRating\" [(ngModel)]=\"model.Rating\" max=\"10\" label=\"Model Rating\"></igc-rating> The following application shows one example of how this integration works in a real use-case with forms. For further information on the usage of the Rating component, you can check out this topic. View page on GitHub"
  },
  "components/ripple.html": {
    "href": "components/ripple.html",
    "title": "Angular Ripple Directive – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Ripple Directive Overview The Ignite UI for Angular Ripple component creates an animation in response to a touch or a mouse click. Angular Ripple Example Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. Getting Started with Ignite UI for Angular Ripple Directive To get started with the Ignite UI for Angular Ripple directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxRippleModule in the app.module.ts file. // app.module.ts import { IgxRippleModule } from 'igniteui-angular'; // import { IgxRippleModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxRippleModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxRippleDirective as standalone dependencies. // home.component.ts import { IgxRippleDirective, IgxButtonDirective } from 'igniteui-angular'; // import { IgxRippleDirective, IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<button igxButton=\"contained\" igxRipple>Click Me</button>', styleUrls: ['home.component.scss'], standalone: true, imports: [IgxRippleDirective, IgxButtonDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Ripple module or directive imported, you can start using the igxRipple directive. Warning The igxRipple uses the Web Animation API and runs natively on browsers that support it. The web-animations.min.js polyfill is available for other browsers. Using the Angular Ripple Directive Adding Ripple Effect Use the igxRipple directive to add a ripple effect to the specified element: <button igxButton=\"contained\" igxRipple>Click Me</button> Examples Custom Color You can easily change the default ripple color using the igxRipple: <button igxButton=\"contained\" igxRipple=\"white\">White</button> Centered Ripple Effect By default, the ripple effect starts from the position of the click event. You can change this behavior using the igxRippleCentered property and setting the center of the element as origin. <button igxButton=\"contained\" igxRipple=\"white\" [igxRippleCentered]=\"true\">Centered</button> Ripple Duration We can use the igxRippleDuration property to change the duration of the ripple animation, which, by default, is set to 600 milliseconds. <button igxButton=\"contained\" igxRipple [igxRippleDuration]=\"2000\">Click Me</button> Ripple Target Use the igxRippleTarget property to attach a ripple effect to a specific element inside a parent element. <div class=\"parent\" igxRipple=\"white\" igxRippleTarget=\".child\" [igxRippleCentered]=\"true\"> ... <button class=\"sample-button child\" igxButton=\"contained\">Read More</button> </div> Notice that no matter whether you click on the parent or the child element, the ripple effect will only appear on the button. Note The child element, which you want to target with the igxRippleTarget property, has to be relatively positioned. Styling First, in order to use the functions exposed by the theme engine, we need to import the index file, where all styling functions and mixins are located, into our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; You can easily create a new theme, that extends the ripple-theme and accepts the parameters, required to customize the ripple as desired. $custom-ripple-theme: ripple-theme( $color: #217346 ); Using CSS variables The next step is to pass the custom ripple theme: @include css-vars($custom-ripple-theme); Using Component Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom ripple theme to the `igx-ripple` mixin @include ripple($custom-ripple-theme); } } Note A color that is set using the igxRiple directive, would take precedence from the one, set within a custom theme. Demo API References IgxRippleDirective IgxRipple Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/select.html": {
    "href": "components/select.html",
    "title": "Angular Select Component - Ignite UI for Angular",
    "keywords": "Angular Select Component Overview Angular Select is a form component used for selecting a single value from a list of predefined values. The Angular Select Component provides functionality identical to the native HTML select element, but offers a lot more customization options. It is based on the IgxDropDownComponent and supports all of its features, including templating, virtualization, and customizing the dropdown list items. Angular Select Example Below is a basic Angular Select example. It has a simple contextual menu that displays a list of several choices opening per click. Getting Started with Ignite UI for Angular Select To get started with the Ignite UI for Angular Select component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSelectModule in the app.module.ts file. // app.module.ts ... import { IgxSelectModule } from 'igniteui-angular'; // import { IgxSelectModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxSelectModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSelectComponent as a standalone dependency, or use the IGX_SELECT_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_SELECT_DIRECTIVES } from 'igniteui-angular'; // import { IGX_SELECT_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-select [(ngModel)]=\"selected\"> <label igxLabel>Simple Select</label> <igx-select-item value=\"Orange\">Orange</igx-select-item> <igx-select-item value=\"Apple\">Apple</igx-select-item> <igx-select-item value=\"Banana\">Banana</igx-select-item> <igx-select-item value=\"Mango\">Mango</igx-select-item> </igx-select> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_SELECT_DIRECTIVES, FormsModule] /* or imports: [IgxSelectComponent, IgxSelectItemComponent, IgxLabelDirective, FormsModule] */ }) export class HomeComponent { public selected: string; } Now that you have the Ignite UI for Angular Select module or directives imported, you can start using the igx-select component. Using the Angular Select Add the igx-select along with a list of items to choose from. We use igx-select-item to display the items that the igx-select contains. <igx-select> <label igxLabel>Simple Select</label> <igx-select-item value=\"Orange\">Orange</igx-select-item> <igx-select-item value=\"Apple\">Apple</igx-select-item> <igx-select-item value=\"Banana\">Banana</igx-select-item> <igx-select-item value=\"Mango\">Mango</igx-select-item> </igx-select> Another way to do it would be to use a collection of items that we want to display using the *ngFor structural directive: public items: string[] = ['Orange', 'Apple', 'Banana', 'Mango']; <igx-select [(ngModel)]=\"selected\"> <label igxLabel>Simple Select</label> <igx-select-item *ngFor=\"let item of items\" [value]=\"item\"> {{item}} </igx-select-item> </igx-select> By default, the Select component will use the innerText of the item element in the input field. In cases with more complex item templates, you can explicitly set the text property to specify what to display in the input field when this item is selected. For example: <igx-select> <igx-select-item *ngFor=\"let item of items\" [value]=\"item.value\" [text]=\"item.text\"> {{item.text}} ( {{item.count}} ) </igx-select-item> </igx-select> To see the text property in action with a bit more sophisticated item templates, check the grouping sample below Select with Groups section. Input Properties The Select component supports the following directives applicable to the Input Group: igxLabel - No need to set the for property, as linking with the Angular Select input is handled automatically via aria-labelledby. igx-prefix/igxPrefix igx-suffix/igxSuffix - Note the built-in toggle button suffix will always be displayed last. igx-hint/igxHint <igx-select [(ngModel)]=\"selected\"> <label igxLabel>Pick a fruit</label> <igx-prefix> <span class=\"bio-prefix\">BIO</span> </igx-prefix> <igx-suffix *ngIf=\"selected\"> <igx-icon (click)=\"clearSelection($event)\">clear</igx-icon> </igx-suffix> <igx-hint>Choose a banana</igx-hint> <igx-select-item *ngFor=\"let item of items\" [value]=\"item\"> {{item}} </igx-select-item> </igx-select> Note If no placeholder is specified for the Select component and there is no selection made, the igxLabel will transition and appear where you would expect the placeholder to be. Group Select Items To help visually separate item groups, the select component supports item grouping by wrapping items in an <igx-select-item-group>. This works best with hierarchical data that can be iterated to declare the components. In the following example, each group has a label and a collection of items: public greengrocery: Array<{ label: string, items: Array<{ type: string, origin: string }> }> = [ { label: 'Fruits', items: [ { type: 'Apple', origin: 'local' }, { type: 'Orange', origin: 'import' }, { type: 'Banana', origin: 'import'} ] }, { label: 'Vegetables', items: [ { type: 'Cucumber', origin: 'local' }, { type: 'Potato', origin: 'import' }, { type: 'Pepper', origin: 'local' } ] } ]; Then in your template file you can iterate over the objects and access their items accordingly: <igx-select #select> <label igxLabel>Select With Groups</label> <igx-select-item-group *ngFor=\"let group of greengrocery\" [label]=\"group.label\"> <igx-select-item *ngFor=\"let item of group.items\" [value]=\"item.type\" [text]=\"item.type\"> {{item.type}} <igx-icon title=\"Local product\" *ngIf=\"item.origin === 'local'; else templateImport\" >local_shipping</igx-icon> <ng-template #templateImport> <igx-icon title=\"Import product\">flight</igx-icon> </ng-template> </igx-select-item> </igx-select-item-group> </igx-select> Header & Footer Currently, there are no default header and footer templates for the Select component. However, you can add a header or a footer template by marking them respectively with igxSelectHeader or igxSelectFooter. As these are custom templates, you should define their styling as well. In this example, there are both header and footer ng-templates defined. In the header there is a basic filtering, implemented via igx-buttongroup. The footer includes static summary of all of the items, based on the delivery method. <igx-select> <label igxLabel>Pick your fruit</label> <igx-select-item *ngFor=\"let fruit of fruits\" [value]=\"fruit.type\" [text]=\"fruit.type\" [ngSwitch]=\"fruit.delivery\"> {{fruit.type}} <igx-icon *ngSwitchCase=\"'flight'\">flight</igx-icon> <igx-icon *ngSwitchCase=\"'train'\">train</igx-icon> <igx-icon *ngSwitchCase=\"'boat'\">directions_boat</igx-icon> </igx-select-item> <ng-template igxSelectHeader> <div class=\"custom-select-header\"> <span class=\"sample-template-heading\">DELIVERY METHOD</span> <igx-buttongroup (click)=\"filter($event.target.title)\"> <button igxButton title=\"flight\"><igx-icon title=\"flight\">flight</igx-icon></button> <button igxButton title=\"train\"><igx-icon title=\"train\">train</igx-icon></button> <button igxButton title=\"boat\"><igx-icon title=\"boat\">directions_boat</igx-icon></button> </igx-buttongroup> </div> </ng-template> <ng-template igxSelectFooter> <div class=\"custom-select-footer\"> <span class=\"sample-template-heading\">TOTAL</span> <div class=\"sample-template-icons\"> <span class=\"sample-template-icons__item\"> <igx-icon title=\"flight\" [class.important-icon]=\"selected === 'flight'\" >flight</igx-icon> {{flightCount}} </span> <span class=\"sample-template-icons__item\"> <igx-icon title=\"train\" [class.important-icon]=\"selected === 'train'\" >train</igx-icon> {{trainCount}} </span> <span class=\"sample-template-icons__item\"> <igx-icon title=\"boat\" [class.important-icon]=\"selected === 'boat'\" >directions_boat </igx-icon> {{boatCount}} </span> </div> </div> </ng-template> </igx-select> Custom Toggle Button in Angular Select You can customize the default toggle button, using the igxSelectToggleIcon directive or setting a TemplateRef to the toggleIconTemplate property. <igx-select #select> ... <ng-template igxSelectToggleIcon let-collapsed> <igx-icon>{{ collapsed ? 'add_circle' : 'add_circle_outline'}}</igx-icon> </ng-template> ... <igx-select> Keyboard Navigation Open the igx-select by clicking on the Space, Enter or ALT + Up/Down Arrow keys, while the select is focused. Close the igx-select using the ALT + Up/Down Arrow combination or any of the Enter, Space, Esc or Tab keys. Using the Up/Down Arrow keys will navigate through the items. Using the Home or End keys will navigate you to the first and last items in the list. You can navigate through list items, starting with a certain character, by pressing the corresponding key. You can navigate to a specific item by rapidly typing the first few characters of the item you wish to go to. Select an item using the Enter or Space keys Note igx-select supports only single selection of items. You can also try out the drag and drop App Builder™ to see how it automates certain processes and reduces the need for excessive hand coding when building your next Angular app. Custom Overlay Settings You can create custom OverlaySettings. To do this you first define your template like so: <igx-select [overlaySettings]=\"customOverlaySettings\"> <igx-select-item *ngFor=\"let item of items\"> {{item}} </igx-select-item> </igx-select> Where the overlaySettings property is bound to your custom settings. Inside your class, you would have something along the lines of: export class MyClass implements OnInit { @ViewChild(IgxSelectComponent) public select: IgxSelectComponent; public items: string[] = ['Orange', 'Apple', 'Banana', 'Mango', 'Tomato']; public customOverlaySettings: OverlaySettings; public ngOnInit(): void { const positionSettings: PositionSettings = { closeAnimation: scaleOutBottom, horizontalDirection: HorizontalAlignment.Right, horizontalStartPoint: HorizontalAlignment.Left, openAnimation: scaleInTop, verticalDirection: VerticalAlignment.Bottom, verticalStartPoint: VerticalAlignment.Bottom }; this.customOverlaySettings = { target: this.select.inputGroup.element.nativeElement, positionStrategy: new ConnectedPositioningStrategy( positionSettings ), scrollStrategy: new AbsoluteScrollStrategy() }; } } You can see that we create a PositionSettings object that is directly passed to our ConnectedPositioningStrategy, it is not required to do it, but since we want to define a custom positioning, we use them to override the strategy's default settings. You can set all settings inside of the ngOnInit hook and this will automatically affect your template upon the component's generation. You can also pass in a customized OverlaySettings object to the IgxSelectComponent's open function, where your template should look like this: <igx-select> <igx-select-item *ngFor=\"let item of items\"> {{item}} </igx-select-item> </igx-select> <button (click)=\"onClick($event)\"></button> And you class has the following: export class MyClass implements OnInit { /* -- */ private otherCustomOverlaySettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy(), scrollStrategy: new AbsoluteScrollStrategy() } onClick(event: MouseEvent): void { this.select.open(this.otherCustomOverlaySettings) } /* -- */ } Note If you pass in your custom settings both as an argument in the open function and in the template, igx-select will use the one provided in the open function. However, if you bind the settings to an internal event, such as opening or opened then igx-select will use the settings that are provided in the template. Styling Every component has its own theme. To get the Select styled, you have style its containing components. In our case, we need to use both the input-group-theme and the drop-down-theme. Take a look at the Input Group and the Drop Down styling sections to get a better understanding of how to style those two components. Note The IgxSelectComponent uses the IgxOverlay to hold and display the igx-select-items list container. To properly scope your styles you might have to use an OverlaySetting.outlet. For more details check the IgxOverlay styling guide. API Reference IgxSelectComponent IgxSelectItemComponent IgxDropDownComponent IgxDropDownItemComponent OverlaySettings ConnectedPositioningStrategy GlobalPositionStrategy AbsoluteScrollStrategy PositionSettings Theming Dependencies IgxDropDown Theme IgxIcon Theme IgxOverlay Theme IgxInputGroup Theme Additional Resources NgModel ViewChild ngForOf Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/simple-combo.html": {
    "href": "components/simple-combo.html",
    "title": "Single Select ComboBox Component",
    "keywords": "Angular Single Select ComboBox Component Overview The Angular Single Select ComboBox component is a modification of ComboBox component that allows single selection. We call it \"simple combo\". Due to high demand for single-selection mode for the original ComboBox component, we created an extension component which offers an editable search input that allows users to choose an option from a predefined list of items and to input custom values. Angular Simple ComboBox Example In this Angular Simple ComboBox example, you can see how users can select the chart's trend line type. In addition, the Simple ComboBox exposes keyboard navigation and custom styling capabilities. Angular Simple ComboBox Features The simple combobox control exposes the following features: - Data Binding - local data and remote data - Value Binding - Filtering - Grouping - Custom Values - Templates - Integration with Template Driven Forms and Reactive Forms Getting Started with Ignite UI for Angular Simple ComboBox To get started with the Ignite UI for Angular Simple ComboBox component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSimpleComboModule in your app.module.ts file. import { IgxSimpleComboModule } from 'igniteui-angular'; // import { IgxSimpleComboModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxSimpleComboModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSimpleComboComponent as a standalone dependency, or use the IGX_SIMPLE_COMBO_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_SIMPLE_COMBO_DIRECTIVES } from 'igniteui-angular'; // import { IGX_SIMPLE_COMBO_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-simple-combo></igx-simple-combo>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_SIMPLE_COMBO_DIRECTIVES] /* or imports: [IgxSimpleComboComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Simple ComboBox module or directives imported, you can start using the igx-simple-combo component. Using the Angular Simple ComboBox Just like the regular combobox, you can bind the igx-simple-combo to data. export class MySimpleComboComponent implements OnInit { public cities: City[]; public ngOnInit() { this.cities = getCitiesByPopulation(10000000); } } <igx-simple-combo [data]=\"cities\"></igx-simple-combo> Our simple combobox is now bound to the array of cities. Data value and display properties Since the simple combobox is bound to an array of complex data (i.e. objects), we need to specify a property that the control will use to handle the selected items. The control exposes two @Input properties - valueKey and displayKey: valueKey - Optional, recommended for object arrays - Specifies which property of the data entries will be stored for the simple combobox's selection. If valueKey is omitted, the simple combobox value will use references to the data entries (i.e. the selection will be an array of entries from igxSimpleCombo.data). displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the simple combobox will use the specified valueKey (if any). In our case, we want the simple combobox to display the name of each city and its value to store the id of each city. Therefore, we are binding these properties as values to the simple combobox's displayKey and valueKey, respectively: <igx-simple-combo [data]=\"cities\" [displayKey]=\"'name'\" [valueKey]=\"'id'\"></igx-simple-combo> Note When the data source is comprised of a simple type (e.g. string[], number[]), do not specify a valueKey and displayKey. Two-Way Binding The simple combobox component fully supports two-way data-binding with [(ngModel)] as well as usage in template driven and reactive forms. The simple combobox selection can be accessed either through two-way binding or through the selection API. We can pass in an item of the same type as the ones in the simple combobox's selection (based on valueKey) and any time one changes, the other is updated accordingly. In the following example, the first city in the provided data will initially be selected. Any further changes in the simple combobox's selection will reflect on the selectedCities. <igx-simple-combo [data]=\"cities\" [(ngModel)]=\"selectedCity\" [displayKey]=\"'name'\" [valueKey]=\"'id'\"></igx-simple-combo> export class MySimpleComboComponent implements OnInit { public cities: City[]; public selectedCity: number; public ngOnInit(): void { this.cities = getCitiesByPopulation(10000000); this.selectedCity = this.cities[0].id; } } Two-way binding can also be achieved without a specified valueKey. For example, if valueKey is omitted, the bound model will look like this: export class MySimpleComboComponent { public cities: City[] = [ { name: 'Sofia', id: '1' }, { name: 'London', id: '2' }, ...]; public selectedCity: City = this.cities[0]; } Selection API The simple combobox component exposes API that allows getting and manipulating the current selection state of the control. One way to get its selection is via the selection property. It returns a value which corresponds to the selected item, depending on the specified valueKey (if any). In our example, selection will return the selected city's id: export class MySimpleComboComponent { ... public selection: string = this.simpleCombo.selection; } Using the selection API, you can also change the simple combobox's selected item without user interaction with the control - via a button click, as a response to an Observable changing, etc. For example, we can implement a button that selects a city, using the select method: <igx-simple-combo [data]=\"cities\" [displayKey]=\"'name'\" [valueKey]=\"'id'\"></igx-simple-combo> <button igxButton (click)=\"selectFavorite()\">Select Favorite</button> When the button is clicked, London will be added to the simple combobox's selection: export class MySimpleComboComponent { @ViewChild(IgxSimpleComboComponent, { read: IgxSimpleComboComponent, static: true }) public simpleCombo: IgxSimpleComboComponent; ... selectFavorites(): void { this.simpleCombo.select('2'); } } The simple combobox also fires an event every time its selection changes - selectionChanging. The emitted event arguments, ISimpleComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the displayed item. The event can also be cancelled, preventing the selection from taking place. Binding to the event can be done through the proper @Output property on the igx-simple-combo tag: <igx-simple-combo [data]=\"cities\" [displayKey]=\"'name'\" [valueKey]=\"'id'\" (selectionChanging)=\"handleCityChange($event)\"> </igx-simple-combo> Keyboard Navigation When the simple combobox is closed and focused: ArrowDown or Alt + ArrowDown will open the simple combobox's dropdown. Note Any other key stroke will be handled by the input. When the simple combobox is opened and an item in the list is focused: ArrowDown will move to the next list item. If the active item is the last one in the list and custom values are enabled, the focus will be moved to the Add item button. ArrowUp will move to the previous list item. If the active item is the first one in the list, the focus will be moved back to the search input while also selecting all of the text in the input. End will move to the last list item. Home will move to the first list item. Space will select/deselect the active list item. Enter will select/deselect the active list item and will close the list. Esc will close the list. When the simple combobox is opened and allow custom values are enabled, and add item button is focused: Enter will add a new item with valueKey and displayKey equal to the text in the search input and will select the new item. ArrowUp will move the focus back to the last list item or if the list is empty, will move the focus to the input. Cascading Scenario The following sample demonstrates a scenario where the igx-simple-combo is used: Check out our Angular Grid with Cascading Combos Sample. Template Configuration The API of the simple combobox is used to get the selected item from one component and load the data source for the next one, as well as clear the selection and data source when needed. <igx-simple-combo #country [data]=\"countriesData\" (selectionChanging)=\"countryChanging($event)\" placeholder=\"Choose Country...\" [(ngModel)]=\"selectedCountry\" [displayKey]=\"'name'\"> </igx-simple-combo> <igx-simple-combo #region [data]=\"regionData\" (selectionChanging)=\"regionChanging($event)\" placeholder=\"Choose Region...\" [(ngModel)]=\"selectedRegion\" [displayKey]=\"'name'\" [disabled]=\"regionData.length === 0\"> </igx-simple-combo> <igx-simple-combo #city [data]=\"citiesData\" placeholder=\"Choose City...\" [(ngModel)]=\"selectedCity\" [displayKey]=\"'name'\" [disabled]=\"citiesData.length === 0\"> </igx-simple-combo> Component Definition export class SimpleComboCascadingComponent implements OnInit { public selectedCountry: Country; public selectedRegion: Region; public selectedCity: City; public countriesData: Country[]; public regionData: Region[] = []; public citiesData: City[] = []; public ngOnInit(): void { this.countriesData = getCountries(['United States', 'Japan', 'United Kingdom']); } public countryChanging(e: ISimpleComboSelectionChangingEventArgs) { this.selectedCountry = e.newSelection as Country; this.regionData = getCitiesByCountry([this.selectedCountry?.name]) .map(c => ({name: c.region, country: c.country})) .filter((v, i, a) => a.findIndex(r => r.name === v.name) === i); this.selectedRegion = null; this.selectedCity = null; this.citiesData = []; } public regionChanging(e: ISimpleComboSelectionChangingEventArgs) { this.selectedRegion = e.newSelection as Region; this.citiesData = getCitiesByCountry([this.selectedCountry?.name]) .filter(c => c.region === this.selectedRegion?.name); this.selectedCity = null; } } Angular Simple ComboBox Remote Binding The Ignite UI for Angular Simple ComboBox Component exposes an API that allows binding a combobox to a remote service and retrieving data on demand. Demo The sample below demonstrates remote binding using the dataPreLoad property to load new chunk of remote data and following the steps described in ComboBox Remote Binding: Angular Simple ComboBox Styling Using the Ignite UI for Angular Theming, we can greatly alter the simple combobox appearance. First, in order for us to use the functions exposed by the theme engine, we need to import the index file in our style file: @use 'igniteui-angular/theming' as *; Following the simplest approach, we create a new theme that extends the combo-theme and accepts the $empty-list-background parameter: $custom-simple-combo-theme: combo-theme( $empty-list-background: #1a5214 ); The IgxSimpleComboComponent uses the IgxDropDownComponent internally as an item container. It also includes the IgxInputGroup component. Creating new themes, that extend these components' themes, and scoping them under the respective classes will let's you change the simple combobox styles: $custom-drop-down-theme: drop-down-theme( $background-color: #d9f5d6, $header-text-color: #1a5214, $item-text-color: #1a5214, $focused-item-background: #72da67, $focused-item-text-color: #1a5214, $hover-item-background: #a0e698, $hover-item-text-color: #1a5214, $selected-item-background: #a0e698, $selected-item-text-color: #1a5214, $selected-hover-item-background: #72da67, $selected-hover-item-text-color: #1a5214, $selected-focus-item-background: #72da67, $selected-focus-item-text-color: #1a5214, ); The last step is to include the component's theme. :host ::ng-deep { @include css-vars($custom-combo-theme); @include css-vars($custom-drop-down-theme); } Note The IgxSimpleCombo component uses the IgxOverlay service to hold and display the simple combobox items list container. To properly scope your styles you might have to use an OverlaySetting.outlet. For more details check the IgxOverlay Styling Guide. Note The default type of the IgxSimpleCombo is box unlike the IgxSelect where it is line. Demo Known Issues The simple combobox does not have input for sizing its height. In the future, the IgxInputGroup component will expose an option that allows custom sizing, and then the IgxSimpleCombo will use the same functionality for proper styling and better consistency. When the simple combobox is bound to an array of primitive data which contains undefined (i.e. [ undefined, ...]), undefined is not displayed in the dropdown. When it is bound to an array of complex data (i.e. objects) and the value used for valueKey is undefined, the item will be displayed in the dropdown, but cannot be selected. When the simple combobox is bound via ngModel and is marked as required, null, undefined and '' values cannot be selected. When the simple combobox is bound to a remote service and there is a predefined selection, its input will remain blank until the requested data is loaded. Note The simple combobox uses igxForOf directive internally hence all igxForOf limitations are valid for the simple combobox. For more details see igxForOf Known Issues section. API Summary IgxSimpleComboComponent IgxComboComponent Styles Additional components and/or directives with relative APIs that were used: IgxDropDownComponent IgxInputGroupComponent Theming Dependencies IgxDropDown Theme IgxIcon Theme IgxOverlay Theme Additional Resources ComboBox Features ComboBox Remote Binding ComboBox Templates Template Driven Forms Integration Reactive Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/slider/slider.html": {
    "href": "components/slider/slider.html",
    "title": "Angular Slider | Ignite UI for Angular | Infragistics",
    "keywords": "Angular Slider Component Overview The Ignite UI for Angular Slider is a form component which allows selection in a given range by moving a thumb along a track. The track can be defined as continuous or stepped and the slider can be configured so users can choose between single value and range (lower and upper value) slider types. Angular Slider Example Getting Started with Ignite UI for Angular Slider To get started with the Ignite UI for Angular Slider component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSliderModule in your app.module.ts file. Warning This component requires HammerModule to be imported in the root module of the application in order for user interactions to work as expected.. // app.module.ts import { HammerModule } from '@angular/platform-browser'; import { IgxSliderModule } from 'igniteui-angular'; // import { IgxSliderModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxSliderModule, HammerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSliderComponent as a standalone dependency, or use the IGX_SLIDER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_SLIDER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_SLIDER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-slider [minValue]=\"0\" [maxValue]=\"100\" [step]=\"10\" [(ngModel)]=\"task.completion\"></igx-slider>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_SLIDER_DIRECTIVES, FormsModule] /* or imports: [IgxSliderComponent, FormsModule] */ }) export class HomeComponent { public task: Task; } When using standalone components, HammerModule should be imported in the app.config file. //app.config.ts import { ApplicationConfig, importProvidersFrom } from '@angular/core'; import { provideRouter } from '@angular/router'; import { appRoutes } from './app.routes'; import { HammerModule } from '@angular/platform-browser'; export const appConfig: ApplicationConfig = { providers: [ importProvidersFrom(HammerModule), provideRouter(appRoutes) ], }; Now that you have the Ignite UI for Angular Slider module or directives imported, you can start using the igx-slider component. Using the Angular Slider Discrete Slider By default, the Slider Component is set to discrete type. A discrete slider provides a visualization of the current value with a numeric label (bubble). The bubble can be shown upon hovering on the slider thumb. You can also use the slider with predefined steps to track only meaningful values for the user. In the following example, we define a discrete slider that displays values from 0% to 100% and the step is set to 10% per increment/decrement. We also bind the slider value to a property in our component called \"completion\", using Angular ngModel, to allow two way binding with an input component. <!--sample.component.html--> <igx-slider [minValue]=\"0\" [maxValue]=\"100\" [step]=\"10\" [(ngModel)]=\"task.completion\"></igx-slider> <igx-input-group type=\"border\"> <input igxInput id=\"percentInput\" type=\"number\" [(ngModel)]=\"task.completion\" /> <label igxLabel for=\"percentInput\">Task Completion</label> <igx-suffix>%</igx-suffix> </igx-input-group> // sample.component.ts import { Component, ViewChild } from '@angular/core'; import { IgxInputDirective, IgxSliderComponent } from 'igniteui-angular'; // import { IgxInputDirective, IgxSliderComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-sample', styleUrls: ['./sample.component.scss'], templateUrl: './sample.component.html' }) export class SampleComponent { public task = { completion: 10 }; constructor() { } } We should now see two-way data binding between our two components. Continuous Slider First, specify the slider type by setting the continuous input to true. Next, define the minimum and maximum values using minValue and maxValue. Note Continuous slider doesn't have step indicators over the track and visible thumb labels during interaction. <!--sample.component.html--> <igx-slider id=\"slider\" [minValue]=\"0\" [maxValue]=\"100\" [continuous]=true [(ngModel)]=\"volume\"> </igx-slider> <label igxLabel for=\"slider\">Volume: {{volume}}</label> Lets also bind the slider value to a property in our component called \"volume\". // sample.component.ts // Set an initial value public volume = 20; If the sample is configured properly, dragging the slider thumb should update the label below and the slider value should be limited between the specified minimum and maximum values: Range Slider First, set the slider type to RANGE. Next, we bind the slider value to an object with properties for lower and upper values. <!--sample.component.html--> <igx-slider [type]=\"sliderType.RANGE\" [minValue]=\"0\" [maxValue]=\"1000\" [(lowerValue)]=\"priceRange.lower\" [(upperValue)]=\"priceRange.upper\"> </igx-slider> <igx-input-group type=\"border\"> <label igxLabel for=\"lowerRange\">From</label> <igx-prefix>$</igx-prefix> <input igxInput id=\"lowerRange\" type=\"number\" [(ngModel)]=\"priceRange.lower\" /> </igx-input-group> <igx-input-group type=\"border\"> <label igxLabel for=\"upperRange\">To</label> <igx-prefix>$</igx-prefix> <input igxInput id=\"upperRange\" type=\"number\" [(ngModel)]=\"priceRange.upper\" /> </igx-input-group> // sample.component.ts import { Component } from '@angular/core'; import { IgxSliderType } from 'igniteui-angular'; // import { IgxSliderType } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-sample', styleUrls: ['./sample.component.scss'], templateUrl: './sample.component.html' }) export class SampleComponent { public sliderType = IgxSliderType; public priceRange = { lower: 200, upper: 800 }; constructor() { } } Note When using a slider of type RANGE, binding to ngModel will work only in the direction of updating the model from the slider. In order to use two-way binding for both values, you can take advantage of the lowerValue and upperValue bindings. In some cases, values near to the minimum and maximum are not appropriate. You can further provide a useful range to limit the user choice along with setting minValue and maxValue. This can be done by setting lowerBound and upperBound. Now, the user will not be able to move the thumb in the range of 0 to 100 and in the range of 900 to 1000. <!--sample.component.html--> <igx-slider [type]=\"sliderType.RANGE\" [minValue]=\"0\" [maxValue]=\"1000\" [(lowerValue)]=\"priceRange.lower\" [(upperValue)]=\"priceRange.upper\" [lowerBound]=\"100\" [upperBound]=\"900\"> </igx-slider> Labels mode We've seen only numbers in the thumbs so far, although there is another approach that you could use in order to present information - by using an array of primitive values. Note Your array of primitive values should contains at least two values, otherwise labelsView won't be enabled. Once we have the definition that corresponds to the preceding rule, we are ready to give it to the labels input property, which would handle our data by spreading it equally over the track. Now, label values represent every primitive value we've defined in our collection. They could be accessed at any time through the API by requesting either lowerLabel or upperLabel. Note Please take into account the fact that when labelsView is enabled, your control over the maxValue, minValue and step inputs will be taken. Another important factor is the way that the slider handles the update process when labelsView is enabled. It simply operates with the index(es) of the colleciton, which respectively means that the value, lowerBound and upperBound properties control the track by following/setting them (index(es)). <!--sample.component.html--> <igx-slider #slider3 [type]=\"sliderType\" [labels]=\"labels\" [lowerBound]=\"1\" [upperBound]=\"5\"> <ng-template igxSliderThumbFrom let-value let-labels=\"labels\"> <span class=\"ellipsis\">{{ labels[value.lower] }}</span> </ng-template> <ng-template igxSliderThumbTo let-value let-labels=\"labels\"> <span class=\"ellipsis\">{{ labels[value.upper] }}</span> </ng-template> </igx-slider> // sample.component.ts public sliderType: SliderType = SliderType.RANGE; public labels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']; As we see from the sample above, setting boundaries is still a valid operation. Addressing lowerBound and upperBound, limits the range you can slide through. Lables templating During the showcase above, we've intentionally shown how we can provide our custom label template, by using both igxSliderThumbFrom and igxSliderThumbTo directives. Intuitively we can assume that igxSliderThumbFrom corresponds to the lowerLabel and igxSliderThumbTo to the upperLabel. The context here gives us implicitly a reference to the value input property and explicitly a reference to the labels input if labelsView is enabled. <ng-template igxSliderThumbFrom let-value let-labels=\"labels\"> <span class=\"ellipsis\">{{ labels[value.lower] }}</span> </ng-template> <ng-template igxSliderThumbTo let-value let-labels=\"labels\"> <span class=\"ellipsis\">{{ labels[value.upper] }}</span> </ng-template> Slider Tick Marks & labels Slider tick marks, provide a new and more appealing way for data visualization, like a particular timeframe, days of the week and more. With this new functionality, the users are not obliged to interact with the Angular Slider in order to see what data range is being represented. It is extremely flexible, with regards to the control over positioning and orientation of the tick marks and tick labels. The ticks can be turned on/off, as well as can be toggled between primary, secondary or both. In addition, this feature provides a way to turn on/of primary, secondary tick labels or both. Tick labels can change their rotation form horizontal to vertical (top to bottom (90) or bottom to top (-90)). Enable ticks We can enable the ticks of the slider by setting the showTicks to true. Use primaryTicks to set the number of primary ticks. Use SecondaryTicks to set the number of secondary ticks. <!--sample.component.html--> <igx-slider id=\"slider\" [maxValue]=\"100\" [step]=\"10\" [showTicks]=\"true\" [primaryTicks]=\"3\" [secondaryTicks]=\"4\"> </igx-slider> // sample.component.ts // Change slider type initial value public type = SliderType.RANGE; Labels orientation and visibility. In the following sample we disable all secondary labels by setting secondaryTickLabels to false. <igx-slider [step]=\"10\" [type]=\"type\" [maxValue]=\"100\" [continuous]=\"true\" [showTicks]=\"true\" [primaryTicks]=\"3\" [secondaryTicks]=\"4\" [secondaryTickLabels]=\"false\" [tickLabelsOrientation]=\"labelsOrientation\"> </igx-slider> We also rotate all viable labels by setting the TickLabelsOrientation to BottomToTop ```typescript ... { public type = SliderType.RANGE: public labelsOrientation = TickLabelsOrientation.BottomToTop; } ... Ticks position Let’s move on and see how to change the position of the ticks. <div class=\"slider-container\"> <igx-slider [maxValue]=\"20\" [showTicks]=\"true\" [secondaryTicks]=\"21\" [primaryTickLabels]=\"false\" [ticksOrientation]=\"ticksOrientation\"> </igx-slider> </div> The position change has come from the ticksOrientation input, which is changed from Bottom(default) to Mirror. This mirrors the visualization of the ticks and displays them above and below the slider. // The available options are: Top, Bottom and Mirror public ticksOrientation = TicksOrientation.Mirror; Note When the ticksOrientaion is set to Top or Mirror and there are visible tick labels the thumb label is hidden intentionally. This prevents a bad user experience and overlapping between the two labels. Slider ticks with labels view This example show how the tick labels and the thumb label works together. <igx-slider [labels]=\"labels\" [showTicks]=\"true\" [secondaryTicks]=\"3\" ></igx-slider> public type: SliderType = SliderType.RANGE; public labels = [\"04:00\", \"08:00\", \"12:00\", \"16:00\", \"20:00\", \"00:00\"]; Here, the primaryTicks input has not been set, because it won’t be reflected in any way. The length of the collection takes precedence over it. This does not mean that secondaryTicks cannot be set. All secondary ticks will be empty (without any labels). Template labels Lastly, we will see how we can provide a custom template for the tick labels and what the template context provides. <igx-slider [showTicks]=\"true\" [primaryTicks]=\"3\" [secondaryTicks]=\"3\"> <ng-template igxSliderTickLabel let-value let-primary=\"isPrimary\" let-idx=\"index\"> {{ tickLabel(value, primary, idx) }} </ng-template> </igx-slider> Applying IgxTickLabelTemplateDirective to the ng-template assigns the template over all tick labels. Note The context executes per each tick. Which means that it provides a reference to: each corresponding tick value If that tick is primary. tick index. And the labels collection if we have such one. public tickLabel(value, primary, index) { if (primary) { return Math.round(value); } return value; } In the tickLabel callback above, we are rounding the value of every primary tick. Styling Lets change the default styles of our slider component by creating a new theme for it. Demo This is the final result from applying our new theme. Creating a component theme First we need to create a custom palette Now let's create our component theme and pass that custom palette to it. // In app-slider-styling.component.scss // Create slider theme. $custom-slider-theme: slider-theme( $track-color: #ff7400, $track-hover-color: #ff7400, $thumb-color: #ff7400, $base-track-color: #ddd, $base-track-hover-color: #ccc, $tick-label-color: #b246c2, $tick-label-color-tall: #ff7400, $tick-color: #b246c2, $tick-color-tall: #ff7400, ); Applying the component theme Now to apply the component theme all that's left is to include css-vars mixin and pass the $custom-slider-theme map. // In app-slider-styling.component.scss // Pass our custom-slider-theme to `css-vars` mixin. // The `:host` here makes sure that all the theming will affect only this slider component. :host { @include css-vars($custom-slider-theme); } API References IgxSliderComponent IgxSliderComponent Styles SliderType IRangeSliderValue TicksOrientation TickLabelsOrientation Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/slider/slider-ticks.html": {
    "href": "components/slider/slider-ticks.html",
    "title": "Tick Marks | Thumb Track | Ignite UI for Angular | Infragistics",
    "keywords": "Usage API References IgxSliderComponent IgxSliderComponent Styles IRangeSliderValue SliderType Additional Resources Slider overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/snackbar.html": {
    "href": "components/snackbar.html",
    "title": "Angular Snackbar Component",
    "keywords": "Angular Snackbar Component Overview The Ignite UI for Angular Snackbar component provides feedback about an operation with a single-line message, which can include an action. The Snackbar message appears above all other elements and is positioned at the bottom center of the screen. Angular Snackbar Example Getting Started with Ignite UI for Angular Snackbar To get started with the Ignite UI for Angular Snackbar component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSnackbarModule in your app.module.ts file. // app.module.ts ... import { IgxSnackbarModule } from 'igniteui-angular'; // import { IgxSnackbarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxSnackbarModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSnackbarComponent as a standalone dependency. // home.component.ts import { IgxSnackbarComponent, IgxButtonDirective } from 'igniteui-angular'; // import { IgxSnackbarComponent, IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button igxButton=\"contained\" (click)=\"snackbar.open()\">Delete Message</button> <div> <igx-snackbar #snackbar>Message deleted</igx-snackbar> </div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxSnackbarComponent, IgxButtonDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Snackbar module or component imported, you can start using the igx-snackbar component. Using the Angular Snackbar Show Snackbar In order to display the snackbar component, use its open() method and call it on a button click. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"snackbar.open()\">Delete Message</button> <div> <igx-snackbar #snackbar>Message deleted</igx-snackbar> </div> If the sample is configured properly, you should see the demo sample. A snackbar appears displaying a text message when the button is clicked. As you can see in the code snippet above, one way to set the massage displayed in the snackbar is to use the content projection. But if you need to switch the value programmatically based on some custom logic you can just pass the value as a parameter to the open() method. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"snackbar.open('Message deleted')\">Delete Message</button> <button igxButton=\"contained\" (click)=\"snackbar.open('Message deletion was not successful. Please try again')\">Delete Message</button> <div> <igx-snackbar #snackbar></igx-snackbar> </div> Hide/Auto Hide Once opened, the snackbar disappears after a period specified by the displayTime input which is set initially to 4000 milliseconds. This behavior is enabled by default but you can change it by setting autoHide to false. In this way, the snackbar will remain visible. Using the snackbar close() method, you can close the component in the code. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"snackbar.open()\">Send message</button> <div> <igx-snackbar #snackbar [autoHide]=\"false\" actionText=\"CLOSE\" (clicked)=\"close(snackbar)\">Message sent</igx-snackbar> </div> // sample.component.ts public close(element) { element.close(); } If the sample is configured properly, the first snackbar appears when the button is clicked, showing both the message and action button. The auto-hide feature is disabled and the snackbar disappears on 'CLOSE' button click. Another snackbar passes a different message through the open() method and hides it when the display time expires. The third component passes a message as a param to the open() method and adds an icon using content projection. Display Time Use displayTime and set it to an interval in milliseconds to configure how long the snackbar component is visible. By default, as we said, it's initially set to 4000 miliseconds. Customize Snackbar We can also customize the content of the Snackbar to display more complex elements than a message and a button. If we want to show the snackbar while loading a file, for example, a loading animation could be added to its content. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"snackbar.open()\">Load file</button> <div> <igx-snackbar #snackbar displayTime=\"5000\">File loading <svg id=\"dots\" height=\"20px\"> <g id=\"dots\" fill=\"#FFFFFF\"> <circle id=\"dot1\" cx=\"5\" cy=\"18\" r=\"2\"></circle> <circle id=\"dot2\" cx=\"15\" cy=\"18\" r=\"2\"></circle> <circle id=\"dot3\" cx=\"25\" cy=\"18\" r=\"2\"></circle> </g> </svg> </igx-snackbar> </div> //sample.component.scss #dots #dot1 { animation: load 1s infinite; } #dots #dot2 { animation: load 1s infinite; animation-delay: 0.2s; } #dots #dot3 { animation: load 1s infinite; animation-delay: 0.4s; } @keyframes load { 0% { opacity: 0; } 50% { opacity: 1; } 100% { opacity: 0; } } As a result, a message and three loading dots appear in the snackbar. Snackbar in list Having all main snackbar features covered, we can integrate this component in a more interesting scenario. We can use the snackbar to provide a notification and the ability to revert actions. Let’s create a list with contacts that can be deleted. When an item is deleted, a snackbar is displayed containing a message and a button to undo the action. <!--sample.component.html--> <igx-list> <igx-list-item [isHeader]=\"true\">Contacts</igx-list-item> <igx-list-item igxRipple=\"pink\" igxRippleTarget=\".igx-list__item\" *ngFor=\"let item of navItems\"> <div class=\"item-container\"> <div class=\"contact\"> <igx-avatar [src]=\"item.avatar\" shape=\"circle\"></igx-avatar> <div class=\"contact__info\"> <span class=\"name\">{{item.text}}</span> </div> </div> <span igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"delete(item)\"> <igx-icon [style.color]=\"'#ff5252'\">delete</igx-icon> </span> </div> </igx-list-item> <igx-snackbar actionText=\"Undo\" (clicked)=\"restore()\">Contact deleted</igx-snackbar> </igx-list> //sample.component.ts import { Component, OnInit, ViewChild } from '@angular/core'; import { IgxSnackbarComponent } from 'igniteui-angular'; // import { IgxSnackbarComponent } from '@infragistics/igniteui-angular'; for licensed package ... @ViewChild(IgxSnackbarComponent) public snackbar: IgxSnackbarComponent; public navItems: any[]; public deletedItems = []; constructor() { } public ngOnInit() { this.navItems = [ { avatar: 'assets/images/avatar/2.jpg', text: 'Richard Mahoney'}, { avatar: 'assets/images/avatar/4.jpg', text: 'Lisa Landers' }, { avatar: 'assets/images/avatar/14.jpg', text: 'Marianne Taylor' }, { avatar: 'assets/images/avatar/17.jpg', text: 'Ward Riley' } ]; } public delete(item) { this.deletedItems.push([item, this.navItems.indexOf(item)]); this.navItems.splice(this.navItems.indexOf(item), 1); this.snackbar.open(); } public restore() { const [item, index] = this.deletedItems.pop(); this.navItems.splice(index, 0, item); this.snackbar.close(); } Overlay Settings The IgxSnackbarComponent uses Overlay Settings to control the position of its container. The default settings can be changed by defining Custom OverlaySettings and passing them to the snackbar open() method: public customSettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy( { horizontalDirection: HorizontalAlignment.Left, verticalDirection: VerticalAlignment.Top }), modal: true, closeOnOutsideClick: true, }; snackbar.open(customSettings); Users can also provide a specific outlet where the snackbar will be placed in the DOM when it is visible: <igx-snackbar [outlet]=\"igxBodyOverlayOutlet\"></igx-snackbar> <div #igxBodyOverlayOutlet igxOverlayOutlet></div> Styling To get started with styling the snackbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the snackbar-theme and accepts the $text-color, $background, $button-color and the $border-radius parameters. $dark-snackbar: snackbar-theme( $text-color: #FFCD0F, $background: #292826, $button-color: #FFCD0F, $border-radius: 12px ); Including themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include snackbar($igx-snackbar-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include snackbar($igx-snackbar-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($igx-snackbar-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($igx-snackbar-theme); } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $dark-snackbar: snackbar-theme( $text-color: color($dark-palette, \"secondary\", 400), $background: color($dark-palette, \"primary\", 400), $button-color: color($dark-palette, \"secondary\", 400), $border-radius: 12px ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-snackbar schema: // Extending the dark snackbar schema $dark-snackbar-schema: extend($_dark-snackbar, ( text-color:( color: (\"secondary\", 400) ), background: ( color: (\"primary\", 400) ), button-color: ( color: (\"secondary\", 400) ), border-radius: 12px ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-snackbar: $dark-snackbar-schema )); // Defining snackbar theme with the global dark schema $dark-snackbar: snackbar-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References In this article we learned how to use and configure the IgxSnackbarComponent. For more details in regards its API, take a look at the links below: IgxSnackbarComponent Styles: IgxSnackbarComponent Styles Additional Resources Our community is active and always welcoming to new ideas. * [Ignite UI for Angular **Forums**](https://www.infragistics.com/community/forums/f/ignite-ui-for-angular) * [Ignite UI for Angular **GitHub**](https://github.com/IgniteUI/igniteui-angular) View page on GitHub"
  },
  "components/sparkline.html": {
    "href": "components/sparkline.html",
    "title": "Angular Sparkline | Data Visualization Tools | Infragistics",
    "keywords": "Angular Sparkline Overview The Ignite UI for Angular sparkline component is a lightweight charting control. It is intended for rendering within a small scale layout such as within a grid cell, but can also be rendered alone. The sparkline control has several visual elements and corresponding features that can be configured and customized such as the chart type, markers, ranges, trendlines, unknown value plotting, and tooltips. Angular Sparkline Overview Example View on StackBlitz Dependencies In order to use the Ignite UI for Angular sparkline component, the following packages need to be installed: npm install --save igniteui-angular-core npm install --save igniteui-angular-charts The Angular sparkline component requires the import of the following modules: // app.module.ts import { IgxSparklineModule } from 'igniteui-angular-charts'; import { IgxSparklineCoreModule } from 'igniteui-angular-charts'; import { SparklineDisplayType } from 'igniteui-angular-charts'; @NgModule({ imports: [ IgxSparklineCoreModule, IgxSparklineModule ] }) export class AppModule {} Sparkline Types The Ignite UI for Angular sparkline component supports the following types of sparklines: Area Column Line WinLoss The type is defined by setting the displayType property. If the displayType property is not specified, then by default, the Line type is displayed. The WinLoss sparkline type is a column chart type, in which the value of each column is equal to either the positive maximum (for positive values) or the negative minimum (for negative values) of the bound data set, often denoting a Win or a Loss, or similar opposing concepts. For the WinLoss sparkline to display properly, the data set should have both positive and negative values. If the WinLoss sparkline is bound to the same data as the other types such as the Line type, which can be bound to a collection of numeric values, then the sparkline component will select two values from the collection - the highest and the lowest - and will render the sparkline based upon those values. <igx-sparkline height=\"200px\" width=\"400px\" [dataSource]=\"data\" valueMemberPath=\"Value\" displayType=\"Area\" /> View on StackBlitz Markers The Ignite UI for Angular sparkline component allows you to show markers as circular colored icons on your series to indicate the individual data points based on X/Y coordinates. Markers can be set on sparklines of display types Line, Area, and Column. The WinLoss type of sparkline does not currently accept markers. By default, markers are not displayed. Markers in the sparkline can be placed in any combination of the following locations: All: Display markers for all data points in the sparkline. Low: Display markers on the data point of the lowest value. If there are multiple points at the lowest value, it will show on each point with that value. High: Display markers on the data point of the highest value. If there are multiple points at the highest value, it will show on each point with that value. First: Display a marker on the first data point in the sparkline. Last: Display a marker on the last data point in the sparkline. Negative: Display markers on the negative data points plotted in the sparkline. All of the markers mentioned above can be customized using the related marker types' property in aspects of color, visibility, and size. For example, the Low markers above will have properties lowMarkerBrush, lowMarkerVisibility, and lowMarkerSize. <igx-sparkline highMarkerVisibility=\"Visible\" lowMarkerVisibility=\"Visible\" firstMarkerVisibility=\"Visible\" lastMarkerVisibility=\"Visible\" negativeMarkerVisibility=\"Visible\" markerVisibility=\"Collapsed\" markerSize=\"10\" firstMarkerSize=\"10\" lastMarkerSize=\"10\" lowMarkerSize=\"10\" highMarkerSize=\"10\" negativeMarkerSize=\"10\"/> View on StackBlitz Normal Range The normal range feature of the Ignite UI for Angular sparkline component is a horizontal stripe representing some pre-defined meaningful range when the data is being visualized. The normal range can be set as a shaded area outlined with the desired color. The normal range can be wider than the maximum data point or beyond, and it can also be as thin as the sparkline's Line display type, to serve as a threshold indicator, for instance. The width of the normal range is determined by the following three properties, which serve as the minimum settings required for displaying the normal range: normalRangeVisibility: Whether or not the normal range is visible. normalRangeMaximum: The bottom border of the range. normalRangeMinimum: The top border of the range. By default, the normal range is not displayed. When enabled, the normal range shows up with a light gray color appearance, which can also be configured using the normalRangeFill property. You can also configure whether or not to show the normal range in front of or behind the plotted series in your sparkline component by setting the displayNormalRangeInFront property. <igx-sparkline normalRangeVisibility=\"Visible\" normalRangeMinimum=\"1\" normalRangeMaximum=\"4\" normalRangeFill=\"rgba(88, 88, 88, 0.4)\" displayNormalRangeInFront=\"true\" /> View on StackBlitz Trendlines The Ignite UI for Angular sparkline component has support for a range of trendlines that display as another layer on top of the actual sparkline layer. To display a sparkline, you can use the trendLineType property. The trendlines are calculated according to the algorithm specified by the trendLineType property using the values of the data the the chart is bound to. Trendlines can only be displayed one at a time and by default, the trendline is not displayed. A list of supported trendlines can be found below: None CubicFit CumulativeAverage ExponentialAverage ExponentialFit LinearFit LogarithmicFit ModifiedAverage PowerLawFit QuadraticFit QuarticFit QuinticFit SimpleAverage WeightedAverage The following code example shows how to enable a trendline in the Ignite UI for Angular sparkline component: <igx-sparkline trendLineThickness=\"3\" trendLinePeriod=\"5\" trendLineType=\"ExponentialFit\" trendLineBrush=\"gray\" /> View on StackBlitz Unknown Value Interpolation The Ignite UI for Angular sparkline component can detect unknown values and render the space for unknown values through a specified interpolation algorithm. If your data contains null values and you do not use this feature, meaning no interpolation is specified, the unknown value will not be plotted. In order to plot the unknown values, you can set the unknownValuePlotting property of the sparkline component. <igx-sparkline unknownValuePlotting=\"LinearInterpolate\" /> View on StackBlitz Sparkline in Data Grid You can embed the Ignite UI for Angular sparkline component in a template column of data grid or other components that support templates. The following code example shows how to do this: <igx-grid #grid1 [data]=\"data | async\" [height]=\"'500px'\" width=\"100%\" [autoGenerate]='false' > <!-- ... --> <igx-column [field]=\"'OrderHistory'\" [width]=\"'160px'\" header=\"Order History\" > <ng-template igxCell let-val> <igx-sparkline height=\"50px\" width=\"150px\" [dataSource]=\"val\" valueMemberPath=\"Sold\" displayType=\"Line\" lineThickness=\"2\" brush=\"rgb(21, 190, 6)\" > </igx-sparkline> </ng-template> </igx-column> <!-- ... --> </igx-grid> View on StackBlitz View page on GitHub"
  },
  "components/splitter.html": {
    "href": "components/splitter.html",
    "title": "Angular Splitter Component | Split Panes | Ignite UI for Angular | Infragistics",
    "keywords": "Angular Splitter Component Overview The Ignite UI for Angular Splitter component provides the ability to create layouts, split into multiple vertically or horizontally arranged panes that may be resized, expanded and collapsed. These interactions are performed through UI exposed in the splitter bars between the panes. A simple Splitter layout is demonstrated in the demo below. Angular Splitter Example Getting Started with Ignite UI for Angular Splitter To get started with the Ignite UI for Angular Splitter component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSplitterModule in your app.module.ts file. // app.module.ts ... import { IgxSplitterModule } from 'igniteui-angular'; // import { IgxSplitterModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxSplitterModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSplitterComponent as a standalone dependency, or use the IGX_SPLITTER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_SPLITTER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_SPLITTER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-splitter> <igx-splitter-pane> Pane 1 </igx-splitter-pane> <igx-splitter-pane> Pane 2 </igx-splitter-pane> </igx-splitter> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_SPLITTER_DIRECTIVES] /* or imports: [IgxSplitterComponent, IgxSplitterPaneComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Splitter module or directives imported, you can start using the igx-splitter component. Using the Angular Splitter igxSplitter is initialized with the igx-splitter tag. Multiple splitter panes can be defined under a single igx-splitter component. The content of the pane is templatable and will be rendered in its own resizable container. <!-- splitter.component.html --> <igx-splitter> <igx-splitter-pane> ... </igx-splitter-pane> <igx-splitter-pane> ... </igx-splitter-pane> <igx-splitter-pane> ... </igx-splitter-pane> </igx-splitter> Orientation The splitter can be vertical or horizontal, which is defined by the type input. The default value is Vertical. public type = SplitterType.Horizontal; <igx-splitter [type]=\"type\"> <igx-splitter-pane> ... </igx-splitter-pane> <igx-splitter-pane> ... </igx-splitter-pane> </igx-splitter> Configuring panes The igxSplitterPane component contains several input properties. You can set the initial pane size by using the size input property. The minSize and maxSize input properties can be used to set the minimum or maximum allowed size of the pane. Resizing beyond minSize and maxSize is not allowed. <igx-splitter> <igx-splitter-pane size='300px' minSize='100px'> ... </igx-splitter-pane> <igx-splitter-pane size='300px' maxSize='500px'> ... </igx-splitter-pane> </igx-splitter> You can also forbid the resizing of a pane by setting its resizable input property to false. <igx-splitter> <igx-splitter-pane [resizable]='false'> ... </igx-splitter-pane> <igx-splitter-pane> ... </igx-splitter-pane> </igx-splitter> Nested panes You can nest splitter components to create a more complex layout inside a splitter pane. public typeHorizontal = SplitterType.Horizontal; public typeVertical = SplitterType.Vertical; <igx-splitter style='height: 30vh;' [type]='typeHorizontal' > <igx-splitter-pane> <igx-splitter [type]='typeVertical' [style.width]='\"100%\"'> <igx-splitter-pane> Pane1.1 </igx-splitter-pane> <igx-splitter-pane> Pane1.2 </igx-splitter-pane> </igx-splitter> </igx-splitter-pane> <igx-splitter-pane> <igx-splitter [type]='typeVertical' [style.width]='\"100%\"'> <igx-splitter-pane> Pane2.1 </igx-splitter-pane> <igx-splitter-pane> Pane2.2 </igx-splitter-pane> </igx-splitter> </igx-splitter-pane> </igx-splitter> Demo Keyboard navigation Keyboard navigation is available by default in the splitter component. When you focus a splitter bar and press one of the following key combinations, the described behavior is performed. Key combinations Arrow Up - Moves the splitter bar up in a vertical splitter Arrow Down - Moves the splitter bar down in a vertical splitter Arrow Left - Moves the splitter bar left in a horizontal splitter Arrow Right - Moves the splitter bar right in a horizontal splitter Ctrl + Arrow Up - Expands/Collapses a pane in a vertical splitter Ctrl + Arrow Down - Expands/Collapses a pane in a vertical splitter Ctrl + Arrow Left - Expands/Collapses a pane in a horizontal splitter Ctrl + Arrow Right - Expands/Collapses a pane in a horizontal splitter Styling To get started with styling the igxSplitter component, you need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; You can change the default styles of the splitter by creating a new theme that extends the splitter-theme. // In splitter-styling-sample.component.scss $splitter-theme: splitter-theme( $bar-color: #011627, $handle-color: #ECAA53, $expander-color: #ECAA53, $border-radius: 0, $focus-color: #ECAA53, $size: 4px ); Using CSS Variables The next step is to pass the custom splitter theme: @include css-vars($custom-splitter-theme); Using Theme Overrides In order to style components for Internet Explorer 11, we have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. On the other side, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom splitter theme to the `igx-splitter` mixin @include splitter($custom-splitter-theme); } } Demo This is the final result from applying your new theme. Custom sizing You can either use the --size variable, targeting the igx-splitter directly: igx-splitter { --size: 10px; } Or you can use the universal --igx-splitter-size variable to target all instances: <div class=\"my-app\"> <igx-splitter></igx-splitter> </div> .my-app { --igx-splitter-size: 10px; } API References IgxSplitterComponent IgxSplitterPaneComponent SplitterType IgxSplitterComponent Styles Theming Dependencies IgxDropDown Theme IgxIcon Styles Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/spreadsheet-activation.html": {
    "href": "components/spreadsheet-activation.html",
    "title": "Angular Spreadsheet | Activation | Infragistics",
    "keywords": "Angular Spreadsheet Activation The Angular Spreadsheet component exposes properties that allow you to determine the currently active cell, pane, and worksheet in the control. This is helpful as it can help you to determine where the user may be navigating or editing in the control. Angular Spreadsheet Activation Example Activation Overview The activation of the Angular IgxSpreadsheetComponent control is split up between the cells, panes, and worksheets of the current workbook of the spreadsheet. The three \"active\" properties are described below: activeCell: Returns or sets the active cell in the spreadsheet. To set it, you must create a new instance of SpreadsheetCell and pass in information about that cell, such as the column and row or the string address of the cell. activePane: Returns the active pane in the currently active worksheet of the spreadsheet control. activeWorksheet: Returns or sets the active worksheet in the workbook of the spreadsheet control. This can be set by setting it to an existing worksheet in the workbook attached to the spreadsheet. Code Snippet The following code snippet shows setting activation of the cell and worksheet in the IgxSpreadsheetComponent control: this.spreadsheet.activeWorksheet = this.spreadsheet.workbook.worksheets(1); this.spreadsheet.activeCell = new SpreadsheetCell(\"C5\"); API References activeCell activePane activeWorksheet SpreadsheetCell IgxSpreadsheetComponent workbook View page on GitHub"
  },
  "components/spreadsheet-chart-adapter.html": {
    "href": "components/spreadsheet-chart-adapter.html",
    "title": "Angular Spreadsheet | Chart Adapter | Infragistics",
    "keywords": "Angular Spreadsheet Chart Adapter The Angular Spreadsheet component allows displaying charts in your IgxSpreadsheetComponent. Angular Spreadsheet Chart Adapter Example Chart Adapter Overview Using chartAdapter you can display the charts in the spreadsheet. The spreadsheet chart adapters creates and initializes chart elements for the spreadsheet based on a Infragistics.Documents.Excel.WorksheetChart instance. In order to add a WorksheetChart to a worksheet, you must use the addChart method of the worksheet’s Shapes collection.You can find more detail of adding charts in Excel below. Here are the steps by step description : Add the SpreadsheetChartAdapterModule reference to your project Create an instance of a SpreadsheetChartAdapter class assigning it to the Spreadsheet Run your app and load a worksheet containing a chart. Supported Charts Types There are over 35 chart types supported by the Spreadsheet ChartAdapters including, Line, Area, Column, and Doughnut. See the full list here: Column Charts Clustered column Stacked column 100% stacked column Line Charts Line Line with Markers Stacked line Stacked line with markers 100% stacked line 100% stacked line with markers Pie Charts Donut Charts Bar Charts Clustered bar Stacked bar 100% stacked bar Area Charts Area Stacked area 100% stacked area XY (Scatter) and Bubble Charts Scatter (with Marker only) Scatter with smooth lines Scatter with smooth lines and markers Scatter with straight lines Scatter with straight lines and markers Bubble (without effects) Bubble3DEffect Stock Charts High-low-close Open-high-low-close Volume-high-low-close Volume-open-high-low-close Radar Charts Radar without markers Radar with markers Filled Radar Combo Charts Column and line chart sharing xAxis Column and line chart and 2nd xAxis Stacked Area and Column Custom Combination Dependencies [!Note] In the following code snippet, an external ExcelUtility class is used to save and load a workbook. When setting up your Angular spreadsheet control to add charts, you will need to import the SpreadsheetChartAdapter class like so: import { IgxSpreadsheetChartAdapterModule } from 'igniteui-angular-spreadsheet-chart-adapter'; import { SpreadsheetChartAdapter } from 'igniteui-angular-spreadsheet-chart-adapter'; import { ChartTitle, ChartType, FormattedString, Workbook } from 'igniteui-angular-excel'; import { ExcelUtility } from \"ExcelUtility\"; import { Worksheet } from 'igniteui-angular-excel'; import { WorksheetCell } from 'igniteui-angular-excel'; Code Snippet The following code snippet demonstrates how to add charts to the currently viewed worksheet in the IgxSpreadsheetComponent control: this.spreadsheet.chartAdapter = new SpreadsheetChartAdapter(); ExcelUtility.loadFromUrl(process.env.PUBLIC_URL + \"/ExcelFiles/ChartData.xlsx\").then((w) => { this.spreadsheet.workbook = w; const sheet: Worksheet = this.spreadsheet.workbook.worksheets(0); sheet.defaultColumnWidth = 500 * 20; sheet.rows(0).height = 150 * 20; const cell1: WorksheetCell = sheet.getCell(\"A1\"); const cell2: WorksheetCell = sheet.getCell(\"B1\"); const cell3: WorksheetCell = sheet.getCell(\"C1\"); const cell4: WorksheetCell = sheet.getCell(\"D1\"); const dataCellAddress = \"A4:D6\"; const chart1 = sheet.shapes().addChart(ChartType.Line, cell1, { x: 0, y: 0 }, cell1, { x: 100, y: 100 }); const title: Angular ChartTitle = new ChartTitle(); title.text = new FormattedString(\"Line Chart\"); chart1.chartTitle = title; chart1.setSourceData(dataCellAddress, true); const chart2 = sheet.shapes().addChart(ChartType.ColumnClustered, cell2, { x: 0, y: 0 }, cell2, { x: 100, y: 100 }); const title2: ChartTitle = new ChartTitle(); title2.text = new FormattedString(\"Column Chart\"); chart2.chartTitle = title2; chart2.setSourceData(dataCellAddress, true); const chart3 = sheet.shapes().addChart(ChartType.Area, cell3, { x: 0, y: 0 }, cell3, { x: 100, y: 100 }); const title3: ChartTitle = new ChartTitle(); title3.text = new FormattedString(\"Area Chart\"); chart3.chartTitle = title3; chart3.setSourceData(dataCellAddress, true); const chart4 = sheet.shapes().addChart(ChartType.Pie, cell4, { x: 0, y: 0 }, cell4, { x: 100, y: 100 }); const title4: ChartTitle = new ChartTitle(); title4.text = new FormattedString(\"Pie Chart\"); chart4.chartTitle = title4; chart4.setSourceData(dataCellAddress, true); }); API References addChart chartAdapter SpreadsheetChartAdapter IgxSpreadsheetComponent workbook View page on GitHub"
  },
  "components/spreadsheet-clipboard.html": {
    "href": "components/spreadsheet-clipboard.html",
    "title": "Angular Spreadsheet | Clipboard Operations | Infragistics",
    "keywords": "Angular Working with Clipboard This topic explains how to perform clipboard operations on the Ignite UI for Angular spreadsheet component. Angular Working with Clipboard Example Dependencies Before making use of the clipboard you will want to import the SpreadsheetAction enumeration: import { IgxSpreadsheetComponent } from 'igniteui-angular-spreadsheet'; import { SpreadsheetAction } from 'igniteui-angular-spreadsheet'; Usage The following code snippet shows how you can execute commands related to the clipboard in the Angular IgxSpreadsheetComponent control: public cut(): void { this.spreadsheet.executeAction(SpreadsheetAction.Cut); } public copy(): void { this.spreadsheet.executeAction(SpreadsheetAction.Copy); } public paste(): void { this.spreadsheet.executeAction(SpreadsheetAction.Paste); } API References SpreadsheetAction IgxSpreadsheetComponent View page on GitHub"
  },
  "components/spreadsheet-commands.html": {
    "href": "components/spreadsheet-commands.html",
    "title": "Angular Spreadsheet | Commands | Infragistics",
    "keywords": "Angular Working with Commands The Angular Spreadsheet component allows you to perform commands for activating different features of the spreadsheet. This topic explains how to perform different operations with the control using commands. Many of the commands will perform their action based on the active cells, rows, or worksheets. For example two such commands are ZoomIn and ZoomOut. See the SpreadsheetAction enum for a full list. Angular Working with Commands Example Dependencies Before making use of the commands you will want to import the SpreadsheetAction import { IgxSpreadsheetComponent } from 'igniteui-angular-spreadsheet'; import { SpreadsheetAction } from 'igniteui-angular-spreadsheet'; Usage The following snippet shows how you can setup the data validation rules @ViewChild(\"spreadsheet\", { read: IgxSpreadsheetComponent }) public spreadsheet: IgxSpreadsheetComponent; // ... public zoomIn(): void { this.spreadsheet.executeAction(SpreadsheetAction.ZoomIn); } public zoomOut(): void { this.spreadsheet.executeAction(SpreadsheetAction.ZoomOut); } API References ExecuteAction SpreadsheetAction View page on GitHub"
  },
  "components/spreadsheet-conditional-formatting.html": {
    "href": "components/spreadsheet-conditional-formatting.html",
    "title": "Angular Spreadsheet | Conditional Formatting | Infragistics",
    "keywords": "Angular Spreadsheet Conditional Formatting The Angular Spreadsheet component allows you to conditionally format the cells of a worksheet. This allows you to highlight different pieces of your data based on a condition. Angular Spreadsheet Conditional Formatting Example Conditional Formatting Overview You can configure the conditional formatting of a particular worksheet by using the many Add methods exposed on the conditionalFormats collection of that worksheet. The first parameter of these Add methods is the string region of the worksheet that you would like to apply the conditional format to. Many of the conditional formats that you can add to your worksheet have a cellFormat property that determines the way that the cells should look when the condition in that conditional format holds true. For example, you can use the properties attached to this cellFormat property such as fill and font to determine the background and font settings of your cells, respectively. When a conditional format is created and a cellFormat applied, there is a subset of properties that are currently supported by the worksheet cell. The properties that are currently honored off of the cellFormat are fill, Border properties, formatString, and some font properties such as strikethrough, underline, italic, bold, and color. Many of these can be seen from the code snippet below. There are a few conditional formats that do not have a cellFormat property, as their visualization on the cells behaves differently. These conditional formats are the DataBarConditionalFormat, ColorScaleConditionalFormat, and IconSetConditionalFormat. When loading a pre-existing workbook from Excel, the formats will be preserved when that workbook is loaded. The same is true for when you save the workbook out to an Excel file. The following lists the supported conditional formats in the Angular IgxSpreadsheetComponent control: AverageConditionalFormat: Added using the addAverageCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s value is above or below the average or standard deviation for the associated range. BlanksConditionalFormat: Added using the addBlanksCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value is not set. ColorScaleConditionalFormat: Added using the addColorScaleCondition method, this conditional format exposes properties which control the coloring of a worksheet cell based on the cell’s value as relative to minimum, midpoint, and maximum threshold values. DataBarConditionalFormat: Added using the addDataBarCondition method, this conditional format exposes properties which display data bars in a worksheet cell based on the cell’s value as relative to the associated range of values. DateTimeConditionalFormat: Added using the addDateTimeCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s date value falls within a given range of time. DuplicateConditionalFormat: Added using the addDuplicateCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s value is unique or duplicated across the associated range. ErrorsConditionalFormat: Added using the addErrorsCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value is valid. FormulaConditionalFormat: Added using the addFormulaCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value meets the criteria defined by a formula. IconSetConditionalFormat: Added using the addIconSetCondition method, this conditional format exposes properties which display icons in a worksheet cell based on the cell’s value as relative to threshold values. NoBlanksConditionalFormat: Added using the addNoBlanksCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value is set. NoErrorsConditionalFormat: Added using the addNoErrorsCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value is valid. OperatorConditionalFormat: Added using the addOperatorCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether the cell’s value meets the criteria defined by a logical operator. RankConditionalFormat: Added using the addRankCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s value is within the top of bottom rank of values across the associated range. TextOperatorConditionalFormat: Added using the addTextCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s text value meets the criteria defined by a string and a FormatConditionTextOperator value as placed in the addTextCondition method’s parameters. UniqueConditionalFormat: Added using the addUniqueCondition method, this conditional format exposes properties which control the visual attributes of a worksheet cell based on whether a cell’s value is unique across the associated range. Dependencies In order to add conditional formatting to the IgxSpreadsheetComponent control, you will need to import the following dependencies: import { CellFill } from \"igniteui-angular-excel\"; import { Color } from 'igniteui-angular-core'; import { ColorScaleType } from \"igniteui-angular-excelScaleType\"; import { FormatConditionAboveBelow } from 'igniteui-angular-excel'; import { FormatConditionIconSet } from 'igniteui-angular-excel'; import { FormatConditionOperator } from 'igniteui-angular-excel'; import { FormatConditionTextOperator } from 'igniteui-angular-excel'; import { FormatConditionTimePeriod } from 'igniteui-angular-excel'; import { FormatConditionTopBottom } from \"igniteui-angular-excel\"; import { WorkbookColorInfo } from 'igniteui-angular-excel'; Code Snippet The following code snippet demonstrates how to add each of the conditional formats to a spreadsheet in the IgxSpreadsheetComponent control: let sheet = this.spreadsheet.activeWorksheet; let red = new Color(); red.colorString = \"#ff0000\"; let blue = new Color(); blue.colorString = \"#0000ff\"; let green = new Color(); green.colorString = \"#00ff00\"; let gray = new Color(); gray.colorString = \"#d3d3d3\"; let avgFormat = sheet.conditionalFormats().addAverageCondition(\"A1:A10\", FormatConditionAboveBelow.AboveAverage); avgFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(red); let blanksFormat = sheet.conditionalFormats().addBlanksCondition(\"B1:B10\"); blanksFormat.cellFormat.fill = CellFill.createSolidFill(new WorkbookColorInfo(gray)); let colorFormat = sheet.conditionalFormats().addColorScaleCondition(\"C1:C10\", ColorScaleType.ThreeColor); colorFormat.minimumThreshold.formatColor = new WorkbookColorInfo(red); colorFormat.midpointThreshold.formatColor = new WorkbookColorInfo(blue); colorFormat.maximumThreshold.formatColor = new WorkbookColorInfo(green); let dataBarFormat = sheet.conditionalFormats().addDataBarCondition(\"D1:D10\"); let dateTimeFormat = sheet.conditionalFormats().addDateTimeCondition(\"E1:E10\", FormatConditionTimePeriod.NextWeek); dateTimeFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(red); let duplicateFormat = sheet.conditionalFormats().addDuplicateCondition(\"F1:F10\"); duplicateFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(blue); let errorFormat = sheet.conditionalFormats().addErrorsCondition(\"G1:G10\"); errorFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(green); let formulaFormat = sheet.conditionalFormats().addFormulaCondition(\"H1:H10\", \"=H1>2\"); formulaFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(red); let iconFormat = sheet.conditionalFormats().addIconSetCondition(\"I1:I10\", FormatConditionIconSet.IconSet3TrafficLights1); let noBlanksFormat = sheet.conditionalFormats().addNoBlanksCondition(\"J1:J10\"); noBlanksFormat.cellFormat.fill = CellFill.createSolidFill(new WorkbookColorInfo(gray)); let noErrorFormat = sheet.conditionalFormats().addErrorsCondition(\"K1:K10\"); noErrorFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(red); let operatorFormat = sheet.conditionalFormats().addOperatorCondition(\"L1:L10\", FormatConditionOperator.Greater); operatorFormat.setOperand1(500); operatorFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(blue); let rankFormat = sheet.conditionalFormats().addRankCondition(\"M1:M10\", FormatConditionTopBottom.Top, 5); rankFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(green); let textFormat = sheet.conditionalFormats().addTextCondition(\"N1:N10\", \"A\", FormatConditionTextOperator.Contains); textFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(red); let uniqueFormat = sheet.conditionalFormats().addUniqueCondition(\"O1:O10\"); uniqueFormat.cellFormat.font.colorInfo = new WorkbookColorInfo(blue); API References addAverageCondition addBlanksCondition addColorScaleCondition addDataBarCondition addDateTimeCondition addDuplicateCondition addErrorsCondition addFormulaCondition addIconSetCondition addNoBlanksCondition addNoErrorsCondition addOperatorCondition addRankCondition addTextCondition addUniqueCondition cellFormat ColorScaleConditionalFormat ColorScaleConditionalFormat: conditionalFormats DataBarConditionalFormat DataBarConditionalFormat: DateTimeConditionalFormat: DuplicateConditionalFormat: ErrorsConditionalFormat: FormatConditionTextOperator formatString FormulaConditionalFormat: IconSetConditionalFormat IconSetConditionalFormat: NoBlanksConditionalFormat: NoErrorsConditionalFormat: OperatorConditionalFormat: RankConditionalFormat: IgxSpreadsheetComponent TextOperatorConditionalFormat: UniqueConditionalFormat: View page on GitHub"
  },
  "components/spreadsheet-configuring.html": {
    "href": "components/spreadsheet-configuring.html",
    "title": "Angular Spreadsheet | Configuring | Cell | Formula | Navigation | Selection | Infragistics",
    "keywords": "Angular Configuring Spreadsheet The Angular Spreadsheet component allows the user to configure many different aspects of the control. This includes, but is not limited to, editing of the cells, the visibility of gridlines and headers, protection, zoom level, and various other properties related to the Excel worksheet. Angular Configuring Spreadsheet Example Configuring Cell Editing When a user edits a cell value and confirms the new input, the IgxSpreadsheetComponent control has the ability to navigate to cells adjacent to the currently active cell on press of the Enter key, depending on the configuration of the spreadsheet. In order to enable this Enter key navigation, you can set the isEnterKeyNavigationEnabled property to true. If set to false, the active cell will stay the same when pressing the Enter key. You can also configure the direction of the adjacent cell navigated to on press of the Enter key by setting the enterKeyNavigationDirection property to Down, Up, Left or Right. The following code snippets demonstrate the above: <igx-spreadsheet isEnterKeyNavigationEnabled=true enterKeyNavigationDirection=\"Left\"> </igx-spreadsheet> this.spreadsheet.isEnterKeyNavigationEnabled = true; this.spreadsheet.enterKeyNavigationDirection = SpreadsheetEnterKeyNavigationDirection.Left; Configuring Formula Bar The Angular IgxSpreadsheetComponent allows you to configure the visibility of the formula bar by setting the isFormulaBarVisible property of the control. The following code snippets demonstrate the above: <igx-spreadsheet isFormulaBarVisible=true></igx-spreadsheet> this.spreadsheet.isFormulaBarVisible = true; Configuring Gridlines The IgxSpreadsheetComponent allows you to configure the visibility of its gridlines by setting the areGridlinesVisible property of the control. The following code snippets demonstrate the above: <igx-spreadsheet areGridlinesVisible=true></igx-spreadsheet> this.spreadsheet.areGridlinesVisible = true; Configuring Headers The IgxSpreadsheetComponent allows you to configure the visibility of its headers by setting the areHeadersVisible property of the control. The following code snippets demonstrate the above: <igx-spreadsheet areHeadersVisible=false></igx-spreadsheet> this.spreadsheet.areHeadersVisible = false; Configuring Navigation The IgxSpreadsheetComponent control allows you to configure navigation between a worksheet's cells by configuring whether or not the control is in \"end mode.\" End mode is the functionality where, on press of an arrow key, the active cell will be moved from the current cell to the end of the row or column where data exists in the adjacent cells, depending on the direction of the arrow key pressed. This functionality is good for navigating to the end of large blocks of data very quickly. For example, if you are in end mode, and you click in a large 100x100 block of data, and press the Right arrow key, this will navigate to the right end of the row that you are in to the furthest right column with data. After this operation, the IgxSpreadsheetComponent will pop out of end mode. End mode goes into effect at runtime when the user presses the End key, but it can be configured programmatically by setting the isInEndMode property of the spreadsheet control. The following code snippets demonstrate the above, in that the IgxSpreadsheetComponent will begin in end mode: <igx-spreadsheet isInEndMode=true></igx-spreadsheet> this.spreadsheet.isInEndMode = true; Configuring Protection The IgxSpreadsheetComponent will respect the protection of a workbook on a worksheet-by-worksheet basis. Configuration for a worksheet's protection can be configured by calling the Protect() method on the worksheet to protect it, and the Unprotect() method to unprotect it. You can activate or deactivate protection on the IgxSpreadsheetComponent control's currently active worksheet by using the code below: this.spreadsheet.activeWorksheet.protect(); this.spreadsheet.activeWorksheet.unprotect(); Configuring Selection The IgxSpreadsheetComponent control allows you to configure the type of selection allowed in the control then modifier keys (Shift or Ctrl) are pressed by the user. This is done by setting the selectionMode property of the spreadsheet to one of the following values: AddToSelection: New cell ranges are added to the SpreadsheetSelection object's cellRanges collection without needing to hold down the ctrl key when dragging via the mouse and a range is added with the first arrow key navigation after entering the mode. One can enter the mode by pressing Shift+F8. ExtendSelection: The selection range in the SpreadsheetSelection object's cellRanges collection representing the active cell is updated as one uses the mouse to select a cell or navigating via the keyboard. Normal: The selection is replaced when dragging the mouse to select a cell or range of cells. Similarly when navigating via the keyboard a new selection is created. One may add a new range by holding the Ctrl key and using the mouse and one may alter the selection range containing the active cell by holding the Shift key down while clicking with the mouse or navigating with the keyboard such as with the arrow keys. The SpreadsheetSelection object mentioned in the descriptions above can be obtained by using the activeSelection property of the IgxSpreadsheetComponent control. The following code snippets demonstrate configuration of the selection mode: <igx-spreadsheet selectionMode=\"ExtendSelection\"></igx-spreadsheet> this.spreadsheet.selectionMode = SpreadsheetCellSelectionMode.ExtendSelection; The selection of the IgxSpreadsheetComponent control can also be set or obtained programmatically. For single selection, you can set the activeCell property Multiple selection is done through the SpreadsheetSelection object that is returned by the IgxSpreadsheetComponent control's activeSelection property. The SpreadsheetSelection object has an AddCellRange() method that allows you to programmatically add a range of cells to the selection of the spreadsheet in the form of a new SpreadsheetCellRange object. The following code snippet demonstrates adding a cell range to the spreadsheet's selection: this.spreadsheet.activeSelection.addCellRange(new SpreadsheetCellRange(2, 2, 5, 5)); Configuring Tab Bar Area The IgxSpreadsheetComponent control respects the configuration of the visibility and width of the tab bar area from the WindowOptions of the currently active workbook via the tabBarWidth and TabBarVisibility properties, respectively. The tab bar area is the area that visualizes the worksheet names as tabs in the control. You can configure the tab bar's visibility and width using the following code snippet: this.spreadsheet.workbook.windowOptions.tabBarVisible = false; this.spreadsheet.workbook.windowOptions.tabBarWidth = 200; Configuring Zoom Level The Angular Spreadsheet component supports zooming in and out by configuring its zoomLevel property. The zoom level can be a maximum of 400% and a minimum of 10%. Setting this property to a number represents the percentage as a whole number, so setting the zoomLevel to 100 is equivalent to setting it to 100%. The following code snippets show how to configure the spreadsheet's zoom level: <igx-spreadsheet zoomLevel=200></igx-spreadsheet> this.spreadsheet.zoomLevel = 200; API References activeCell activeSelection CellRanges ExtendSelection: selectionMode SpreadsheetCellRange SpreadsheetSelection IgxSpreadsheetComponent WindowOptions workbook zoomLevel View page on GitHub"
  },
  "components/spreadsheet-data-validation.html": {
    "href": "components/spreadsheet-data-validation.html",
    "title": "Angular Spreadsheet | Data Validation | Infragistics",
    "keywords": "Angular Data Validation This topic explains how to configure and set the built-in data validation rules. Angular Data Validation Example Dependencies When setting up the data validation rules you will need to import the rules you want to use. import { AnyValueDataValidationRule } from 'igniteui-angular-excel'; import { CustomDataValidationRule } from 'igniteui-angular-excel'; import { DataValidationErrorStyle } from 'igniteui-angular-excel'; import { ListDataValidationRule } from 'igniteui-angular-excel'; import { OneConstraintDataValidationOperator } from 'igniteui-angular-excel'; import { OneConstraintDataValidationRule } from 'igniteui-angular-excel'; import { TwoConstraintDataValidationOperator } from 'igniteui-angular-excel'; import { TwoConstraintDataValidationRule } from 'igniteui-angular-excel'; Usage The following snippet shows how you can setup the data validation rules // this validation rule has only input message set const valRule1 = new AnyValueDataValidationRule(); valRule1.inputMessageTitle = \"Hotel room booking form\"; valRule1.inputMessageDescription = \"Please us the form below to choose your accommodation type\"; this.spreadsheet.workbook.worksheets(0).rows(1).cells(0).dataValidationRule = valRule1; this.spreadsheet.workbook.worksheets(0).rows(1).cells(0).value = \"Hotel room booking form\"; // this validation rule has a two constraint validation set const valRule2 = new TwoConstraintDataValidationRule(); valRule2.validationOperator = TwoConstraintDataValidationOperator.Between; valRule2.setLowerConstraint(1); valRule2.setUpperConstraint(4); valRule2.inputMessageTitle = \"Adults\"; valRule2.inputMessageDescription = \"Adults count must be min, 1 and max. 4.\"; valRule2.errorMessageTitle = \"Adult requirement not met\"; valRule2.errorMessageDescription = \"There must be between 1 and 4 adults per room.\"; valRule2.errorStyle = DataValidationErrorStyle.Information; this.spreadsheet.workbook.worksheets(0).rows(3).cells(1).dataValidationRule = valRule2; this.spreadsheet.workbook.worksheets(0).rows(3).cells(1).value = 1; this.spreadsheet.workbook.worksheets(0).rows(3).cells(0).value = \"Adults\"; // this validation rule has a custom formula validation set const valRule3 = new CustomDataValidationRule(); const separator = getLocaleNumberSymbol(window.navigator.language, NumberSymbol.Group); valRule3.setFormula(\"=AND((B4+B5)<5 \" + separator + \" (B4+B5)>0)\", null); valRule3.inputMessageTitle = \"Children\"; valRule3.inputMessageDescription = \"Children and adults cannot be more than 4 per room.\"; valRule3.errorMessageTitle = \"Room limit exceeded\"; valRule3.errorMessageDescription = \"The maximum persons per room is 4.\"; valRule3.errorStyle = DataValidationErrorStyle.Warning; this.spreadsheet.workbook.worksheets(0).rows(4).cells(1).dataValidationRule = valRule3; this.spreadsheet.workbook.worksheets(0).rows(4).cells(1).value = 0; this.spreadsheet.workbook.worksheets(0).rows(4).cells(0).value = \"Children\"; // this validation rule has a list of accepted choices validation set const valRule4 = new ListDataValidationRule(); valRule4.setValues([\"FB\", \"HB\", \"BB\" ]); valRule4.inputMessageTitle = \"Servicing\"; valRule4.inputMessageDescription = \"Allowed values: FB (Full board - breakfast, lunch, and dinner)\" + \", HB (Half board - breakfast and dinner), BB (Bed and breakfast)\"; valRule4.errorMessageTitle = \"Invalid Option\"; valRule4.errorMessageDescription = \"Please choose FB, HB, or BB\"; valRule4.errorStyle = DataValidationErrorStyle.Stop; this.spreadsheet.workbook.worksheets(0).rows(5).cells(1).dataValidationRule = valRule4; this.spreadsheet.workbook.worksheets(0).rows(5).cells(1).value = \"FB\"; this.spreadsheet.workbook.worksheets(0).rows(5).cells(0).value = \"Servicing\"; // this validation rule has a single constraint validation set const valRule5 = new OneConstraintDataValidationRule(); valRule5.inputMessageTitle = \"Check In Date\"; const checkinDate = new Date(); valRule5.inputMessageDescription = \"The hotel operates from\" + checkinDate; valRule5.validationOperator = OneConstraintDataValidationOperator.GreaterThanOrEqualTo; valRule5.setConstraint(checkinDate); this.spreadsheet.workbook.worksheets(0).rows(6).cells(1).dataValidationRule = valRule5; this.spreadsheet.workbook.worksheets(0).rows(6).cells(1).value = checkinDate.toLocaleDateString(); this.spreadsheet.workbook.worksheets(0).rows(6).cells(0).value = \"Check In Date\"; // this validation rule has a single constraint validation set const valRule6 = new OneConstraintDataValidationRule(); valRule6.inputMessageTitle = \"Check Out Date\"; valRule6.inputMessageDescription = \"The check out date must be greater than the check in date\"; valRule6.validationOperator = OneConstraintDataValidationOperator.GreaterThan; valRule6.setConstraintFormula(\"=B7\", null); const checkOutDate = new Date(); checkOutDate.setDate(checkOutDate.getDate() + 1); this.spreadsheet.workbook.worksheets(0).rows(7).cells(1).dataValidationRule = valRule6; this.spreadsheet.workbook.worksheets(0).rows(7).cells(1).value = checkOutDate.toLocaleDateString(); this.spreadsheet.workbook.worksheets(0).rows(7).cells(0).value = \"Check Out Date\"; API References IgxSpreadsheetComponent View page on GitHub"
  },
  "components/spreadsheet-hyperlinks.html": {
    "href": "components/spreadsheet-hyperlinks.html",
    "title": "Angular Spreadsheet | Hyperlinks | Infragistics",
    "keywords": "Angular Spreadsheet Hyperlinks The Angular Spreadsheet component allows display of pre-existing hyperlinks in your Excel workbook as well as insertion of new ones that can link to websites, file directories, and even other worksheets in the workbook. Angular Spreadsheet Hyperlinks Example Hyperlinks Overview Hyperlinks are added to the IgxSpreadsheetComponent control by accessing the Hyperlinks collection on the worksheet that you want to place the hyperlink on. This collection has an Add method that takes a WorksheetHyperlink object, where you can define the cell address, the hyperlink URL to be navigated to, the display text, and a tooltip to optionally be displayed on hover. Dependencies When setting up your Angular spreadsheet control to use hyperlinks, you will need to import the WorksheetHyperlink class like so: import { WorksheetHyperlink } from 'igniteui-angular-excel'; Code Snippet The following code snippet demonstrates how to add a hyperlink to the currently viewed worksheet in the Angular IgxSpreadsheetComponent control: this.spreadsheet.activeWorksheet.hyperlinks().add(new WorksheetHyperlink(\"A1\", \"http://www.infragistics.com\", \"Infragistics\", \"Infragistics Home Page\")); API References Hyperlinks IgxSpreadsheetComponent WorksheetHyperlink View page on GitHub"
  },
  "components/spreadsheet-overview.html": {
    "href": "components/spreadsheet-overview.html",
    "title": "Angular Spreadsheet Component – Ignite UI for Angular",
    "keywords": "Angular Spreadsheet Overview The Angular Spreadsheet (Excel viewer) component is lightweight, feature-rich and supplied with all the necessary options for operating, visualizing, and editing all types of spreadsheet data – scientific, business, financial, and more. All the information can be presented in a tabular format that feels intuitive and easy to navigate across cells, panes, and worksheets. The IgxSpreadsheetComponent is complemented by flexible Excel-like interface, detailed charts, and features such as activation, cell editing, conditional formatting, styling, selection, clipboard. Angular Spreadsheet Example Functionality Features Just like in Excel spreadsheet, you can apply filtering functionality, sorting, move cells, customization in terms of cells color, keyboard shortcuts, and add the ability to even calculate formulas. Spreadsheet Usage Performance The spreadsheet is compatible on all modern browsers and optimized for complex and voluminous spreadsheet models, while ensuring flawless functionality and simplicity. Flexible layout and easy customization You can easily select, add, remove, switch the features you want on/off, and configure React sheets in an instant so that it all answers the needs of end-users. There are also configurable libraries, styling and formatting alternatives, visibility options, plenty of themes to choose from. Convenient Excel-like interface Just like operating data in Excel, our spreadsheet component delivers all well-known Excel clip board operations – copy, paste, cut. You won’t need extra training or new skills in order to start using it right away. It also comes with options for sorting, full keyboard navigation, values and formulas, cell dragging, column and rows editing, filtering, number formatting, resizing. The smart and fast calculation engine powers even the most complex estimations. With no dependencies on Excel. Data operations Collect and manage scientific, business, engineering, financial and educational data. Prepare and create analysis, advanced grids, reports, data input forms, budgeting, forecasting scenarios, custom spreadsheets. All of this thanks to the comprehensive API. Fast and secure data processing With our spreadsheet, processing data is 100% safe and secure… Excel and CSV import & export With the built-in Excel import/export functionality, you can instantly load and open Excel documents and view them on-demand, add changes and save them. Also, effortlessly export your completed Excel .xlsx spreadsheets. Dependencies When installing the Angular spreadsheet component, the core and excel package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-excel npm install --save igniteui-angular-spreadsheet Component Modules The IgxSpreadsheetComponent requires the following modules: import { IgxExcelModule } from 'igniteui-angular-excel'; import { IgxSpreadsheetModule } from 'igniteui-angular-spreadsheet'; @NgModule({ imports: [ // ... IgxExcelModule, IgxSpreadsheetModule, // ... ] }) export class AppModule {} Usage Now that the Angular spreadsheet module is imported, next is the basic configuration of the spreadsheet. <igx-spreadsheet #spreadsheet height=\"500px\" width=\"100%\"> </igx-spreadsheet> [!Note] In the following code snippet, an external ExcelUtility class is used to save and load a workbook. The following demonstrates how to load a workbook into the Angular spreadsheet import { IgxSpreadsheetComponent } from 'igniteui-angular-spreadsheet'; import { ExcelUtility } from 'ExcelUtility'; // ... @ViewChild(\"spreadsheet\", { read: IgxSpreadsheetComponent }) public spreadsheet: IgxSpreadsheetComponent; ngOnInit() { const excelFile = '../../assets/Sample1.xlsx'; ExcelUtility.loadFromUrl(excelFile).then((w) => { this.spreadsheet.workbook = w; }); } API References IgxSpreadsheetComponent workbook View page on GitHub"
  },
  "components/stepper.html": {
    "href": "components/stepper.html",
    "title": "Angular Stepper Component – Ignite UI for Angular",
    "keywords": "Angular Stepper Component Overview The Ignite UI for Angular Stepper is a highly customizable component that visualizes content as a process and shows its progress by dividing the content into successive steps. It appears as a vertical or horizontal line. Provided by the Ignite UI for Angular Component library, the stepper component delivers a wizard-like workflow and multiple features like step validation, styling, orientation and keyboard navigation. Angular Stepper Example In this Angular Stepper example, you can see how users are given the opportunity to customize their credit card and they pass trough the process in five logical steps - selecting card type, adding business information, filling in personal information, providing shipping details and confirmation. Note that the fourth step in our Angular stepper demo gets enabled only if the user ticks the checkbox in the second step, signifying that their mailing address is different from the business physical address. Getting Started with Ignite UI for Angular Stepper To get started with the Ignite UI for Angular Stepper component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxStepperModule in your app.module.ts file. // app.module.ts ... import { IgxStepperModule } from 'igniteui-angular'; // import { IgxStepperModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxStepperModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxStepperComponent as a standalone dependency, or use the IGX_STEPPER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { HammerModule } from '@angular/platform-browser'; import { FormsModule } from '@angular/forms'; import { IGX_STEPPER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_STEPPER_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: `<igx-stepper> <igx-step> <p igxStepTitle>Step 1</p> </igx-step> <igx-step> <p igxStepTitle>Step 2</p> </igx-step> </igx-stepper>`, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_STEPPER_DIRECTIVES, FormsModule, HammerModule] /* or imports: [IgxStepperComponent, FormsModule, HammerModule] */ }) export class HomeComponent { public task: Task; } Now that you have the Angular Stepper module or directives imported, you can start with a basic configuration of the igx-stepper and its steps. Now that you have the Angular Stepper module or directives imported, you can start with a basic configuration of the igx-stepper and its steps. Using the Angular Stepper IgxStepComponent is the representation of every step that belongs to the IgxStepperComponent. Steps provide isValid, active, optional, disabled and completed properties, which give you the ability to configure the step states according to your business requirement. Declaring a Stepper Now that we have the stepper module imported, let’s get started with its configuration. Steps can be declared using one of the following approaches. Iterating through a data set <igx-stepper> <igx-step *ngFor=\"let step of stepsData\" [disabled]=”step.disabled”> <igx-icon igxStepIndicator> {{step.indicator}} </igx-icon> <p igxStepTitle> {{step.title}} </p> </igx-step> </igx-stepper> Creating static steps <igx-stepper> <igx-step> <p igxStepTitle>Step 1</p> </igx-step> <igx-step> <p igxStepTitle>Step 2</p> </igx-step> </igx-stepper> For each step the user has the ability to configure indicator, title, subtitle and content using the igxStepIndicator, igxStepTitle, igxStepSubtitle and igxStepContent directives as follows: <igx-stepper> <igx-step> <igx-icon igxStepIndicator>home</igx-icon> <p igxStepTitle>Home</p> <p igxStepSubtitle>Home Sub Title</p> <div igxStepContent> ... </div> </igx-step> </igx-stepper> Changing the Stepper Orientation You can customize the stepper orientation through the exposed orientation property. It takes a member of the IgxStepperOrientation enum - Horizontal (default value) or Vertical. Horizontal Stepper Orientation horizontal is the default value for the igx-stepper orientation property. When the stepper is horizontally orientated you have the opportunity to determine whether the steps’ content would be displayed above or below the steps’ headers. This could be achieved by setting the IgxStepperComponent contentTop boolean property, which default value is false. In case it is enabled the steps’ content would be displayed above the steps’ headers. Vertical Stepper Orientation You can easily switch from the horizontal to vertical layout. In order to change the default orientation you should set the orientation property to vertical. <igx-stepper [orientation]=\"'vertical'\"> <igx-step> … </igx-step> <igx-step> … </igx-step> </igx-stepper> The sample below demonstrates how stepper orientation and titles position could be changed runtime. Step States IgxStepperComponent supports four steps states and each of them apply different styles by default: active - Determines whether the step is the currently displayed. By design, if the user does not explicitly set some step’s active attribute to true, the initial active step would be the first non-disabled step. disabled - Determines whether the step is interactable. By default, the disabled attribute of a step is set to false. optional - By default, the optional attribute of a step is set to false. If validity of a step in linear stepper is not required, then the optional attribute can be enabled in order to be able to move forward independently from the step validity. completed - By default, the completed attribute of a step returns false. The user, however, can override this default completed behavior by setting the completed attribute as needed. When step is marked as completed not only that the style of the step header is changed by default, but also the style of the progress line between the completed step and the next one. Both styles could be modified using the exposed CSS variables. The IgxStepperComponent gives you the opportunity to set validation logic for each step through the two-way bindable isValid property. Based on its value it is decided whether the user will have the ability to move forward in linear stepper mode. By default, the isValid property of a step is set to true. Linear Stepper The igx-stepper gives you the opportunity to set its steps flow using the linear property. By default, linear is set to false and the user is enabled to select any non-disabled step in the IgxStepperComponent. When the linear property is set to true, the stepper will require the current non-optional step to be valid before proceeding to the next one. If the current non-optional step is not valid you cannot go forward to the next step until you validate the current one. Note Optional steps validity is not taken into account in order to move forward. The following example demonstrates how to configure a linear stepper: Step Interactions IgxStepperComponent provides the following API methods for step interactions: navigateTo – activates the step by given index. next - activates the next non-disabled step. prev – activates the previous non-disabled step. reset – resets the stepper to its initial state. Note The reset method would not clear the step`s content. This should be done manually. Customizing the Steps The Ignite UI for Angular Stepper gives you the ability to configure different options for titles, indicators and more. This could be achieved through the stepType property of the IgxStepperComponent. It takes a member of the IgxStepType enum: Full (default value) Indicator Title Full If titles and subtitles are defined, with this setup both indicators and titles would be rendered. The user would also have the ability to define the position of the title for the steps, so it could be placed before, after, above or below the step indicator. The user can configure the title position using the titlePosition property. Both properties take member of IgxStepperTitlePosition enum: end start bottom top When the igx-stepper is horizontally orientated, the title position default value is bottom. When the orientation is set to vertical layout the title position by default is end. Note titlePosition property is applicable only when the stepper stepType property is set to full. Indicator If you want to display only indicators for the steps, set the stepType option to indicator. The step indicator supports any content, however with the restriction that its size would be always 24 pixels. Having this in mind, we recommend using IgxIconComponent or IgxAvatarComponent as step indicators. Title If you want to display only titles for the steps, set the stepType option to title. In this way if subtitles are defined, they will also be rendered below the step title. Note This container could be re-templated as per your requirement without any size restrictions. For example, you could add an indicator with size greater than 24 pixels inside it. The sample below demonstrates all exposed step types and how they could be changed: The IgxStepperComponent also allows you to customize the rendered indicators for active, invalid and completed steps. This could be achieved through the igxStepActiveIndicator, igxStepInvalidIndicator and igxStepCompletedIndicator directives: <igx-stepper> <ng-template igxStepActiveIndicator> <igx-icon>edit</igx-icon> </ng-template> <ng-template igxStepInvalidIndicator> <igx-icon>error</igx-icon> </ng-template> <ng-template igxStepCompletedIndicator> <igx-icon>check</igx-icon> </ng-template> ... </igx-stepper> Note This templates would be applied for all steps with the relevant state. Angular Stepper Animations Angular Stepper Animations provide the end-users with a beautiful experience interacting with the defined steps. The available animation options differ depending on the orientation of the stepper. When the stepper is horizontally orientated, it is configured to use the slide animation by default. It also supports fade as an alternative. The animations are configured through the horizontalAnimationType input. In vertically orientated layout, the animation type could be defined using the verticalAnimationType property. By default, its value is grow and the user has the ability to set it to fade as well. Setting none to the both animation type inputs disables stepper animations. IgxStepperComponent gives you the ability to configure the duration of the transition between the steps. This could be achieved through the animationDuration property, which takes a number as an argument and it is common to the both orientations. Keyboard Navigation Angular Stepper provides a rich variety of keyboard interactions to the end-user. This functionality is enabled by default and allows end-users to easily navigate through the steps. The IgxStepperComponent navigation is compliant with W3 accessability standards and convenient to use. Key Combinations Tab - moves the focus to the next tabbable element Shift + Tab - moves the focus to the previous tabbable element Arrow Down - moves the focus to the header of the next accessible step when the igx-stepper is vertically orientated Arrow Up - moves the focus to the header of the previous accessible step when the igx-stepper is vertically orientated Arrow Left - moves the focus to the header of the previous accessible step in both orientations Arrow Right - moves the focus to the header of the next accessible step in both orientations Home - moves the focus to the header of the FIRST enabled step in the igx-stepper End - moves the focus to the header of the LAST enabled step in the igx-stepper Enter / Space - activates the currently focused step Note By design when the user presses the Tab key over the step header the focus will move to the step content container. In case the container should be skipped the developer should set the content container [tabIndex]=\"-1\". The Stepper Component is also available in the low-code, drag and drop App Builder™. Angular Stepper Styling Using the Ignite UI for Angular Theming, we can greatly alter the igx-stepper appearance. First, in order to use the functions exposed by the theme engine, we need to import the index file in our style file: @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the stepper-theme and pass the parameters, which we would like to change: $custom-stepper-theme: stepper-theme( $current-title-color: #351e65, $current-subtitle-color: #5f4691, $step-separator-style: \"solid\" ); Using CSS Variables The last step is to include the component's theme. :host { @include css-vars($custom-stepper-theme); } Using Theme Overrides In order to style components for older browsers, like IE11, we have to use a different approach, since CSS variables are not supported there. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include stepper($custom-stepper-theme); } } Demo The sample below demonstrates a simple styling applied through the Ignite UI for Angular Theming. API Reference IgxStepperComponent IgxStepComponent Additional Resources Our community is active and always welcoming new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/style-guide.html": {
    "href": "components/style-guide.html",
    "title": "Style guide",
    "keywords": "Style guide Colors Primary Secondary 1 Secondary 2 Accent Info Success Warning Error badges NEW UPDATED Bold, italic and scratched This text is bold. This text is italic. This text is scratched. Headings Header text h1 Header text h2 Header text h3 Header text h4 Header text h5 Header text h6 Paragraph By default Markdown adds paragraphs at double line breaks. Single line breaks by themselves are simply wrapped together into a single line. If you want to have soft returns that break a single line, add two spaces at the end of the line. This line has a paragraph break at the end (empty line after). Theses two lines should display as a single line because there's no double space at the end. The following line has a soft break at the end (two spaces at end) This line should be following on the very next line. This line has a paragraph break at the end (empty line after). Links www.infragistics.com Link to other topic Internal link Block Quotes Headers break on their own Note that headers don't need line continuation characters as they are block elements and automatically break. Only text lines require the double spaces for single line breaks. Unordered Lists Item 1 Item 2 Item 3 Ordered Lists Item 1 Item 1 is really something Item 2 Item two is really something else Inline Code Structured statements like for x =1 to 10 loop structures can be codified using single back ticks. Code Blocks :host { ::ng-deep { // comment @include splitter($custom-splitter-theme); } } Alerts Warning This is some Note Text that spreads across two lines Note Singe line NOTE. Important Don't forget to screw on your hat! Table test test test test test val Using the Table menu set the desired size of the table. val val val val Using the Table menu set the desired size of the table. val val val val Using the Table menu set the desired size of the table. val val val Page pagination First Previous 1 2 3 Next Last Details summary text To achieve this look you need to wrap your details inside a div with a class .fancy-details summary text To achieve this look you need to wrap your details inside a div with a class .fancy-details View page on GitHub"
  },
  "components/switch.html": {
    "href": "components/switch.html",
    "title": "Angular Switch Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Switch Component Overview The Ignite UI for Angular Switch component is a binary choice selection component that behaves similarly to the switch component in iOS. Angular Switch Example Getting Started with Ignite UI for Angular Switch To get started with the Ignite UI for Angular Switch component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxSwitchModule in your app.module.ts file. // app.module.ts ... import { IgxSwitchModule } from 'igniteui-angular'; // import { IgxSwitchModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxSwitchModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxSwitchComponent as a standalone dependency. // home.component.ts import { IgxSwitchComponent } from 'igniteui-angular'; // import { IgxSwitchComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-switch [checked]=\"true\"> Simple switch </igx-switch> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxSwitchComponent] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Switch module or component imported, you can start using the igx-switch component. Using the Angular Switch At its core the switch component allows for toggling between on/off state. The default styling is done according to the selection controls specification in the Material Design guidelines. To get a simple switch as the one in the demo, add the following code inside the component template: <igx-switch [checked]=\"true\"> Simple switch </igx-switch> Switch properties Let's enhance the code above by binding the switch properties to some data. Say, we have an array of settings objects, each having two properties - name and state. You can bind the switch component checked property to the underlying object state property. Analogically, you can bind the value property to name. // toggle.component.ts ... public settings = [ { name: 'WiFi', state: false}, { name: 'Bluetooth', state: true}, { name: 'Device visibility', state: false} ]; Enhance the component template by adding a switch for each setting and then binding the corresponding property: <!--toggle.component.html--> <igx-switch *ngFor=\"let setting of settings\" [checked]=\"setting.state\"> {{ setting.name }} </igx-switch> Add some styles: :host { display: flex; flex-flow: column nowrap; padding: 16px; } igx-switch { margin-top: 24px; } And the final result should be something like that: Label Positioning You can position the label using the switch's labelPosition property: <igx-switch labelPosition=\"before\"></igx-switch> If the labelPosition is not set, the label will be positioned after the switch. Styling To get started with styling the switch, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Then, we create a new theme that extends the switch-theme and use some of its parameters to style the switch's items: // in styles.scss $custom-switch-theme: switch-theme( $thumb-on-color: #ECAA53, $track-on-color: #F0CB9C ); Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include switch($custom-switch-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include switch($custom-switch-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($custom-switch-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($custom-switch-theme); } Demo API References IgxSwitchComponent IgxSwitchComponent Styles Theming Dependencies IgxRipple Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/tabbar.html": {
    "href": "components/tabbar.html",
    "title": "Angular Bottom Navigation Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Bottom Navigation Component Overview The Ignite UI for Angular Bottom Navigation component enables the user to navigate among a number of content panels displayed in a single view. The navigation through the panels is accomplished with the tab buttons located at bottom of your application. Note igx-tab-bar selector is deprecated. You could use igx-bottom-nav instead. IgxTabBarComponent class is renamed to IgxBottomNavComponent. IgxTabBarModule is renamed to IgxBottomNavModule. Angular Bottom Navigation Example Getting Started with Ignite UI for Angular Bottom Navigation To get started with the Ignite UI for Angular Bottom Navigation component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxBottomNavModule in your app.module.ts file. // app.module.ts ... import { IgxBottomNavModule } from 'igniteui-angular'; // import { IgxBottomNavModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxBottomNavModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxBottomNavComponent as a standalone dependency, or use the IGX_BOTTOM_NAV_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_BOTTOM_NAV_DIRECTIVES, IgxIconComponent } from 'igniteui-angular'; // import { IGX_BOTTOM_NAV_DIRECTIVES, IgxIconComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-bottom-nav> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>library_music</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 1 content.</igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>video_library</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 2 content.</igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>library_books</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 3 content.</igx-bottom-nav-content> </igx-bottom-nav-item> </igx-bottom-nav> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_BOTTOM_NAV_DIRECTIVES, IgxIconComponent] /* or imports: [IgxBottomNavComponent, IgxBottomNavItemComponent, IgxBottomNavHeaderComponent, IgxBottomNavContentComponent, IgxIconComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Bottom Navigation module or directives imported, you can start using the igx-bottom-nav component. Using the Angular Bottom Navigation Our component's template includes the Bottom Navigation and three items. Each item wraps an igx-bottom-nav-header and an igx-bottom-nav-content component which represent respectively the header and the container of the data. Headers usually consist of an icon and an optional text label. The Bottom Navigation control is compatible with the Material Design Icons so to adopt them in your application simply add the Material+Icons import in your 'styles.css' file in the main application folder. Note If you haven't used the igx-icon in your application so far, please make sure to import the IgxIconModule in the app.module.ts before proceeding. // styles.css ... @import url('https://fonts.googleapis.com/icon?family=Material+Icons'); ... <igx-bottom-nav> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>library_music</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 1 content.</igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>video_library</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 2 content.</igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon>library_books</igx-icon> </igx-bottom-nav-header> <igx-bottom-nav-content>This is Item 3 content.</igx-bottom-nav-content> </igx-bottom-nav-item> </igx-bottom-nav> If all went well, you should see the demo sample in your browser. Customizing Bottom Navigation Let's modify the tabs by adding labels alongside the icons and make sure the headers are properly styled. First, define some object arrays for the data source in the component typescript file: public songsList: object[] = [ { title: 'Havana', artist: 'Camila Cabello' }, { title: 'Meant To Be', artist: 'Bebe Rexha & Florida Georgia Line' }, { title: 'New Rules', artist: 'Dua Lipa' }, { title: 'Wolves', artist: 'Selena Gomez & Marshmello' } ]; public moviesList: object[] = [ { title: 'Logan', genre: 'Action, Drama, Sci-Fi' }, { title: 'Wonder Woman', genre: 'Action, Adventure, Fantasy' }, { title: 'Guardians of the Galaxy Vol. 2', genre: 'Action, Adventure, Sci-Fi' }, { title: 'Star Wars: The Last Jedi', genre: 'Action, Adventure, Fantasy' } ]; public booksList: object[] = [ { title: 'Wonder', author: 'R. J. Palacio' }, { title: 'Milk and Honey', author: 'Rupi Kaur' }, { title: 'Giraffes Can\\'t Dance', author: 'Jeff Kinne' }, { title: 'The Getaway', author: 'Selena Gomez & Marshmello' } ]; Next, update the component's template markup as follows: <igx-bottom-nav> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon igxBottomNavHeaderIcon>library_music</igx-icon> <span igxBottomNavHeaderLabel>Songs</span> </igx-bottom-nav-header> <igx-bottom-nav-content> <div class=\"item\" *ngFor=\"let song of songsList\"> <span class=\"item-line1\">{{song.title}}</span><br/> <span class=\"item-line2\">{{song.artist}}</span> </div> </igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon igxBottomNavHeaderIcon>video_library</igx-icon> <span igxBottomNavHeaderLabel>Movies</span> </igx-bottom-nav-header> <igx-bottom-nav-content> <div class=\"item\" *ngFor=\"let movie of moviesList\"> <span class=\"item-line1\">{{movie.title}}</span><br/> <span class=\"item-line2\">{{movie.genre}}</span> </div> </igx-bottom-nav-content> </igx-bottom-nav-item> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon igxBottomNavHeaderIcon>library_books</igx-icon> <span igxBottomNavHeaderLabel>Books</span> </igx-bottom-nav-header> <igx-bottom-nav-content> <div class=\"item\" *ngFor=\"let book of booksList\"> <span class=\"item-line1\">{{book.title}}</span><br/> <span class=\"item-line2\">{{book.author}}</span> </div> </igx-bottom-nav-content> </igx-bottom-nav-item> </igx-bottom-nav> You probably noticed that in addition to placing the icon and the span with the label between the item's header tags, we also attach the igxBottomNavHeaderIcon and the igxBottomNavHeaderLabel directives to them. These directives denote the respective elements and apply the proper styles to them. Finally, add the CSS classes used by the DIV and SPAN elements of the content's template to the component's CSS file: .item { margin-bottom: 5px; } .item-line1 { font-size: 14px; color: gray; } .item-line2 { font-size: 12px; color: darkgray; } igx-bottom-nav-content { padding: 10px; } After these modifications our Bottom Navigation should look similar to this: If having labels and icons in the headers is not enough, you can simply add your custom content between the header tags. Here is an example: <igx-bottom-nav> <igx-bottom-nav-item> <igx-bottom-nav-header> <igx-icon igxBottomNavHeaderIcon>video_library</igx-icon> <span igxBottomNavHeaderLabel>Movies</span> <div> <!-- your custom tab header content goes here --> </div> </igx-bottom-nav-header> <igx-bottom-nav-content> <h1>Tab content</h1> </igx-bottom-nav-content> </igx-bottom-nav-item> </igx-bottom-nav> Integration With Router Outlet Container Despite the primary usage of the Bottom Navigation component is to define tab items with content, there may be cases in which you may need to define tab items with headers only. Probably, the main scenario for such usage is navigation between views using the Angular Router. The following example will demonstrate how to configure the Bottom Navigation component to switch between three components in a single router-outlet. To start we need a main component hosting the Bottom Navigation component and three view components with some content for demonstration purposes. For code snippets' simplicity, the view components will have a very short template but feel free to make them more distinguishable if you need. Also import these view components in your app.module.ts file. // bottomnav-routing.component.ts import { Component } from '@angular/core'; @Component({ selector: 'app-bottomnav-routing', styleUrls: ['bottomnav-routing.component.scss'], templateUrl: 'bottomnav-routing.component.html' }) export class BottomNavRoutingComponent { } @Component({ template: '<p>Item 1 Content</p>' }) export class BottomNavRoutingView1Component { } @Component({ template: '<p>Item 2 Content</p>' }) export class BottomNavRoutingView2Component { } @Component({ template: '<p>Item 3 Content</p>' }) export class BottomNavRoutingView3Component { } The next step is to create the appropriate navigation mappings in the app-routing.module.ts file: import { RouterModule, Routes } from '@angular/router'; import { TabbarRoutingComponent, TabbarRoutingView1Component, TabbarRoutingView2Component, TabbarRoutingView3Component, } from './tabbar-routing.component'; const routes: Routes = [ { path: '', pathMatch: 'full', redirectTo: '/tabbar-routing' }, { path: 'tabbar-routing', component: TabbarRoutingComponent, children: [ { path: 'tabbar-view1', component: TabbarView1Component }, { path: 'tabbar-view2', component: TabbarView2Component }, { path: 'tabbar-view3', component: TabbarView3Component } ] } ]; @NgModule({ exports: [ RouterModule ], imports: [ RouterModule.forChild(routes) ] }) export class TabbarRoutingModule { } Now that we have all navigation routes setup, we need to declare the BottomNavigation component and configure it for routing. Also, make sure to add a router-outlet for rendering the view components' output. <!-- bottomnav-routing.component.html --> <router-outlet></router-outlet> <igx-bottom-nav #tabs1> <igx-bottom-nav-item routerLinkActive #rla1=\"routerLinkActive\" [selected]=\"rla1.isActive\" > <igx-bottom-nav-header routerLink=\"tabbar-view1\"> <igx-icon igxBottomNavHeaderIcon>phone</igx-icon> </igx-bottom-nav-header> </igx-bottom-nav-item> <igx-bottom-nav-item routerLinkActive #rla2=\"routerLinkActive\" [selected]=\"rla2.isActive\" > <igx-bottom-nav-header routerLink=\"tabbar-view2\"> <igx-icon igxBottomNavHeaderIcon>supervisor_account</igx-icon> </igx-bottom-nav-header> </igx-bottom-nav-item> <igx-bottom-nav-item routerLinkActive #rla3=\"routerLinkActive\" [selected]=\"rla3.isActive\" > <igx-bottom-nav-header routerLink=\"tabbar-view3\"> <igx-icon igxBottomNavHeaderIcon>format_list_bulleted</igx-icon> </igx-bottom-nav-header> </igx-bottom-nav-item> </igx-bottom-nav> The above code creates a BottomNavigation component with three tab items. All tab items are having the RouterLinkActive directive applied which tracks whether the linked route is currently active. Please, note, that the RouterLink directive is applied on the header element itself, not on the tab item. If any of these links becomes active, the corresponding tab item will have its selected property set because of the binding to the RouterLinkActive directive's isActive property. This way the selected tab item will always stay synchronized with the current browser's address. The approach described above is used by the following sample to demonstrate routing using the BottomNavigation component: Styles To get started with styling the tabs, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the bottom-nav-theme and accepts various parameters that allow us to style the tab groups. $dark-bottom-nav: bottom-nav-theme( $background: #292826, $active-item-color: #F4D45C ); If we take a look at the bottom-nav-theme, we will notice that there are even more parameters available to us in order to style our bottom navigation component! Note In order to style any additional components that are used as part of an item's content, an additional theme should be created that is specific to the respective component. Including themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include bottom-nav($dark-bottom-nav); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include bottom-nav($dark-bottom-nav); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($dark-bottom-nav); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($dark-bottom-nav); } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $dark-bottom-nav: bottom-nav-theme( $background: color($dark-palette, \"primary\", 400), $active-item-color: color($dark-palette, \"secondary\", 400) ); Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-bottom-nav schema: // Extending the dark bottom nav schema $dark-bottom-nav-schema: extend($_dark-bottom-nav, ( background: ( color: (\"primary\", 400) ), active-item-color: ( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-bottom-nav: $dark-bottom-nav-schema )); // Defining bottom-nav-theme with the global dark schema $dark-bottom-nav: bottom-nav-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxBottomNavComponent IgxBottomNavComponent Styles IgxIconComponent Theming Dependencies IgxIcon Theme IgxRipple Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/tabs.html": {
    "href": "components/tabs.html",
    "title": "Angular Tabs Component | Ignite UI for Angular",
    "keywords": "Angular Tabs Component Overview Ignite UI for Angular Tabs is a full-featured user interface component that has the primary purpose to organize and group related content in a single tabbed view, thus saving space and making content more comprehensible. It packs different features like animations, templating, customization options, and others. Tabs in Angular are extremely useful when you’re building a web page with plenty of content that must be fitted into categories and displayed in a concise and space-efficient way. The igx-tabs component in Ignite UI for Angular is used to organize or switch between similar data sets. It functions as a wrapper for igx-tab-item which respectively represent the container for the data and the tab header. The Angular Tabs Component places tabs at the top and allows scrolling when there are multiple tab items on the screen. Angular Tabs Example This is a basic example of Angular Nested Tabs where we have one tab within another where only one view can be seen at the time. Using nested tabs in Angular, we can display information in a better, structured way. Getting Started with Ignite UI for Angular Tabs To get started with the Ignite UI for Angular Tabs component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTabsModule in your app.module.ts file. // app.module.ts ... import { IgxTabsModule } from 'igniteui-angular'; // import { IgxTabsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxTabsModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTabsComponent as a standalone dependency, or use the IGX_TABS_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_TABS_DIRECTIVES } from 'igniteui-angular'; // import { IGX_TABS_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-tabs> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 1</span> </igx-tab-header> <igx-tab-content> This is Tab 1 content. </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 2</span> </igx-tab-header> <igx-tab-content> This is Tab 2 content. </igx-tab-content> </igx-tab-item> </igx-tabs> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_TABS_DIRECTIVES] /* or imports: [IgxTabsComponent, IgxTabItemComponent, IgxTabHeaderComponent, IgxTabContentComponent, IgxTabHeaderLabelDirective] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Tabs module or directives imported, you can start using the igx-tabs component. Using the Angular Tabs We set the Angular Tabs header by providing content to igx-tab-header. To set the tab's name we simply add a span with igxTabHeaderLabel directive. Any content that will appear as a tab item's content should be added between igx-tab-content tags. <igx-tabs> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 1</span> </igx-tab-header> <igx-tab-content> This is Tab 1 content. </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 2</span> </igx-tab-header> <igx-tab-content> This is Tab 2 content. </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 3</span> </igx-tab-header> <igx-tab-content> This is Tab 3 content. </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 4</span> </igx-tab-header> <igx-tab-content> This is Tab 4 content. </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <span igxTabHeaderLabel>Tab 5</span> </igx-tab-header> <igx-tab-content> This is Tab 5 content. </igx-tab-content> </igx-tab-item> </igx-tabs> If the sample is configured properly, the final result should look like that: Angular Tabs Alignment IgxTabs tabAlignment input property controls how tabs are positioned and arranged. It accepts four different values - start, center, end and justify. Start (default): the width of the tab header depends on the content (label, icon, both) and all tabs have equal padding. First tab is aligned to the tabs container left side. Center: the width of the tab header depends on the content and occupies the tabs container center. If the space is not enough to fit all items, scroll buttons are displayed. End: the width of the tab header depends on the content and all tabs have equal padding. Last tab is aligned to the tabs container right side. Justify: all tab headers are equal in width and fully fit the tabs container. If the space is not enough to fit all items, scroll buttons are displayed. Sample below demostrates how tabs get aligned when switching between tabAlignment property values. Customizing Angular Tabs Let's modify the tabs and make them more appealing by including icons using the igxTabHeaderIcon directive. The igx-tabs component is compatible with the Material Design Icons so it will be very easy to adopt them in your application. Note If you haven't used the igx-icon in your application so far, please make sure to import the IgxIconModule in the app.module.ts before proceeding. First, add the Material Icons in your 'styles.scss' file in the main application folder. Next, add igx-icon with igxTabHeaderIcon directive set, as a child of igx-tab-header. // styles.scss ... @import url('https://fonts.googleapis.com/icon?family=Material+Icons'); ... <igx-tabs> <igx-tab-item> <igx-tab-header> <igx-icon igxTabHeaderIcon>library_music</igx-icon> <span igxTabHeaderLabel>Albums</span> </igx-tab-header> <igx-tab-content> Albums </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <igx-icon igxTabHeaderIcon>favorite</igx-icon> <span igxTabHeaderLabel>Favorite</span> </igx-tab-header> <igx-tab-content> Favorite </igx-tab-content> </igx-tab-item> <igx-tab-item> <igx-tab-header> <igx-icon igxTabHeaderIcon>info</igx-icon> <span igxTabHeaderLabel>Details</span> </igx-tab-header> <igx-tab-content> Details </igx-tab-content> </igx-tab-item> </igx-tabs> If the sample is configured properly, the tabs should look like the following example: If setting the labels and icons is not enough, you can also provide your own custom content directly between igx-tab-header tags. <igx-tabs> <igx-tab-item> <igx-tab-header> <!-- your custom tab content goes here --> <div> <img src=\"https://static.infragistics.com/marketing/Website/products/ignite-ui-landing/ignite-ui-logo.svg\" width=\"80px\" height=\"40px\"> </div> </igx-tab-header> <igx-tab-content> <h1>IgniteUI Rocks!</h1> </igx-tab-content> </igx-tab-item> </igx-tabs> You can also add you own custom tab header's prefix and suffix simply by using igxPrefix and igxSuffix directives. The sample below demonstrates how to add a tab with custom header content and prefix/suffix. Integration With Router Outlet Container Although the igx-tabs component is meant to be used as a list of tabs with content specified for each tab item, there might be cases in which you need to define tab items where the content is separate from the tab content. When defining tab items you have the ability to apply directives to them. For example, you may use this functionality to achieve navigation between views using the Angular Router. The following example will demonstrate how to configure the igx-tabs component to switch between three components in a single router-outlet. To start we need a component to hold our igx-tabs component and three view components with some content for demonstration purposes. For simplicity, the view components have very short templates. import { Component } from '@angular/core'; @Component({ selector: 'app-tabs-routing', styleUrls: ['tabs-routing.component.scss'], templateUrl: 'tabs-routing.component.html' }) export class TabsRoutingComponent { } @Component({ template: '<p>Tab 1 Content</p>' }) export class TabsRoutingView1Component { } @Component({ template: '<p>Tab 2 Content</p>' }) export class TabsRoutingView2Component { } @Component({ template: '<p>Tab 3 Content</p>' }) export class TabsRoutingView3Component { } Next, we create the appropriate navigation mappings in the app-routing.module.ts file: import { RouterModule, Routes } from '@angular/router'; import { TabsRoutingComponent, TabsRoutingView1Component, TabsRoutingView2Component, TabsRoutingView3Component } from './tabs-routing.component'; ... const routes: Routes = [ { path: '', pathMatch: 'full', redirectTo: '/tabs-routing' }, { path: 'tabs-routing', component: TabsRoutingComponent, children: [ { path: 'view1', component: TabsRoutingView1Component }, { path: 'view2', component: TabsRoutingView2Component }, { path: 'view3', component: TabsRoutingView3Component }, ] } ]; @NgModule({ exports: [RouterModule], imports: [RouterModule.forRoot(appRoutes)] }) export class AppRoutingModule { } Now that we have all navigation routes set up, we need to declare the igx-tabs component and configure it for routing. Make sure to add a router-outlet for rendering the view components. <!-- tabs-routing.component.html --> <igx-tabs #tabs1> <igx-tab-item routerLinkActive #rla1=\"routerLinkActive\" [selected]=\"rla1.isActive\" > <igx-tab-header routerLink=\"view1\"> <span igxTabHeaderLabel>Tab 1</span> </igx-tab-header> </igx-tab-item> <igx-tab-item routerLinkActive #rla2=\"routerLinkActive\" [selected]=\"rla2.isActive\" > <igx-tab-header routerLink=\"view2\"> <span igxTabHeaderLabel>Tab 2</span> </igx-tab-header> </igx-tab-item> <igx-tab-item routerLinkActive #rla3=\"routerLinkActive\" [selected]=\"rla3.isActive\" > <igx-tab-header routerLink=\"view3\"> <span igxTabHeaderLabel>Tab 3</span> </igx-tab-header> </igx-tab-item> </igx-tabs> <router-outlet></router-outlet> The above code creates an igx-tabs component with three tab items. Each tab item's header has the RouterLink directive applied, which is used to specify the routing link used for the navigation. If any of the links becomes active, the corresponding tab item will have its selected property set because of the binding to the RouterLinkActive directive's isActive property. This way the selected tab item will always be synchronized with the current url path. Note Please note that the routerLink directive is set to the igx-tab-header, not directly to the igx-tab-item. Styles To get started with styling the tabs, we need to import the theming module, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the tabs-theme and accepts various properties that allow us to style the tab groups. $dark-tabs: tabs-theme( $item-text-color: #F4D45C, $item-background: #292826, $item-hover-background: #F4D45C, $item-hover-color: #292826, $item-active-color: #F4D45C, $item-active-icon-color: #F4D45C, $indicator-color: #F4D45C, $tab-ripple-color: #F4D45C ); If we take a look at the tabs-theme, we will notice that there are even more properties available to us in order to style our tabs. Note In order to style any component used as part of a tab content, additional themes should be created specific to the respective component. The last step is to include the component theme in our application. @include css-vars($dark-tabs); If you are targeting browsers that don't support CSS variables, like IE 11, you can use the theme component mixin to overwrite its default theme: :host { ::ng-deep { @include tabs($dark-tabs); } } Palettes & Colors Instead of hardcoding the color values, like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #292826; $dark-palette: palette( $primary: $black-color, $secondary: $yellow-color, $grays: #fff ); We can easily retrieve any color from the palette using igx-color. $dark-tabs: tabs-theme( $palette: $dark-palette, $item-text-color: color($dark-palette, \"secondary\", 400), $item-background: color($dark-palette, \"primary\", 400), $item-hover-background: color($dark-palette, \"secondary\", 400), $item-hover-color: color($dark-palette, \"primary\", 400), $item-active-color: color($dark-palette, \"secondary\", 400), $item-active-icon-color: color($dark-palette, \"secondary\", 400), $indicator-color: color($dark-palette, \"secondary\", 400), $tab-ripple-color: color($dark-palette, \"secondary\", 400) ); API References IgxIconComponent IgxNavbarComponent IgxTabsComponent IgxTabsComponent Styles IgxTabItemComponent IgxTabHeaderComponent IgxTabContentComponent Theming Dependencies IgxIcon Theme IgxRipple Theme IgxButton Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/texthighlight.html": {
    "href": "components/texthighlight.html",
    "title": "Angular Text Highlight Directive | Ignite UI for Angular",
    "keywords": "Angular Text Highlight Directive Overview The IgxTextHighlightDirective and IgxTextHighlightService in Ignite UI for Angular are used to highlight parts of a text, providing options for case sensitive searches and to highlight only exact matches. They allow the developer to keep an active highlight, which can be any of the already highlighted parts. Angular Text Highlight Directive Example Getting Started with Ignite UI for Angular Text Highlight Directive To get started with the Ignite UI for Angular Text Highlight directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTextHighlightModule in your app.module.ts file. // app.module.ts ... import { IgxTextHighlightModule } from 'igniteui-angular'; // import { IgxTextHighlightModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [IgxTextHighlightModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTextHighlightDirective as a standalone dependency. // home.component.ts import { IgxTextHighlightDirective, IgxTextHighlightService } from 'igniteui-angular'; // import { IgxTextHighlightDirective, IgxTextHighlightService } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <div igxTextHighlight [value]=\"html\" [groupName]=\"'group1'\" [containerClass]=\"'search-text'\" class=\"search-text\"> {{html}} </div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxTextHighlightDirective] }) export class HomeComponent { constructor(public textHighlightService: IgxTextHighlightService) {} } Now that you have the Ignite UI for Angular Text Highlight module or directive imported, you can start using the igxTextHighlight. Using the Angular Text Highlight Directive Let's create a search box that we can use to highlight different parts of the text. We will use Ignite UI for Angular's InputGroup component in which we will add a text input with buttons for clear matches, find next, find previous, and a button for specifying whether the search will be case-sensitive or not. Also it has a label for how many matches we have found. <div class=\"search-container\"> <igx-input-group type=\"search\" class=\"input-group\"> <igx-prefix> <igx-icon *ngIf=\"searchText.length == 0\">search</igx-icon> <igx-icon *ngIf=\"searchText.length > 0\" (click)=\"clearSearch()\">clear</igx-icon> </igx-prefix> <input #search1 id=\"search1\" igxInput placeholder=\"Search\" autocomplete=\"off\" [(ngModel)]=\"searchText\" (ngModelChange)=\"onTextboxChange()\" (keydown)=\"searchKeyDown($event)\" /> <igx-suffix> <div class=\"caseSensitiveButton\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"updateSearch()\" [style.background]=\"caseSensitive ? 'rgb(73, 180, 254)' : 'transparent'\"> <igx-icon class=\"caseSensitiveIcon\" fontSet=\"material\">text_fields</igx-icon> </button> </div> <ng-container *ngIf=\"searchText.length > 0\"> <span> <ng-container *ngIf=\"matchCount > 0\"> {{ index + 1 }} of {{ matchCount }} results </ng-container> <ng-container *ngIf=\"matchCount == 0\"> No results </ng-container> </span> </ng-container> <div class=\"searchButtons\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"findPrev()\" [disabled]=\"!canMoveHighlight\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> <button igIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"findNext()\" [disabled]=\"!canMoveHighlight\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </div> </igx-suffix> </igx-input-group> </div> Then, we will add a div with text and the IgxTextHighlight directive. Note that, since we need to bind the value input to the text in the div, we will also use interpolation for the div's text. <div igxTextHighlight [value]=\"html\" [groupName]=\"'group1'\" [containerClass]=\"'search-text'\" class=\"search-text\"> {{html}} </div> In the .ts file of our component first we need to add the following fields, that are used for bindings in our component's template: @Component({ ... }) export class HomeComponent { public html = '...'; @ViewChild(IgxTextHighlightDirective, {read: IgxTextHighlightDirective}) public highlight: IgxTextHighlightDirective; public searchText: string = ''; public matchCount: number = 0; public caseSensitive: boolean = false; public index: number = 0; public get canMoveHighlight() { return this.matchCount > 1; } } Then we need to add the following methods which will allow the user to apply the highlights for the text they have typed in the search box and to move the active highlight around. @Component({ ... }) export class HomeComponent { constructor(public textHighlightService: IgxTextHighlightService) {} public searchKeyDown(ev) { if (this.searchText) { if (ev.key === 'Enter' || ev.key === 'ArrowDown' || ev.key === 'ArrowRight') { ev.preventDefault(); this.findNext(); } else if (ev.key === 'ArrowUp' || ev.key === 'ArrowLeft') { ev.preventDefault(); this.findPrev(); } } } public onTextboxChange() { this.index = 0; this.find(0); } public updateSearch() { this.caseSensitive = !this.caseSensitive; this.find(0); } public clearSearch() { this.searchText = ''; this.find(0); } private findNext() { this.find(1); } private findPrev() { this.find(-1); } private find(increment: number) { if (this.searchText) { this.matchCount = this.highlight.highlight(this.searchText, this.caseSensitive); this.index += increment; this.index = this.index < 0 ? this.matchCount - 1 : this.index; this.index = this.index > this.matchCount - 1 ? 0 : this.index; if (this.matchCount) { this.textHighlightService.setActiveHighlight('group1', { columnIndex: 0, index: this.index, page: 0, rowIndex: 0 }); } } else { this.highlight.clearHighlight(); } } } If the sample is configured properly, the final result should look like that: Search across multiple elements The igxTextHighlight allows you to search across multiple elements which all share one active highlight. This is done by having the same groupName value across multiple TextHighlight directives. In order to setup the sample we will reuse the search box from the previous sample, but this time we will add two div elements. The column and row inputs are useful when you have multiple elements and in our case the second div has a different row value. <div igxTextHighlight [groupName]=\"'group1'\" [row]=\"0\" [containerClass]=\"'search-text'\" [value]=\"firstParagraph\" class=\"search-text\"> {{firstParagraph}} </div> <div igxTextHighlight [groupName]=\"'group1'\" [row]=\"1\" [containerClass]=\"'search-text'\" [value]=\"secondParagraph\" class=\"search-text\"> {{secondParagraph}} </div> In the .ts file we have the firstParagraph and secondParagraph fields, which are bound to the respective value inputs of the text highlight directives. Also, we will now use ViewChildren instead of ViewChild to get all the highlights in our template. public firstParagraph = \"...\"; public secondParagraph = \"...\"; @ViewChildren(IgxTextHighlightDirective) public highlights; All the rest of the code in the .ts file is identical to the single element example with the exception of the find method. Changes to this method are necessary since we now have multiple elements, but the code there can be used regardless of the number of TextHighlight directives you have on your page. @Component({ ... }) export class HomeComponent { constructor(public textHighlightService: IgxTextHighlightService) {} private find(increment: number) { if (this.searchText) { let count = 0; const matchesArray = []; this.highlights.forEach((h) => { count += h.highlight(this.searchText, this.caseSensitive); matchesArray.push(count); }); this.matchCount = count; this.index += increment; this.index = this.index < 0 ? this.matchCount - 1 : this.index; this.index = this.index > this.matchCount - 1 ? 0 : this.index; if (this.matchCount) { let row; for (let i = 0; i < matchesArray.length; i++) { if (this.index < matchesArray[i]) { row = i; break; } } const actualIndex = row === 0 ? this.index : this.index - matchesArray[row - 1]; this.textHighlightService.setActiveHighlight('group1', { index: actualIndex, rowIndex: row }); } } else { this.highlights.forEach((h) => { h.clearHighlight(); }); this.matchCount = 0; } } } Styles The IgxTextHighlight directive can be styled in terms of changing the color and the background of all occurrences of the given string. To get started, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the highlight-theme and accepts the $resting-background, $resting-color, $active-background and the $active-color parameters. $dark-highlight: highlight-theme( $resting-background: #FFCD0F, $resting-color: #292826, $active-background: #292826, $active-color: #FFCD0F ); The $resting-background and the $resting-color parameters will be applied to all highlighted occurrences, except for the active highlighted string, which will be styled based on the $active-background and the $active-color parameters. The last step is to include the newly created theme. If $legacy-support is set to true, include the component theme like that: @include highlight($dark-highlight); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include highlight($dark-highlight); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($dark-highlight); Note Keep in mind that by default the $legacy-support is set to false Custom styles Let's say we want to provide an even richer styling to our highlighted text parts. In order to do this, we can take advantage of the cssClass and the activeCssClass inputs of the IgxTextHighlight directive. We can combine these classes with the styles from the highlight-theme and provide an awesome experience to our users! All we have to do is create a couple of css classes with some properties and attach them by using the inputs from above: <div igxTextHighlight [cssClass]=\"'custom-highlight'\" [activeCssClass]=\"'custom-active-highlight'\"> {{html}} </div> // cssClass .custom-highlight { border: 1px solid #FFCD0F; } // activeCssClass .custom-active-highlight { box-shadow: 0 0 3px 0 rgba(0,0,0,0.75); } As mentioned earlier, we can even combine them with a theme: :host { ::ng-deep { @include highlight($dark-highlight); // cssClass .custom-highlight { border: 1px solid #FFCD0F; } // activeCssClass .custom-active-highlight { box-shadow: 0 0 3px 0 rgba(0,0,0,0.75); } } } Demo API References For more detailed information regarding the TextHighlight directive's API, refer to the following link: IgxTextHighlight API Additional components that were used: IgxInputGroupComponent IgxInputGroupComponent Styles Additional Resources Grid Search Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes.html": {
    "href": "components/themes.html",
    "title": "Theming Component - Native Angular | Ignite UI for Angular",
    "keywords": "Themes With only a few lines of code, users can easily change the theming for their components. Being developed through SASS, the API use is low-difficulty and offers restyling of one component, multiple components, or the entire suite. The Essence of a Theme Since IgniteUI for Angular bases its component designs on the Material Design Guidelines, we try to get as close as possible to colors, sizes, and overall look and feel of our components to those created by Google. Our approach to theming is based around several simple concepts. Palettes The first concept is the one of palettes of colors. As in any visual tool, colors are the main difference between one application and another. The Material Design Guidelines prescribe predefined palettes of colors that range in hue and lightness for a base color. There's a good reason for that. They really want to ensure good color matching and contrast between the background colors and the foreground text colors. This is great, but limiting at the same time. If you wanted to have your own custom palette that matches your branding, you would be out of luck. We recognize this is a problem, so we invented an algorithm that would generate Material-like palettes from base colors you provide. Even more, we also generate contrast text colors for each hue in the palette. Themes The second concept is the one of themes. Palettes, wouldn't do much good if they weren't used by a theme. So we have themes for each component, and a global one, that styles the entire application and every component in it. You simply pass your generated palette to the global theme, we take care of the rest. You can, of course, style each component individually to your liking. We will take a closer look at how to do that later in this article. Typography The last concept revolves around typography. Although we have a default typeface choice, we really want to give you the power to style your application in every single way. Typography is such an important part of that. We provide a method for changing the font family, the sizes and weights for headings, subheadings and paragraph texts in your app. Note Theming requires Sass. Generating Color Palettes Our theming library is based on Sass. If you used the Ignite UI CLI to bootstrap your app, you can specify the style in the angular-cli.json config to scss, the CLI will take care of compiling the Sass styles for you. If you haven't used Ignite UI CLI then you have to configure your builder to compile Sass styles for you. Our palettes accept arguments for primary, secondary, info, success, warn, and error colors. The primary color is the one that will be the more prominent color throughout your application. The secondary color is the one used on elements that are actionable, such as buttons, switches, sliders, etc. The only required arguments we require, though, are the ones for primary and secondary colors. We default the ones for info, success, warn, and error to a predefined set of our choosing. To get started with our first color palette, create an scss file that would be the base file for your global theme. I will call mine \"my-app-theme.scss\". @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $company-color: #2ab759; // Some green shade I like $secondary-color: #f96a88; // Watermelon pink $my-color-palette: palette( $primary: $company-color, $secondary: $secondary-color, ); Now we have a palette, that contains exactly 74 colors! Whoa, wait, what? How did that happen? You provided 2 and got 74? Where did the other 72 colors come from? Let's stop here to explain what just happened as it's quite important. When you provided primary and secondary colors, we took those and generated shades and accent colors for each one. Basically now in your palette you have 2 sub-palettes for primary and secondary colors. Each sub-palette contains 12 additional color variations based on the original color. 4 of the 12 colors are lighter shades of your original color, and 4 are darker. The remaining 4 colors are more exaggerated 'accent' versions of the original color. With the original color that makes for a total of 13 colors in each palette. With so many colors in each sub-palette you may be wondering, how on Earth will I know which one is which, right? It's quite simple, really. Each of the colors in the sub-palette has a number. We assign the number 500 to the original color. The lighter shades start from 100 and range to 400. The darker shades start from 600 and range to 900. The accent colors have string names A100, A200, A400, and A700, respectively. Okay, but now that's only 26 out of 72. Don't worry, there's another sub-palette we give you. One that consists of gray 'colors', called grays. It's just like the other two color sub-palettes, but doesn't include any accent variations. Good, now we're up to 26 + 9 for a total of 35 colors. That is still a long way from 74. Where do the other 39 colors come from? Let's solve the final puzzle. Remember you can also have 4 additional colors for info, success, warn and error. So that leaves another 35 colors unaccounted for. Remember the count for the primary, secondary, and grays sub-palettes was exactly 35? The other 35 remaining colors are contrast text colors for each of the colors in the primary, secondary, and grays sub-palettes. Got it? Good! But how does one access any of the colors in the palette? Getting Sub-Palette Colors We provide a function that is easy to remember and use igx-color. It takes three arguments - palette, color, and variant; $my-primary-600: color($my-palette, \"primary\", 600); $my-primary-A700: color($my-palette, \"secondary\", \"A700\"); $my-warning-color: color($my-palette, \"warn\"); // sample usage .my-awesome-class { background: $my-primary-600; border-color: $my-primary-A700; } .warning-bg { background: $my-warning-color; } Getting Contrast Text Colors Similar to how we get sub-palette colors, there's a way to get the contrast text color for each of the colors in the sub-palettes. $my-primary-800: color($my-palette, \"primary\", 600); $my-primary-800-text: contrast-color($my-palette, \"primary\", 600); // sample usage .my-awesome-article { background: $my-primary-800; color: $my-primary-800-text; } Generating a Theme If you've included the \"igniteui-angular.css\" file in your application project, now is a good time to remove it. We are going to use our own \"my-app-theme.scss\" file to generate our own theme. Let's start from our very first example on this page. This time, though, we're going to be including two mixins core and theme; For now core doesn't accept any arguments. theme, however, does accept 2 - $palette and $exclude. For now, we'll only talk about the $palette argument. We'll take a deeper look at what $exclude does later on when we talk about individual component themes. Important Including core before theme is essential. The core mixin provides all base definitions needed for theme to work. // Import the IgniteUI themes library first @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $company-color: #2ab759; // Some green shade I like $secondary-color: #f96a88; // Watermelon pink $my-color-palette: palette( $primary: $company-color, $secondary: $secondary-color, ); // IMPORTANT: Make sure you always include core first! @include core(); // Pass the color palette we generated to the theme mixin @include theme($my-color-palette); That's it. Your application will now use the colors from your newly generated palette. Customizing Typography (WIP) In its current state, the defining custom typography is limited to changing the font family of the application. We'll be updating this functionality with subsequent releases. Our intent is to provide a robust way to customize the typography in your application. To customize the typography use the typography mixin. It takes exactly one argument - config. Important Including typography after core is essential. This is subject to change in future releases. // Import the IgniteUI themes library first @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; // IMPORTANT: Make sure you always include core first! @include core(); // Include typography before theme @include typography( $config: ( font-family: \"Comic Sans MS\", ) ); @include theme($default-palette); View page on GitHub"
  },
  "components/themes/elevations.html": {
    "href": "components/themes/elevations.html",
    "title": "Elevations (Shadows)",
    "keywords": "Elevations Elevations are used to establish and maintain functional boundaries between Document Object Model trees to enable better functional encapsulation. The implementation of the Elevations in Ignite UI for Angular is modeled after the Elevations in Material Design. Overview Shadows in Ignite UI for Angular closely follow the Material Design guidelines for establishing depth hierarchy based on 25 elevation levels. The size of the shadow cast is related to the elevation level number. The higher the elevation level number, the larger the shadow will be. Elevations in Ignite UI for Angular are exposed as CSS variables. Each variable stores a set of 3 box-shadows. These box-shadows represent the umbra, penumbra, and antumbra elements that are the properties of shadows as observed in the real world. Here's a list of resting elevations as used in various components in Ignite UI for Angular in the Material Theme and their corresponding CSS variable names: Component Default Elevation Level CSS Variable banner, button, toast 0 --ig-elevation-0 badge, carousel buttons, search input 1 --ig-elevation-1 button group, contained button, card, grid, switch 2 --ig-elevation-2 navbar, snackbar 4 --ig-elevation-4 floating action button, 6 --ig-elevation-6 bottom navigation, ghost chip, dropdown 8 --ig-elevation-8 navdrawer 16 --ig-elevation-16 dialog 24 --ig-elevation-24 As you can see from the CSS Variable column, all elevations are defined in the following format --ig-elevation-[level]. As mentioned, the elevation level number go from 0 through 24(inclusive). Usage To begin using elevations in your own components all you need is to reference the variable name of the desired level. .floaty-element { box-shadow: var(--ig-elevation-6); } Changing the elevation in an existing component theme works similarly. [igxButton=\"contained\"] { --resting-shadow: var(--ig-elevation-4); --hover-shadow: var(--ig-elevation-12); --focus-shadow: var(--ig-elevation-12); } The documentation for each component theme lists the default elevation used in each of its states. If elevation is not listed, the component doesn't use any of the predefined elevation levels. Defining Elevations Updating the default elevations works in a way similar to how palette colors are updated. You simply need to reassign the variable to a different value. With elevations, make sure the value is a box-shadow. Example: /* styles.css */ :root { --ig-elevation-1: 0 2px 6px 0 rgba(0, 0, 0, .18); --ig-elevation-2: 0 3px 9px 0 rgba(0, 0, 0, .24); } Now, all components that use elevation levels 1 and 2 will have their shadows updated. Shadowing You can shadow the globally set elevations for a specific scope only. We already saw that the button component uses elevation level 2 for its resting state. Level 2 is also used by the card and grid components. So to change the shadows for all three, all you need to do is: [igxButton=\"contained\"], igx-grid, igx-card { --ig-elevation-2: 0 3px 9px 0 rgba(0, 0, 0, .24); } This will set the --resting-shadow in the contained button and card, and the --grid-shadow in the grid, to the value assigned to --ig-elevation-2; Elevations can be created and consumed in a more powerful way using Sass as well. Check out the related topics below to learn more. Additional Resources Related topics: Elevations with Sass Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/index.html": {
    "href": "components/themes/index.html",
    "title": "Theming Engine - Angular | Ignite UI for Angular",
    "keywords": "Theming Ignite UI for Angular allows you to modify the styles of all component themes using CSS variables. If you really wanted to dig deep, we provide a powerful Sass theming engine that allows you to create global component themes tailored to your specific design language that work in all modern browsers. Note This document describes the theming system in Ignite UI for Angular from version 12 forward. Starting with version 12 CSS variables are the recommended way to modify the global and component themes. You can still use the Sass theming library as you would've prior to version 12. Basic Usage Ignite UI for Angular includes the following themes as part of its package: - Material - Bootstrap - Fluent - Indigo All themes have light and dark variants as well as support for left-to-right(LTR) and right-to-left(RTL) content by default. The easiest way to start using any of the bundled themes in your application is by specifying the path to a CSS theme file in your angular.json configuration. For example, if you wanted to use the dark Material theme, you would include the path to the theme file like so: \"styles\": [ \"node_modules/igniteui-angular/styles/igniteui-angular-dark.css\", \"src/styles.css\" ] Note If you've installed the Ignite UI for Angular package using ng add igniteui-angular, you will have noticed that we've already added igniteui-angular.css to the styles array. Here's the full list of themes included in the styles folder: Theme Name Path Material Light node_modules/igniteui-angular/styles/igniteui-angular.css Material Dark node_modules/igniteui-angular/styles/igniteui-angular-dark.css Bootstrap Light node_modules/igniteui-angular/styles/igniteui-bootstrap-light.css Bootstrap Dark node_modules/igniteui-angular/styles/igniteui-bootstrap-dark.css Material Dark Green node_modules/igniteui-angular/styles/igniteui-dark-green.css Fluent Light node_modules/igniteui-angular/styles/igniteui-fluent-light.css Fluent Dark node_modules/igniteui-angular/styles/igniteui-fluent-dark.css Fluent Light Excel node_modules/igniteui-angular/styles/igniteui-fluent-light-excel.css Fluent Dark Excel node_modules/igniteui-angular/styles/igniteui-fluent-dark-excel.css Fluent Light Word node_modules/igniteui-angular/styles/igniteui-fluent-light-word.css Fluent Dark Word node_modules/igniteui-angular/styles/igniteui-fluent-dark-word.css Indigo Light node_modules/igniteui-angular/styles/igniteui-indigo-light.css Indigo Dark node_modules/igniteui-angular/styles/igniteui-indigo-dark.css As you can see, we ship Ignite UI for Angular with a substantial amount of themes. This is not the end of our theming story, though. All themes are compiled from Sass source and are built using our powerful theming engine. This engine contains Sass mixins and functions many of which are publicly exposed, which allows you to completely redesign all components in your application. If Sass isn't your thing that's completely fine, we've made it easy to modify the compiled themes using custom CSS properties, or otherwise known as CSS variables. You can still use Sass in combination with CSS variables. Global Variables If you inspect any of the CSS themes above, you will notice that there are quite a few CSS variables included in the :root scope; We include variables for colors, shadows, typography, and configuration. Modifying any of these variables will allow you to customize the overall look and feel of the theme and conversely the components. What most people look for when modifying a theme is changing the default colors used by the components. If you wanted to change the primary and secondary colors, all you have to do is type the following in your styles.css file: /* styles.css */ :root { --ig-primary-h: 105deg; --ig-primary-s: 29%; --ig-primary-l: 56%; --ig-secondary-h: 259deg; --ig-secondary-s: 63%; --ig-secondary-l: 24%; } Let's break down the names of these color variables. The ig prefix is there as a unique identifier to indicate that this variable is part of an Ignite UI for Angular theme, primary is the name of the color palette, and h, s, and l stand for hue, saturation, and lightness. We will take a deeper look at palettes in the Palettes section of the documentation. For now all you need to know is that we have several base colors (primary, secondary, success, info, etc.) that include different shades or variants that are all generated from the hue, saturation, and lightness CSS variables, The 500 color variants are considered the main representation values for hue, saturation, and lightness. For instance, the primary 500 color variant is declared as --ig-primary-500: hsla(var(--ig-primary-h), var(--ig-primary-s), var(--ig-primary-l), var(--ig-primary-a)). Following this approach, you can completely overhaul the entire palette. Warning Some components do not use colors from the palettes. In those instances, you will have to target the component CSS variables directly to modify their colors. To find out which palette colors are used by what component, take a look at the Components Documentation. Likewise, changing the elevations(shadows) is just as easy. We include 25 elevation levels (0-24). Here's a simplified version of what those variables look like: /* styles.css */ :root { --ig-elevation-0: none; --ig-elevation-1: 0 1px 3px 0 rgba(0, 0, 0, 0.26), 0 1px 1px 0 rgba(0, 0, 0, 0.12), 0 2px 1px -1px rgba(0, 0, 0, 0.08); /* ... */ --ig-elevation-24: 0 11px 15px -7px rgba(0, 0, 0, 0.26), 0 24px 38px 3px rgba(0, 0, 0, 0.12), 0 9px 46px 8px rgba(0, 0, 0, 0.08); } These are essentially stacked CSS box-shadow declarations. You can replace them with any other valid box-shadow value. The higher the elevation level number is, the bigger the shadow is. Again, different components use different elevation levels, to find out which elevation levels are used by which component, take look at the Components Documentation. We will take a deeper look at elevations in the Elevations of the documentation. Configuration There are several variables that allow you to configure the global behavior of the theme: Roundness To configure the radius factor of all components you can change the value of the --ig-radius-factor variable. The default value is 1, meaning the default radius factor is used across component themes. Example: /* Makes all components appear blocky in shape */ :root { --ig-radius-factor: 0; } Elevation Factor To configure the elevation factor of all components you can change the value of the --ig-elevation-factor variable. The default value is 1, meaning the default elevations are used across component themes. Example: /* Makes all components appear flat (no-shadows) */ :root { --ig-elevation-factor: 0; } Component Variables All components provide the ability to modify their themes using component-specific CSS variables. Each component exposes two variables that modify the same property. The exposed variables can be thought of as global and local. They both modify the component theme in the same way, the only difference is that global variables have the igx-[component-name] prefix attached to the variable name and can be used from parent selectors to style child components, while local variables are specific to a component instance. Let's look at an example. Say you wanted to modify the background of the avatar. The avatar looks for the following CSS variables that modify its background: /* styles.css */ :root { --igx-avatar-background: black; } igx-avatar { --background: orange; } The snippet above will set the background in all avatars to orange. The avatar component will look for the --background variable first. If explicitly set, it will take its value. In other words, local variables have higher priority and will work only if applied to the igx-avatar directly, either by using its tag selector or any other selector that targets igx-avatar. The global --igx-avatar-background can be thought of as fallback variable. It's going to be used only if the local --background is not explicitly overridden. For the curious, here's how this is implemented internally in the avatar: igx-avatar { --background: var(--igx-avatar-background, var(--ig-gray-400)); background: var(--background); } You would generally use global variables when you want to apply changes to all instances of a component while local variables target specific component instances and will always override the global variable. Here's another example: <!-- app.component.html --> <igx-avatar>AB</igx-avatar> <igx-avatar>CD</igx-avatar> <app-contacts></app-contacts> <!-- contacts.component.html --> <igx-avatar>EF</igx-avatar> <igx-avatar>GH</igx-avatar> /* styles.css */ :root { --igx-avatar-background: lavender; } /* contacts.component.css */ igx-avatar { --background: purple; } Avatars AB and CD will use the globally set lavender color as background, while avatars EF and GH will have purple backgrounds. Each component has all of its theme properties documented in the styling section of the component documentation. This should be all you need to get you started with theming. You can modify global palette colors, elevations, and change component theme properties by creating global and local component themes. If you want to learn more, we have extensive documentation covering topics like Palettes, Elevations, Typography, and Theming with Sass in depth. Additional Resources Related topics: Palettes Elevations Typography Theming with Sass Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/misc/angular-material-theming.html": {
    "href": "components/themes/misc/angular-material-theming.html",
    "title": "Angular Material Theming",
    "keywords": "Angular Material Theming The Ignite UI for Angular theming engine makes it easy to be used together with external components imported from other theming libraries like the Angular Material library. Ignite UI and Angular Material Overview Angular Material is a UI component library for mobile and desktop Angular web applications. It includes several prebuilt themes and a great number of components that are based on the Material Design specification. The Ignite UI for Angular is a complete set of Material-based UI Widgets, Components & Sketch UI kits and supporting directives for Angular that enables developers to build modern high-performance apps. Our theming engine is easy to use and allows theming granularity on different levels from a single component, multiple components, or the entire suite. Furthermore, it can be used to style components from other theming libraries with very little effort. The following article demonstrates how to use both Ignite UI and Angular Material components in one application and how to style them to look similar. Angular Material Theming Example Getting Started with Ignite UI and Angular Material How to install Angular Material If you are using Angular CLI and have an existing Angular project, you can add Angular Material with the command below: ng add @angular/material Then, you will have to choose one of the prebuilt themes and whether to set up global typography styles and browser animations for Angular Material. Once you're done with this configuration, your application is ready to use the Angular Material components. You can find more information about using the Angular Material library at their official documentation. How to install Ignite UI for Angular To install the Ignite UI for Angular package along with all of its dependencies, font imports, and styles references, run the following command in your project: ng add igniteui-angular Then, you can use the Ignite UI components by importing their respective modules in your app.module.ts file: // manually addition of the Igx Avatar component import { IgxAvatarModule } from 'igniteui-angular'; // import { IgxAvatarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ..., IgxAvatarModule, ... ] )} Follow our Getting Started topic for a complete introduction about using Ignite UI for Angular in existing projects. Further information on how to import and use each of our components along with guided examples can be found in the component's documentation. Ignite UI and Angular Material components Let's see how our demo sample is done. It is a mixture of Ignite UI and Angular Material components, styled to fit nicely in one application. The navigation in our example is created using the material mat-toolbar together with igx-buttons and igx-avatar. The menu under the Campaigns button is also taken from the Angular Material library. Below the nav, we are using the igx-card component to display some statistics. Within the cards, we have placed multiple items - igx-avatars and igx-icons as well as material buttons. Clicking on the More buttons, you will see the igx-dialog: Next, we have added an igx-expansion-panel showing information about some credit cards. Inside its content, there are mat-sliders, an igx-divider and a mat-stepper with mat-form-fields. Finally, we inserted an Ignite UI for Angular icon button in the top right corner, that changes the theme of the whole app: Styling Angular Components To get started with styling components using the Ignite UI theming engine, create an scss file named of your choice that would be the base file for your global theme. We will call this file _variables.scss. Next, we need to import the Ignite UI and Angular Material index files: // _variables.scss ```scss @use \"igniteui-angular/theming\" as *; @use \"@angular/material\" as mat; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Color Palettes Ignite UI for Angular's igx-palette function produces a color palette map including three sub-palettes for the primary, secondary and gray shades as well as five additional colors for info, success, warn, error and surface. For each color variant, our theming engine automatically generates text contrast colors at build-time, that are also included in the palette. Below, you can see the predefined light material palette: $igx-light-palette: palette( $primary: #09f, $secondary: #e41c77 $info: #1377d5, $success: #4eb862, $warn: #fbb13c, $error: #ff134a, $gray: #000, $surface: #fff ); Unlike Ignite UI palettes, Angular Material color palette maps include shades for only one color and their corresponding contrast colors. For example, we can see the $mat-purple palette: $light-primary-text: white; $dark-primary-text: rgba(black, 0.87); $mat-purple: ( 50: #f3e5f5, 100: #e1bee7, ..., A700: #aa00ff, contrast: ( 50: $dark-primary-text, 100: $dark-primary-text, ..., A700: $light-primary-text, ) ); Generating Theme Palettes To define a theme palette, we will have to use the material define-palette function which generates a map of hues to colors. In our sample, we want to style Angular Material components with Ignite UI theme therefore we need to transform our $light-material-palette according to their structure. To achieve this, we are going to create a Sass function with parameters for $color, $saturations and $palette that returns a map of all color variants followed by the contrast colors. The saturations we are using follow the Material Design color system. $saturations: (50, 100, 200, 300, 400, 500, 600, 700, 800, 900, A100, A200, A400, A700); @function material-like-palette( $color, $saturations, $palette, ) { $shade: (); $contrast: (); $result: (); @each $saturation in $saturations { $shade: map-merge($shade, ( $saturation: color($palette, $color, $saturation) )); $contrast: map-merge($contrast, ( $saturation: color($palette, $color, #{$saturation}-contrast) )); $result: map-merge($shade, (contrast: $contrast)); } @return $result; } Light Theme Palette We will define a light primary material theme palette using the primary color of the Ignite UI $igx-light-palette and our newly created material-like-palette function. The result has to be passed as a parameter to the define-palette function which will generate color values for the default, lighter, darker and text shades and add them to the palette map: $light-palette-primary: mat.define-palette( material-like-palette('primary', $saturations, $igx-light-palette)); Let's do the same for the light accent palette: $light-palette-accent: mat.define-palette( material-like-palette('secondary', $saturations, $igx-light-palette)); Finally, we are ready to pass the two color palettes to the define-light-theme function which will create an Angular Material theme with colors taken from the Ignite UI material color palette: $custom-mat-light-theme: mat.define-light-theme(( color: ( primary: $light-palette-primary, accent: $light-palette-accent ) )); Note Visit our palettes with Sass section to discover more about the palettes provided by Ignite UI for Angular and learn how to create a new one. Dark Theme Palette Following the previous approach, we are going to create material palettes for the dark mode. This time, we are also going to define a custom igx-palette: // Custom palette $custom-dark-palette: palette( $primary: #206094, $secondary: #72da67, $surface: #222, $info: #1377d5, $success: #4eb862, $warn: #fbb13c, $error: #ff134a, ); // Material dark primary palette $dark-palette-primary: mat.define-palette( material-like-palette('primary', $saturations, $custom-dark-palette)); // Material dark accent palette $dark-palette-accent: mat.define-palette( material-like-palette('secondary', $saturations, $custom-dark-palette)); // Material dark theme $custom-mat-dark-theme: mat.define-dark-theme(( color: ( primary: $dark-palette-primary, accent: $dark-palette-accent ) )); Themes In order to switch between light and dark mode, we are adding a custom dark class which will be changed on button click. In our stylesheet file, we are going to include different color palettes scoped to each class. Ignite UI for Angular comes with predefined themes inspired by the Material Design. To use them, first, you have to include our core mixin and then our built-in theme mixin - theme. We will also make use of our predefined material palettes - $light-material-palette and $dark-material-palette. For the Angular Material components, we also need to include their core mixin and then the all-component-themes mixin with the aforementioned custom material themes. // Make sure you always include the core mixin first @include core(); ::ng-deep { @include mat.core(); @include theme($igx-light-palette); @include mat.all-component-themes($custom-mat-light-theme); .dark { @include dark-theme($custom-dark-palette); @include mat.all-component-themes($custom-mat-dark-theme); } } Warning Be sure to place the above code inside the ::ng-deep selector to penetrate the Emulated ViewEncapsulation. Light Mode Once we are done configuring color palettes and themes, we can make some additional color changes to our components. The background color for our application needs to be set explicitly on the host element. In our sample, we want to use the surface color of the passed palette. The logo is an SVG image hence we can easily change its color using the CSS. Also, we will change some of the colors of the mat-slider component to secondary so that it can fit better in our app: :host { &.light { // The background color of the application in light mode background: color($igx-light-palette, 'surface'); // The application logo fill color #Path1 { fill: color($igx-light-palette, 'secondary'); } // The application logo stroke color #Path2 { stroke: color($igx-light-palette, 'secondary'); stroke-width: \"0.8\"; } } // Update material slider component colors for both light and dark mode .mat-mdc-slider.secondary .mdc-slider__track--inactive, .mat-mdc-slider.secondary .mdc-slider__thumb-knob { background-color: color($custom-mat-light-theme, 'secondary'); } .mat-mdc-slider.secondary .mdc-slider__track--active_fill, .mat-mdc-slider.secondary .mdc-slider__thumb-knob { border-color: color($custom-mat-light-theme, 'secondary'); } .mat-mdc-slider.secondary .mat-mdc-slider-visual-thumb .mat-ripple > * { background-color: color($custom-mat-light-theme, 'secondary'); opacity: .12; } } Dark Mode For our dark variant, we are going to apply the same CSS styles but using the $custom-dark-palette. In addition, we will update some of the colors of the mat-stepper component: :host { &.dark { // The background color of the application in dark mode background: color($custom-dark-palette, 'surface'); // The application logo fill color #Path1 { fill: color($custom-dark-palette, 'secondary'); } // The application logo stroke color #Path2 { stroke: color($custom-dark-palette, 'secondary'); stroke-width: \"0.8\"; } ::ng-deep { // The background of the selected step icon inside the material stepper .mat-step-header .mat-step-icon-selected { background-color: color($custom-dark-palette, 'secondary'); } // The background of the material stepper .mat-stepper-horizontal { background: color($custom-dark-palette, 'surface'); } } } } Generate class The Angular Material toolbar uses CSS classes for its background color. In our sample, we want that color to change according to the selected theme, hence we are going to use the color-classes mixin. It will generate CSS class names for all colors for a given property and color palette, with optional prefix and suffix attached to the class name. For the demo, we will include the mixin twice - once for the light mode with the respective $igx-light-palette as a first value and second time for the dark mode with the $custom-dark-palette: :host { &.light { @include color-classes( $palette: $igx-light-palette, $prop: 'background', $prefix: 'bg' ); } &.dark { @include color-classes( $palette: $custom-dark-palette, $prop: \"background\", $prefix: \"bg\" ); } } Then, add a CSS class to your navbar component following the pattern \"bg - color from the palette - color variant\". In our sample app, we are using bg-gray-100. Angular Components Typography Ignite UI for Angular exposes four default type scales for each of its themes, which can be used inside the typography mixin to define the global typography styles of an application. In our example, we are going to apply the material predifined typeface and type-scale but you can create custom ones if you wish. :host { @include typography($font-family: $material-typeface, $type-scale: $material-type-scale); } To customize the Angular Material typography, we need to use their define-typography-config function. We will override their $font-family with the Ignite UI $material-typeface and their $button styles as follows: $custom-typography: mat.define-typography-config( $font-family: $material-typeface, $button: mat.define-typography-level(14px, $font-weight: 600) ); Then, the typography config has to be passed to the define-light-theme mixin: $custom-mat-light-theme: mat.define-light-theme(( color: ( primary: $light-palette-primary, accent: $light-palette-accent ), typography: $custom-typography )); Check Angular Material Typography documentation for more detailed information. API References Light Material Palette Dark Material Palette Light Material Theme Dark Material Theme Palette Function Typography Mixin Related topics: Palettes Component Themes Typography Avatar Component Button Component Dialog Component Icon Component Expansion Panel Component Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/misc/bootstrap-theming.html": {
    "href": "components/themes/misc/bootstrap-theming.html",
    "title": "Bootstrap Theming",
    "keywords": "Bootstrap Theming The Ignite UI for Angular theming engine provides an opportunity to be used in conjunction with other component libraries such as the popular NG Bootstrap based on Bootstrap’s markup and CSS. Overview The Ignite UI for Angular is a complete set of Material-based UI Widgets, Components & Sketch UI kits and supporting directives for Angular that enables developers to build modern high-performance apps. Our theming engine is easy to use and allows theming granularity on different levels from a single component, multiple components, or the entire suite. Therefore, some users want to take advantage of it not only with Ignite UI components but also with other libraries. In this article, we will look through the usage of Ignite UI together with Ng Bootstrap components. Demo Basic Usage Add NG Bootstrap If you are using Angular CLI and have an existing Angular project, you can install NG Bootstrap with the command below: ng add @ng-bootstrap/ng-bootstrap Once installed, you have to import the NG Bootstrap main module into your app.module.ts file: import {NgbModule} from '@ng-bootstrap/ng-bootstrap'; @NgModule({ imports: [ ..., NgbModule, ... ] )} At this point your applications is ready to use the NG Bootstrap components. You can find more information about using the Bootstrap library at their official documentation. Add Ignite UI for Angular To install the Ignite UI for Angular package along with all of its dependencies, font imports, and styles references, run the following command in your project: ng add igniteui-angular Then, you can use the Ignite UI components by importing their respective modules in your app.module.ts file: // manually addition of the Igx Avatar component import { IgxAvatarModule } from 'igniteui-angular'; // import { IgxAvatarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ..., IgxAvatarModule, ... ] )} Follow our Getting Started topic for a complete introduction about using Ignite UI for Angular in existing projects. Further information on how to import and use each of our components along with guided examples can be found in the component's documentation. Components Let's see how our demo sample is done. It is a mixture of Ignite UI and NG Bootstrap components, styled to fit nicely in one application. The navigation in our example is created using the bootstrap navbar together with igx-buttons and igx-avatar. The dropdown under the Campaigns button is also taken from the bootstrap library. Below the nav, we are using the igx-card component to display some statistics. Within the cards, we have placed multiple items - igx-avatars and igx-icons as well as bootstrap buttons and ngb-ratings. Clicking on the More buttons, you will see the igx-dialog: Next, we have added an ngb-accordion showing information about credit cards. Inside its content, there is an igx-list and igx-button. Finally, we inserted an Ignite UI for Angular icon button in the top right corner, that changes the theme of the whole app: Styling To get started with styling components using the Ignite UI theming engine, create an scss file named of your choice that would be the base file for your global theme. We will call this file _variables.scss. Next, we need to import the index file, where all the theme functions and component mixins live: // _variables.scss @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Palettes The Bootstrap library makes use of a Sass map called $theme-colors to provide a palette composed of eight colors: $theme-colors: ( \"primary\": $primary, \"secondary\": $secondary, \"success\": $success, \"info\": $info, \"warning\": $warning, \"danger\": $danger, \"light\": $light, \"dark\": $dark ); Ignite UI for Angular's palette function generates a color palette map including primary, secondary, gray, info, success, warn, and error colors and their color variants. Our predefined bootstrap palette in turn consists of seven colors: $bootstrap-palette: palette( $primary: #0d6efd, $secondary: #6c757d, $info: #0dcaf0, $success: #198754, $warn: #ffc107, $error: #dc3545, $surface: #f8f9fa ); As you can see most of the colors in the Bootstrap palette overlap with the colors defined in the Bootstrap palette of Ignite UI for Angular. Hence, we can simply map the Bootstrap theme colors to our light or dark bootstrap palette colors. First, we are going to define Sass variables that extract values from the $light-bootstrap-palette: // Colors from the Ignite UI light bootstrap color palette $light-primary: color($light-bootstrap-palette, \"primary\"); $light-secondary: color($light-bootstrap-palette, \"secondary\"); $light-success: color($light-bootstrap-palette, \"success\"); $light-info: color($light-bootstrap-palette, \"info\"); $light-warning: color($light-bootstrap-palette, \"warn\"); $light-danger: color($light-bootstrap-palette, \"error\"); After that, we will create a new color palette which will be used for the dark mode of the sample: // Defining custom color palette $custom-dark-palette: palette( $primary: #ecaa53, $secondary: #011627, $gray: #fff, $surface: #222 ); // Creating Sass variables for primary and secondary colors $dark-primary: color($custom-dark-palette, \"primary\"); $dark-secondary: color($custom-dark-palette, \"secondary\"); Note Visit our palettes with Sass section to discover more about the palettes provided by Ignite UI for Angular and learn how to create a new one. Themes In order to switch between light and dark mode, we are adding a custom class to the host element which will be changed on button click. In our stylesheet file, we are going to include different color palettes scoped to each class. Light mode Ignite UI for Angular comes with predefined themes inspired by the Bootstrap 4 library. To use them, first, you have to include our core mixin and then our built-in theme mixin - bootstrap-light-theme. We will also make use of our predefined bootstrap palette - $light-bootstrap-palette. The background color for our application needs to be set explicitly on the host element. In our sample, we want to use the surface color of the passed palette. At this point we have to modify the Bootstrap $theme-colors map with the Sass variables we created earlier: // Make sure you always include thecore mixin first @include core(); :host { &.light { // The background color of the application in light mode background: color($light-bootstrap-palette, 'surface'); ::ng-deep { // Applying the igx predefined light bootstrap palette and theme @include bootstrap-light-theme($light-bootstrap-palette); $theme-colors: ( \"primary\": $light-primary, \"secondary\": $light-secondary, \"success\": $light-success, \"info\": $light-info, \"warning\": $light-warning, \"danger\": $light-danger ); } } } The light and dark colors from the $theme-colors map, which don't have corresponding values in the Ignite UI palettes, can also be replaced with values at our discretion. For instance: $custom-light: color($light-bootstrap-palette, \"gray\", 100); $custom-dark: color($light-bootstrap-palette, \"gray\", 800); :host { &.light { ::ng-deep { $theme-colors: ( \"light\": $custom-light, \"dark\": $custom-dark, ); } } } Dark mode For our dark variant, we are going to use our newly created $custom-dark-palette. We have to include it in the dark class styles and also modify the $theme-colors map with the new values. All components in Ignite UI for Angular use colors from the passed palette, therefore they fit nicely in the dark mode without any additional adjustments. However, we have to do some more styling changes for the ng-bootstrap components: :host { &.dark { // The background color of the application in dark mode background: color($custom-dark-palette, 'surface'); ::ng-deep { // Applying our custom dark palette @include bootstrap-dark-theme($custom-dark-palette); // Overriding bootstrap button colors with colors from the custom dark palette .igx-card-actions .btn-primary { background-color: $dark-primary; border-color: $dark-primary; &:hover { background-color: color($custom-dark-palette, 'primary', 600); } } // Overriding ngb-accordion colors with colors from the custom dark palette .accordion { .card-header { background-color: color($custom-dark-palette, 'gray', 200); color: color($custom-dark-palette, 'gray', 900); } .card { background-color: color($custom-dark-palette, 'surface'); border-color: color($custom-dark-palette, 'gray', 300); } } // Overriding bootstrap dropdown colors with colors from the custom dark palette .dropdown .dropdown-menu { background-color: color($custom-dark-palette, 'surface'); border-color: color($custom-dark-palette, 'gray', 300); .dropdown-item { color: color($custom-dark-palette, 'gray', 800); &:hover { background-color: color($custom-dark-palette, 'gray', 200); } } } // Modifying the bootstrap color map $theme-colors: ( \"primary\": $dark-primary, \"secondary\": $dark-secondary ); } } } Lastly, we need to import the Bootstrap library - always import it at the end! :host { ::ng-deep { // Importing Bootstrap .scss file // Make sure you always import it last @import \"~bootstrap/scss/bootstrap\"; } } Once we are done with modifying the $theme-colors map, the bootstrap components will already use the colors from the igx $light-bootstrap-palette for the light mode, and $custom-dark-palette for the dark one. Warning Be sure to place the above code inside the ::ng-deep selector to penetrate the Emulated ViewEncapsulation. Generate class The bootstrap navbar uses CSS classes for its background color. In our sample, we want that color to change according to the selected theme, hence we are going to use the color-classes mixin. It will generate CSS class names for all colors for a given property and color palette, with optional prefix and suffix attached to the class name. For the demo, we will include the mixin twice - once for the light mode with the respective $light-bootstrap-palette as a first value and second time for the dark mode with the $custom-dark-palette: :host { &.light { @include color-classes( $palette: $light-bootstrap-palette, $prop: 'background', $prefix: 'bg' ); } &.dark { @include color-classes( $palette: $custom-dark-palette, $prop: 'background', $prefix: 'bg' ); } } Then, add a CSS class to your navbar component following the pattern \"bg - color from the palette - color variant\". In our sample app, we are using bg-gray-200. Typography Ignite UI for Angular exposes four default type scales for each of its themes, which can be used inside the typography mixin to define the global typography styles of an application. In our example, we are going to apply the bootstrap predifined typeface and type-scale but you can create custom ones if you wish. :host { @include typography($font-family: $bootstrap-typeface, $type-scale: $bootstrap-type-scale); } API References Light Bootstrap Palette Dark Bootstrap Palette Light Bootstrap Theme Dark Bootstrap Theme Palette Function Typography Mixin Related topics: Palettes Component Themes Typography Avatar Component Button Component Dialog Component Icon Component List Component Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/misc/printing-styles.html": {
    "href": "components/themes/misc/printing-styles.html",
    "title": "Print Layout",
    "keywords": "Printing styles The Ignite UI for Angular theming engine provides some default printing styles, which make sure that our components have at least the bare minimum to look the same on paper as they appear on the web page. How to make use of the printing styles In order to make sure that the components will be fully visible on the paper, you need to make sure that they are the same size or smaller than the document for print, otherwise, they will be cut off. By default the printing styles are incorporated in the compiled CSS. If you are not planning to print, we suggest you turn them off in order to reduce the size of the outputted CSS. You can do that in your theme SCSS file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; // Turn the print styles off by setting the $print-layout param to false. core($print-layout: false) // Add the theme and the palette. @include theme($default-palette); Since v13.2 we decided not to hide any component by default since we don't know what parts you want to be visible on paper, we leave that for you to decide. In order to remove a piece or a whole component from the printed page, you can eather add the class .igx-no-print to the element/component you don't want to print, or if you don't have access to the DOM you can directly target that element tag or class and set its display: none. Let's say that you can't' accesses a button in the DOM to put .igx-no-print on it. You can still hide that button from printing styles using SCSS. @media print { [igxButton] { display: none; } } Here @media print is used in order to make sure that the styles you write inside will only take effect while printing. If you want to print in black and white you can use .igx-bw-print class on any element and that element and everything inside it will turn black & white when printed. To print the igx-grid we recommend using the export to excel feature or making a screenshot of the grid and printing it. View page on GitHub"
  },
  "components/themes/palettes.html": {
    "href": "components/themes/palettes.html",
    "title": "Palettes",
    "keywords": "Palettes Ignite UI for Angular exposes CSS variables that allow you to update the colors in your application in a consistent way. Overview Ignite UI for Angular exposes over 80 color variants as CSS variables for 8 base colors - primary, secondary, gray, info, success, warn, error, and surface. The primary, secondary, and gray colors follow the 2014 Material Design Color Palette. This means these colors include the following variants: All *Primary & Secondary Only* **50** **100** **200** **300** **400** **500** **600** **700** **800** **900** *A100* *A200* *A400* *A700* As the table above shows, the `gray` color doesn't include the `A100`, `A200`, `A400`, and `A700` variants, while the `primary` and `secondary` colors contain all 14 color variants. We include 5 additional colors that are not part of the 2014 Material Design Color Palette - `info`, `success`, `warn`, `error`, and `surface`. On top of the aforementioned colors, we also include Level AAA WCAG compliant contrast colors for each color variant. This means that you can safely use the corresponding contrast color variants as foreground colors for the base color variant. Note Contrast colors are generated at build-time by the Sass theming engine. Overriding the CSS variables will not update the corresponding contrast colors. Here's an excerpt of the primary color as declared in the Light Material Palette: :root { --ig-primary-h: 204deg; --ig-primary-s: 100%; --ig-primary-l: 50%; --ig-primary-a: 1; --ig-primary-50: hsla( var(--ig-primary-h), calc(var(--ig-primary-s) * 1.23), calc(var(--ig-primary-l) * 1.78), var(--ig-primary-a) ); --ig-primary-100: hsla( var(--ig-primary-h), calc(var(--ig-primary-s) * 0.8), calc(var(--ig-primary-l) * 1.66), var(--ig-primary-a) ); --ig-primary-200: hsla( var(--ig-primary-h), calc(var(--ig-primary-s) * 0.64), calc(var(--ig-primary-l) * 1.43), var(--ig-primary-a) ); // ... --ig-primary-50-contrast: black; --ig-primary-100-contrast: black; --ig-primary-200-contrast: black; // ... } All primary colors variants are derived from 4 base variables - --ig-primary-h, --ig-primary-s, --ig-primary-l, and --ig-primary-a. Each one of these variables holds the HSLA parts for a single color. HSLA stands for hue, saturation, lightness, and alpha. It's another color scheme used to describe colors. We decided to use this approach as it allows us to modify all variants of the primary, secondary and other colors at runtime. Defining Palettes If you wanted to change the color variants for a color from the palette, you can do so by overriding its HSLA values in your stylesheets. For instance, changing the primary colors is as easy as writing: /* The HSLA representation of orange (#ffa500) */ /* hsla(38.8,100%,50%, 1); */ :root { --ig-primary-h: 38.8deg; --ig-primary-s: 100%; --ig-primary-l: 50%; --ig-primary-a: 1; } This will automatically update all the other primary variants. You will notice that color variants for each color are monochromatic. This is because all color variants are generated from the HSLA variables. Scoping We've seen that overriding colors in the palette is relatively easy. We can update the global palette by scoping color variants to the :root selector in the styles.css file of our application: Let's say your corporate primary color is #9f349c and you want to create primary variants for it. Here's how you would go about doing this. First get the HEX representation of the color in the HSLA color space. In this case it's 302deg for hue, 51% for saturation, 41% for lightness and 1 for alpha. Having derived the HSLA values, all you need to do to update the primary palette to this color is replace the global h, s, and l values for the primary palette: :root { --ig-primary-h: 302deg; --ig-primary-s: 51%; --ig-primary-l: 41%; } This will not automatically calculate the contrast color for each primary color variant. There are many tools out there that will help you determine if a specific color has enough contrast when used in combination with another color. You can use the built-in contrast checker in Chrome when determining the contrast color you want to pick for each color variant. We provide a Sass function for generating color palettes at build-time. If you prefer that we generate all color variants and their contrast colors for you from your own colors, check out the Palettes with Sass section of the documentation. Apart from having a single global palette, you can also create several palettes scoped to other CSS selectors. For example, we can have a blue and red palette scoped to class selectors: /* styles.css */ /* cornflowerblue hsl(218.5,79.2%,66.1%) */ .blue-theme { --ig-primary-h: 218.5deg; --ig-primary-s: 79.2%; --ig-primary-l: 66.1%; --ig-primary-a: 1; } /* brick red hsl(351.7,57%,52.5%) */ .red-theme { --ig-primary-h: 351.7deg; --ig-primary-s: 57%; --ig-primary-l: 52.5%; --ig-primary-a: 1; } <app-component class=\"blue-theme\"></app-component> Then you can simply overhaul the colors in your application by changing the value of the class attribute from blue-theme to red-theme. This approach works for overriding palette colors for individual components as well. In some instances, you don't want to create multiple palettes, but you would want to change a palette color used in component. Let's look at the material avatar component theme. It uses the 400 variant of the gray color for its background. Now, we can customize the theme by overriding the property responsible for setting the background, or we could change the disabled background color for it by overriding the gray 400 palette color: igx-avatar { --ig-gray-400: 146deg, 36%, 64%; } Dark vs. Light Warning The colors that have the biggest impact on foreground and background colors are gray and surface. These two colors will be displayed against one another in most cases. For that reason the surface color should always contrast the gray. Palettes in Ignite UI for Angular dictate whether a theme is going to be light or dark. The two colors that have the biggest impact on that are gray and surface. See, the gray color variants in all themes are based on either a very light color shade, like #fff, or a very dark one like #222. Light themes have gray variants based on dark shades of gray, while dark themes are the opposite - all gray variants are a shade of white. These gray colors will be displayed against another color, usually the surface color. The surface color should always be on the opposite end of the gray in the gray scale to ensure themes look good. To make this a bit clearer, below is a list of some gray and surface color variants in both a light and a dark theme; Material Light: :root { /* surface is set to white, i.e. ligthness 100% */ --ig-surface-h: 0deg; --ig-surface-s: 0%; --ig-surface-l: 100%; --ig-surface-a: 1; --ig-gray-h: 0deg; /* grays are based on black to contrast the surface color */ --ig-gray-h: 0%; --ig-gray-s: 0%; --ig-gray-900: var(--ig-gray-h), var(--ig-gray-s), 13%; } Material Dark: :root { /* surface is a dark shade of gray, i.e. lightness only at 13% */ --ig-surface-h: 0deg; --ig-surface-s: 0%; --ig-surface-l: 13%; --ig-surface-a: 1; /* grays are based on white to contrast the surface color */ --ig-gray-h: 0deg; --ig-gray-s: 0%; --ig-gray-900: var(--ig-gray-h), var(--ig-gray-s), 98%; } Be mindful when changing the gray and surface color variants as they are used in most components and have a big impact on their overall look and feel. Other Colors So far we've covered the primary, secondary, gray, and surface color variants and how you can override them. There are four more colors - info, success, warn, and error. They are usually used to set the colors in different states. For example, the igx-input-group component uses these colors in its input validation states. They can be changed as the first three variants. Just update their h, s, and l variables. Additional Resources Related topics: Palettes with Sass Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/animations.html": {
    "href": "components/themes/sass/animations.html",
    "title": "Animations",
    "keywords": "Animations Ignite UI for Angular includes over 100+ pre-built animations specially designed for a better user experience. Sass Animations Keyframes Mixin The Ignite UI for Angular keyframes mixin is used to register new keyframes animations. The mixin takes the name of a keyframes animation as a parameter and adds it to the global keyframe register list. In that way, the keyframes will not be duplicated in the exported CSS when including the same keyframes animation several times. For instance, doing this: @include fade-in(); @include fade-in(); Will result in only one @keyframes rule added to the produced CSS: @keyframes fade-in { ... } Keyframes selectors for the animation steps along with CSS styles for the keyframes are defined inside the body of the mixin. Here's an example of creating a new animation mixin that can be used with our animation mixin. @mixin fade-in-bottom { @include keyframes(fade-in-bottom) { 0% { transform: translateY(50px); opacity: 0; } 100% { transform: translateY(0); opacity: 1; } } } Animation Mixin The animation mixin serves as a vessel for animating elements using a list of animation properties passed as parameters. Users can specify animation properties like name, duration, delay, direction, iteration count, etc. Multiple keyframe animations can be passed to the animation mixin. //include the 'fade-in-top' keyframes animation mixin @include fade-in-top(); //include the animation mixin with parameters .my-class { @include animation('fade-in-top' 3s $ease-out-quad infinite); } Timing Functions We include a list of pre-baked timing functions to use with our keyframes mixins. Read the documentation to find the full list of timing functions. View on codesandbox View on stackblitz Angular Animations Apart from Sass keyframes and animations mixin, we also include pre-defined Angular animations. Like this sample? Get access to our complete Angular toolkit and start building your own apps in minutes. Download it for free. View on codesandbox View on stackblitz Usage The Ignite UI for Angular animations are grouped into 8 categories depending on their visual effects - fade, flip, grow, miscellaneous, rotate, scale, slide, and swing. Every group accepts a different set of parameters, allowing you to modify the behavior of any of the included animations. Each animation is an AnimationReferenceMetadata object as produced by the animation function provided by Angular. If parameters are attached, they act as default values. When an animation is invoked via the useAnimation function, then parameter values are allowed to be passed in directly. If any of the passed in parameter values are missing, then the default values will be used. import { transition, trigger, useAnimation } from '@angular/animations'; import { fadeIn, fadeOut } from \"igniteui-angular/animations/main\"; animations: [ trigger('fadeInOut', [ transition('void => *', [ useAnimation(fadeIn, { params: { duration: '.35s', easing: 'ease-out' } }) ]), transition('* => void', [ useAnimation(fadeOut, { params: { duration: '.2s', easing: 'ease-out' } }) ]) ]) ] Timing Functions Ignite UI for Angular includes a set of timing functions that can be used to ease in or out an animation. There are three main timing function groups - EaseIn, EaseOut, and EaseInOut, each containing the following timings: quad cubic quart quint sine expo circ back To use a specific timing function, import it first: import { EaseOut } from \"igniteui-angular/animations/easings\"; and then use it as value for the easing param in any animation: useAnimation(fadeIn, { params: { easing: EaseOut.back } }); API References Animations AnimationSettings IAnimationParams Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/component-themes.html": {
    "href": "components/themes/sass/component-themes.html",
    "title": "Component Themes",
    "keywords": "Component Themes Component themes allow you to change the styles of specific component instances by overriding the globally defined theme. Overview Before we dig deep into how you can create component-level themes, let's take a few moments to talk about how Ignite UI for Angular approaches component theming. Because we want to be able to support older browsers, like IE11, we have two completely different approaches for theming components. The first approach is to style component instances using CSS variables. By using CSS variables we gain the ability to create component themes without replicating their styles over and over again. Also, this approach allows us to modify the value of the CSS variables at runtime. The second approach is to create a new set of CSS rules that overwrite any previously declared CSS rules for a specific component. This approach is pretty straight-forward, and it is the only way we can provide sensible theming support for older browser, albeit it is not ideal as it adds a lot of additional CSS rules to the generated CSS theme. We'll take a look at how these approaches work in practice, and how to use one instead of the other when generating component-level themes. Creating Themes There are several parts to a component theme: The component theme function - A Sass function that normalizes the passed arguments and produces a theme to be consumed by a component mixin. The CSS variable mixin - A Sass mixin that consumes a component theme and produces CSS variables used to style a particular component. The component mixin - A Sass mixin that consumes a component theme and produces CSS rules used to style a particular component. Say you want to create a new global avatar theme that has a different background color to the one we set in the avatar's default theme. As mentioned in the overview section there are 2 general approaches to creating a component theme. There are even more ways you can organize and scope your component themes. The most straightforward way to do that is in the same file you defined your global theme. Defining an avatar theme: // Some place after @include theme(...); // Change the background of the avatar to purple. $avatar-purple-theme: avatar-theme( $background: purple, ); // Pass the css-vars to the `css-vars` mixin @include css-vars($avatar-purple-theme); The above code produces CSS variables for the igx-avatar component. These new CSS variables overwrite the default avatar rules. Similarly, if you were to include css-vars mixin later down in the global scss file, the mixin will again overwrite any previously defined themes. For instance: // ... @include css-vars($avatar-purple-theme); // Later $avatar-royalblue-theme: avatar-theme( $background: royalblue, ); @include css-vars($avatar-royalblue-theme); In the above code, the de facto global theme is now the $avatar-royalblue-theme as it overwrites any previously included css-vars mixins. This brings us to our next point. Scoping Themes As we saw in the previous example, when adding multiple themes targeting the same component at the same level, the last theme mixin takes precedence. This is due to the way the CSS cascade works. If you want to have two or more themes targeting the same type of component, you will have to scope them to a selector. For instance we can create multiple igx-avatar themes and scope them to specific CSS selectors we can later use in our component markup. // ... // CSS class selectors .avatar-royalblue { @include css-vars($avatar-royalblue-theme); } .avatar-purple { @include css-vars($avatar-purple-theme); } In a component template: <div class=\"avatar-royalblue\"> <igx-avatar initials=\"AZ\"></igx-avatar> </div> <div class=\"avatar-purple\"> <igx-avatar icon=\"home\"></igx-avatar> </div> View Encapsulation So far we've explored ways to create themes that are globally scoped, and are included in a single Sass file. However, this is not always desirable, and in some instances you will want the Sass file to be bound to a specific component. In those cases we have to take View Encapsulation, and specifically how it is emulated in Angular, into consideration. The Angular team has adopted 3 strategies for View Encapsulation - Emulated(default), ShadowDom, and None. To learn more about each of these strategies, take a look at the Angular Documentation. We will take a closer look at how to handle theming of Ignite UI for Angular components that are part of View Encapsulated parent components. What exactly does Emulated View Encapsulation mean, anyway? This type of View Encapsulation does not take advantage of the Shadow DOM specification, instead it employs a way to bind styles for a component and its children by using a unique attribute identifier applied on the host element. Any style rules you add to a stylesheet of a View Encapsulated component that target some inner selector will not apply because they do not reference the unique attribute of the host element. To be able to 'penetrate' this encapsulation we have to use some View Encapsulation penetration strategy. Right now, in Angular this strategy is ::ng-deep; it allows you to target any inner selector, which is encapsulated by its host element. It's good practice to use ::ng-deep if you're dealing with CSS rules, instead of CSS variables and you want to customize a single instance of a component. We'll provide an example for that in the next section. Let's take a look at an example using CSS variables. Let's create an avatar theme that is bound to specific parent component. Here's our simple component: import { Component, Input } from \"@angular/core\"; @Component({ selector: \"app-avatar\", styleUrls: [\"./app-avatar.component.scss\"], template: `<igx-avatar [initials]=\"initials\"></igx-avatar>`, }) export class AvatarComponent extends Component { @Input() public initials = \"AZ\"; } And this is what our Sass stylesheet looks like: // app-avatar.component.scss // Import the theming module @use \"igniteui-angular/theming\" as *; // !IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $avatar-royalblue-theme: avatar-theme( $background: royalblue, ); :host { @include css-vars($avatar-royalblue-theme); } When using CSS variables, we don't have to use the ::ng-deep pseudo-selector. With the code above we've created CSS variables for the igx-avatar, which will always have royalblue as its background color. The theme for our custom avatar will not 'leak' into other igx-avatar component instances, thus staying encapsulated within our custom app-avatar component. Any Ignite UI for Angular theme built with the $igx-legacy-support set to false will allow styling of components without the need of Sass in your project. For instance the above could be achieved by setting the value of --igx-avatar-background CSS variable to the desired color: /* app-avatar.component.css */ :host { --igx-avatar-background: royalblue; } Targeting Older Browsers In the overview section I mentioned you could use hard-coded values to style your components by setting the $igx-legacy-support global variable to true. If you use the theme mixin and pass it $legacy-support with value of true it will set the $igx-legacy-support to true, too. Usage in global themes The below example shows how you can style components using hard-coded values. // Import the theming module @use \"igniteui-angular/theming\" as *; // !IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include theme($palette: $default-palette, $legacy-support: true); // Overwrite the default themes for igx-avatar using hard-coded values: $avatar-royalblue-theme: avatar-theme( $background: royalblue, ); @include avatar($avatar-royalblue-theme); Usage in encapsulated views The below sample uses the sample from the View Encapsulation section as a starting point: // Import the theming module @use \"igniteui-angular/theming\" as *; // !IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; // Enable legacy support first. // !IMPORTANT: Only applicable for versions older than Ignite UI for Angular 13. $igx-legacy-support: true; $avatar-royalblue-theme: avatar-theme( $initials-background: royalblue, ); :host ::ng-deep { @include avatar($avatar-royalblue-theme); } API Overview Global Theme Avatar Theme Additional Resources Learn how to configure a global theme: Global Themes Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/configuration.html": {
    "href": "components/themes/sass/configuration.html",
    "title": "Theming Library Configuration",
    "keywords": "Configuration The Ignite UI for Angular theming library exposes several input arguments variables that let you configure how the theming engine works. Legacy Support The development of Ignite UI for Angular started back in 2016 when Internet Explorer 11 was still relevant. Some of our users depend on IE11 to this day. Our theming engine was built in a way that allows you to produce styles for ever-green and old browsers alike, using the same API. We allow you to configure how the engine behaves based on a single global variable - $igx-legacy-support. By default, it is set to false, but you can shadow its declaration. The value of this variable is also implicitly set when you specify the $legacy-support parameter on the theme mixin. Warning The $legacy-support option was removed in igniteui-angular 13.0.x. Support for IE11 and legacy browsers was removed in version 13 and this option is no longer valid. Example: // Sets the global $igx-legacy-support variable to true @include theme( $legacy-support: true ); This is the default way to turn off legacy support for the theme you're building in your styles.scss file. If you have styles scoped to specific components, like the app.component.scss file, you will have to specify the legacy support there as well. // app.component.scss $igx-legacy-support: true; $color: color($light-material-palette, 'primary', 900); We recommend you create a _variables.scss file in the styles directory of your project where you store all of your global configuration variables. In this way, you can simply import your configuration in every style file. Global Variables Here's a list of global Sass variables forwarded in the main theming module: Variable Name Description $components Stores a register of all component themes. Used for tree-shaking. $dropped-themes Stores a register of dropped themes. Used for tree-shaking. Scrollbar Styling The Ignite UI for Angular themes ship with custom scrollbar styles that allow you to change the width and/or the colors of all scrollbars in your application. To apply the included styles, make sure to set the ig-scrollbar class to an element that contains your root app component. To customize the scrollbar further, you can create a new theme that extends the existing scrollbar-theme and accepts the $schema, $thumb-background, $track-background and the $scrollbar-size parameters. // app.component.scss $my-scrollbar-theme: scrollbar-theme($thumb-background: black, $track-background: gray); @include scrollbar($my-scrollbar-theme); The parameters can also be directly applied to the scrollbar function to prevent the creation of additional themes. // app.component.scss @include scrollbar(scrollbar-theme($scrollbar-size: 16px)); Additional Resources Learn the concepts: Palettes Typography Elevations Schemas Animations Learn how to create application-wide themes: Application Themes Learn how to create component-specific themes: Component Themes Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/elevations.html": {
    "href": "components/themes/sass/elevations.html",
    "title": "Elevations/Shadows",
    "keywords": "Elevations Elevations are used to establish and maintain functional boundaries between Document Object Model trees to enable better functional encapsulation. You can create sets of elevations using our Sass theming library. Overview Elevations in Ignite UI for Angular are declared as a map of 25 elements. Each element is a key-value pair where the key is the elevation level name (0..24) and the value is a list of 3 box-shadow declarations. We allow you to generate new sets of elevations where you can define the color for the shadows. Additionally, we expose functions for retrieving a specific elevation level from the elevations map. We expose a global variable $elevations that is used across components by default. If you've not read the CSS variables documentation related to Elevations, we suggest you do that first before reading on. Usage The following section demonstrates how to create and retrieve custom elevations. Configuring Elevations To change the colors used by the default elevation presets, you need to configure the elevations preset module. // Define the 3 elevation colors @use 'igniteui-theming/sass/elevations/presets' as * with( $color-1: rgb(153, 191, 170), // Umbra $color-2: rgb(92, 134, 141), // Penumbra $color-3: rgb(92, 61, 70) // Ambient ); @include elevations($material-elevations); Retrieving Elevations To retrieve a set of box-shadows from the elevations map you can pass up to two arguments to the elevation function - an elevation map and the wanted elevation level. It returns a list of 3 box shadows for the given level. If you want to retrieve the elevation from the default $elevations map, you can omit the first argument. // Returns elevation 1 shadows $elevation-1: elevation(1); // Returns elevation 1 shadows $my-elevation-1: elevation($name: 1); Passing Elevations to Themes Several theme mixins allow you to pass an elevations map. Most notably, the theme has a parameter named $elevations which allows you to update the elevations for all component themes. Force all component themes to use your custom elevations: @include theme( //... $elevations: $my-elevations ); In addition to this, you can tell the theme to ignore/not use elevations completely: @include theme( //... $elevations: $my-elevations, $elevation: false // disables all elevations ); Some component themes also accept the $elevations parameter to allow you to pass custom elevation for their instances only. For instance, the card component does support passing custom elevations. To find out which components accept a custom elevations map, take a look at their Sass documentation. Each component uses only specific levels from the elevations map, those too are listed in the component's Sass docs. @include card(card-theme( //... $elevations: $my-elevations, )); Since the elevation function returns a list of box shadows, you can use the return value of that function to modify only certain elevations in your component themes. $card-theme: card-theme( $resting-shadow: elevation(10) ); @include card($card-theme); This compiles to: .igx-card { box-shadow: 0 6px 6px -3px rgba(0, 0, 0, 0.26), 0 10px 14px 1px rgba(0, 0, 0, 0.12), 0 4px 18px 3px rgba(0, 0, 0, 0.08); } You can also pass simple box shadows without taking advantage of the elevation function: $card-theme: card-theme( $resting-shadow: 0 10px 10px 10px #666 ); .my-card { @include card($card-theme); } Here is the result from the above snippet: .my-card .igx-card { /* ... */ box-shadow: 0 10px 10px 10px #666; } Custom Elevations It is possible to create an elevations map that doesn't adhere to the Material Design Guidelines as generated by the elevations function. Make sure your custom elevation maps contain at least 25 elevation levels. Here's the elevations map signature our themes expect to build correctly: // Omitted levels 2 through 23 for brevity $elevations: ( 0: box-shadow(...), 1: box-shadow(...), ... 24: box-shadow(...) ); Elevation Schema Declarations The elevation levels are also used in theme schema declarations. More on that in the Schema section of the documentation. API References Creating Elevations Retrieving Elevations Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/global-themes.html": {
    "href": "components/themes/sass/global-themes.html",
    "title": "Global Themes",
    "keywords": "Global Themes The global theme allows you to quickly generate a theme that uses your custom color palette, schema, and elevations. The color palette, schema, and elevations will be propagated to all components that don't have custom themes created for them. Overview If you've included the igniteui-angular.css file in your application project, now is a good time to remove it. We are going to use our own my-app-theme.scss file to generate a global theme for all components in our application. Ignite UI for Angular uses a global theme by default to theme the entire suite of components. You can, however, create themes scoped to components you have in your app, depending on your use case. For now, we will be including all of our themes in a single file. To generate a global theme we're going to be including two mixins core and theme. Both of those mixins accept a few arguments: ###core Name Type Default Description $print-layout boolean true Include/exclude the styles for printing. $enhanced-accessibility boolean false Switches component colors and other properties to more accessible values. ###theme Name Type Default Description $palette map null The palette map to be used to by the default themes of all components. $schema map $light-material-schema The schema used as basis for styling the components. $exclude list () A list of component themes to be excluded from the global theme. $roundness Number 1 Sets the global roundness factor for all components (the value can be any decimal fraction between 0 and 1). $elevation boolean true Turns on/off elevations for all components in the theme. $elevations Map $material-elevations The elevation map to be used by all component themes. Let's create a custom global theme that will use the primary and secondary colors of our company. // Import the theming module @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $primary-color: #2ab759; $secondary-color: #f96a88; $my-color-palette: palette( $primary: $primary-color, $secondary: $secondary-color ); // IMPORTANT: Make sure you always includecore first! @include core(); // Add the typography styles before the main theme. @include typography(); // Pass the color palette we generated to thetheme mixin. @include theme($my-color-palette); Let's explain what the core and theme mixins do. The core mixin takes care of some configurations, like adding enhanced accessibility(e.g. colors suitable for color blind users) and printing styles for all components. The theme mixin includes each individual component style (bar the ones listed as excluded) and configures the palette, schema, elevations, and roundness that is not listed in the $exclude list of components. Important Including core and typography before theme is essential. The core and typography mixins provide all base definitions needed for the theme mixin to work correctly. Excluding Components The theme mixin allows you to provide a list of component names to be excluded from the global theme styles. For instance, if you want to completely remove all styles we include for the igx-avatar and igx-badge to reduce the amount of produced CSS or to supply your own custom styles, you can do so by passing the list of components like so: // ... $unnecessary: (igx-avatar, igx-badge); @include theme($my-color-palette, $exclude: $unnecessary); If you know your app will not be using some of our components, we recommend you add them to the $exclude list. You can do the inverse, i.e. include only the component styles you want using the method below: @use 'sass:map'; @function include($items, $register) { @return map.keys(map.remove($register, $items...)); } $allowed: (igx-avatar, igx-badge); @include theme( $exclude: include($allowed, $components) ); Light and Dark Themes In addition to the more powerful theme mixin, we include two additional global theme mixins for fast bootstrapping light and dark themes. Those mixins are light-theme and dark-theme. Here's a quick showcase of how you can create a light and dark theme for your application: .light-theme { @include light-theme($light-material-palette); } .dark-theme { background: #333; color: #fff; @include dark-theme($light-material-palette); } Ideally, you set .light-theme or .dark-theme classes on an element high in your application DOM tree. Your app-root element is a good candidate for that. Available Themes Ignite UI for Angular gives you the option to pick from a set of predefined themes. The table below shows all the built-in themes that you can use right away. Theme Mixin Schema Color Palette Available in version Material (base) theme() $light-material-schema null all Material (light) light-theme() $light-material-schema $light-material-palette 6.2 + Material (dark) dark-theme() $dark-material-schema $dark-material-palette 6.2 + Fluent fluent-light-theme() $light-fluent-schema $light-fluent-palette $light-fluent-excel-palette $light-fluent-word-palette 8.2 + Fluent (dark) fluent-dark-theme() $dark-fluent-schema $dark-fluent-palette $dark-fluent-excel-palette $dark-fluent-word-palette 8.2 + Bootstrap bootstrap-light-theme() $light-bootstrap-schema $light-bootstrap-palette 9.0 + Bootstrap (dark) bootstrap-dark-theme() $dark-bootstrap-schema $dark-bootstrap-palette 9.0 + Indigo indigo-light-theme() $light-indigo-schema $light-indigo-palette 10.1 + Indigo (dark) indigo-dark-theme() $dark-indigo-schema $dark-indigo-palette 10.1 + Note Note that all high-level theme mixins wrap the base theme mixin. All theme mixins can be used as a starting point to create your own theme. Let's create a new theme by using the bootstrap-light-theme mixin. // Import the theming module @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; $primary-color: #b71053; $secondary-color: #6c757d; $my-color-palette: palette( $primary: $primary-color, $secondary: $secondary-color ); // IMPORTANT: Make sure you always includecore first! @include core(); // Pass the color palette we generated to thebootstrap-theme mixin @include bootstrap-light-theme($my-color-palette); Browser Support Prior to Ignite UI for Angular 13, the value of $igx-legacy-support is quite important as it determines how component themes work. When its value is set to true, individual component style rules will have their values set at build time to the hard-coded values defined in their theme. If you set the value of $igx-legacy-support to false, however, style rules will look for values from CSS variables defined at the :root scope, or the nearest block scope. The general rule of thumb regarding what the value of $legacy-support should be dictated by whether you will be including support for Internet Explorer 11 or not. If you want to include support for IE11 set the $legacy-support value to true, otherwise setting its value to false (default) will force CSS variables for theming. Support for IE11 and older browsers was removed in Ignite UI for Angular 13. API Overview Global Theme Light Theme Dark Theme Palette Additional Resources Learn how to create individual component themes: Component Themes Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/index.html": {
    "href": "components/themes/sass/index.html",
    "title": "Theming with Sass",
    "keywords": "Theming with Sass Ignite UI for Angular doesn't shy away from exposing its Sass theming API so you can take full control of the styling in your application. The API we expose is, to a large extent, the exact same API we use internally to build every single theme we bundle with the product. It's abstract and allows for theming granularity on different levels - from a single component the entire application suite. Overview Since IgniteUI for Angular bases its component designs on the Material Design Principles, we try to get as close as possible to colors, sizes, typography, and overall look and feel of our components to those created by Google for our default theme. The Material Design system keeps changing and doesn't stray from implementing major changes, which ultimately affects how we write and modify the styles of the components we ship. With support for 3 additional themes - Microsoft Fluent, Bootstrap, and our own Indigo Design systems, adapting the Material Design system is not a straight-forward task. It required us to build a very modular, configurable, and yet maintainable base from which vastly different component styles can be generated. We also have to support old and new browsers alike, so Sass has been a tremendous help in this endeavor, giving us tools that allowed us to create a visceral system of variables, functions and mixins. Our approach to theming is based around several concepts - Theme Schemas, Palettes, Typography, Roundness, Elevations, and Animations. These concepts are then mixed to produce the final theme. Each concept is further broken down to allow for a more granular approach to styling. Since we want to ensure specific aspects of our design system remain unscathed, we don't allow you to change every single thing and completely rewrite the styles using the API we expose, however, you could if you did some digging. We will explain every single concept in detail and the related APIs so that you can feel truly in control of our theming engine. Note Although the Sass theming library is powerful, most people will only need to modify a few CSS variables to customize the default theme. We encourage you to read through the CSS variables documentation first. You should only need to use Sass if you wanted to modify the produced theme on a deeper level. A good example would be when you need to create several different reusable theme variants for the same component, or to tree-shake the produced CSS to only include styles for the components you use in your app. Palettes The first concept we need to understand is palettes. As in any visual tool, colors are the main differentiating factor between one application and another. The Material Design Guidelines prescribe predefined palettes of colors that range in hue, lightness, and saturation for a given base color. There's a good reason for that. They really want to ensure good color matching and contrast between the background colors and the foreground text colors. This is great but limiting at the same time. If you wanted to have your own custom palette based on the Material guidelines that matches your branding, you would probably be out of luck. We recognize this is a problem, so we invented an algorithm that generates Material-like palettes from base colors you provide. We also generate contrast text colors for each hue in the palette. Schemas The second important concept revolves around theme schemas. Theme schemas are like recipes for individual component themes. They give individual component themes information about what palette colors they should use and what the overall roundness and shadows should be. For instance, a component scheme tells a component theme that the background color of an element should be the 500 variant from the primary color, without caring what palette the user passes to the component theme. Typography Typography is a separate module in our Sass theming library and is decoupled from the individual component themes. Although we have a default typeface of choice, we really want to give you the power to style your application in every single way. Typography is such an important part of that. We provide a method for changing the font family, the sizes and weights for headings, subheadings, buttons, body text, etc. in your app. Roundness The Sass theming system defines minimum and maximum roundness for each component. You may be more familiar with the term border-radius in the context of CSS. Roundness is similar in that it uses border-radius to style the elements of the component, however, roundness in the context of the theming system is a number between 0 and 1. A component that has a roundness of 0 uses the minimum border-radius as defined by the component theme - it could be 0 or a non-zero value. Likewise, setting the roundness to 1 will set the border-radius to the maximum allowed radius for the component. While the minimum and maximum border-radius are defined in the component theme itself, the base roundness value is set in the component schema. Elevations Elevations are the shadows being set for different parts of each component theme. They are based on 25(0-24) levels as prescribed by the Material Design guidelines. Having a finite number of shadows allows us to have a consistent way of defining depth hierarchy in our applications. In Sass they are defined as a map of 24 elevation levels with box-shadows as values and later passed to a component theme. Component schemas will provide generic information to the theme about the elevation levels specific elements should use. Animations Some components use keyframe transitions and animations to communicate changes of state in a clear way. We include a huge library of keyframe animations and timing functions that can be imported and used throughout your application. They are treeshaken so including the same animation mixin twice produces only a single CSS declaration in your output stylesheet. Themes Finally, we have component themes. Palettes, Schemas, Elevations, Roundness, and Animations wouldn't do much good on their own if they weren't used by a theme. We provide themes for individual component, and a global one, that styles the entire application and every component in it. You simply pass the palette and schema to the global theme, we take care of the rest. You can, of course, style each component individually to your liking by creating custom schemas, elevations, and by passing different values for roundness and colors to the component theme mixins. Additional Resources Learn the concepts: Configuration Palettes Typography Elevations Schemas Animations Learn how to create application-wide themes: Application Themes Learn how to create component-specific themes: Component Themes Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/palettes.html": {
    "href": "components/themes/sass/palettes.html",
    "title": "Palettes",
    "keywords": "Palettes The Ignite UI for Angular theming engine provides several powerful functions and mixins for generating and retrieving colors. Overview Palettes in the context of Ignite UI for Angular are declared as Sass Maps with the keys of those map being the palette colors (primary, secondary, gray, etc.). Each color is in turn a map itself and has all color variants listed as keys. The values assigned to those color variants are the actual colors used throughout all component themes. All palette maps are generated programatically by the palette function. The function accepts arguments for primary, secondary, gray, surface, info, success, warn, and error colors. The primary color is usually your brand color. It is mostly used to style static elements, such as the igx-navbar component. The secondary color is the one used on elements that are actionable, such as buttons, switches, sliders, etc. The only required arguments are the ones for primary and secondary colors. The surface color is used to color the 'surface' of some components, such as cards, menus, date/time pickers, banners sheets, etc. We default the colors for surface, gray, info, success, warn, and error to a predefined set of our choosing. To get started with your first color palette, create an scss file that would be the base file for your global theme. I will call mine _\"variables.scss\". // _variables.scss $melon-palette: palette( $primary: #2ab759, $secondary: #f96a88, ); Warning The value you pass to $primary, $secondary, or any other color must be of type color. You cannot pass CSS variables as arguments as those can't be resolved at Sass build-time. We created a palette that contains variants for all colors in it, including automatically created text contrast colors for each variant. If you haven't checked the documentation regarding palettes with CSS variables, go check it out now. It contains information about all the color variants of a palette. The palette function does a lot internally to help you create colors at build-time that you can reuse throughout your .scss documents. The function is nice in that it will create a huge map of colors for you, but the algorithm for generating the color variants is very opinionated and may not match your exact needs. Our component themes don't care how the palette is generated, it only cares about the shape of the map. In case you want to manually create your palette, or create the palette generating function yourself here's what we expect to get as a palette map. $handmade-palette: ( primary: ( 50: to-hsl(#e6eff8), '50-contrast': black, 100: to-hsl(#bfd7f2), '100-contrast': black, 200: to-hsl(#98bfec), '200-contrast': black, 300: to-hsl(#85b5e9), '300-contrast': white, 400: to-hsl(#73a6e4), '400-contrast': white, 500: to-hsl(#6797de), '500-contrast': white, 600: to-hsl(#3681dd), '600-contrast': white, 700: to-hsl(#357fda), '700-contrast': white, 800: to-hsl(#306dc8), '800-contrast': white, 900: to-hsl(#284ea8), '900-contrast': white, 'A100': to-hsl(#98bfec), 'A100-contrast': white, 'A200': to-hsl(#73a6e4), 'A200-contrast': white, 'A400': to-hsl(#3681dd), 'A400-contrast': white, 'A700': to-hsl(#284ea8), 'A700-contrast': white ), secondary: ( 50: to-hsl(#fef7e2), '50-contrast': black, 100: to-hsl(#fdeab7), '100-contrast': black, 200: to-hsl(#fbdd89), '200-contrast': black, 300: to-hsl(#fad15c), '300-contrast': black, 400: to-hsl(#f9c63f), '400-contrast': black, 500: to-hsl(#f7bd32), '500-contrast': white, 600: to-hsl(#f6b02d), '600-contrast': white, 700: to-hsl(#f49e2a), '700-contrast': white, 800: to-hsl(#f38e28), '800-contrast': white, 900: to-hsl(#f38e28), '900-contrast': white, 'A100': to-hsl(#fbdd89), 'A100-contrast': black, 'A200': to-hsl(#f9c63f), 'A200-contrast': black, 'A400': to-hsl(#f6b02d), 'A400-contrast': white, 'A700': to-hsl(#f38e28), 'A700-contrast': white ), gray: ( 50: to-hsl(#fff), '50-contrast': black, 100: to-hsl(#fafafa), '100-contrast': black, 200: to-hsl(#f5f5f5), '200-contrast': black, 300: to-hsl(#f0f0f0), '300-contrast': black, 400: to-hsl(#dedede), '400-contrast': black, 500: to-hsl(#b3b2b2), '500-contrast': black, 600: to-hsl(#979696), '600-contrast': white, 700: to-hsl(#7b7a7a), '700-contrast': white, 800: to-hsl(#404040), '800-contrast': white, 900: to-hsl(#1a1a1a), '900-contrast': white ), info: ( 500: to-hsl(rgb(18, 118, 211)), '500-contrast': black ), success: ( 500: to-hsl(rgb(76, 184, 96)), '500-contrast': black ), warn: ( 500: to-hsl(rgb(251, 178, 60)), '500-contrast': black ), error: ( 500: to-hsl(rgb(255, 20, 75)), '500-contrast': black ), surface: ( 500: to-hsl(rgb(255, 255, 255)), '500-contrast': black ) ); :root { --ig-primary-a: 1; --ig-secondary-a: 1; --ig-info-a: 1; --ig-success-a: 1; --ig-warn-a: 1; --ig-error-a: 1; --ig-gray-a: 1; --ig-surface-a: 1; } The to-hsl() function takes a color, no matter the color space, and returns its hue, saturation, and lightness values in a comma-separated list, which will be used when declaring the CSS variables for each shade in the palette. The alpha value for each palette color(primary, secondary, gray, etc.) must be initialized separately. Predefined Palettes We provide predefined light and dark palettes, which you can use along with our schemas to create themes for your components: Light Palettes $light-material-palette $light-fluent-excel-palette $light-fluent-word-palette $light-fluent-palette $light-bootstrap-palette $light-indigo-palette Dark Palettes $dark-material-palette $dark-fluent-excel-palette $dark-fluent-word-palette $dark-fluent-palette $dark-bootstrap-palette $dark-indigo-palette We also provide a few additional palettes that you can use: Light Additional Palettes $light-green-palette $light-purple-palette Dark Additional Palettes $dark-green-palette $dark-purple-palette You can mix and match all light palettes with a light schema of your choice and vice versa - all dark palettes with a dark schema that you think will best match your needs and vision. The Default Palette The theme mixin takes a palette(see the previous section) as one of its arguments. The passed palette is assigned to the global $default-palette variable. This palette stored in this variable is used across the Sass library as fallback palette, whenever a palette is expected, but not explicitly provided by the user. You can use this knowledge to your advantage to allow you to re-use the same palette across multiple Sass documents in your application. For example, you could have the following Sass files in your app. // src/styles/_variables.scss $my-palette: palette( $primary: #2ab759, $secondary: #f96a88, ); $default-palette: $my-palette; In your main styles file: // src/styles/styles.scss @use 'variables' as *; @include theme($palette: $my-palette); In a component .scss file: @use '../styles/styles/variables' as *; :host { background: color($variant: 900); } This ensures that the same palette, declared in our _variables.scss file is used across all Sass files Grayscale Colors Similar to the primary and secondary colors, you can provide another color to the palette function that will be used to generate shades of gray. The default color used to generate the gray palette in all light themes is #000, or better known as black. The gray color variants are mainly used for setting text colors across components. Modifying the value is useful when changing the background or surface colors in your application. For instance, if your application uses a darker surface background, setting the gray color to white is sensible, and will force all text colors to be based on shades of white. To generate a palette that uses white for its gray shades: // Import the Ignite UI themes library first $company-color: #2ab759; /* Some green shade I like */ $secondary-color: #f96a88; /* Watermelon pink */ $grayscale-base: #fff; /* Used to generate shades of gray */ $my-color-palette: palette( $primary: $company-color, $secondary: $secondary-color, $gray: $grayscale-base ); Colors Variants We provide a function that is easy to remember and use - color. It can take up to three arguments - palette, color, and variant; // Get the primary CSS variable reference of the 500 color variant $my-primary-500: color(); // Get the primary CSS variable reference of the 600 color variant $my-primary-600: color($variant: 600); // Get the secondary A700 color variant as a HEX value from $my-palette $my-primary-A700: color($my-palette, 'secondary', 'A700'); // Get the warn 500 color variant as HEX value from $my-palette $my-warning-color: color($my-palette, 'warn'); .my-awesome-class { background: $my-primary-600; border-color: $my-primary-A700; } .warning-bg { background: $my-warning-color; } If you omit the $palette argument, you will get a string referencing the corresponding CSS variable variant. If you do not provide $color and/or $variant, they will be assigned to primary and 500 respectively. Contrast Text Colors Similar to how we retrieve color variants, there's a way to get the contrast text color for each of the color variants in the palette. $my-primary-800: color($my-palette, 'primary', 600); $my-primary-800-text: contrast-color($my-palette, 'primary', 600); // sample usage .my-awesome-article { color: $my-primary-800-text; background: $my-primary-800; } Color Classes We understand that some people prefer to use CSS classes to apply colors to web elements, be it text or background. We have a mixin that allows you to generate CSS classes for each color in the palette. The mixin takes a few arguments that allow you control the CSS class name as well as the CSS property to pass the palette color to; $prop - The CSS property to assign the color to. $prefix - A prefix string to be attached to the generated class name. The default is 'igx'. $suffix - A suffix string to be attached to the generated class name. $palette - The palette to use. For instance, if you want to generate CSS classes that apply background color to elements, you can do the following: @include color-classes( $prop: 'background-color', $prefix: 'bg' ); The above code will generate CSS classes for each color variant in the palette. For instance, the 500 color variant of the primary palette will be given the following class .bg-primary-500; <div class=\"bg-primary-500\">...</div> CSS Variables When reading about the color palette in the CSS Variables section of the documentation, you would've noticed that all palette colors are included as CSS variables. We do this internally every time we generate a theme using the theme mixin. The theme calls another mixin in its body - palette. It takes a palette and converts the colors in it into CSS variables. You use this mixin when you want your custom palette colors to be included as CSS variables. Here's an example: $my-palette: palette( $primary: #2ab759, $secondary: #f96a88, ); @include palette($my-palette); API Reference Palettes Getting Palette Colors Getting Contrast Colors Generating Color Classes Schemas Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/presets/bootstrap.html": {
    "href": "components/themes/sass/presets/bootstrap.html",
    "title": "Switching from Material to Bootstrap Theme",
    "keywords": "Switching from Material to Bootstrap Theme Since version 9.0 our components include a new theme inspired by Bootstrap 4 and ng-bootstrap. In order to switch from Material to Bootstrap, you can use one of the built-in mixins. Bootstrap Light Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include bootstrap-light-theme($light-bootstrap-palette); Bootstrap Dark Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include bootstrap-dark-theme($dark-bootstrap-palette); API Overview Light Theme Dark Theme View page on GitHub"
  },
  "components/themes/sass/presets/fluent.html": {
    "href": "components/themes/sass/presets/fluent.html",
    "title": "Switching from Material to Fluent Theme",
    "keywords": "Switching from Material to Fluent Theme Since version 8.2 our components include a new theme inspired by the Microsoft Fluent Design System In order to switch from Material to Fluent, you can use one of the build-in mixins. We support Word and Excel palettes. To use them just pass one of the two maps $light-fluent-excel-palette or $light-fluent-word-palette to the theme mixin: Fluent Light Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include fluent-light-theme($light-fluent-excel-palette); Fluent Dark Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include fluent-dark-theme($dark-fluent-excel-palette); API Overview Light Theme Dark Theme View page on GitHub"
  },
  "components/themes/sass/presets/indigo.html": {
    "href": "components/themes/sass/presets/indigo.html",
    "title": "Switching from Material to Indigo Theme",
    "keywords": "Switching from Material to Indigo Theme Since version 10.1 our components include a new theme inspired by our own design language. In order to switch from Material to Indigo, you can use one of the built-in mixins. Indigo Light Theme @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include indigo-light-theme($light-indigo-palette); Indigo Dark Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include indigo-dark-theme($dark-indigo-palette); API Overview Light Theme Dark Theme View page on GitHub"
  },
  "components/themes/sass/presets/material.html": {
    "href": "components/themes/sass/presets/material.html",
    "title": "Default Theme",
    "keywords": "Default Theme The Material theme is the default theme in Ignite UI for Angular. To use it include the theme mixins after core. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include theme($light-material-palette); Material Light Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include light-theme($light-material-palette); Material Dark Theme @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); @include dark-theme($dark-material-palette); Both light-theme and dark-theme mixins includes the theme mixin. We create those mixins just for your convenience, otherwise, if you want to use the theme but with a dark palette and dark schema you have to manually do the following: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; @include core(); $primary-color: #2ab759; $secondary-color: #f96a88; $my-color-palette: palette( // IMPORTANT, the primary and secondary colors are required $primary: $primary-color, $secondary: $secondary-color, // The $gray will ensure that all the black text, borders, etc will // become a shade of white in order to be visible against a dark background $gray: #fff // Since all individual components use the $default-palette by default, if you don't specify the rest of the colors like $info and $error they will use their default values from the $default-palette ); @include theme($my-color-palette, $schema: $dark-schema); API Overview Global Theme Light Theme Dark Theme View page on GitHub"
  },
  "components/themes/sass/roundness.html": {
    "href": "components/themes/sass/roundness.html",
    "title": "Roundness",
    "keywords": "Roundness Ignite UI for Angular allows you to change the shape of components by setting their roundness to a value between 0 and 1. Overview Border radius is defined in the theme schema of the component (see the example below). The border radius for any component defined in this manner can then be controlled via the $roundness parameter of the theme mixin or a single CSS variable called --ig-radius-factor. $light-toast: ( ..., border-radius: (rem(26px), rem(0), rem(26px)), ); As you can see from the example, the component schema for the Toast defines the border radius as a list of three values. The first value is the default border radius (i.e. when $roundness or --ig-radius-factor is not declared). The second value denotes the minimum allowed border radius (i.e. when $roundness or --ig-radius-factor is set to 0). And the third value denotes the maximum allowed border radius (i.e. when $roundness or --ig-radius-factor is set to 1). In the toast component the default and maximum values match. Any value between 0 and 1 assigned to $roundness or --ig-radius factor will set the border radius of the toast as a percentage of the maximum value. For instance, setting the value to .5 will make the border radius of the Toast component to be 50% of its maximum allowed border radius, which is 13 pixels. // Make all components sharp by setting the roundness parameter to 0. @include theme( ..., $roundness: 0 ); How to use? Let's see how we can change the default values for the toast from the example above. If you want the toast to still be affected by the $roundness or the --ig-radius-factor variable in the resulting theme, use the border-radius function provided by the Ignite UI for Angular package. // Change the default, min and max values, // while preserving customization via $roundness or --ig-radius-factor. $toast-theme: ( ..., border-radus: border-radius(rem(4px), rem(4px), rem(16px)) ); @include css-vars($toast-theme); If you want the border-radius to be a constant value, unaffected by changes of --ig-radius-factor, just pass it directly to the border-radius parameter. // Will be unaffected by changes to $roundess or --ig-radius-factor. $toast-theme: ( ..., border-radus: rem(4px) ); @include css-vars($toast-theme); Baseline border radius values The table below shows an excerpt of some of the component border radius values as defined in the Material schema. Component Min/Max Radius Default Radius Button(Flat) 0 / 20px 4px Button(Contained) 0 / 20px 4px button(Fab) 12px / 28px 28px button(Icon) 0 / 18px 18px Button-group 0 / 20px 4px Chip 0 / 20px 4px Card 0 / 24px 4px Carousel 0 / 36px 0 Dialog 0 / 36px 4px Drop-down 0 / 20px 4px Expansion panel 0 / 16px 0 input(Border) 0 / 20px 4px input(Box) 0 / 20px 4px 4px 0 0 input(Search) 0 / 20px 4px List 0 / 24px 0 List item 0 / 24px 0 Navdrawer 0 / 36px 0 Snackbar 0 / 24px 4px Tooltip 0 / 16px 4px Toast 0 / 26px 26px Please refer to the Schema documentation for each component to find out what the default and min/max radius values are for each theme. Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/schemas.html": {
    "href": "components/themes/sass/schemas.html",
    "title": "Schemas",
    "keywords": "Schemas Schemas are a simple, declarative way to list all properties a component theme uses. Overview Schemas are like recipes. They are simple Sass maps, similar to JSON that allow us to define all properties a theme might use. Those properties can be colors, elevation levels, roundness, etc. Anything a theme consumes can be described as a schema, then passed to the global or component theme. A component schema can extend an existing component schema and override its properties. Schemas should be used when you want to change the default theme properties of a component in a way that will not result in duplicating CSS style rules or CSS variables. Let's take a look at the light Material Avatar schema: $_light-avatar: extend( $_square-shape-avatar, ( background: ( color: ('gray', 400) ), color: ( color: ('gray', 800) ), ) ); As you can see from the example above, the component schema defines the properties the Avatar Theme consumes. It just prescribes the colors the avatar should use, without referencing a concrete color palette map. Let's take the background property for example. It tells the avatar theme what the default background should be. The background can be assigned any value, that is, a value that can be assigned to the CSS background-color property. You can also assign a map to background, like in the sample above. When you assign a map to the background property, the map should contain functions as the key names (e.g. color), and arguments for the functions as values for said keys. We do this to be able to resolve the values later on, when the avatar theme is being built. See, because we don't know the palette a user might pass to the avatar theme, we should be able to resolve it later on, only when the palette is known. We can also add other functions and arguments to the background map as key value pairs. For instance we may want to run the resolved result from color: ('gray', 400) through the to-opaque function we have, to resolve the HEX value for the 400 color variant of the gray palette, which is usually represented in rgba. Let's see how the schema will change when we make this addition: $_light-avatar: ( icon-background: ( color: ('gray', 400), to-opaque: #fff ), ... ); The result of the color function call will automatically be passed as the first argument to the to-opaque function. Since to-opaque accepts a second argument for the background color, we provide it as the value. If the function doesn't accept any additional arguments, you should assign an empty list () as its value. Extending Schemas As you saw from the example above. Schemas are simple maps and as such can be extended by overriding some of their properties. You might want to extend the material avatar schema by only changing its background property, without having to copy all other properties manually. This is easily done using the extend function we provide. $my-avatar-schema: extend($_light-avatar, ( background: limegreen )); Now the value of $my-avatar-schema will contain all properties of $_light-avatar, but the value for background will have be limegreen. Predefined Schemas We provide predefined light and dark schemas that we use in our theme presets: Light Schemas $light-material-schema $light-fluent-schema $light-bootstrap-schema $light-indigo-schema Dark Schemas $dark-material-schema $dark-fluent-schema $dark-bootstrap-schema $dark-indigo-schema We use the light and dark schemas accordingly with the light and dark palettes to create the component themes. For example, using the $light-material-schema along with the $light-material-palette will help us create all of the light material component themes. And vice versa - using the $dark-material-schema along with the $dark-material-palette will give us the dark material component themes. Consuming Schemas Until now we have shown what a component schema is and how you can create one, but we have not talked about how you can use schemas in your Sass project. Individual component schemas are bundled up in a global schema map for all components we have. So the $_light-avatar schema is part of the global $light-material-schema. The $light-material-schema maps component schemas to component names. The $light-material-schema looks something like this: $light-material-schema: ( igx-avatar: $_light-avatar, igx-badge: $_light-badge, ... ); We do this so we can pass the entire $light-material-schema to the theme mixin. So for instance if we wanted to modify the $light-material-schema by replacing the default component schema the avatar component uses we might do: $my-light-schema: extend($light-material-schema, ( igx-avatar: $my-avatar-schema )); Now we can pass all that to the global theme mixin: // styles.scss @include theme( $schema: $my-light-schema, $palette: $default-palette ); Avatars in your global theme will now have use limegreen color for their background. Some component schemas, like the button schema, have property definitions for roundness. This means that you can change the default button roundness for all buttons. Finally, let's see how individual component themes can use the schema we created above. $my-avatar-theme: avatar-theme( $schema: $my-avatar-schema ); Conclusions Although schemas require a deeper knowledge of our theming library compared to theme functions and mixins, they allow us to declare component themes without increasing the size of the produced CSS. Another benefit of using schemas is how reusable and extensible they are as they are simple Sass maps. You can mix and match component schemas to create global theme schemas. We use schemas internally to create variations that result in different pre-bundled themes for Material, Bootstrap, Fluent, and Indigo. API Overview Avatar Schema Light Components Schema Dark Components Schema Global Theme Avatar Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/sass/typography.html": {
    "href": "components/themes/sass/typography.html",
    "title": "Typography",
    "keywords": "Typography The Ignite UI for Angular Typography Sass module allows you to modify the typography for all components in your application, specific typographic scale, or specific components. Overview An application can define multiple typography scales that may share scale categories between one another. A scale category is a set of type styles, containing information about font-family, font-size, font-weight, line-height, letter-spacing, and text-transform. Ignite UI for Angular exposes 4 default type scales for each of its themes - $material-type-scale, $fluent-type-scale, $bootstrap-type-scale, and $indigo-type-scale, which are in turn used by the typography mixin to set the typography styles. You can, however, create additional type scales. In many cases you would only need to make slight modifications to the typography, thus it's recommended that you read the Typography section of the CSS Variables documentation first, if you haven't already. Using Sass to modify the typography is only required if you want to make deeper changes pertaining to the entire typographic scale. Usage Important By default we don't apply any typography styles. To use our typography in your application you have to set the ig-typography CSS class on a top-level element and include the typography mixin in your base .scss file. We have selected Titillium Web to be the default font in the Material theme for Ignite UI for Angular. To use it you have to host it yourself, or include it from Google Fonts: <link href=\"https://fonts.googleapis.com/css?family=Titillium+Web:300,400,600,700\" rel=\"stylesheet\"> There are a several mixins and functions that are used to set and retrieve category styles to/from a type scale. Those are: type-style [function] - Returns a set of style rules to be used by a type scale category. type-scale [function] - Returns a set of 13 style categories. type-scale-category [function] - Returns a map of style rules from a type scale and category. type-style [mixin] - Adds style rules to a selector from a specific type scale and category. type-style-vars [mixin] - Adds style rules to a selector from a specific type style. typography [mixin] - Defines the global application typography styles. Let's take a closer look at what each one of the aforementioned mixins and functions do. The Type Style The type-style function is an interface-like function that simply ensures that certain arguments are passed as part of the style set for a scale category. Say, for instance that we want to define a new set of style rules for the h1 scale category. To do so, we could simply write: $h1-style: type-style( $font-size: 112px, $font-weight: 600, $line-height: 96px, ... ); The Type Scale The type scale produces a map of 13 typography styles used as scale categories. To generate a new type scale, do the following: $my-type-scale: type-scale(...); Important You have to provide a type style for each of the 13 scale categories. A style can be generated using the type-style function as shown above. $my-type-scale: type-scale($h1: $h1-style, [$h2...$overline]); You can modify an existing type scale by extending it. To change the h1 type style of the $material-type-scale you can do: $my-type-scale: extend( $material-type-scale, ( h1: type-style(...) ) ); Adding additional type styles to a scale is just as easy: $my-type-category: type-style( $font-weight: 600, $font-size: 42px, $text-transform: uppercase, ... ); $my-type-scale: extend( $my-type-scale, ( 'my-category': $my-type-category ) ); The Typography Mixin The typography mixin defines the global typography styles for an application, including how the native h1-h6 and p elements are styled. It currently accepts 2 arguments: $font-family - The global font family to be used by the application. $type-scale - The default type scale to be used by the application. To use the typography styles, include the typography mixin anywhere after the core mixin and before the theme mixin. Let's take advantage of the type scale $my-type-scale we defined above and make it the default type scale. @include typography( $font-family: $material-typeface, $type-scale: $my-type-scale, ); We expose four variables for typeface, similar to type-scale - $material-typeface, $fluent-typeface, $bootstrap-typeface, and $indigo-typeface. You can use any of them in combination with any type-scale when including the typography mixin. Custom Type Styles The type-style mixin can be used to retrieve the style rules for a scale category from a specific type scale. Furthermore, it allows you to add additional style rules. .my-fancy-h1 { @include type-style('h1') { color: royalblue; } } The above code will produce a class style selector .my-fancy-h1, which contains all of the style rules for the h1 scale category from $my-type-scale with the addition of the color property set to the royalblue color. Now, if you set the class of any element to .my-fancy-h1, it will look like any other h1 element but be also royalblue in color. Component Typography Most of the components in Ignite UI for Angular use scale categories for styling the text. For instance, the igx-card component uses the following scale categories: h6 - used for styling card title. subtitle-2 - used for styling card subtitle and small title. body-2 - used for styling card text content. There are two ways to change the text styles of a card. The first is by modifying the h6, subtitle-2, and/or body-2 scales in the material type scale that we pass to the typography mixin. So if we wanted to make the title in a card smaller, all we have to do is change the font-size of the h6 scale category. // Create a custom h6 scale category style $my-h6: type-style($font-size: 12px); // Create a custom type scale with the modified h6 $my-type-scale: extend($material-type-scale, (h6: $my-h6)); // Pass the custom scale to the global typography mixin @include typography($type-scale: $my-type-scale); Warning The above code will modify the h6 scale category globally, which will affect the look and feel of all components that use the h6 scale. This is done for consistency so that all h6 elements look the same across your app. We understand that you may want to apply the modification for h6 to specific components only, like the igx-card component in our case. This is why every component has its own typography mixin, which accepts a category configuration. // Create a custom h6 scale category style $my-h6: type-style($font-size: 12px); // You can specify which categories from the type sale the card uses $card-categories: ( title: 'h6', title-small: 'subtitle-2', subtitle: 'subtitle-2', content: 'body-2', ); .my-cool-card { // Overwrite the 'h6' type style for this scope @include type-style-vars('h6', $my-h6); // Pass the custom card catergories to the card typography mixin @include card-typography($card-categories); } We no longer include the typography mixin by passing it the $my-type-scale scale with our modification to the h6 category. Now all we do is pass the custom h6 style we created to the type-style-vars mixin. CSS Classes In addition to adding text styles for all components based on type scale categories, we also style the default h1-h6 and p elements. This allows us to separate semantics from styling. So for instance, even though the h1 tag has some default styling that we provide when using typography, you can modify it to look like an h3 by giving it a class of ig-typography__h3. <h1 class=\"ig-typography__h3\">Some text</h1> Here's a list of all CSS classes we provide by default: ig-typography__h1 ig-typography__h2 ig-typography__h3 ig-typography__h4 ig-typography__h5 ig-typography__h6 ig-typography__subtitle-1 ig-typography__subtitle-2 ig-typography__body-1 ig-typography__body-2 ig-typography__button ig-typography__caption ig-typography__overline Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/themes/typography.html": {
    "href": "components/themes/typography.html",
    "title": "Typography",
    "keywords": "Typography The typography in Ignite UI for Angular is modeled after the [Material Type System](https://material.io/design/typography/the-type-system.html#). It's non-intrusive and optional, allowing you to modify the type styles using CSS only. Overview The type system is a type scale consisting of 13 different category type styles used across most components. All of the scale categories are completely reusable and adjustable by the end user. Here's a list of all 13 category styles as defined for the Material Theme in Ignite UI for Angular: Scale Category Font Family Font Weight Font Size Text Transform Letter Spacing Line Height CSS Class CSS Variables h1 Titillium Web 300 6 rem none -.09375 rem 7 rem ig-typography__h1 --ig-h1-* h2 Titillium Web 300 3.75 rem none -.0312 rem 4.4375 rem ig-typography__h2 --ig-h2-* h3 Titillium Web 400 3 rem none 0 3.5625 rem ig-typography__h3 --ig-h3-* h4 Titillium Web 400 2.125 rem none .015625 rem 2.5 rem ig-typography__h4 --ig-h4-* h5 Titillium Web 400 1.5 rem none 0 1.75 rem ig-typography__h4 --ig-h5-* h6 Titillium Web 600 1.25 rem none .009375 rem 1.5 rem ig-typography__h4 --ig-h6-* subtitle-1 Titillium Web 400 1 rem none .009375 rem 1.5 rem ig-typography__subtitle-1 --ig-subtitle-1-* subtitle-2 Titillium Web 600 .875 rem none .00625 rem 1.5 rem ig-typography__subtitle-2 --ig-subtitle-2-* body-1 Titillium Web 400 1 rem none .03125 rem 1.75 rem ig-typography__body-1 --ig-body-1-* body-2 Titillium Web 400 .875 rem none .015625 rem 1.25 rem ig-typography__body-2 --ig-body-2-* button Titillium Web 600 .875 rem uppercase .046875 1 rem ig-typography__button --ig-button-* caption Titillium Web 400 .75 rem none .025 rem 1 rem ig-typography__caption --ig-caption-* overline Titillium Web 400 .625 rem uppercase .09375 rem 1 rem ig-typography__overline --ig-overline-* Each theme defines its own type scale. This means each one of the themes we ship - Material, Fluent, Boostrap, and Indigo will have its own type scale. They all share the same scale categories, but can have different font family, weight, size, text transform, letter spacing, and line height. Usage Important By default we don't apply any typography styles. To use our typography in your application you have to set the ig-typography CSS class on a top-level element. All of its children will then use our typography styles. We have selected Titillium Web to be the default font for the Material Theme in Ignite UI for Angular. To use it you have to host it yourself, or include it from Google Fonts: <link href=\"https://fonts.googleapis.com/css?family=Titillium+Web:300,400,600,700\" rel=\"stylesheet\" /> Enable the typography styles by setting the ig-typography class on the body element. <!-- index.html --> <body class=\"ig-typography\"> <app-root></app-root> </body> Changing the Font Family To change the font family in all components, all you have to do is overwrite the --ig-typography CSS variable with another font-family value; /* styles.css */ :root { --ig-font-family: \"Open Sans\", sans-serif; } Type Styles The type styles are used internally by most of the components in Ignite UI for Angular. For instance, the documentation says the button component uses the button type style. This means that we can modify the typography of the button component by ovewriting the included --ig-button-* CSS variables. Let's say we want to change the text of the button in the Material Theme to always be lowercase. :root { --ig-button-text-transform: lowercase; } Additional Resources Typography with Sass Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/time-picker.html": {
    "href": "components/time-picker.html",
    "title": "Angular Time Picker Component | Ignite UI for Angular",
    "keywords": "Angular Time Picker Overview The time picker component allows users to input or select time portions of a `Date` object from a dropdown or dialog with spinners, which is then mirrored in the input field. In dropdown mode, which is the default one, the input field is editable and users can also edit selected time. The time picker component has different built-in templates for displaying a clock button, as well as features like validation, custom time formatting, and more. Angular Time Picker Example In general, users can enter a preferred time either through text input or by choosing a time value from an Angular Time Picker dropdown. The basic Angular Time Picker example below shows how users can easily enter the value with the help of the dropdown or by using the keyboard. Getting Started with Ignite UI for Angular Time Picker To get started with the Ignite UI for Angular Time Picker component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTimePickerModule in your app.module.ts file. Note The IgxTimePicker is also dependent on both the BrowserAnimationsModule and HammerModule for touch interactions. They need to be added to the AppModule as well. // app.module.ts ... import { HammerModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxTimePickerModule } from 'igniteui-angular'; // import { IgxTimePickerModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., BrowserAnimationsModule, HammerModule, IgxTimePickerModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTimePickerComponent as a standalone dependency, or use the IGX_TIME_PICKER_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { FormsModule } from '@angular/forms'; import { IGX_TIME_PICKER_DIRECTIVES } from 'igniteui-angular'; // import { IGX_TABS_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-time-picker [(ngModel)]=\"time\"></igx-time-picker>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_TIME_PICKER_DIRECTIVES, FormsModule] /* or imports: [IgxTimePickerComponent, FormsModule] */ }) export class HomeComponent { public time: Date; } Now that you have the Ignite UI for Angular Time Picker module or directives imported, you can start using the igx-time-picker component. Using the Angular Time Picker Default To add the time picker in a template, use the following code: <!--meeting.component.html--> <igx-time-picker></igx-time-picker> The output should be the same as the one in the demo. Binding The Time Picker in Angular can be bound to either a Date object or time-only string value in ISO 8601 format by setting the value property or ngModel. First create a time string in ISO 8601 format: public time = '09:15:30'; Then use the ngModel to create a two-way data-binding: <igx-time-picker [(ngModel)]=\"time\"></igx-time-picker> or set value input in the template: <igx-time-picker [value]=\"time\"></igx-time-picker> To use it in a reactive form you need to set a formControlName on the picker <form [formGroup]=\"form\"> <igx-time-picker formControlName=\"timePicker\"></igx-time-picker> </form> export class SampleFormComponent { // ... public form: FormGroup; constructor(private fb: FormBuilder) { this.form = this.fb.group({ timePicker: ['', Validators.required] }); } } Projecting components The time picker component allows projecting child components - the same as in the IgxInputGroupComponent: igxLabel, IgxHint, igxPrefix, igxSuffix, excluding IgxInput. More detailed information about this can be found in the Label & Input topic. In the default configuration, a dropdown/dialog toggle icon is shown as a prefix. It can be changed or redefined using the IgxPickerToggleComponent component. It can be decorated with either igxPrefix or igxSuffix, which will define its position - at the start of the input or at the end respectively. In the following example we have added a custom label and hint and changed the default toggle icon position to be displayed as a suffix: <igx-time-picker [(ngModel)]=\"date\" mode=\"dialog\" [inputFormat]=\"'hh:mm'\"> <label igxLabel>Home Time </label> <igx-picker-toggle igxSuffix> <igx-icon>home</igx-icon> </igx-picker-toggle> <igx-hint>{{date.toLocaleString()}}</igx-hint> </igx-time-picker> public date: Date = new Date(); And here's our templated Ignite UI for Angular Time Picker: Custom action buttons The IgxTimePickerComponent supports action button customization. To achieve that, wrap the buttons in ng-template marked with the igxPickerActions directive selector. In the example below, custom action buttons are added for 'CANCEL', 'DONE' and 'NOW' actions. <!-- sample.component.html --> <igx-time-picker #picker format=\"hh:mm\" mode=\"dropdown\"> <ng-template igxTimePickerActions> <div class=\"container action-buttons\"> <button igxButton=\"flat\" (click)=\"picker.cancelButtonClick()\">cancel</button> <button igxButton=\"flat\" (click)=\"picker.okButtonClick()\">done</button> <button igxButton=\"flat\" (click)=\"selectNow(picker)\">now</button> </div> </ng-template> </igx-time-picker> // sample.component.ts ... public selectNow(timePicker: IgxTimePickerComponent) { timePicker.value = new Date(); timePicker.close(); } ... And there we have it, a re-templated time picker with dropdown, custom actions and two-way binding support: Customizing the toggle and clear icons The IgxTimePickerComponent can be configured with IgxPickerToggleComponent and IgxPickerClearComponent, these can be used to change the toggle and clear icons without having to add your own click handlers. <igx-time-picker> <label igxLabel>Select time</label> <igx-picker-toggle igxPrefix> <igx-icon>snooze</igx-icon> </igx-picker-toggle> <igx-picker-clear igxSuffix> <igx-icon>delete</igx-icon> </igx-picker-clear> </igx-time-picker> Keyboard Navigation Users can navigate the component's time portions via the keyboard Up and Down arrow keys or by scrolling in the input field and in the dropdown/dialog. Navigation in the input is possible regardless of the minValue or maxValue, while navigation in the dropdown/dialog will be restricted within the minValue and maxValue range. The time picker dropdown can be opened either by toggle icon click, Space key or Alt + Down keys press. In dialog mode this can be done by input click. Enter key press or mouse click outside the dropdown/dialog applies the selection and closes the dropdown/dialog. Pressing the Escape key cancels the selection and closes the dropdown/dialog. When entered a new value while dropdown is closed, click outside of the time picker or press Tab to move the focus so that the value is accepted. Examples Dialog Mode The default time picker mode is editable dropdown mode. To change the time picker mode to read-only dialog mode, set the mode input to dialog: // timePickerDropdown.component.ts import { PickerInteractionMode } from 'igniteui-angular'; // import { PickerInteractionMode } from '@infragistics/igniteui-angular'; for licensed package ... public mode = PickerInteractionMode.Dialog; <!--timePickerDropdown.component.html--> <igx-time-picker [mode]=\"mode\"></igx-time-picker> or just change the mode in the time picker like this: <!--timePickerDropdown.component.html--> <igx-time-picker mode=\"dialog\"></igx-time-picker> In dialog mode, the dialog header displays the currently selected time in the picker's input format. You can change the header position by setting the headerOrientation property. When the minValue and maxValue are set the dialog displays the time within that range only. See the Min max value example below, for more details. Display and input format The time picker component supports different display and input formats. The display format is the format of the value when in edit mode and can be one of the listed Angular DatePipe formats. This allows it to support predefined format options, such as shortTime and longTime. The input format is the format of the value when not in edit mode and the format, in which the time portions are displayed in the dropdown/dialog. The inputFormat property accepts a constructed format string using characters supported by the DatePipe, e.g. hh:mm:ss, but doesn't support predefined format options, such as shortTime and longTime. If the inputFormat property is not defined, it defaults to hh:mm tt. <igx-time-picker [(ngModel)]=\"time\" [inputFormat]=\"`hh:mm:ss`\" [displayFormat]=\"`shortTime`\"> </igx-time-picker> Note The IgxTimePicker now supports IME input. When composition ends, the control converts the wide-character numbers to ASCII characters. Increment and decrement The time picker exposes public increment and decrement methods, which accept two optional parametars: the DatePart to be modified and the delta by which it will be changed. If not specified the DatePart defaults to Hours and the delta defaults to itemsDelta. You can find a sample that illustrates the use of both methods at Date Time Editor Directive. Forms and Validation The time picker component supports all directives from the core FormsModule NgModel and ReactiveFormsModule (FormControl, FormGroup, etc.). This also includes the Forms Validators functions. In addition, the component's min and max values also act as form validators. The Reactive Forms Integration sample demonstrates how to use the igxTimePicker in Reactive Forms. Min max value You can specify minValue and maxValue to restrict the user input, in which case the dropdown/dialog will display the time within that range only. In dropdown mode however, it is still possible for the user to type in an invalid time. You can handle the validationFailed event in order to notify the user if that happens. Note The min/max values should be a Date object or a time-only string in the ISO 8601 format: // app.module.ts ... import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { IgxTimePickerModule, IgxToastModule } from 'igniteui-angular'; // import { IgxTimePickerModule, IgxToastModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., BrowserAnimationsModule, IgxTimePickerModule, IgxToastModule], ... }) export class AppModule {} // app.component.ts public time = '10:00:00'; public min = '09:15:30'; public max = '18:15:30'; @ViewChild('toast', { static: true }) private toast; public onValidationFailed() { this.toast.open(); } <igx-time-picker [(ngModel)]=\"time\" [itemsDelta]=\"{hours:2, minutes:5}\" [inputFormat]=\"'hh:mm:ss tt'\" [headerOrientation]=\"true\" [minValue]=\"min\" [maxValue]=\"max\" (onValidationFailed)=\"onValidationFailed()\"> <label igxLabel>Meeting Start</label> </igx-time-picker> <igx-toast #toast message=\"Value must be between 09:15:30 AM and 06:15:30 PM\"></igx-toast> The dropdown displays values within the min/max range (09:15:30 AM~06:15:30 PM) based on the items delta. A toast is added to show a message when an invalid time has been typed in. Note The displayed values for each time portion in the dropdown/dialog are calculated based on the items delta always starting from zero. If the minValue and maxValue does not match the items delta, the displayed values will start/end from the next/last possible value that matches the threshold. And there we have it: Using date and time picker together In some cases when the IgxDatePicker and the IgxTimePicker are used together, we might need them to be bound to one and the same Date object value. To achieve that in template driven forms, use the ngModel to bind both components to the same Date object. In reactive forms, we can handle the valueChange event of each component and update the value of the other. Styling To get started with styling the time picker, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the time-picker-theme and accepts parameters that style the time picker. $my-time-picker-theme: time-picker-theme( $text-color: #E4C8A5, $hover-text-color: #ECAA53, $selected-text-color: #ECAA53, $header-background: #ECAA53, $header-hour-text-color: #011627, $header-time-period-color: #011627, $background-color: #011627 ); Note In order to style any additional components that are used as part of the time picker window's content (such as the IgxButton), an additional theme should be created that is specific to the respective component and is placed under the dialog window's scope only (so it does not affect the rest of the application). Since the time picker window uses the IgxOverlayService, in order for our custom theme to reach down the time picker window that we want to style, we will provide a specific outlet where the dialog window will be placed in the DOM when it is visible. The items in our time picker are not descendants of our component host - they are currently being displayed in the default overlay outlet, at the end of the document body. Changing this is done by making use of the outlet property in the overlaySettings. The outlet controls where the overlay container should be rendered. Here, we can pass a reference to the element where we'd like our container to be: <igx-time-picker #picker [overlaySettings]=\"{ outlet: element }\"> </igx-time-picker> export class TimepickerStylingComponent { constructor(public element: ElementRef) { } } Now, the time picker's items are properly rendered inside of our component's host, which means that our custom theme will take effect: Note In order to learn more about the various options for providing themes to elements that are shown by using the IgxOverlayService, you can take a look at the Overlay styling topic. Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the theme like that: @include time-picker($my-time-picker-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include time-picker($my-time-picker-theme); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($my-time-picker-theme); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($my-time-picker-theme); } Demo API References IgxIconComponent IgxInputDirective IgxInputGroupComponent IgxTimePickerComponent IgxTimePickerComponent Styles IgxOverlayService IgxOverlay Styles Theming Dependencies IgxInputGroup Theme IgxIcon Theme IgxButton Theme IgxOverlay Theme Additional Resources Date Time Editor Label & Input Reactive Forms Integration Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/toast.html": {
    "href": "components/toast.html",
    "title": "Angular Toast Component – Ignite UI for Angular | Infragistics",
    "keywords": "Angular Toast Component Overview The Ignite UI for Angular Toast component provides information and warning messages that are auto-hiding, non-interactive and cannot be dismissed by the user. Notifications can be displayed at the bottom, the middle, or the top of the page. Angular Toast Example Getting Started with Ignite UI for Angular Toast To get started with the Ignite UI for Angular Toast component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxToastModule in your app.module.ts file. // app.module.ts ... import { IgxToastModule } from 'igniteui-angular'; // import { IgxToastModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxToastModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxToastComponent as a standalone dependency. // home.component.ts import { IgxToastComponent, IgxButtonDirective } from 'igniteui-angular'; // import { IgxToastComponent, IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button igxButton=\"contained\" (click)=\"toast.open()\">Show notification</button> <igx-toast #toast>Notification displayed</igx-toast> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxToastComponent, IgxButtonDirective] /* or imports: [IgxTimePickerComponent, IgxButtonDirective] */ }) export class HomeComponent { public time: Date; } Now that you have the Ignite UI for Angular Toast module or component imported, you can start using the igx-toast component. Using the Angular Toast Show Toast In order to display the toast component, use its open() method and call it on a button click. You can pass the toast content inside the element. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"toast.open()\">Show notification</button> <igx-toast #toast>Notification displayed</igx-toast> Another way to set the toast content is to directly pass the message as a parameter to the open() method. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"toast.open('Notification displayed')\">Show notification</button> <igx-toast #toast></igx-toast> The open() method can also be used in the AppComponent file to manage the value of the message. // app.component.ts @ViewChild('toast', { read: IgxToastComponent }) public toast: IgxToastComponent; public message: any; public ngOnInit() { this.message = 'Display message'; } public showMessage() { this.toast.open(this.message); } Warning The igx-toast component show and hide methods have been deprecated. open and close should be used instead. Examples Hide/Auto Hide Once opened, the toast disappears after a period specified by the displayTime input which is set initially to 4000 milliseconds. This behavior is enabled by default but you can change this by setting autoHide to false. This way, the toast remains visible. Using the toast close() method, you can close the component. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"toast.open()\">Show Toast</button> <button igxButton=\"contained\" (click)=\"toast.close()\">Hide Toast</button> <igx-toast #toast [autoHide]=\"false\">Notification displayed</igx-toast> If the sample is configured properly, the toast will appear when the Show button is clicked. For the first component auto-hide feature is disabled and the toast will disappear on 'Hide' button click. In the other two components you can see in action how to pass different messages through the open() method and use content projection. Display Time Use displayTime and set it to an interval in milliseconds to configure how long the toast component is visible. <!--sample.component.html--> <button igxButton=\"contained\" (click)=\"toast.open()\">Show notification</button> <igx-toast #toast displayTime=\"1000\">Notification displayed</igx-toast> If the sample is configured properly, the toast auto hides faster. Positioning Use positionSettings property to configure where the toast appears. By default, it is displayed at the bottom of the page. In the sample below, we set notification to appear at the top position. <!--sample.component.html--> <div> <button igxButton=\"contained\" (click)=\"open(toast)\">Show notification on top</button> <igx-toast #toast>Notification displayed</igx-toast> </div> // sample.component.ts import { VerticalAlignment } from 'igniteui-angular'; // import { VerticalAlignment } from '@infragistics/igniteui-angular'; for licensed package ... public open(toast) { toast.positionSettings.verticalDirection = VerticalAlignment.Top; toast.open(); } ... Overlay Settings The IgxToastComponent uses Overlay Settings to control the position of its container. The default settings can be changed by defining Custom OverlaySettings and passing them to the toast open() method: public customSettings: OverlaySettings = { positionStrategy: new GlobalPositionStrategy( { horizontalDirection: HorizontalAlignment.Left, verticalDirection: VerticalAlignment.Top }), modal: true, closeOnOutsideClick: true, }; toast.open(customSettings); Users can also provide a specific outlet where the toast will be placed in the DOM when it is visible: <igx-toast [outlet]=\"igxBodyOverlayOutlet\"></igx-toast> <div #igxBodyOverlayOutlet igxOverlayOutlet></div> Styling To get started with styling the toast, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the toast-theme and accepts the $shadow, $background, $text-color and the $border-radius parameters. $custom-toast-theme: toast-theme( $background: #dedede, $text-color: #151515, $border-radius: 12px ); Using CSS variables The last step is to pass the custom toast theme: @include css-vars($custom-toast-theme); Using mixins In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom toast theme to the `igx-toast` mixin @include toast($custom-toast-theme); } } Using color palettes Instead of hardcoding the color values, like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $white-color: #dedede; $black-color: #151515; $light-toast-palette: palette($primary: $white-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-toast-theme: toast-theme( $background: color($light-toast-palette, \"primary\", 400), $text-color: color($light-toast-palette, \"secondary\", 400), $border-radius: 12px ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to the Palettes topic for detailed guidance on how to use them. Using schemas You can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-toast schema: // Extending the toast schema $light-toast-schema: extend($_light-toast, ( background: ( color: (\"primary\", 400) ), text-color: ( color: (\"secondary\", 400) ), border-radius: 12px ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( igx-toast: $light-toast-schema )); // Defining toast with the global light schema $custom-toast-theme: toast-theme( $palette: $light-toast-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. API References IgxToastComponent IgxToastComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/toggle.html": {
    "href": "components/toggle.html",
    "title": "Angular Toggle Component | Ignite UI for Angular",
    "keywords": "Angular Toggle Directive Overview The Ignite UI for Angular Toggle directive allows the users to make a container in the DOM toggleable through user interaction. Angular Toggle Example Getting Started with Ignite UI for Angular Toggle To get started with the Ignite UI for Angular Toggle directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxToggleModule in your app.module.ts file. // app.module.ts ... import { IgxToggleModule } from 'igniteui-angular'; // import { IgxToggleModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxToggleModule] ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxToggleDirective as a standalone dependency. // home.component.ts import { IgxToggleDirective, IgxButtonDirective } from 'igniteui-angular'; // import { IgxToggleDirective, IgxButtonDirective } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <button class=\"toggle-button\" igxButton=\"contained\" (click)=\"toggleContent()\">Toggle</button> <div class=\"toggle-content\" igxToggle> <section class=\"toggle-section\"> <img src=\"assets/images/toggle/nature.jpg\" alt=\"Nature\" /> </section> </div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IgxToggleDirective, IgxButtonDirective] }) export class HomeComponent {} Now that you have the Ignite UI for Angular Toggle module or directive imported, you can start using the igxToggle directive. Using the Angular Toggle Directive Display Toggle In order to show and hide the toggle content, use its open and close methods: import { IgxToggleDirective } from 'igniteui-angular' // import { IgxToggleDirective } from '@infragistics/igniteui-angular'; for licensed package ... export class Class { @ViewChild(IgxToggleDirective) toggle: IgxToggleDirective; toggleContent() { if (this.toggle.collapsed) { this.toggle.open(); } else { this.toggle.close(); } } } Then in the template of our component, we can apply the directive on the element we want to be togglable: <!--template.component.html--> <button class=\"toggle-button\" igxButton=\"contained\" (click)=\"toggleContent()\">Toggle</button> <div class=\"toggle-content\" igxToggle> <section class=\"toggle-section\"> <img src=\"assets/images/toggle/nature.jpg\"/> </section> </div> Examples Change Position In the next sample, we'll use a different positioning strategy so that the content is displayed below the button. The igxToggle directive uses the IgxOverlayService provider. The open, close and toggle methods accept optional overlay settings that control how the content is displayed. If omitted, the default overlay settings are used as seen in the previous sample. Note By default, the closeOnOutsideClick property is set to true. In order to disable this functionality, the property has to be set to false. Additionally, the closeOnEscape property defaults to false, so in order to make use of it, we have to set it to true. // template.component.ts ... @ViewChild(IgxToggleDirective) public igxToggle: IgxToggleDirective; @ViewChild('button') public igxButton: ElementRef; public _positionSettings = { horizontalStartPoint: HorizontalAlignment.Left, verticalStartPoint: VerticalAlignment.Bottom }; public _overlaySettings = { target: this.igxButton.nativeElement, closeOnOutsideClick: false, closeOnEscape: true, positionStrategy: new ConnectedPositioningStrategy(this._positionSettings) }; public toggle() { this.igxToggle.toggle(this._overlaySettings); } This is how our toggle should look like now: Automatic Toggle Actions In order to avoid using the open and close methods, we can use a directive, which has an onClick handler, and changes the state of the toggle we are referring to automatically. If we would like to take advantage of this functionality, we will have to use the IgxToggleActionDirective from the IgxToggleModule and assign the IgxToggleDirective to it. Note The IgxToggleActionDirective should be declared on the element we are planing to use like a trigger (toggle). <!--template.component.html--> <button class=\"toggle-button\" igxButton=\"contained\" [igxToggleAction]=\"toggleRef\">Toggle</button> <div class=\"toggle-content\" igxToggle #toggleRef=\"toggle\"> <section class=\"toggle-section\"> <h6>Automatic toggle actions</h6> </section> </div> After these changes the toggle should work exactly in the same way. Note By default IgxToggleActionDirective excludes its host element from the closeOnOutsideClick property. Therefore, clicking on the host element will not fire any event. Additionally, this directive will set its host element as the overlay settings target. Automatic Toggle Service Provider There is a convenient way to keep the state of the igxToggle directive and command it via the igxNavigationService provider. We just need to set an identifier for our igxToggle element, which will be used to register the toggle with the service. If we would like to control its state automatically, we have to pass this identifier to the igxToggleActionDirective. <!--template.component.html--> <button igxToggleAction=\"toggleId\" class=\"toggle-button\" igxButton=\"contained\">Toggle</button> <div igxToggle id=\"toggleId\" class=\"toggle-content\"> <section class=\"toggle-section\"> <h6>Toggled by the service provider</h6> </section> </div> If all went well, it will look like this: Offsetting the Toggle Container We can manipulate the position of the toggle container along the corresponding axis by a provided amount: // deltaX and deltaY determine by how much the container will be offset compared to its' previous position public offsetToggle() { const deltaX = 30; const deltaY = 30; this.toggle.setOffset(deltaX, deltaY); } API References IgxToggleDirective IgxToggleActionDirective Additional components and/or directives with relative APIs that were used: IgxOverlayOutletDirective IgxOverlayService igxNavigationService Theming Dependencies IgxOverlay Theme Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/tooltip.html": {
    "href": "components/tooltip.html",
    "title": "Angular Tooltip Component | Ignite UI for Angular",
    "keywords": "Angular Tooltip Directive Overview The igxTooltip and the igxTooltipTarget directives provide us with the ability to create a fully customizable tooltip and attach it to any element on our page. While most tooltips have a limited number of available positions, with the igxTooltipTarget directive we can specify any position we want on the page while keeping it in relation to the target (anchor) and provide various other overlay settings like scroll strategies and custom animations! Angular Tooltip Example Getting Started with Ignite UI for Angular Tooltip To get started with the Ignite UI for Angular Tooltip directive, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTooltipModule in your app.module.ts file. // app.module.ts ... import { IgxTooltipModule } from 'igniteui-angular'; // import { IgxTooltipModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [IgxTooltipModule], }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTooltipDirective as a standalone dependency, or use the IGX_TOOLTIP_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_TOOLTIP_DIRECTIVES, IgxAvatarComponent } from 'igniteui-angular'; // import { IGX_TOOLTIP_DIRECTIVES, IgxAvatarComponent } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-avatar class=\"avatar\" #target=\"tooltipTarget\" [igxTooltipTarget]=\"tooltipRef\" src=\"assets/images/avatar/10.jpg\" size=\"medium\" shape=\"circle\"> </igx-avatar> <div #tooltipRef=\"tooltip\" igxTooltip> Her name is Madelyn James </div> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_TOOLTIP_DIRECTIVES, IgxAvatarComponent] /* or imports: [IgxTooltipDirective, IgxTooltipTargetDirective, IgxAvatarComponent] */ }) export class HomeComponent {} Now that you have the Ignite UI for Angular Tooltip module or directives imported, you can start using the igxTooltip directive. Using the Angular Tooltip Let's say we want to create a simple text tooltip like the one above. In our case, we're using our awesome IgxAvatar as the element, so we start by importing the IgxAvatarModule first. // app.module.ts import { IgxTooltipModule, IgxAvatarModule } from 'igniteui-angular'; // import { IgxTooltipModule, IgxAvatarModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [IgxTooltipModule, IgxAvatarModule], }) export class AppModule {} Tooltip target The avatar will be our target and all we have to do is set the igxTooltipTarget directive on it, which basically marks our element as one that has a tooltip. The igxTooltipTarget directive extends the igxToggleAction directive. The igxTooltipTarget directive is exported with the name tooltipTarget. <!--simpleTooltip.component.html--> <igx-avatar class=\"avatar\" #target=\"tooltipTarget\" igxTooltipTarget src=\"assets/images/avatar/10.jpg\" size=\"medium\" shape=\"circle\"> </igx-avatar> Tooltip Now let's create the tooltip element itself! Since we want a simple text tooltip, we will define an ordinary div element with text inside and set the igxTooltip directive on it, which marks it as a tooltip. The igxTooltip directive extends the igxToggle directive. The igxTooltip directive is exported with the name tooltip. <!--simpleTooltip.component.html--> <div #tooltipRef=\"tooltip\" igxTooltip> Her name is Madelyn James </div> Attach tooltip to target Now that we have both our target and tooltip defined, all that's left for us to do is assign the tooltip's reference to the igxTooltipTarget selector of the target. <!--simpleTooltip.component.html--> <igx-avatar class=\"avatar\" #target=\"tooltipTarget\" [igxTooltipTarget]=\"tooltipRef\" src=\"assets/images/avatar/10.jpg\" size=\"medium\" shape=\"circle\"> </igx-avatar> <div #tooltipRef=\"tooltip\" igxTooltip> Her name is Madelyn James </div> If everything went well, you should see the sample shown in the Tooltip Demo section. Show/Hide delay settings What if we want to control the amount of time that should pass before showing and hiding the tooltip? For this purpose we can use the showDelay and the hideDelay properties of the igxTooltipTarget directive. Both properties are of type number and take time in milliseconds. Note The built-in UI interaction behavior of the IgxTooltipTargetDirective and its respective API methods work by taking showDelay and hideDelay property values into account. Showing and hiding the tooltip through the API of the IgxTooltipDirective does not take the showDelay and hideDelay property values into account. If necessary, such logic would have to be implemented manually according to the application's specifics. Rich tooltip Customizing and styling the content of our tooltip has never been easier with the igxTooltip directive! Since the tooltip itself is an ordinary element in our markup, we can basically improve its content by adding any elements we need and have the ability to style them accordingly! Let's expand on the use of the igxTooltip and use it to provide more details for a specific location on a map! We'll use a simple div to represent our map, the IgxAvatar for a logo in our tooltip and the IgxIcon for the location icon on our map. For this purpose, we will get their respective modules. // app.module.ts import { IgxTooltipModule, IgxAvatarModule, IgxIconModule } from 'igniteui-angular'; // import { IgxTooltipModule, IgxAvatarModule, IgxIconModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [IgxTooltipModule, IgxAvatarModule, IgxIconModule], }) export class AppModule {} We will also use the following styles for our application: /* richTooltip.component.css */ .location:hover { cursor: pointer; } .map { overflow: hidden; display: flex; align-items: center; justify-content: center; width: 200px; height: 252px; background-image: url(assets/images/card/media/infragisticsMap.png); border: 1px solid #D4D4D4; } .locationTooltip { width: 310px; background-color: var(--igx-grays-700); padding: 3px; font-size: 13px; } .locationTooltipContent { display: flex; justify-content: center; align-items: center; } .logo { margin-right: 10px; min-width: 25px; width: 45px; height: 45px; } Let's start by creating our map. We need a simple div that has for a background an image with a map. Also, we will add an icon that will indicate the position of our location! Since we want to provide more details for this location, our icon will obviously be the tooltip target. <!--richTooltip.component.html--> <div class=\"map\"> <igx-icon class=\"location\" [style.color]=\"'blue'\" fontSet=\"material\" [igxTooltipTarget]=\"locationTooltip\">location_on</igx-icon> ... </div> Now for the tooltip! For its content, we will create a container that will be populated with some text information elements and an avatar. Then we will simply attach the tooltip to the target and include some nice CSS styling! <!--richTooltip.component.html--> <div class=\"wrapper\"> <div class=\"map\"> <igx-icon class=\"location\" [style.color]=\"'blue'\" fontSet=\"material\" [igxTooltipTarget]=\"locationTooltip\">location_on</igx-icon> <div class=\"locationTooltip\" #locationTooltip=\"tooltip\" igxTooltip> <div class=\"locationTooltipContent\"> <igx-avatar class=\"logo\" src=\"assets/images/card/avatars/igLogo.png\" size=\"medium\" shape=\"square\"></igx-avatar> <div> <div>Infragistics Inc. HQ</div> <div>2 Commerce Dr, Cranbury, NJ 08512, USA</div> </div> </div> </div> </div> </div> If all went well, this is how our location and tooltip should look like: Overlay configuration Both the igxTooltip and igxTooltipTarget directives use the IgxOverlayService to open and close the respective tooltip element. The igxTooltipTarget directive exposes an overlaySettings property (inherited from the igxToggleAction), which can be used to customize the animations of our tooltip, its position in the UI and a lot more! If this property is not set, then default overlay settings will be used. Note Any property that is set through the overlaySettings will override the same property from the default overlay settings and will have a direct impact on the tooltip. Styling To get started with styling the tooltip, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the tooltip-theme and accepts the $text-color, $background and the $border-radius parameters. $dark-tooltip: tooltip-theme( $text-color: #ECAA53, $background: #011627, $border-radius: 6px ); Note In order to style any additional components that are used as part of the tooltip's content (such as IgxButton, IgxSwitch, etc.), an additional theme should be created that is specific to the respective component and placed under the tooltip's scope only (so it does not affect the rest of the application). Since the tooltip uses the IgxOverlayService, in order for our custom theme to reach down the tooltip that we want to style, we will provide a specific outlet where the tooltip will be placed in the DOM when it is visible. <igx-avatar #target=\"tooltipTarget\" [igxTooltipTarget]=\"tooltipRef\" [igxToggleOutlet]=\"outlet\"> </igx-avatar> <div #outlet=\"overlay-outlet\" igxOverlayOutlet> <div #tooltipRef=\"tooltip\" igxTooltip> Her name is Madelyn James </div> </div> Note In order to learn more about various options for providing themes to elements that are shown by using the IgxOverlayService, you can take a look at the Overlay styling topic. Including Themes The last step is to include the component theme in our application. If $legacy-support is set to true, include the component theme like that: @include tooltip($dark-tooltip); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include tooltip($dark-tooltip); } } If $legacy-support is set to false(default), include the component css variables like that: @include css-vars($dark-tooltip); Note If the component is using an Emulated ViewEncapsulation, you still have to use :host because you need a global selector in order to override the variables. :host { @include css-vars($dark-tooltip); } So now our styled tooltip should look like this: Demo Accessibility Elements with the igxTooltip directive have an autogenerated id property (if not set by the developer), a tooltip role and the aria-hidden attribute that is automatically updated depending on whether the tooltip is visible or not. By setting the aria-describedby attribute of the target to its respective tooltip's id, a reference will be provided to the tooltip element. This provides screenreaders the information needed to read out the tooltip's contents when the end-user triggers the tooltip. Extra care should be taken in the following scenarios: The tooltip's content is too complex to be automatically interpreted. The tooltip is used with a manually implemented behavior (e.g. manually show/hide) instead of the built-in one. The target element is unfocusable. API References In this article we learned how to create, configure and style awesome tooltips for the elements on our page! We also used some additional Ignite UI for Angular components like icons and avatars to improve on the design of our application! The respective APIs are listed below: IgxTooltipDirective IgxTooltipTargetDirective Additional components and/or directives that were used: IgxAvatarComponent IgxIconComponent IgxToggleDirective IgxToggleActionDirective Styles: IgxTooltipDirective Styles IgxAvatarComponent Styles IgxIconComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/transaction.html": {
    "href": "components/transaction.html",
    "title": "Angular Batch Editing | Angular Crud | Ignite UI for Angular | Infragistics",
    "keywords": "Transaction Service The Transaction Service is an injectable middleware (through Angular's DI) that a component may use to accumulate changes without immediately affecting the underlying data. Note The data transformation from the schema above is not mandatory. You do not need to use a pipe in order to use the Transaction Service. The Transaction Service allows adding transactions. After at least one transaction is added, you may commit or clear all the changes or the changes for a single record only. As it keeps a detailed log, it can also execute undo and redo operations. Every time you execute an operation (transaction), it is added to the transaction log and undo stack. All the changes in the transaction log are then accumulated per record. From that point, the service maintains an aggregated state that consists only of add/update/delete operations for unique records. This is based on a State interface which has three properties: recordRef, type and value. We have built three classes on top of the Transaction Service that provide users with the ability to commit all changes they have made, or only changes made to a specific record, at once. Those classes are igxBaseTransactionService, igxTransactionService and igxHierarchicalTransactionService. The igxTransactionService and igxHierarchicalTransactionService are fully integrated with our igxGrid, igxHierarchicalGrid and igxTreeGrid components. You can find detailed examples of using those components with transactions enabled in the following topics: igxGrid Batch Editing and Transactions igxHierarchicalGrid Batch Editing and Transactions igxTreeGrid Batch Editing and Transactions A more detailed overview of the opportunities that the Transaction Service provides can be found in our \"Building a transaction service for managing large scale editing experiences\" blog Additional Resources Transaction Service API Transaction Service class hierarchy How to use the Transaction service Build CRUD operations with igxGrid Grid Batch Editing Tree Grid Batch Editing Hierarchical Grid Batch Editing \"Building a transaction service for managing large scale editing experiences\" blog View page on GitHub"
  },
  "components/transaction-classes.html": {
    "href": "components/transaction-classes.html",
    "title": "Angular Batch Editing | Transaction Service | Ignite UI for Angular | Infragistics",
    "keywords": "Transaction Service class hierarchy Transaction, State, Transaction Log The Transaction is the main building block of the Transaction service. The Transaction is actually every operation that you execute on the data. The Transaction interface defines three properties: id, newValue and type. The id of the Transaction should be unique per data record and defines the record that this transaction is affecting. The type may be any of the three transaction types: ADD, DELETE and UPDATE, depending what operation you execute. The newValue contains the value of the new record in case you are adding an ADD transaction. If you are updating an existing record, the newValue would contain the changes only. You may have several transactions of UPDATE type with same id. If you are deleting a record, the newValue will contain the value of the deleted record. You can see an example of how adding each type of transaction looks like in the How to use the Transaction service topic. Every time you add a Transaction, it is added to the transaction log and undo stack. All the changes in the transaction log are then accumulated per record. From that point, the service maintains an aggregated State. The State consists of unique records and every record may be of one of the supported transaction types, mentioned above. While adding transactions you may turn on pending transactions by calling startPending. All subsequent transactions will be accumulated in single transaction until you call endPending. If you pass true to endPending all accumulated transactions will be added as a single transaction in the transaction log and in the undo stack. Using igxBaseTransaction Our grid module provides a very basic implementation of the Transaction service (igxBaseTransactionService) with just pending session functionality allowing for Row Editing feature. By using startPending and endPending Row editing can combine multiple per-cell operations into a single change. This means editing multiple cells of a single record creates a single transaction and you can handle just the row edit event. With the accumulated state being a partial object, we can also use the service to check which cell has been edited and build UI around that. The igxBaseTransactionService has no undo stack so it does not provide undo/redo functionality. A detailed example of how you may use igxBaseTransactionService to enable Row Editing is provided in the following topics: Grid Row Editing Tree Grid Row Editing Hierarchical Grid Row Editing General information on igxTransactionService and igxHierarchicalTransactionService igxTransactionService and igxHierarchicalTransactionService are injectable middlewares, that implement the Transaction Service interface. A component may use those to accumulate changes without affecting the underlying data. The provider exposes API to access, manipulate (undo and redo) and discard or commit one or all changes to the data. In a more concrete example, igxTransactionService and igxHierarchicalTransactionService can work with both cell editing and row editing of the IgxGrid. The transaction for the cell edit is added when the cell exits edit mode. When row editing starts the grid sets its transaction service in pending state by calling startPending. Each edited cell is added to the pending transaction log and is not added to the main transaction log. When the row exits edit mode all the changes are added to the main transaction log and to the undo log as a single transaction. In both cases (cell editing and row editing) the state of the grid edits consists of all updated, added and deleted rows and their last states. Those can later be inspected, manipulated and submitted at once or per id. Changes are collected for individual cells or rows, depending on editing mode, and accumulated per data row/record. Using igxTransactionService igxTransactionService extends igxBaseTransactionService. If you want your component to use transactions when making data operation, you need to define the igxTransactionService as a provider in your component's providers array. The igxTransactionService provides an undo stack so you may get advantage of the undo/redo functionality. The Undo stack is actually an array that contains arrays of transactions. When using the igxTransactionService, you may check the canUndo accessor in order to understand if there are any transactions in the Undo stack. If there are - you may use the undo method to remove the last transaction and redo to apply the last undone transaction. You may find a detailed example of how igxGrid with Batch Editing is implemented in the following topic: Grid Batch Editing Using igxHierarchicalTransactionService igxHierarchicalTransactionService extends igxTransactionService. The igxHierarchicalTransactionService is designed to handle the relations between parents and children (use this when you have a hierarchical data structure, as in igxTreeGrid, for example). The service ensures that a new record will be added to the place you expect when adding an ADD transaction. When you delete a parent record, its' children will be promoted to the higher level of hierarchy, or will be deleted with their parent, depending on implementation. You can see the cascadeOnDelete property of the tree grid for a concrete example - depending on the value, deleting a parent record will have different effects on its children. In your application, you may want to handle the scenario where the user tries to add a child record to a parent record that is already deleted and is waiting for the transaction to be committed. The Transaction Service will not allow adding a record to a parent that is to be deleted and an error message will be shown in the Console. However, you may check if a parent is to be deleted and implement your own alert to the user using the following code: const state = this.transactions.getState(parentRecordID); if (state && state.type === TransactionType.DELETE) { // Implement your logic here } You may find a detailed examples of how igxTreeGrid and igxHierarchicalGrid with Batch Editing are implemented in the following topics: Tree Grid Batch Editing Hierarchical Grid Batch Editing Transaction Factory In the concrete implementation of transactions inside of Ignite UI for Angular grids, a factory is used in order to instantiate the proper transaction service, depending on the value of the grid's batchEditing. There are two separate transaction factories - the IgxFlatTransactionFactory (used for Grid and Hierarchical Grid) and IgxHierarchicalTransactionFactory (used for Tree Grid). Both classes expose only one method - create - which returns a new instance of the proper type. The parameter passed (TRANSACTION_TYPE) is internally used - None is used when batchEditing is false and Base - when batch editing is enabled. An enum is used (instead of a true - false flag), as it allows to be expanded upon. Using Transaction Factory Both IgxFlatTransactionFactory and IgxHierarchicalTransactionFactory are provided in root and are exposed in the public API. If you want to instantiate a new instance of a transaction service, depending on some arbitrary check, you can use a transaction factory. In the below example, you can see how you can instantiate different transaction services depending on an arbitrary (hasUndo) flag: import { IgxFlatTransactionFactory, TRANSACTION_TYPE } from 'igniteui-angular'; // import { IgxFlatTransactionFactory, TRANSACTION_TYPE } from '@infragistics/igniteui-angular'; for licensed package export class MyCustomComponent { ... constructor(private transactionFactory: IgxFlatTransactionFactory) {} ... public transaction!: IgxTransactionService<Transaction, State>; public set hasUndo(val: boolean) { if (val) { this.transactions = this.transactionFactory.create(TRANSACTION_TYPE.Base); } else { this.transactions = this.transactionFactory.create(TRANSACTION_TYPE.None); } } } Both factory classes can be extended and overriden in the DI hierarchy (using the providers array) in order to provide your own, custom implementation. This, combined with the fact that all of the classes the get instantiated by the factories are also public, gives you a lot of control over what's provided to the components that use transaction implementations internally. For example, to override the transaction service used internally by the IgxGridComponent, you can do the following: First, define a custom factory class import { IgxFlatTransactionFactory, TRANSACTION_TYPE, IgxBaseTransactionService, TransactionService, Transaction, State } from 'igniteui-angular'; // import { IgxFlatTransactionFactory, TRANSACTION_TYPE, IgxBaseTransactionService, // TransactionService, Transaction, State } from '@infragistics/igniteui-angular'; for licensed package class CustomTransactionService extends IgxBaseTransactionService { ... } export class CustomTransactionFactory extends IgxFlatTransactionFactory { ... create(type: TRANSACTION_TYPE): TransactionService<Transaction, State> { if (type === TRANSACTION_TYPE.Base) { return new CustomTransactionService(); } super.create(type); } } Then, in your component's providers array, override the IgxFlatTransactionFactory (used by igx-grid) with your custom implementation. import { IgxFlatTransactionFactory } from 'igniteui-angular'; // import { IgxFlatTransactionFactory } from '@infragistics/igniteui-angular'; for licensed package import { CustomTransactionFactory } from '../custom-factory.ts'; @Component({ selector: 'app-grid-view', template: `<igx-grid [batchEditing]=\"true\" [data]=\"data\" [autoGenerate]=\"true\"></igx-grid>`, providers: [{ provide: IgxFlatTransactionFactory, useClass: CustomTransactionFactory }] }) export class GridViewComponent { ... } Now, when batchEditing is set to true, the grid will receive an instance of CustomTransactionService. Additional Resources Transaction Service API Transaction Service How to use the Transaction service Grid Batch Editing Tree Grid Batch Editing Hierarchical Grid Batch Editing View page on GitHub"
  },
  "components/transaction-how-to-use.html": {
    "href": "components/transaction-how-to-use.html",
    "title": "Angular Batch Editing | Angular Crud | Ignite UI for Angular | Infragistics",
    "keywords": "How to use the Transaction service You may get advantage of the Transaction Service when using any component that needs to preserve the state of its data source and to commit many transactions at once. When working with the Ignite UI for Angular grid components, you may use the igxTransactionService and igxHierarchicalTransactionService that are integrated with the grids and provide batch editing out of the box. However, if you need to use transactions with any other Ignite UI for Angular or custom component, you may again use the igxTransactionService and implement similar behavior. Angular How to use the Transaction service Example In this topic we will use igxList component to demonstrate how to enable transactions. We will demonstrate how to add transactions, how to transform the data through a pipe and how to visually update the view in order to let the user see the changes that are about to be committed. Include Transaction Service Include Transaction Service in project We have two options to include IgxTransactionService in our application. The first one is to add it to AppModule or other parent module in the application, as it is done in the demo above: @NgModule({ ... providers: [ IgxTransactionService ] }) export class AppModule { } The other option is to provide it in the component, where the transaction service is used: @Component({ selector: 'transaction-base', styleUrls: ['./transaction-base.component.scss'], templateUrl: 'transaction-base.component.html', providers: [IgxTransactionService] }) export class TransactionBaseComponent { } Inject Transaction Service in component In our ts file, we should import igxTransactionService from the igniteui-angular library, as well as the State and Transaction interfaces and the TransactionType enum, which will be needed by our application: import { IgxTransactionService, State, Transaction, TransactionType } from 'igniteui-angular'; // import { IgxTransactionService, State, Transaction, TransactionType } from '@infragistics/igniteui-angular'; for licensed package Then Transaction Service should be imported in the constructor: constructor(private _transactions: IgxTransactionService<Transaction, State>) { ... } Define igxList In our html template, we define an igxList component with edit, delete and add actions, which modify the list and its items: <igx-list> <igx-list-item [isHeader]=\"true\">Wishlist</igx-list-item> <igx-list-item *ngFor=\"let item of this.wishlist | transactionBasePipe\" [ngClass]=\"{ deleted: isDeleted(item.id), edited: isEdited(item.id) }\"> <p igxListLineTitle>{{item.name}}</p> <p igxListLineSubTitle>Costs: {{item.price}}</p> <igx-icon igxListAction (click)=\"onEdit()\" *ngIf=\"item.id === 1 && item.price !== '$999'\">edit</igx-icon> <igx-icon igxListAction (click)=\"onDelete()\" *ngIf=\"item.id === 2 && !isDeleted(item.id)\">delete</igx-icon> </igx-list-item> <button igxButton (click)=\"onAdd()\" [disabled]=\"itemAdded(4)\">Add New</button> </igx-list> Pipe for pending changes The list component from above uses the transactionBasePipe to display changes to the items in the wishlist without affecting the original data. Here is how the pipe looks like: @Pipe({ name: 'transactionBasePipe', pure: false }) export class TransactionBasePipe implements PipeTransform { /** * @param transactions Injected Transaction Service. */ constructor(public transactions: IgxTransactionService<Transaction, State>) { } public transform(data: WishlistItem[]) { // the pipe should NOT operate on the original dataset // we create a copy of the original data and then use it for visualization only const _data = [...data]; const pendingStates = this.transactions.getAggregatedChanges(false); for (const state of pendingStates) { switch (state.type) { case TransactionType.ADD: // push the newValue property of the current `ADD` state _data.push(state.newValue); break; case TransactionType.DELETE: // pipe doesn't delete items because the demo displays them with a different style // the record will be deleted once the state is committed break; case TransactionType.UPDATE: const index = _data.findIndex(x => x.id === state.id); // merge changes with the item into a new object // to avoid modifying the original data item _data[index] = Object.assign({}, _data[index], state.newValue); break; default: return _data; } } return _data; } } Edit, delete, add functionality Define edit functionality The second list item contains an edit button, which updates the item's data. <igx-icon igxListAction (click)=\"onEdit()\" *ngIf=\"item.id === 1 && item.price !== '$999'\">edit</igx-icon> When the button is pressed, inside the onEdit event handler, an 'UPDATE' transaction is created: public onEdit(): void { const newPrice = \"$999\"; // there can be multiple `UPDATE` transactions for the same item `id` // the `newValue` property should hold only the changed properties const editTransaction: Transaction = { id: this.wishlist[0].id, type: TransactionType.UPDATE, newValue: { price: newPrice } }; // provide the first wishlist item as a `recordRef` argument this.transactions.add(editTransaction, this.wishlist[0]); } Additionally, there is a function that checks items for unsaved edits: public isEdited(id): boolean { const state = this.transactions.getState(id); return state && state.type === TransactionType.UPDATE; } Define delete functionality The third list item contains a delete button, which deletes the item's data. <igx-icon igxListAction (click)=\"onDelete()\" *ngIf=\"item.id === 2 && !isDeleted(item.id)\">delete</igx-icon> When the button is pressed, inside onDelete event handler, a 'DELETE' transaction is created: public onDelete(): void { // after a `DELETE` transaction, no further changes should be made for the same `id` // the `newValue` property should be set to `null` since we do not change any values, const deleteTransaction: Transaction = { id: this.wishlist[1].id, type: TransactionType.DELETE, newValue: null }; // provide the second wishlist item as a `recordRef` argument this.transactions.add(deleteTransaction, this.wishlist[1]); } In addition, there is a function that checks items for unsaved deletion: public isDeleted(id): boolean { const state = this.transactions.getState(id); return state && state.type === TransactionType.DELETE; } Define add functionality At the end of the list an ADD button is added, which adds a new item to the list. <button igxButton (click)=\"onAdd()\" [disabled]=\"itemAdded(4)\">Add New</button>``` When the button is pressed, inside the onAdd event handler, an 'ADD' transaction is created: public onAdd(): void { // it must have a unique 'id' property const item: WishlistItem = { id: 4, name: 'Yacht', price: 'A lot!' }; // in an `ADD` transaction you do not need to provide a `recordRef` argument, // since there is nothing to refer to yet this.transactions.add({ id: 4, type: TransactionType.ADD, newValue: item }); } In addition, there is a function that checks items for unsaved addition: public itemAdded(id: number): boolean { const found = this.transactions.getState(id) || this.wishlist.find(x => x.id === 4); return !!found; } Transaction Log The demo demonstrates the pending transactions inside a log: <div> <h5>Transaction Log</h5> <div *ngFor=\"let transaction of this.getTransactionLog()\"> {{transaction.type.toUpperCase()}} -> {{transaction.name}} Costs: {{transaction.price}} </div> </div> public getTransactionLog(): any[] { return this.transactions.getTransactionLog().map(transaction => { const item = this.wishlist.find(x => x.id === transaction.id); return Object.assign({ type: transaction.type }, item, transaction.newValue); }); } We will also add a representation of the current state of our list. It will show how the data looks before the pending transactions are committed: <div> <h5>Data Items</h5> <div *ngFor=\"let item of this.wishlist\"> <div>{{item.name}} - {{item.price}}</div> </div> </div> Commit pending transactions Once we are done with all our changes, we may commit them all at once using the commit method of the igxTransactionService. It applies all transactions over the provided data: <button igxButton=\"contained\" (click)=\"onCommit()\" [disabled]=\"this.getTransactionLog().length === 0\">Commit Transactions</button> public onCommit(): void { // the `commit` function expects the original data array as its parameter this.transactions.commit(this.wishlist); } If we are using the igxHierarchicalTransactionService we can also use an overload of the commit method which expects primaryKey and childDataKey as arguments. public onCommit(): void { this.transactions.commit(this.wishlist, primaryKey, childDataKey); } Clear pending transactions At any point of our interaction with the list, we may clear the Transaction log, using the clear method. <button igxButton=\"contained\" (click)=\"onClear()\" [disabled]=\"this.getTransactionLog().length === 0\">Clear Transactions</button> public onClear(): void { this.transactions.clear(); } Additional Resources Transaction Service API Transaction Service Transaction Service class hierarchy View page on GitHub"
  },
  "components/tree.html": {
    "href": "components/tree.html",
    "title": "Angular Tree Component - Ignite UI for Angular",
    "keywords": "code-view .codesandbox-btn { display: none !important; } Angular Tree Component Overview The Angular Tree Component allows users to represent hierarchical data in a tree-view structure with parent-child relationships, as well as to define static tree-view structure without a corresponding data model. Its primary purpose is to allow end-users to visualize and navigate within hierarchical data structures. The Ignite UI for Angular Tree Component also provides load on demand capabilities, item activation, bi-state and tri-state cascading selection of items through built-in checkboxes, built-in keyboard navigation and more. Angular Tree Example In this basic Angular Tree example, you can see how to define an igx-tree and its nodes by specifying the node hierarchy and iterating through a hierarchical data set. Getting Started with Ignite UI for Angular Tree To get started with the Ignite UI for Angular Tree component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTreeModule in your app.module file. // app.module.ts ... import { IgxTreeModule } from 'igniteui-angular'; // import { IgxTreeModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxTreeModule], ... }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTreeComponent as a standalone dependency, or use the IGX_TREE_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_TREE_DIRECTIVES } from 'igniteui-angular'; // import { IGX_TREE_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: ` <igx-tree> <igx-tree-node> Angular Libraries <igx-tree-node>Ignite UI for Angular</igx-tree-node> <igx-tree-node>Angular Material</igx-tree-node> </igx-tree-node> <igx-tree-node> Web Component Libraries <igx-tree-node>Ignite UI for Web Components</igx-tree-node> <igx-tree-node>Open UI 5</igx-tree-node> </igx-tree-node> <igx-tree-node> Blazor Libraries <igx-tree-node>Ignite UI for Blazor</igx-tree-node> </igx-tree-node> </igx-tree> `, styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_TREE_DIRECTIVES] /* or imports: [IgxTreeComponent, IgxTreeNodeComponent] */ }) export class HomeComponent {} Now that we have the Ignite UI for Angular Tree module or directives imported, let’s get started with a basic configuration of the igx-tree and its nodes. Using the Angular Tree IgxTreeNodesComponent is the representation of every node that belongs to the IgxTreeComponent. Nodes provide disabled, active, selected and expanded properties, which give you opportunity to configure the states of the node as per your requirement. data property can be used to add a reference to the data entry the node represents. Binding [data] is required for searching through nodes using IgxTreeComponent.findNodes(). Declaring a tree Nodes can be declared using one of the following approaches. Declaring the tree and its nodes by specifying the node hierarchy and iterating through a data set <igx-tree> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [expanded]=\"isNodeExpaded(node)\" [selected]=\"isNodeSelected(node)\"> {{ node.text }} <img [src]=\"node.image\" [alt]=\"node.imageAlt\" /> <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\" [expanded]=\"isNodeExpaded(child)\" [selected]=\"isNodeSelected(child)\"> {{ child.text }} </igx-tree-node> </igx-tree-node> </igx-tree> Nodes can be bound to a data model so that their expanded and selected states are reflected in the underlying data as well. <igx-tree (nodeSelection)=\"handleSelectionEvent($event)\"> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [(expanded)]=\"node.expanded\" [(selected)]=\"node.selected\"> {{ node.text }} <img [src]=\"node.image\" [alt]=\"node.imageAlt\" /> <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\"> <a igxTreeNodeLink [href]=\"child.url\" target=\"_blank\"> {{ child.text }} </a> </igx-tree-node> </igx-tree-node> </igx-tree> Declaring a tree by creating static unbound nodes In order to render a tree you do not necessarily need a data set - individual nodes can be created without an underlying data model: <igx-tree> <igx-tree-node [expanded]=\"true\" [selected]=\"false\"> I am a parent node 1 <img src=\"hard_coded_src.webb\" alt=\"Alt Text\" /> <igx-tree-node [expanded]=\"true\" [selected]=\"false\"> I am a child node 1 <igx-tree-node> <a igxTreeNodeLink href=\"https://google.com\" target=\"_blank\"> I am a child node of the child </a> </igx-tree-node> </igx-tree-node> </igx-tree-node> <igx-tree-node [expanded]=\"false\" [selected]=\"false\"> I am a parent node 2 <img src=\"hard_coded_src.webb\" alt=\"Alt Text\" /> <igx-tree-node [expanded]=\"false\" [selected]=\"false\"> I am a child node 1 </igx-tree-node> </igx-tree-node> <igx-tree-node [selected]=\"false\" [disabled]=\"true\"> I am a parent node 3 </igx-tree-node> </igx-tree> Nodes with links When a node should render a link, the IgxTreeNodeLink directive should be added to the <a> tag. This will ensure the proper aria role is assigned to the node's DOM elements. <igx-tree> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [expanded]=\"isNodeExpaded(node)\" [selected]=\"isNodeSelected(node)\"> {{ node.text }} <img [src]=\"node.image\" [alt]=\"node.imageAlt\" /> <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\"> <a igxTreeNodeLink [href]=\"child.url\" target=\"_blank\"> {{ child.text }} </a> </igx-tree-node> </igx-tree-node> </igx-tree> Node Interactions IgxTreeNodeComponent could be expanded or collapsed: by clicking on the node expand indicator (default behavior). by clicking on the node if the igx-tree toggleNodeOnClick property is set to true. <igx-tree [toggleNodeOnClick]=\"true\"> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\"> {{ node.text }} <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\"> {{ child.text }} </igx-tree-node> </igx-tree-node> </igx-tree> By default, multiple nodes could be expanded at the same time. In order to change this behavior and allow expanding only single branch at a time, the singleBranchExpand property could be enabled. This way when a node is expanded, all of the others already expanded branches in the same level will be collapsed. <igx-tree [singleBranchExpand]=\"true\"> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\"> {{ node.text }} <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\"> {{ child.text }} </igx-tree-node> </igx-tree-node> </igx-tree> In addition, the IgxTree provides the following API methods for node interactions: expand - expands the node with animation. collapse - collapses the node with animation. toggle - toggles node expansion state with animation. collapseAll - collapses the specified nodes with animation. If no nodes are passed, collapses all parent nodes. expandAll - sets the specified nodes as expanded with animation. If no nodes are passed, expands all parent nodes. deselectAll - deselects all nodes. If a nodes array is passed, deselects only the specified nodes. Does not emit nodeSelection event. Finding Nodes You can find a specific node within an IgxTree by using the findNodes method. It returns an array of nodes, which match the specified data. When finding nodes in more complex data structure scenarios, like composite primary keys, you can pass a custom comparer function in order to specify the criteria for finding nodes based on the data. <igx-tree> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\" [expanded]=\"isNodeExpaded(node)\" [selected]=\"isNodeSelected(node)\"> {{ node.text }} <img [src]=\"node.image\" alt=\"node.imageAlt\" /> <igx-tree-node *ngFor=\"let child of node.children\" [data]=\"child\" [expanded]=\"isNodeExpaded(child)\" [selected]=\"isNodeSelected(child)\"> {{ child.text }} </igx-tree-node> </igx-tree-node> </igx-tree> export class MyTreeViewComponent { public data: { [key: string]: any, valueKey: string } = MY_DATA; @ViewChild(IgxTreeComponent, { read: IgxTreeComponent }) public tree; findNode(valueKey: string) { const comparer: IgxTreeSearchResolver = (data: any, node: IgxTreeNodeComponent) => node.data.valueKey === data; const matchingNodes: IgxTreeNode<{ [key: string]: any, valueKey: string }>[] = this.tree.findNodes(valueKey, comparer); } } Templating To create a reusable template for your nodes, declare <ng-template> within igx-tree. <igx-tree> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\"> <ng-container *ngTemplateOutlet=\"#nodeTemplate; context: { $implicit: node }\"></ng-container> <igx-tree-node *ngFor=\"let child of node.ChildCompanies\" [data]=\"child\"> <ng-container *ngTemplateOutlet=\"#nodeTemplate; context: { $implicit: child}\"></ng-container> </igx-tree-node> </igx-tree-node> <ng-template #nodeTemplate let-data> <div class=\"node-header company\"> <igx-icon class=\"company__logo\">{{ data.Logo }}</igx-icon> <div class=\"company__name\">{{ data.CompanyName }}</div> </div> </ng-template> </igx-tree> Additionally, by using the expandIndicator input you have the ability to set a custom template to be used for rendering the expand/collapse indicators of nodes. <igx-tree> <igx-tree-node *ngFor=\"let node of data\" [data]=\"node\"> </igx-tree-node> <ng-template igxTreeExpandIndicator let-expanded> <igx-icon>{{ expanded ? 'expand_less' : 'expand_more' }}</igx-icon> </ng-template> </igx-tree> Angular Tree Selection In order to setup node selection in the igx-tree, you just need to set its selection property. This property accepts the following three modes: None, BiState and Cascading. Below we will take a look at each of them in more detail. None In the igx-tree by default node selection is disabled. Users cannot select or deselect a node through UI interaction, but these actions can still be completed through the provided API method. Bi-State To enable bi-state node selection in the igx-tree just set the selection property to BiState. This will render a checkbox for every node. Each node has two states - selected or not. This mode supports multiple selection. <igx-tree selection=\"BiState\"> </igx-tree> Cascading To enable cascading node selection in the igx-tree, just set the selection property to Cascading. This will render a checkbox for every node. <igx-tree selection=\"Cascading\"> </igx-tree> In this mode a parent's selection state entirely depends on the selection state of its children. When a parent has some selected and some deselected children, its checkbox is in an indeterminate state. Angular Tree Checkbox The Angular Tree component provides built-in support for checkboxes, allowing users to select more than one item. The TreeView checkboxes also have a tri-state mode, which is applicable only for partially selected parent nodes. In this mode, a parent node will go into the indeterminate state when some but not all of the child nodes are checked. Keyboard Navigation Keyboard navigation in IgxTree provides a rich variety of keyboard interactions for the user. This functionality is enabled by default and allows users to navigate through the nodes. The IgxTree navigation is compliant with W3C accesibility standards and convenient to use. Key Combinations Arrow Down - navigates to the next visible node. Marks the node as active. Does nothing if on the LAST node Ctrl + Arrow Down - navigates to the next visible node. Does nothing if on the LAST node Arrow Up - navigates to the previous visible node. Marks the node as active. Does nothing if on the FIRST node Ctrl + Arrow Up - navigates to the previous visible node. Does nothing if on the FIRST node Arrow Left - on an expanded parent node, collapses it. If on a child node, moves to its parent node. Arrow Right - on an expanded parent node, navigates to the first child of the node. If on a collapsed parent node, expands it. Home - navigates to the FIRST node End - navigates to the LAST visible node Tab - navigates to the next focusable element on the page, outside of the tree Shift + Tab - navigates to the previous focusable element on the page, outside of the tree Space - toggles selection of the current node. Marks the node as active. Shift + Space - toggles selection of all nodes between the active one and the one pressed Space while holding Shift if selection is enabled Enter - activates the focused node. If the node has link in it, open the link * - expands the node and all sibling nodes on the same level When selection is enabled, end-user selection of nodes is only allowed through the rendered checkbox. Since both selection types allow multiple selection, the following mouse + keyboard interactions are available: Click - when performed on the node checkbox, toggles selection of the node if selection is enabled. Otherwise, focuses the node Shift + Click - when performed on the node checkbox, toggles selection of all nodes between the active one and the one clicked while holding Shift if selection is enabled Angular Tree Load On Demand The Ignite UI for Angular IgxTree can be rendered in such way that it requires the minimal amount of data to be retrieved from the server so the user could see it as quickly as possible. With this dynamic data loading approach, only after the user expands a node, the children for that particular parent node will be retrieved. This mechanism, also known as Load on Demand, can be easily configured to work with any remote data. Demo After the user clicks the expand icon, it is replaced by a loading indicator. When the loading property resolves to false, the loading indicator disappears and the children are loaded. Angular Tree Styling Using the Ignite UI for Angular Theming, we can greatly alter the tree appearance. First, in order for us to use the functions exposed by the theme engine, we need to import the index file in our style file: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the tree-theme and pass the parameters, which we would like to change: $custom-tree-theme:tree-theme( $background-selected: #ffe6cc, $background-active: #ecaa53, $background-active-selected: #ff8c1a ); Using CSS Variables The last step is to include the component's theme. :host { @include css-vars($custom-tree-theme); } Using Theme Overrides In order to style components for older browsers, like Internet Explorer 11, we have to use a different approach, since CSS variables are not supported there. If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. To prevent the custom theme to leak into other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { @include tree($custom-tree-theme); } } Known Issues and Limitations Limitation Description Recursive template nodes The igx-tree does not support recursively creating the igx-tree-nodes via template. Learn more. All of the nodes should be declared manually, meaning if you intend to visualize a very deep hierarchy, this would impact the size of your template file. The tree is intended to be primarily used as a layout / navigational component. If a hierarchical data source with numerous levels of depth and homogenous data needs to be visualized, you could use the IgxTreeGrid Using IgxTreeNodes with old View Engine (pre-Ivy) There is an issue in Angular's View Engine (pre-Ivy) that prevents the tree from being used when enableIvy: false is set in tsconfig.json Tab navigation in FireFox Tabbing into the tree via keyboard navigation, when the tree has a scrollbar, will first focus the igx-tree-node element. This is the default behavior in FireFox, however it can be resolved by putting an explicit tabIndex = -1 on the tree. API References IgxTreeComponent IgxTreeNodeComponent Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/advanced-filtering.html": {
    "href": "components/treegrid/advanced-filtering.html",
    "title": "Advanced Filtering in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Advanced Filtering The Advanced filtering provides a dialog which allows the creation of groups with filtering conditions across all columns for any Angular table like the Tree Grid. Angular Tree Grid Advanced Filtering Example Interaction In order to open the advanced filtering dialog, the Advanced Filtering button in the grid toolbar should be clicked. The dialog is using the IgxQueryBuilder component to generate,display and edit the filtering logic. You can have a look at the Query Builder topic for details on the interaction process. In order to filter the data once you are ready with creating the filtering conditions and groups, you should click the Apply button. If you have modified the advanced filter, but you don't want to preserve the changes, you should click the Cancel button. You could also clear the advanced filter by clicking the Clear Filter button. Usage To enable the advanced filtering, the allowAdvancedFiltering input property should be set to true. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> <igx-grid-toolbar></igx-grid-toolbar> </igx-tree-grid> The advanced filtering generates a FilteringExpressionsTree which is stored in the advancedFilteringExpressionsTree input property. You could use the advancedFilteringExpressionsTree property to set an initial state of the advanced filtering. ngAfterViewInit(): void { const tree = new FilteringExpressionsTree(FilteringLogic.And); tree.filteringOperands.push({ fieldName: 'ID', condition: IgxStringFilteringOperand.instance().condition('contains'), searchVal: 'a', ignoreCase: true }); const subTree = new FilteringExpressionsTree(FilteringLogic.Or); subTree.filteringOperands.push({ fieldName: 'ContactTitle', condition: IgxStringFilteringOperand.instance().condition('doesNotContain'), searchVal: 'b', ignoreCase: true }); subTree.filteringOperands.push({ fieldName: 'CompanyName', condition: IgxStringFilteringOperand.instance().condition('startsWith'), searchVal: 'c', ignoreCase: true }); tree.filteringOperands.push(subTree); this.treeGrid.advancedFilteringExpressionsTree = tree; } In case you don't want to show the Tree Grid toolbar, you could use the openAdvancedFilteringDialog and closeAdvancedFilteringDialog methods to open and close the advanced filtering dialog programmatically. Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Tree Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Tree Grid is the intersection between the results of the two filters. External Advanced filtering As you see the demo above the Advanced filtering dialog is hosted in an overlay on top of the Tree Grid. When the setup in the dialog is ready, the apply or close actions would hide that dialog. There is a way to make that dialog stay always visible - be used as a standalone component. In the demo below, the advanced filtering dialog is declared separately of the Tree Grid. Demo Usage It's super easy to configure the advanced filtering to work outside of the Tree Grid. All you need to do is to create the dialog and set its grid property: <igx-advanced-filtering-dialog [grid]=\"treegrid1\"> </igx-advanced-filtering-dialog> You can also see how our drag and drop App Builder™ can streamline the entire design-to-Angular-code story. Styling To get started with styling the Advanced Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The advanced filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); Since we have other components inside the advanced filtering dialog, such as buttons, chips, dropdowns and inputs, we need to create a separate theme for each one: $custom-button: button-theme( $disabled-color: gray, ... ); $custom-button-group: button-group-theme( $item-background: #292826, ... ); $custom-input-group: input-group-theme( $box-background: #4a4a4a, ... ); $custom-chip: chip-theme( $background: #FFCD0F, ... ); $custom-drop-down: drop-down-theme( $background-color: #292826, ... ); In this example we only changed some of the parameters for the listed components, but the button-theme, button-group-theme, chip-theme, drop-down-theme, input-group-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also add some styles for other elements inside the advanced filtering dialog. @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); @include drop-down($custom-drop-down); .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } .igx-input-group__input::placeholder { color: gray; } } Note We scope most of the components' mixins within igx-advanced-filtering-dialog, so that these custom themes will affect only components nested in the advanced filtering dialog. Otherwise, other buttons, chips, inputs and dropdowns in the application would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); igx-advanced-filtering-dialog { @include button($custom-button); @include button-group($custom-button-group); @include input-group($custom-input-group); @include chip($custom-chip); .igx-input-group__input::placeholder { color: gray; } .igx-filter-empty__title { color: #FFCD0F } .igx-advanced-filter__header { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon { color: #FFCD0F } .igx-filter-tree__expression-actions igx-icon:hover { color: #ffe482 } .igx-filter-tree__expression-actions igx-icon:focus { color: #ffe482 } .igx-filter-contextual-menu { border: 1px solid #FFCD0F } .igx-filter-contextual-menu__close-btn { position: absolute !important; background: #292826 !important; border-color: #FFCD0F !important; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: color($dark-palette, \"secondary\", 400) ); $custom-button: button-theme( $disabled-color: color($dark-palette, \"secondary\", 100), ... ); $custom-button-group: button-group-theme( $item-background: color($dark-palette, \"secondary\", 400), ... ); $custom-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 200), ... ); $custom-chip: chip-theme( $background: color($dark-palette, \"primary\", 400), ... ); $custom-drop-down: drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), ... ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-button, light-button-group, light-chip, light-input-group and light-drop-down schemas: $grid-dark-palette: palette($primary: #11bd7b, $secondary: #e32057, $info: $black-color); $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"info\") ) ) ); $custom-button-schema: extend($_light-button, ( disabled-color:( color: (\"secondary\", 100) ), ... ) ); $custom-button-group-schema: extend($_light-button-group, ( item-background:( color: (\"secondary\", 400) ), ... ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 200) ), ... ) ); $custom-chip-schema: extend($_light-chip, ( background:( color: (\"primary\", 400) ), ... ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), ... ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-button: $custom-button-schema, igx-button-group: $custom-button-group-schema, igx-input-group: $custom-input-group-schema, igx-chip: $custom-chip-schema, igx-drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $grid-dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button-group: button-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-chip: chip-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Filtering Excel Style Filtering Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/batch-editing.html": {
    "href": "components/treegrid/batch-editing.html",
    "title": "Batch Editing and Transactions in Angular Tree Grid Grid - Infragistics",
    "keywords": "Angular Tree Grid Batch Editing and Transactions The Batch Editing feature of the IgxTreeGrid is based on the HierarchicalTransactionService. Follow the Transaction Service class hierarchy topic to see an overview of the igxHierarchicalTransactionService and details how it is implemented. Below is a detailed example of how is Batch Editing enabled for the Tree Grid component. Angular Tree Grid Batch Editing and Transactions Example The following sample demonstrates a scenario, where the treeGrid has batchEditing enabled and has row editing enabled. The latter will ensure that transaction will be added after the entire row edit is confirmed. Note Transaction state consists of all the updated, added and deleted rows, and their last states. Usage To get started import the IgxTreeGridModule in the app.module.ts file: // app.module.ts ... import { IgxTreeGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxTreeGridModule], ... }) export class AppModule {} Then, all you need to do is enable batchEditing from your Tree Grid: <igx-tree-grid [data]=\"data\" [batchEditing]=\"true\"> ... </igx-tree-grid> This will ensure a proper instance of Transaction service is provided for the igx-tree-grid. The proper TransactionService is provided through a TransactionFactory. You can learn more about this internal implementation in the transactions topic. After batch editing is enabled, define a IgxTreeGrid with bound data source and rowEditable set to true and bind: <igx-tree-grid #treeGrid [batchEditing]=\"true\" [data]=\"data\" primaryKey=\"employeeID\" foreignKey=\"PID\" width =\"100%\" height =\"500px\" rowEditable=true> ... </igx-tree-grid> ... <button igxButton (click)=\"addRow()\">Add Root Level Row</button> <button igxButton [disabled]=\"!treeGrid.transactions.canUndo\" (click)=\"undo()\">Undo</button> <button igxButton [disabled]=\"!treeGrid.transactions.canRedo\" (click)=\"redo()\">Redo</button> <button igxButton [disabled]=\"treeGrid.transactions.getAggregatedChanges(false).length < 1\" (click)=\"openCommitDialog()\">Commit</button> ... The following code demonstrates the usage of the HierarchicalTransactionService API - undo, redo, commit. export class TreeGridBatchEditingSampleComponent { @ViewChild('treeGrid', { read: IgxTreeGridComponent }) public treeGrid: IgxTreeGridComponent; public undo() { /* exit edit mode and commit changes */ this.treeGrid.endEdit(true); this.treeGrid.transactions.undo(); } public redo() { /* exit edit mode and commit changes */ this.treeGrid.endEdit(true); this.treeGrid.transactions.redo(); } public commit() { this.treeGrid.transactions.commit(this.data); this.dialog.close(); } } Note The transactions API won't handle end of edit and you'd need to do it by yourself. Otherwise, Tree Grid would stay in edit mode. One way to do that is by calling endEdit in the respective method. Deleting a parent node in Tree Grid has some peculiarities. If you are using a hierarchical data, the children will be deleted when deleting their parent. If you are using a flat data, you may set the desired behavior using the cascadeOnDelete property of Tree Grid. This property indicates whether the child records should be deleted when their parent gets deleted (by default, it is set to true). Note Disabling rowEditable property will modify Tree Grid to create transactions on cell change and will not expose row editing overlay in the UI. API References HierarchicalTransactionService rowEditable IgxTreeGridComponent IgxGridComponent Additional Resources Build CRUD operations with igxGrid Tree Grid Overview Tree Grid Editing Tree Grid Row Editing Tree Grid Row Adding Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/cascading-combos.html": {
    "href": "components/treegrid/cascading-combos.html",
    "title": "Cascading combos in Angular Tree Grid Grid - Infragistics",
    "keywords": "Angular Grid with Cascading Combos The Grid's Editing functionality provides with the opportunity to use Cascading Combos. By selecting the value in any preceding Combos, the users will receive only the data that is relevant to their selection within the next Combo. Angular Grid with Cascading Combos Sample Overview The sample below demonstrates how Grid works with nested Cascading Combos. Setup In order enable column editing, make sure editable property is set to true. Once the column editig is enabled, you can start by adding your Single Select ComboBox. Please note that here in order to have only one single selection available, you will need to use igxSimpleCombo instead of modifying the igxCombo. To get started with the Simple ComboBox component, first you need to import the IgxSimpleComboModule in your app.module.ts file: import { IgxSimpleComboModule } from 'igniteui-angular'; @NgModule({ imports: [ ... IgxSimpleComboModule, ... ] }) export class AppModule {} Then, in the template, you should bind the combos igx-simple-combo to some data. displayKey - Required for object arrays - Specifies which property will be used for the items' text. If no value is specified for displayKey, the simple combobox will use the specified valueKey (if any). export class MySimpleComboComponent implements OnInit { public countriesData: Country[]; public selectedCountry: Country; public selectedCity: City; public ngOnInit() { this.countriesData = getCountries([ 'United States', 'Japan', 'United Kingdom' ]); } } In order to handle the selection change, we need selectionChanging(). The emitted event arguments, IComboSelectionChangingEventArgs, contain information about the selection prior to the change, the current selection and the items that were added or removed. Therefore, it will filter the values based on the selection of the previous combo. <igx-combo [data]=\"countriesData\" (selectionChanging)=\"countryChanging($event)\"></igx-combo> public countryChanging(event: IComboSelectionChangeEventArgs) { if (event.added.length) { event.newSelection = event.added; } } And lastly, adding the Linear Progress, which is required while loading the list of data. The id is necessary to set the value of id attribute. <igx-linear-bar [id]=\"'region-progress-' + cell.row.data.ID\" [style.visibility]=\"'hidden'\" type=\"info\" [indeterminate]=\"true\"> </igx-linear-bar> API Summary IgxSimpleComboComponent IgxComboComponent Styles IgxLinearProgressBarComponent IgxLinearProgressBarComponent Styles Additional Resources Tree Grid Editing Single Select ComboBox Cascading Combos Linear Progress View page on GitHub"
  },
  "components/treegrid/cell-editing.html": {
    "href": "components/treegrid/cell-editing.html",
    "title": "Cell Editing in Angular TreeGrid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Cell Editing Ignite UI for Angular Tree Grid component provides a great data manipulation capabilities and powerful API for Angular CRUD operations. By default the Tree Grid is using in cell editing and different editors will be shown based on the column data type, thanks to the default cell editing template. In addition, you can define your own custom templates for update-data actions and to override the default behavior for committing and discarding any changes. Angular Tree Grid cell editing and edit templates Example Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. Cell Editing Editing through UI You can enter edit mode for specific cell, when an editable cell is focused in one of the following ways: on double click; on single click - Single click will enter edit mode only if the previously selected cell was in edit mode and currently selected cell is editable. If the previously selected cell was not in edit mode, single click will select the cell without entering edit mode; on key press Enter; on key press F2; You can exit edit mode without committing the changes in one of the following ways: on key press Escape; when you perform sorting, filtering, searching and hiding operations; You can exit edit mode and commit the changes in one of the following ways: on key press Enter; on key press F2; on key press Tab; on single click to another cell - when you click on another cell in the Tree Grid, your changes will be submitted. operations like paging, resize, pin or move will exit edit mode and changes will be submitted. Note The cell remains in edit mode when you scroll vertically or horizontally or click outside the Tree Grid. This is valid for both cell editing and row editing. Editing through API You can also modify the cell value through the IgxTreeGrid API but only if primary key is defined: public updateCell() { this.treeGrid.updateCell(newValue, rowID, 'Age'); } Another way to update cell is directly through update method of IgxGridCell: public updateCell() { const cell = this.treeGrid.getCellByColumn(rowIndex, 'Age'); // You can also get cell by rowID if primary key is defined // const cell = this.treeGrid.getCellByKey(rowID, 'Age'); cell.update(9999); } Cell Editing Templates You can see and learn more for default cell editing templates in the general editing topic. If you want to provide a custom template which will be applied when a cell is in edit mode, you can make use of the igxCellEditor directive. To do this, you need to pass an ng-template marked with the igxCellEditor directive and properly bind your custom control to the cell.editValue: <igx-column field=\"class\" header=\"Class\" [editable]=\"true\"> <ng-template igxCellEditor let-cell=\"cell\" let-value> <igx-select class=\"cell-select\" [(ngModel)]=\"cell.editValue\" [igxFocus]=\"true\"> <igx-select-item *ngFor=\"let class of classes\" [value]=\"class\"> {{ class }} </igx-select-item> </igx-select> </ng-template> </igx-column> This code is used in the sample below which implements an IgxSelectComponent in the cells of the Race, Class and Alignment columns. Note Any changes made to the cell's editValue in edit mode, will trigger the appropriate editing event on exit and apply to the transaction state (if transactions are enabled). Note The cell template igxCell controls how a column's cells are shown when outside of edit mode. The cell editing template directive igxCellEditor, handles how a column's cells in edit mode are displayed and controls the edited cell's edit value. Note By using igxCellEditor with any type of editor component, the keyboard navigation flow will be disrupted. The same applies to direct editing of the custom cell that enters edit mode. This is because the focus will remain on the cell element, not on the editor component that we've added - igxSelect, igxCombo, etc. This is why we should take leverage of the igxFocus directive, which will move the focus directly in the in-cell component and will preserve a fluent editing flow of the cell/row. For more information on how to configure columns and their templates, you can see the documentation for Grid Columns configuration. CRUD operations Note Please keep in mind that when you perform some CRUD operation all of the applied pipes like filtering, sorting and grouping will be re-applied and your view will be automatically updated. The IgxTreeGridComponent provides a straightforward API for basic CRUD operations. Adding a new record The Tree Grid component exposes the addRow method which will add the provided data to the data source itself. public addNewChildRow() { // Adding a new record // Assuming we have a `getNewRecord` method returning the new row data // And specifying the parentRowID. const record = this.getNewRecord(); this.treeGrid.addRow(record, 1); } Updating data in the Tree Grid Updating data in the Tree Grid is achieved through updateRow and updateCell methods but only if primary key for the grid is defined. You can also directly update a cell and/or a row value through their respective update methods. // Updating the whole row this.treeGrid.updateRow(newData, this.selectedCell.cellID.rowID); // Just a particular cell through the Tree Grid API this.treeGrid.updateCell(newData, this.selectedCell.cellID.rowID, this.selectedCell.column.field); // Directly using the cell `update` method this.selectedCell.update(newData); // Directly using the row `update` method const row = this.treeGrid.getRowByKey(rowID); row.update(newData); Deleting data from the Tree Grid Please keep in mind that deleteRow() method will remove the specified row only if primary key is defined. // Delete row through Tree Grid API this.treeGrid.deleteRow(this.selectedCell.cellID.rowID); // Delete row through row object const row = this.treeGrid.getRowByIndex(rowIndex); row.delete(); These can be wired to user interactions, not necessarily related to the igx-tree-grid; for example, a button click: <button igxButton igxRipple (click)=\"deleteRow($event)\">Delete Row</button> Cell validation on edit event Using the grid's editing events we can alter how the user interacts with the grid. In this example, we'll validate a cell based on the data entered in it by binding to the cellEdit event. If the new value of the cell does not meet our predefined criteria, we'll prevent it from reaching the data source by cancelling the event (event.cancel = true). We'll also display a custom error message using IgxToast. The first thing we need to is bind to the grid's event: <igx-tree-grid (cellEdit)=\"handleCellEdit($event)\" ...> ... </igx-tree-grid> The cellEdit emits whenever any cell's value is about to be committed. In our handleCellEdit definition, we need to make sure that we check for our specific column before taking any action: export class MyTreeGridEventsComponent { public handleCellEdit(event: IGridEditEventArgs): void { const column = event.column; if (column.field === 'Age') { if (event.newValue < 18) { event.cancel = true; this.toast.message = 'Employees must be at least 18 years old!'; this.toast.open(); } } else if (column.field === 'HireDate') { if (event.newValue > new Date().getTime()) { event.cancel = true; this.toast.message = 'The employee hire date must be in the past!'; this.toast.open(); } } } } Here, we are validating two columns. If the user tries to set an invalid value for an employee's Age (below 18) or their Hire Date (a future date), the editing will be cancelled (the value will not be submitted) and a toast with an error message will be displayed. The result of the above validation being applied to our igx-tree-grid can be seen in the below demo: Styling The IgxTreeGrid allows for its cells to be styled through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide range of properties, which allow users to style many different aspects of the grid. In the below steps, we are going to go over how you can style the grid's cell in edit mode and how you can scope those styles. In order to use the Ignite UI Theming Library, we must first import the theme index file in our global styles: Importing style library @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Now we can make use of all of the functions exposed by the Ignite UI for Angular theme engine. Defining a palette After we've properly imported the index file, we create a custom palette that we can use. Let's define two colors that we like and use them to build a palette with igx-palette: $white: #fff; $blue: #4567bb; $color-palette: palette($primary: $white, $secondary: $blue); Defining themes We can now define the theme using our palette. The cells are styled by the grid-theme, so we can use that to generate a theme for our IgxTreeGrid: $custom-grid-theme: grid-theme( $cell-editing-background: $blue, $cell-edited-value-color: $white, $cell-active-border-color: $white, $edit-mode-color: color($color-palette, \"secondary\", 200) ); Applying the theme The easiest way to apply our theme is with a sass @include statement in the global styles file: @include grid($custom-grid-theme); This way, the theme will apply to all grids in our application. If we wish to apply this custom styling only to a specific component, we need to scope the theme. Scoped component theme In order for the custom theme to affect only our specific component, we can move all of the styles we just defined from the global styles file to our custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, our styles will be applied only to our custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-grid-theme); } } } Styling Demo In addition to the steps above, we can also style the controls that are used for the cells' editing templates: igx-input-group, igx-datepicker & igx-checkbox Note The sample will not be affected by the selected global theme from Change Theme. API References IgxGridCell IgxTreeGridComponent Styles IgxTreeGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Build CRUD operations with igxGrid Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/treegrid/cell-selection.html": {
    "href": "components/treegrid/cell-selection.html",
    "title": "Angular Tree Grid Cell Selection - Ignite UI for Angular",
    "keywords": "Angular Cell Selection The selection feature enables rich data select capabilities in the Material UI based Tree Grid. Variety of events and single select actions are available thanks to the powerful API and easy to use methods. The Tree Grid now supports three modes for cell selection, and you can easily switch between them by changing cellSelection property. You can disable cell selection, you can select only one cell within the grid or to select multiple cells in the grid, which is provided as default option. But let's dive deeper in each of these options. Angular Cell Selection Example The sample below demonstrates the three types of Tree Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Selection types Tree Grid Multiple-cell Selection How to select cells: By Mouse drag - Rectangular data selection of cells would be performed. By Ctrl key press + Mouse drag - Multiple range selections would be performed. Any other existing cell selection will be persisted. Instant multi-cell selection by using Shift key. Select single cell and select another single cell by holding the Shift key. Cell range between the two cells will be selected. Keep in mind that if another second cell is selected while holding Shift key the cell selection range will be updated based on the first selected cell position (starting point). Keyboard multi-cell selection by using the Arrow keys while holding Shift key. Multi-cell selection range will be created based on the focused cell. Keyboard multi-cell selection by using the Ctrl + Arrow keys and Ctrl + Home/End while holding Shift key. Multi-cell selection range will be created based on the focused cell. Clicking with the Left Mouse key while holding Ctrl key will add single cell ranges into the selected cells collection. Continuous multiple cell selection is available, by clicking with the mouse and dragging. Demo Tree Grid Single Selection When you set the [cellSelection]=\"'single'\", this allows you to have only one selected cell in the grid at a time. Also the mode mouse drag will not work and instead of selecting a cell, this will make default text selection. Note When single cell is selected selected event is emitted, no matter if the selection mode is single or multiple. In multi-cell selection mode when you select a range of cells rangeSelected event is emitted. Tree Grid None selection If you want to disable cell selection you can just set [cellSelection]=\"'none'\" property. In this mode when you click over the cell or try to navigate with keyboard, the cell is not selected, only the activation style is applied and it is going to be lost when you scroll or click over other element on the page. The only way for you to define selection is by using the API methods that are described below. Keyboard navigation interactions While Shift key is pressed Shift + Arrow Up to add above cell to the current selection. Shift + Arrow Down to add below cell to the current selection. Shift + Arrow Left to add left cell to the current selection. Shift + Arrow Right to add right cell to the current selection. While Ctrl + Shift keys are pressed Ctrl + Shift + Arrow Up to select all cells above the focused cell in the column. Ctrl + Shift + Arrow Down to select all cells below the focused cell in the column. Ctrl + Shift + Arrow Left to select all cells till the start of the row. Ctrl + Shift + Arrow Right to select all cells till the end of the row. Ctrl + Shift + Home to select all cells from the focused cell till the first-most cell in the grid Ctrl + Shift + End to select all cells from the focused cell till the last-most cell in the grid Note Continuous scroll is possible only within Grid's body. Api usage Below are the methods that you can use in order to select ranges, clear selection or get selected cells data. Select range selectRange(range) - Select a range of cells with the API. rowStart and rowEnd should use row indexes and columnStart and columnEnd could use column index or column data field value. const range = { rowStart: 2, rowEnd: 2, columnStart: 1, columnEnd: 1 }; this.grid1.selectRange(range); ... const range = { rowStart: 0, rowEnd: 2, columnStart: 'Name', columnEnd: 'ParentID' }; this.grid1.selectRange(range); Note Select range is additive operation. It will not clear your previous selection. Clear cell selection clearCellSelection() will clear the current cell selection. Get selected data getSelectedData() will return array of the selected data in format depending on the selection. Examples below: If three different single cells are selected: expectedData = [ { CompanyName: 'Infragistics' }, { Name: 'Michael Langdon' }, { ParentID: 147 } ]; If three cells from one column are selected: expectedData = [ { Address: 'Obere Str. 57'}, { Address: 'Avda. de la Constitución 2222'}, { Address: 'Mataderos 2312'} ]; If three cells are selected with mouse drag from one row and three columns: expectedData = [ { Address: 'Avda. de la Constitución 2222', City: 'México D.F.', ContactTitle: 'Owner' } ]; If three cells are selected with mouse drag from two rows and three columns: expectedData = [ { ContactTitle: 'Sales Agent', Address: 'Cerrito 333', City: 'Buenos Aires'}, { ContactTitle: 'Marketing Manager', Address: 'Sierras de Granada 9993', City: 'México D.F.'} ]; If two different ranges are selected: expectedData = [ { ContactName: 'Martín Sommer', ContactTitle: 'Owner'}, { ContactName: 'Laurence Lebihan', ContactTitle: 'Owner'}, { Address: '23 Tsawassen Blvd.', City: 'Tsawassen'}, { Address: 'Fauntleroy Circus', City: 'London'} ]; If two overlapping ranges are selected, the format would be: expectedData = [ { ContactName: 'Diego Roel', ContactTitle: 'Accounting Manager', Address: 'C/ Moralzarzal, 86'}, { ContactName: 'Martine Rancé', ContactTitle: 'Assistant Sales Agent', Address: '184, chaussée de Tournai', City: 'Lille'}, { ContactName: 'Maria Larsson', ContactTitle: 'Owner', Address: 'Åkergatan 24', City: 'Bräcke'}, { ContactTitle: 'Marketing Manager', Address: 'Berliner Platz 43', City: 'München'} ]; Note selectedCells() will return cells from all visible rows (rows in the grid's view port) and from all columns, including columns that are out of view. getSelectedData() will also return the selected cell data. getSelectedRanges(): GridSelectionRange[] will return the current selected ranges in the grid from both keyboard and pointer interactions. The type is GridSelectionRange[]. Features integration The multi-cell selection is index based (DOM elements selection). Sorting - When sorting is performed selection will not be cleared. It will leave currently selected cells the same while sorting ascending or descending. Paging - On paging selected cells will be cleared. Selection wont be persisted across pages. Filtering - When filtering is performed selection will not be cleared. If filtering is cleared it will return - the initially selected cells. Resizing - On column resizing selected cells will not be cleared. Hiding - It will not clear the selected cells. If column is hidden, the cells from the next visible column will be selected. Pinning - Selected cell will not be cleared. Same as hiding Group by - On column grouping selected cells will not be cleared. Styling Guidelines The theme engine exposes properties that allows us to style the range of selected cells. Import theme To get started with styling the selection, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Define colors Once done, we can make use of the igx-contrast-color and igx-color functions. With them, we define the colors we would like to use for our selection range: $text-color:contrast-color($default-palette, 'primary', 900); $background-color: color($default-palette, \"primary\", 900); $border-yellow: #f2c43c; Create custom theme Next we create a new theme that extends the grid-theme passing our text-color, background-color and border-yellow variables as $cell-selected-text-color, $cell-selected-background and $cell-active-border-color, respectively: $custom-grid-theme: grid-theme( $cell-selected-text-color: $text-color, $cell-active-border-color: $border-yellow, $cell-selected-background: $background-color ); Apply theme Afterwards, all we need to do is include the mixin in our component's style (could also be in the app styles), so that our igx-tree-grid uses the newly created theme instead of the default one: @include grid($custom-grid-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. We scope the style under :host selector so as not to affect any other grids we might have in our application. :host { ::ng-deep { @include grid($custom-grid-theme); } } With the custom theme applied, the selected grid cells are highlighted with our selected colors: Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxTreeGridComponent API IgxTreeGridRow API IgxGridCell API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Selection Row selection Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/clipboard-interactions.html": {
    "href": "components/treegrid/clipboard-interactions.html",
    "title": "Angular TreeGrid Clipboard Interactions - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Clipboard Interactions Copy to clipboard operations are now available in the Tree Grid. This functionality provides a fast, easy and customizable way to copy data of the Angular Data Grid through the current multi cell data select. System Clipboard behavior gives the user ability to copy data from the Tree Grid into Excel or other external programs. Angular Tree Grid Clipboard Interactions Example Functionality Copy behavior is working with the default interaction defined by the browser and operating system. Thus for the copy and paste behaviors, these are: Windows/Unix based Ctrl + C / Ctrl + Ins as a keyboard shortcut Ctrl + V / Shift + Ins as a keyboard shortcut Copy action through the browser menu macOS ⌘ Cmd + C as a keyboard shortcut ⌘ Cmd + V as a keyboard shortcut Copy action through the browser menu Limitations Both the cut and copy events are not natively supported in Internet Explorer. The exception is the paste event (IE 11) which is emitted but does not expose the clipboardData property in the event. Note In order to copy cells in IE 11, you can use the keyboard selection. Hold the shift key in order to make a multi-cell selection, press Ctrl + C in order to copy. The copy behavior is disabled while the grid is in edit mode. The current version of this feature covers only the copy from grid behavior. Later on we plan to expose paste within grid behavior. API Usage We expose clipboardOptions @Input property, which handles the following options: enabled Enables/disables copying of selected cells. copyHeaders Include the associated headers when copying. copyFormatters Apply any existing column formatters to the copied data. separator The string separator to use the for formatting the data in the clipboard. Default is /t Note Excel can automatically detect text that is separated by tabs (tab-delimited /t) and properly paste the data into separate columns. When the paste format doesn't work, and everything you paste appears in a single column, then Excel's delimiter is set to another character, or your text is using spaces instead of tabs. gridCopy Emitted when a copy operation is executed. Fired only if copy behavior is enabled through the clipboardOptions Additional Resources Tree Grid overview Paging Filtering Sorting Summaries Column Pinning Selection Virtualization and Performance Multi-column headers Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/collapsible-column-groups.html": {
    "href": "components/treegrid/collapsible-column-groups.html",
    "title": "Collapsible Column Groups in Angular Tree Grid - Infragistics",
    "keywords": "Collapsible Column Groups in Angular Data Grid Multi-column headers allow you to have multiple levels of nested columns and column groups. They also provide the ability to mark each column group as collapsible. Collapsible multi-column headers make it possible to collapse/expand, i.e. to show and hide the nested headers under the current one, which will give you a shortened/summarized information for example. Angular Grid Collapsible Column Groups Overview Example Setup To get started with the IgxTreeGrid and the Collapsible multi-column headers , first you need to install Ignite UI for Angular by typing the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTreeGridModule in the app.module.ts file. Also, we strongly suggest that you take a brief look at multi-column groups topic, to see more detailed information on how to setup the column groups in your grid. Usage Collapsible Column Groups is a part of the multi-column headers feature which provides a way to collapse/expand a column group to a smaller set of data. When a column group is collapsed, a subset of the columns will be shown to the end-user and the other child columns of the group will hide. Each collapsed/expanded column can be bound to the grid data source, or it may be unbound, thus calculated. In order to define a column group as collapsible, you need to set the property to [collapsible]=\"true\" and also keep in mind that you need to define the property visibleWhenCollapsed to at least two child columns: at least one column must be visible when the group is collapsed ([visibleWhenCollapsed]=\"true\") and at least one column must be hidden when the group is expanded ([visibleWhenCollapsed]=\"false\"), otherwise the collapsible functionality will be disabled. If visibleWhenCollapsed is not specified for some of the child columns, then this column will be always visible no matter whether the parent state is expanded or collapsed. So let's see the markup below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <!-- Initially the column groups will be expanded---> <!--The column below will be visible when its parent is collapsed--> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <!--The three columns below will be visible when its parent is expanded--> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column field=\"FirstName\" header=\"First Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column field=\"LastName\" header=\"Last Name\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"> </igx-column> <igx-column-group header=\"Customer Address\"> <!--This column visibility will not be changed based on parent expand/collapsed state--> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\"> </igx-column> </igx-column-group> </igx-column-group> And now let's sum up: every child column has three states: Can be always visible, no matter the expanded state of its parent; Can be visible, when its parent is collapsed; Can be hidden, when its parent is collapsed; The initial state of the column group which is specified as collapsible is [expanded]=\"true\". But you can easily change this behavour by setting the property [expanded]=\"false\". Expand/Collapse indicator template Default expand indicator for the igxGrid is the following: Default collapse indicator for the igxGrid is the following: Also, if you need to change the default expand/collapse indicator, we provide two easy ways to do so - via an input property or through a directive. Using an input property You can define custom expand/collapse template and provide it to each of the collapsible column groups using collapsibleIndicatorTemplate input property. Check the markup below: <ng-template #indTemplate let-column=\"column\"> <igx-icon [attr.draggable]=\"false\" >{{column.expanded ? 'remove' : 'add'}} </igx-icon> </ng-template> <igx-column-group header=\"Customer Information\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\" [collapsibleIndicatorTemplate]=\"indTemplate\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Using igxCollapsibleIndicator directive Another way to achieve this behavior is to use the igxCollapsibleIndicator directive as shown in the example below: <igx-column-group header=\"Customer Information\" [collapsible]=\"true\"> <ng-template igxCollapsibleIndicator let-column=\"column\"> <igx-icon [attr.draggable]=\"false\">{{column.expanded ? 'remove' : 'add'}} </<igx-icon> </ng-template> <igx-column field=\"CustomerName\" header=\"Fullname\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"CustomerID\" header=\"Customer ID\" [dataType]=\"'string'\" [visibleWhenCollapsed]=\"false\"></igx-column> <igx-column-group header=\"Customer Address\" [collapsible]=\"true\"> <igx-column field=\"Country\" header=\"Country\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"true\"></igx-column> <igx-column field=\"City\" header=\"City\" [dataType]=\"'string'\" [sortable]=\"true\" [visibleWhenCollapsed]=\"false\"></igx-column> </igx-column-group> </igx-column-group> Note Please keep in mind that initially collapse group option takes precedence over column hidden - If you declared your column to be hidden using the property hidden and you have a group defined where the same column should be shown, the column will be shown. API References IgxColumnComponent IgxGridComponent IgxGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-hiding.html": {
    "href": "components/treegrid/column-hiding.html",
    "title": "Column Hiding in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Column Hiding The Ignite UI for Angular Tree Grid provides an IgxColumnActionsComponent with an IgxColumnHidingDirective which allows users to perform column hiding directly through the user interface or by using the Angular component. The Material UI Grid has a built-in column hiding UI, which can be used through the Tree Grid's toolbar to change the visible state of the columns. In addition, developers can always define the column hiding UI as a separate component and place it anywhere they want on the page. Angular Tree Grid Column Hiding Example Tree Grid Setup Let's start by creating our Tree Grid and binding it to our data. We will also enable both filtering and sorting for the columns. <!--columnHiding.component.html--> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" width=\"100%\" height=\"560px\" columnWidth=\"200px\" [allowFiltering]=\"true\"> <igx-column [field]=\"'Name'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column [field]=\"'ID'\" dataType=\"number\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column [field]=\"'HireDate'\" dataType=\"date\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\" [sortable]=\"true\" [hidden]=\"true\"></igx-column> <igx-column [field]=\"'Address'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'City'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Country'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Fax'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'PostalCode'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Phone'\" dataType=\"string\" [sortable]=\"true\"></igx-column> </igx-tree-grid> Toolbar's Column Hiding UI The built-in Column Hiding UI is placed inside an IgxDropDownComponent in the Tree Grid's toolbar. We can show/hide the Column Hiding UI by using this exact dropdown. For this purpose all we have to do is set both the IgxGridToolbarActionsComponent and the IgxGridToolbarHidingComponent inside of the Tree Grid. We will also add a title to our toolbar by using the IgxGridToolbarTitleComponent and a custom style for our Tree Grid's wrapper. <!--columnHiding.component.html--> <div class=\"grid__wrapper\"> <igx-tree-grid ...> <igx-grid-toolbar> <igx-grid-toolbar-title>Employees</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> ... </igx-tree-grid> </div> /* columnHiding.component.css */ .grid__wrapper { margin: 10px; } The Tree Grid provides us with some useful properties when it comes to using the toolbar's column hiding UI. By using the igx-grid-toolbar-hiding title property, we will set the title that is displayed inside the dropdown button in the toolbar. <!--columnHiding.component.html--> <div class=\"grid__wrapper\"> <igx-tree-grid> <igx-grid-toolbar> <igx-grid-toolbar-title>Employees</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding #hidingActionRef title=\"Column Hiding\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-tree-grid> </div> By using the columnsAreaMaxHeight property of the IgxGridToolbarHidingComponent, we can set the maximum height of the area that contains the column actions. This way if we have a lot of actions and not all of them can fit in the container, a scrollbar will appear, which will allow us to scroll to any action we want. // columnHiding.component.ts public ngAfterViewInit() { this.hidingActionRef.columnsAreaMaxHeight = \"200px\"; } In order to use the expanded set of functionalities for the column hiding UI, we can use the IgxColumnActionsComponent's columnsAreaMaxHeight property. This way we can use it according to our application's requirements. You can see the result of the code from above at the beginning of this article in the Angular Column Hiding Example section. Custom Column Hiding UI Let's say we want to manually define our IgxColumnActionsComponent, add the IgxColumnHidingDirective so that it knows what its purpose would be and put it anywhere on the page. First, however, we need to import the IgxColumnActionsModule. // app.module.ts ... import { ... IgxColumnActionsModule } from 'igniteui-angular'; // import { ..., IgxColumnActionsModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxColumnActionsModule], }) export class AppModule {} Now let's create our IgxColumnActionsComponent. In our application, we will place it next to the grid (which is not the case with the toolbar's column hiding UI, where the component is inside a dropdown by design). We will also set the columns property of the component to the columns of our Tree Grid and include some custom styles to make our application look even better! <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> <igx-column-actions igxColumnHiding #columnHidingUI [columns]=\"treeGrid.columns\"> </igx-column-actions> </div> <div class=\"gridContainer\"> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" width=\"100%\" height=\"500px\" columnWidth=\"200px\"> ... </igx-tree-grid> </div> /* columnHiding.component.css */ .grid__wrapper { margin: 15px; display: flex; flex-direction: row; } .columnHidingContainer { min-width: 250px; height: 560px; display: flex; flex-direction: column; padding-left: 20px; padding-right: 20px; border: 1px gray; border-radius: 10px; box-shadow: 1px 1px 2px 2px rgba(50, 50, 50, 0.25); igx-column-actions { height: 460px; } } .columnsOrderOptionsContainer { margin-top: 20px; margin-bottom: 20px; } .gridContainer { width: 100%; min-width: 200px; display: flex; flex-direction: column; margin-left: 30px; } Add title and filter prompt A couple more things we can do in order to enrich the user experience of our column hiding component is to set the title and the filterColumnsPrompt properties. The title is displayed on the top and the filterColumnsPrompt is the prompt text that is displayed in the filter input of our column hiding UI. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> <igx-column-actions igxColumnHiding #columnHidingUI [columns]=\"treeGrid.columns\" title=\"Column Hiding\" filterColumnsPrompt=\"Type here to search\"> </igx-column-actions> </div> Add column display order options We can also allow the user to choose the display order of the columns in the column hiding UI. For this purpose we will use the columnDisplayOrder property, which is an enumeration type property and has the following options: Alphabetical (order the columns alphabetically) DisplayOrder (order the columns according to the way they are displayed in the Tree Grid) Let's create a couple of nicely designed radio buttons for our options! We just have to go ahead and get the IgxRadio module. // app.module.ts ... import { ... IgxRadioModule } from 'igniteui-angular'; // import { ..., IgxRadioModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxRadioModule], }) export class AppModule {} Now all we have to do is bind the checked property of both radio buttons respectively with different conditions and handle their click events. <!--columnHiding.component.html--> <div class=\"columnHidingContainer\"> ... <div class=\"columnsOrderOptionsContainer\"> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'Alphabetical'\" (click)=\"columnHidingUI.columnDisplayOrder = 'Alphabetical'\"> Alphabetical order </igx-radio> <igx-radio [checked]=\"columnHidingUI.columnDisplayOrder === 'DisplayOrder'\" (click)=\"columnHidingUI.columnDisplayOrder = 'DisplayOrder'\"> Display order </igx-radio> </div> </div> Disable hiding of a column We can easily prevent the user from being able to hide columns through the column hiding UI by simply setting their disableHiding property to true. <!--columnHiding.component.html--> <div class=\"gridContainer\"> <igx-tree-grid ... > ... <igx-column [field]=\"'Name'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\" [sortable]=\"true\" [disableHiding]=\"true\"></igx-column> ... </igx-tree-grid> </div> If all went well, this is how our column hiding UI component should look like: Styling To get started with styling the column actions component, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; By using the simplest approach, we create a new theme that extends the column-actions-theme and accepts the $title-color and the $background-color parameters. $custom-column-actions-theme: column-actions-theme( $background-color: steelblue, $title-color: gold ); As seen, the column-actions-theme only controls colors for the column actions container, but does not affect the buttons, checkboxes and the input-group inside of it. Let's say we want to style the buttons as well, so we will create a new button theme: $custom-button: button-theme($flat-text-color: gold, $disabled-color: black); In this example we only changed the text-color of the flat buttons and the button disabled color, but the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } Note We scope the igx-button mixin within .igx-column-actions, so that only the column hiding buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include column-actions($custom-column-actions-theme); .igx-column-actions { @include button($custom-button); } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: gold; $blue-color: steelblue; $custom-palette: palette($primary: $blue-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $title-color: color($custom-palette, \"secondary\", 400), $background-color: color($custom-palette, \"primary\", 200) ); $custom-button: button-theme( $palette: $custom-palette, $flat-text-color: color($custom-palette, \"secondary\", 400), $disabled-color: black ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. // Extending the dark column actions schema $custom-column-actions-schema: extend($_dark-column-actions, ( title-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ) ) ); // Extending the dark button schema $custom-button-schema: extend($_dark-button, ( flat-text-color:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-column-actions: $custom-column-actions-schema, igx-button: $custom-button-schema )); // Defining column-actions-theme with the global dark schema $custom-column-actions-theme: column-actions-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $custom-button: button-theme( $palette: $custom-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References In this article we learned how to use the built-in column hiding UI in the Tree Grid's toolbar and we defined it as a separate component as well. We introduced a UI that allows the user to choose between different column orders and we set our own custom title and filter prompt texts. We also used an additional Ignite UI for Angular component - the IgxRadio button. The column hiding UI has a few more APIs to explore, which are listed below. IgxColumnActionsComponent IgxColumnActionsComponent Styles Additional components and/or directives with relative APIs that were used: IgxTreeGridComponent properties: hiddenColumnsCount IgxColumnComponent properties: disableHiding IgxGridToolbarComponent properties: showProgress IgxGridToolbarComponent components: IgxGridToolbarTitleComponent IgxGridToolbarActionsComponent IgxGridToolbarComponent methods: IgxTreeGridComponent events: columnVisibilityChanged IgxRadioComponent Styles: IgxTreeGridComponent Styles IgxRadioComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-moving.html": {
    "href": "components/treegrid/column-moving.html",
    "title": "Column Reordering & Moving in Angular Tree Grid - Infragistics",
    "keywords": "Tree Grid Column Reordering & Moving The Tree Grid component in Ignite UI for Angular provides the Column Moving feature to allow columns reordering via standard drag/drop mouse or touch gestures, or by using the Column Moving API. Column moving works both with pinned and unpinned columns and with Multi-column Headers. Moving a column into the pinned area pins the column and vice versa, moving a column outside of the pinned area unpins the column. Note Reordering between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. Moving is allowed between columns/column-groups, if they are top level columns. Note If a column header is templated and the Column Moving is enabled or the corresponding column is groupable, then the templated elements need to have the draggable attribute set to false! This allows to attach handlers for any event emitted by the element, otherwise the event is consumed by the igxDrag directive. Note If the pinned area exceeds its maximum allowed width (80% of the total Tree Grid width), a visual clue notifies the end user that the drop operation is forbidden and pinning is not possible. This means you won't be allowed to drop a column in the pinned area. <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> Angular Tree Grid Column Moving Overview Example Overview Column moving feature is enabled on a per-grid level, meaning that the igx-tree-grid could have either movable or immovable columns. This is done via the moving input of the igx-grid. <igx-tree-grid [moving]=\"true\"></igx-tree-grid> API In addition to the drag and drop functionality, the Column Moving feature also provides two API methods to allow moving a column/reordering columns programmatically: moveColumn - Moves a column before or after another column (a target). The first parameter is the column to be moved, and the second parameter is the target column. Also accepts an optional third parameter position (representing a DropPosition value), which determines whether to place the column before or after the target column. // Move the ID column after the Name column const idColumn = grid.getColumnByName(\"ID\"); const nameColumn = grid.getColumnByName(\"Name\"); grid.moveColumn(idColumn, nameColumn, DropPosition.AfterDropTarget); move - Moves a column to a specified visible index. If the passed index parameter is invalid (is negative, or exceeds the number of columns), or if the column is not allowed to move to this index (if inside another group), no operation is performed. // Move the ID column at 3rd position. const idColumn = grid.getColumnByName(\"ID\"); idColumn.move(3); Note that when using the API, only the columnMovingEnd event will be emitted, if the operation was successful. Also note that in comparison to the drag and drop functionality, using the API does not require setting the moving property to true. Events There are several events related to the column moving to provide a means for tapping into the columns' drag and drop operations. These are columnMovingStart, columnMoving and columnMovingEnd. You can subscribe to the columnMovingEnd event of the igx-tree-grid to implement some custom logic when a column is dropped to a new position. For example, you can cancel dropping the Category after the Change On Year(%) column. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" [moving]=\"true\" (columnMovingEnd)=\"onColumnMovingEnd($event)\"> <igx-column [field]=\"'Name'\" dataType=\"string\" width=\"250px\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\" width=\"250px\"></igx-column> </igx-tree-grid> public onColumnMovingEnd(event) { if (event.source.field === \"Name\" && event.target.field === \"Title\") { event.cancel = true; } } Styling To get started with styling the Tree Grid column moving headers, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $ghost-header-background, $ghost-header-text-color and the $ghost-header-icon-color parameters. // Define dark theme for the column moving $dark-grid-column-moving-theme: grid-theme( $ghost-header-text-color: #F4D45C, $ghost-header-background: #575757, $ghost-header-icon-color: #f4bb5c ); The last step is to include the component mixins with its respective theme: @include grid($dark-grid-column-moving-theme); Note Depending on the component View Encapsulation strategy, it may be necessary to penetrate this encapsulation using ::ng-deep :host { ::ng-deep { @include grid($dark-grid-column-moving-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F4D45C; $black-color: #575757; $dark-palette: palette($primary: $yellow-color, $secondary: $black-color); And then with igx-color we can easily retrieve color from the pallete. $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $ghost-header-text-color: color($dark-palette, \"primary\", 400), $ghost-header-background: color($dark-palette, \"secondary\", 200), $ghost-header-icon-color: color($dark-palette, \"primary\", 500) ); Note The color and palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid. // Extending the dark grid schema $dark-grid-column-moving-schema: extend($_light-grid, ( ghost-header-text-color:( color: (\"primary\", 400) ), ghost-header-background:( color: (\"secondary\", 200) ), ghost-header-icon-color:( color:( \"primary\", 500) ) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global dark-schema $custom-light-schema: extend($light-schema,( igx-grid: $dark-grid-column-moving-schema, )); // Defining dark-grid-theme with the global dark schema $dark-grid-column-moving-theme: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References ColumnComponent IgxTreeGridComponent IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-pinning.html": {
    "href": "components/treegrid/column-pinning.html",
    "title": "Angular Tree Grid Column Pinning - Ignite UI for Angulars",
    "keywords": "Angular Tree Grid Column Pinning A column or multiple columns can be pinned to the left or right side of the Angular UI Grid. Column Pinning in Ignite UI for Angular allows the end users to lock column in a particular column order, this will allow them to see it while horizontally scrolling the Tree Grid. The Material UI Grid has a built-in column pinning UI, which can be used through the Tree Grid's toolbar to change the pin state of the columns. In addition, you can define a custom UI and change the pin state of the columns via the Column Pinning API. Angular Tree Grid Column Pinning Example Column Pinning API Column pinning is controlled through the pinned input of the igx-column. Pinned columns are rendered on the left side of the Tree Grid by default and stay fixed through horizontal scrolling of the unpinned columns in the Tree Grid body. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\"> <igx-column [field]=\"Name\" [pinned]=\"true\"></igx-column> <igx-column [field]=\"Title\"></igx-column> <igx-column [field]=\"ID\"></igx-column> </igx-tree-grid> You may also use the Tree Grid's pinColumn or unpinColumn methods of the IgxTreeGridComponent to pin or unpin columns by their field name: this.treeGrid.pinColumn('Title'); this.treeGrid.unpinColumn('Name'); Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the column is already in the desired state. A column is pinned to the right of the rightmost pinned column. Changing the order of the pinned columns can be done by subscribing to the columnPin event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\" (columnPin)=\"columnPinning($event)\"></igx-tree-grid> public columnPinning(event) { if (event.column.field === 'Name') { event.insertAtIndex = 0; } } Pinning Position You can change the column pinning position via the pinning configuration option. It allows you to set the columns position to either Start or End. When set to End the columns are rendered at the end of the grid, after the unpinned columns. Unpinned columns can be scrolled horizontally, while the pinned columns remain fixed on the right. <igx-tree-grid #grid1 [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-tree-grid> public pinningConfig: IPinningConfig = { columns: ColumnPinningPosition.End }; Demo Custom Column Pinning UI You can define your custom UI and change the pin state of the columns via the related API. Let's say that instead of a toolbar you would like to define pin icons in the column headers that the end user can click to change the particular column's pin state. This can be done by creating a header template for the column with a custom icon. <ng-template igxHeader let-column #pinTemplate> <div class=\"title-inner\"> <span style=\"float:left\">{{column.header || column.field}}</span> <igx-icon class=\"pin-icon\" [class.pinned]=\"column.pinned\" [class.unpinned]=\"!column.pinned\" fontSet=\"fas\" name=\"fa-thumbtack\" (click)=\"toggleColumn(column)\"></igx-icon> </div> </ng-template> <div class=\"grid__wrapper\"> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" height=\"620px\" width=\"100%\"> <igx-column [field]=\"'Name'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"250px\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"300px\"></igx-column> <igx-column [field]=\"'ID'\" dataType=\"number\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'HireDate'\" header=\"Hire Date\" dataType=\"date\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'Address'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'City'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'Country'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'Fax'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'PostalCode'\" header=\"Postal Code\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> <igx-column [field]=\"'Phone'\" dataType=\"string\" [headerTemplate]=\"pinTemplate\" width=\"200px\"></igx-column> </igx-tree-grid> </div> On click of the custom icon the pin state of the related column can be changed using the column's API methods. public toggleColumn(col: ColumnType) { col.pinned ? col.unpin() : col.pin(); } Demo Pinning Limitations Setting column widths in percentage (%) explicitly makes the Tree Grid body and header content to be misaligned when there are pinned columns. For column pinning to function correctly the column widths should be in pixels (px) or auto-assigned by the Tree Grid. API References IgxTreeGridComponent IgxColumnComponent Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-resizing.html": {
    "href": "components/treegrid/column-resizing.html",
    "title": "Angular Tree Grid Column Resizing - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Column Resizing With deferred grid column resizing, the user will see a temporary resize indicator while the Angular drag resizing operation is in effect. The new grid column width is applied once the drag operation has ended. Angular Tree Grid Column Resizing Example Column resizing is also enabled per-column level, meaning that the igx-tree-grid can have a mix of resizable and non-resizable columns. This is done via the resizable input of the igx-column. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\"></igx-column> You can subscribe to the columnResized event of the igx-tree-grid to implement some custom logic when a column is resized. Both, previous and new column widths, as well as the IgxColumnComponent object, are exposed through the event arguments. <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\"> <igx-column [field]=\"'Title'\" [resizable]=\"true\" [width]=\"'100px'\"></igx-column> <igx-column [field]=\"'HireDate'\" [resizable]=\"true\" [width]=\"'100px'\"></igx-column> </igx-tree-grid> public onResize(event) { this.col = event.column; this.pWidth = event.prevWidth; this.nWidth = event.newWidth; } Resizing columns in pixels/percentages Depending on the user scenario, the column width may be defined in pixels, percentages or a mix of both. All these scenarios are supported by the Column Resizing feature. By default if a column does not have width set, it fits the available space with width set in pixels. This means that the following configuration is possible: <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" (columnResized)=\"onResize($event)\" [autoGenerate]=\"false\"> <igx-column [field]=\"'Title'\" [resizable]=\"true\" [width]=\"'10%'\"></igx-column> <igx-column [field]=\"'HireDate'\" [resizable]=\"true\" [width]=\"'100px'\"></igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\" [resizable]=\"true\"></igx-column> </igx-tree-grid> Note There is a slight difference in the way resizing works for columns set in pixels and percentages. Pixels Resizing columns with width in pixels works by directly adding or subtracting the horizontal amount of the mouse movement from the size of the column. Percentages When resizing columns with width in percentages, the horizontal amount of the mouse movement in pixels translates roughly to its percentage amount relative to the grid width. The columns remain responsive and any future grid resizing will still reflect on the columns as well. Restrict column resizing You can also configure the minimum and maximum allowable column widths. This is done via the minWidth and maxWidth inputs of the igx-column. In this case the resize indicator drag operation is restricted to notify the user that the column cannot be resized outside the boundaries defined by minWidth and maxWidth. <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> Mixing the minimum and maximum column width value types (pixels or percentages) is allowed. If the values set for minimum and maximum are set to percentages, the respective column size will be limited to those exact sizes similar to pixels. This means the following configurations are possible: <igx-column [field]=\"'ID'\" width=\"10%\" [resizable]=\"true\" [minWidth]=\"'60px'\" [maxWidth]=\"'230px'\"></igx-column> or <igx-column [field]=\"'ID'\" width=\"100px\" [resizable]=\"true\" [minWidth]=\"'5%'\" [maxWidth]=\"'15%'\"></igx-column> Auto-size columns on double click Each column can be auto sized by double clicking the right side of the header - the column will be sized to the longest currently visible cell value, including the header itself. This behavior is enabled by default, no additional configuration is needed. However, the column will not be auto-sized in case maxWidth is set on that column and the new width exceeds that maxWidth value. In this case the column will be sized according to preset maxWidth value. You can also auto-size a column dynamically using the exposed autosize() method on IgxColumnComponent. @ViewChild('treeGrid') treeGrid: IgxTreeGridComponent; let column = this.treeGrid.columnList.filter(c => c.field === 'ID')[0]; column.autosize(); Auto-size columns on initialization Each column can be set to auto-size on initialization by setting width to 'auto': <igx-column width='auto'>... When the column is first initialized in the view it resolves its width to the size of the longest visible cell or header. Note that cells that are outside of the visible rows are not included. This approach is more performance optimized than auto-sizing post initialization and is recommended especially in cases where you need to auto-size a large number of columns. Styling To get started with the styling of the Tree Grid column resize line, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The simplest approach to achieve this is to create a new theme that extends the grid-theme and accepts many parameters as well as the $resize-line-color parameter. $custom-grid-theme: grid-theme( $resize-line-color: #0288D1 ); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. :host { ::ng-deep { @include grid($custom-grid-theme); } } Defining a color palette Instead of hard-coding the color values, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the specified primary and secondary color: $primary-color: #0288D1; $secondary-color: #BDBDBD; $custom-theme-palette: palette($primary: $primary-color, $secondary: $secondary-color); And then, with igx-color, we can easily retrieve the color from the palette. $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $resize-line-color: color($custom-theme-palette, 'secondary', 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please, refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend the predefined schema provided for every component, in this case - light-grid schema: // Extending the light grid schema $light-grid-schema: extend($_light-grid, ( resize-line-color: ( color: ('secondary', 500) ), header-background: ( color: (\"primary\", 100) ), header-text-color: ( color: (\"primary\", 600) ) ) ); In order to apply our custom schema, we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component theme: // Extending the global light-schema $custom-light-grid-schema: extend($light-schema,( igx-grid: $light-grid-schema )); // Specifying the palette and schema of the custom grid theme $custom-grid-theme: grid-theme( $palette: $custom-theme-palette, $schema: $custom-light-grid-schema ); Don't forget to include the theme in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxTreeGridComponent IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Pinning Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-selection.html": {
    "href": "components/treegrid/column-selection.html",
    "title": "Angular Tree Grid Column Selection - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Column Selection The Column selection feature provides an easy way to select an entire column with a single click. It emphasizes the importance of a particular column by focusing the header cell(s) and everything below. The feature comes with a rich API that allows for manipulation of the selection state, data extraction from the selected fractions and data analysis operations and visualizations. Angular Column Selection Example The sample below demonstrates the three types of Tree Grid's column selection behavior. Use the column selection dropdown below to enable each of the available selection modes. *Units, Unit Price and Delivered are with disabled column selection. Basic usage The column selection feature can be enabled through the columnSelection input, which takes GridSelectionMode values. Interactions The default selection mode is none. If set to single or multiple all of the presented columns will be selectable. With that being said, in order to select a column, we just need to click on one, which will mark it as selected. If the column is not selectable, no selection style will be applied on the header, while hovering. Note Multi-column Headers don't reflect on the selectable input. The IgxColumnGroupComponent is selectable, if at least one of its children has the selection behaviour enabled. In addition, the component is marked as selected if all of its selectable descendents are selected. *Under Personal Details Column Group only column ID and Title are selectable. Keyboard combinations Note The keyboard combinations are available only when the grid columnSelection input is set to multiple. There are two scenarios for keyboard navigation of the Column Selection feature: Multi-column selection - holding ctrl + click on every selectable header cell. Range column selection - holding shift + click selects all selectable columns in between. API manipulations The API provides some additional capabilities when it comes to the non-visible columns such that, every hidden column could be marked as selected by setting the corresponding setter. Note The above statement also applies to the IgxColumnGroupComponent, except that when the selected property is changed it changes the state of its descendants. More information regarding the API manipulations could be found in the API References section. Styling Before diving into the styling options, the core module and all component mixins need to be imported. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Note Please note that row selection and column selection can't be manipulated independently. They depend on the same variables. With that being said, let's move on and change the selection and hover styles. Following the simplest approach, let's define our custom theme. $custom-grid-theme: grid-theme( $row-selected-background: #011627, $row-selected-text-color: #ECAA53, $row-selected-hover-background: #011627, $header-selected-text-color: #ECAA53, $header-selected-background: #011627, $expand-icon-color: #ECAA53, $expand-icon-hover-color: #B64B80 ); grid-theme accepts several parameters but those are the five responsible for changing the appearance of all selected columns: $row-selected-background - sets the background of the selected fraction. $row-selected-text-color - sets the text color of the selected fraction $row-selected-hover-background - sets the color of the hovered cell or bunch of cells. $header-selected-text-color - sets the text color of the selected column header $header-selected-background - sets the background color of the selected column header. Using CSS Variables The last step is to include the custom igx-grid theme. @include css-vars($custom-grid-theme) Overriding the Base Theme In order to style components for Internet Explorer 11, we have to use a different approach, since it doesn't support CSS variables. Note If the component is using the Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. In order to prevent the custom theme from leaking into other components, be sure that you have included the :host selector before ::ng-deep. :host { ::ng-deep { @include grid($custom-column-selection-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References The column selection UI has a few more APIs to explore, which are listed below. IgxTreeGridComponent IgxColumnComponent IgxColumnGrpupComponent IgxTreeGridComponent Styles IgxTreeGridComponent properties: columnSelection selectedColumns selectColumns deselectColumns selectAllColumns deselectAllColumns IgxColumnComponent properties: selectable selected IgxColumnGrpupComponent properties: selectable selected IgxTreeGridComponent events: onColumnsSelectionChange Additional Resources Tree Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/column-types.html": {
    "href": "components/treegrid/column-types.html",
    "title": "Column Data Types in Angular - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Column Types Ignite UI for Angular Tree Grid provides a default handling of number, string, date, boolean, currency and percent column data types, based on which the appearance of the default and editing templates will be present. Default template If you want to enable a data type-specific template, you should set the column dataType input otherwise the column will be treated as a string column since that is the default value for column dataType. Let's see what are the default templates for each type. String This column dataType is not changing the appearance or format of the cell value. Number If the dataType is set to number, the cell value will be formatted based on application or grid's locale settings, as well as when pipeArgs property is specified. Then the number format will be changed based on them, for example it might change the: Number of digits after the decimal point Decimal separator with , or . public options = { digitsInfo: '1.4-4', }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatOptions\" [dataType]=\"'number'\"> </igx-column> DateTime, Date and Time The appearance of the date portions will be set (e.g. day, month, year) based on locale format or pipeArgs input. The pipe arguments can be used to specify a custom date format or timezone: format - The default value for formatting the date is 'mediumDate'. Other available options are 'short', 'long', 'shortDate', 'fullDate', 'longTime', 'fulLTime' and etc. This is a full list of all available pre-defined format options. timezone - The user's local system timezone is the default value. The timezone offset or standard GMT/UTC or continental US timezone abbreviation can also be passed. Different timezone examples which will display the corresponding time of the location anywhere in the world: public formatDateOptions = { /** The date/time components that a date column will display, using predefined options or a custom format string. */ /** e.g 'dd/mm/yyyy' or 'shortDate' **/ format: 'longDate', /** A timezone offset (such as '+0430'), or a standard UTC/GMT or continental US timezone abbreviation. */ timezone: 'GMT' }; public formatOptions = this.options; <igx-column [pipeArgs]=\"formatDateOptions\" [dataType]=\"'date'\"> </igx-column> Available timezones: Timezone Value Alpha Time Zone ‘UTC+1’ Australian Central Time ‘UTC+9:30/ +10:30’ Arabia Standard Time ‘UTC+3’ Central Standard Time ‘UTC-6’ China Standard Time ‘UTC+8’ Delta Time Zone ‘UTC+4’ Greenwich Mean Time ‘UTC+0’ Gulf Standard Time ‘UTC+4’ Hawaii Standard Time ‘UTC-10’ India Standard Time ‘UTC+4’ The Tree Grid accepts date values of type Date object, Number (milliseconds), An ISO date-time string. This section shows how to configure a custom display format. As you can see in the sample, we specify a different format options in order to showcase the available formats for the specific column type. For example, below you can find the format options for the time portion of the date object: // Time format with equivalent example public timeFormats = [ { format: 'shortTime', eq: 'h:mm a' }, { format: 'mediumTime', eq: 'h:mm:ss a' }, { format: 'longTime', eq: 'h:mm:ss a z' }, { format: 'fullTime', eq: 'h:mm:ss a zzzz' }, ]; Cell editing When it comes to cell editing based on the column type a different editor will appear: dateTime - IgxDateTimeEditor directive will be used. This editor will give you a mask directions for the input elements part of the DateTime object. date - IgxDatePicker component will be used. time - IgxTimePicker component will be used. Filtering The same editors listed above will be used when it comes to Quick Filtering/Excel-style Filtering. These are the following filtering operands that each type exposes: dateTime and date - Equals, Does Not Equal, Before, After, Today, Yesterday, This Month, Last Month, Next Month, This Year, Last Year, Next Year, Empty, Not Empty, Null, Not Null; time - At, Not At, Before, After, At or Before, At or After, Empty, Not Empty, Null, Not Null; Summaries The available Summary operands will be Count, Earliest (date/time) and Latest (date/time). Sorting Time type column sorts based on the time portion of the object, ms will be disregarded. Date type column sorts based on the date portion, disregards the time portion. DateTime column sorts based on the full date Boolean The default template is using material icons for visualization of boolean values - 'clear' icon for false values and 'check' icon for true values. As for the editing template, it is using igx-checkbox component. <igx-column [dataType]=\"'boolean'\"> </igx-column> Currency Default template The default template will show a numeric value with currency symbol that would be either prefixed or suffixed. Both currency symbol location and number value formatting is based on the provided Application LOCALE_ID or Tree Grid locale. By using LOCALE_ID import { LOCALE_ID } from '@angular/core'; ... @Component({ selector: 'app-component.sample', templateUrl: 'grid-component.sample.html', providers: [{provide: LOCALE_ID, useValue: 'fr-FR' }] }) By using Grid's locale <igx-grid [locale]=\"'fr-FR'\" [data]=\"data\"> </igx-grid> By using the pipeArgs input the end-user can customize the number format by decimal point, currencyCode and display. public options = { digitsInfo: '3.4-4', currencyCode: 'USD', display: 'symbol-narrow' }; public formatOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatOptions\" [dataType]=\"'currency'\"> </igx-column> Parameter Description digitsInfo Represents Decimal representation of currency value currencyCode ISO 4217 currency code display* Displays the value by narrow or wide symbol *display - for the default en-US locale, the code USD can be represented by the narrow symbol $ or the wide symbol US$. Upon editing of cell's value the currency symbol will be visible as suffix or prefix. More about that could be found in the official Cell editing topic. Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Percent Default template is showing the percent equivalent of the underlying numeric value. The displayed cell value is a multiplied result by display factor of '100' - for example, as the default factor is 100 and the \"value\" passed to the cell is 0.123, then the displayed cell value will be \"12.3%\". When it comes to cell editing, the value will be the same as the data source value - the display factor is '1'. Upon editing of the cell a preview of the percent value will be shown as a suffix element.For example, while editing '0.0547' the preview element will show '5.47%'. public options = { /** * Decimal representation options, specified by a string in the following format: * `{minIntegerDigits}`.`{minFractionDigits}`-`{maxFractionDigits}`. * `minIntegerDigits`: The minimum number of integer digits before the decimal point. Default is 1. * `minFractionDigits`: The minimum number of digits after the decimal point. Default is 0. * `maxFractionDigits`: The maximum number of digits after the decimal point. Default is 3. */ digitsInfo: '2.2-3' }; public formatPercentOptions = this.options; <igx-column field=\"UnitsInStock\" [pipeArgs]=\"formatPercentOptions\" [dataType]=\"'percent'\"> </igx-column> Note When using up/down arrow keys the value will increment/decrement with a step based on the digitsInfo - minFractionDigits (The minimum number of digits after the decimal point. Default is 0) Image Default template is using the value coming from the data as an image source to a default image template. The default image template will extract the name of the image file and set it as alt attribute of the image to meet the accessibility requirement. The displayed cell size is adjusted to the sizes of the images rendered, so keep in mind that large images will still be rendered and the grid rows will become as large as the images in the image column. Filtering, sorting and grouping will be turned off by default for image type columns. If you want to enable them, you need to provide custom strategies which perform the data operations. <igx-column [dataType]=\"'image'\"> </igx-column> When auto-generating columns, the grid analyses the values in the first data record. If a value is of type string and matches the pattern of a url ending in an image extension (gif, jpg, jpeg, tiff, png, webp, bmp) then the column will automatically be marked as dataType === GridColumnDataType.Image and a default image template will be rendered. Default editing template See the editing templates part of Tree Grid Editing topic Custom editing template and formatter Custom template and column formatter definition will always take precedence over the column data type set: Custom template <igx-grid #grid1 [data]=\"data | async\" [autoGenerate]=\"false\"> <igx-column [field]=\"'UnitsInStock'\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [editable]=\"true\"> <ng-template igxCellEditor let-value> {{ value | currency:'USD':'symbol':'1.0-0'}} </ng-template> </igx-column> </igx-grid> Column formatter // Through column formatter property public formatCurrency(value: number) { return `Dollar sign ${value.toFixed(0)}`; } public init(column: IgxColumnComponent) { switch (column.field) { case 'UnitsInStock': column.formatter = this.formatCurrency; break; default: return; } API References IgxGridCell Column pipeArgs Tree Grid locale Column dataType Additional Resources For custom templates you can see cell editing topic Tree Grid overview topic Editing topic Summaries topic View page on GitHub"
  },
  "components/treegrid/conditional-cell-styling.html": {
    "href": "components/treegrid/conditional-cell-styling.html",
    "title": "Conditional Cell Styling in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Conditional Styling If you need to provide any custom styling in the IgxTreeGrid component, you can do it on either row or cell level. Tree Grid Conditional Row Styling The IgxTreeGrid component in Ignite UI for Angular provides two ways to conditional styling of rows based on custom rules. By setting rowClasses input on the IgxTreeGrid component; By setting rowStyles input on the IgxTreeGrid component; Further in this topic wi will cover both of them in more details. Using rowClasses You can conditionally style the IgxTreeGrid rows by setting the rowClasses input and define custom rules. <!-- sample.component.html --> <igx-tree-grid #treeGrid [data]=\"data\" [height]=\"'600px'\" [width]=\"'100%'\" [rowClasses]=\"rowClasses\"> ... </igx-tree-grid> The rowClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. // sample.component.ts public rowClasses = { activeRow: this.activeRowCondition }; public activeRowCondition = (row: RowType) => this.grid?.navigation.activeNode?.row === row.index; // sample.component.scss ::ng-deep { .activeRow { border: 2px solid #fc81b8; border-left: 3px solid #e41c77; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo Using rowStyles Columns now expose the rowStyles property which allows conditional styling of the data rows. Similar to rowClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling (without any conditions). The callback signature for both rowStyles and rowClasses is: (row: RowType) => boolean Let's define our styles: // component.ts public background = (row: RowType) => row.data['Title'] === 'CEO' ? '#6c757d' : row.data['Title'].includes('President') ? '#adb5bd' : row.data['Title'].includes('Director') ? '#ced4da' : row.data['Title'].includes('Manager') ? '#dee2e6' : row.data['Title'].includes('Lead') ? '#e9ecef' : row.data['Title'].includes('Senior') ? '#f8f9fa' : null; public rowStyles = { background: this.background, 'border-left': (row: RowType) => row.data['Title'] === 'CEO' || row.data['Title'].includes('President') ? '2px solid' : null, 'border-color': (row: RowType) => row.data['Title'] === 'CEO' ? '#495057' : null, color: (row: RowType) => row.data['Title'] === 'CEO' ? '#fff' : null }; <!-- sample.component.html --> <igx-tree-grid #treeGrid [data]=\"data\" [moving]=\"true\" primaryKey=\"ID\" foreignKey=\"ParentID\" width=\"100%\" height=\"550px\" [rowStyles]=\"rowStyles\"> ... </igx-tree-grid> Demo Tree Grid Conditional Cell Styling Overview The IgxTreeGrid component in Ignite UI for Angular provides two ways to conditional styling of cells based on custom rules. By setting the IgxColumnComponent input cellClasses to an object literal containing key-value pairs. The key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. The result is a convenient material styling of the cell. // component.ts file public beatsPerMinuteClasses = { downFont: this.downFontCondition, upFont: this.upFontCondition }; ... private downFontCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 95; } // component.scss file .upFont { color: red; } .downFont { color: green; } Using cellClasses You can conditionally style the IgxTreeGrid cells by setting the IgxColumnComponent cellClasses input and define custom rules. <!-- sample.component.html --> <igx-column field=\"UnitPrice\" header=\"Unit Price\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [cellClasses]=\"priceClasses\"></igx-column> The cellClasses input accepts an object literal, containing key-value pairs, where the key is the name of the CSS class, while the value is either a callback function that returns a boolean, or boolean value. // sample.component.ts private upPriceCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] > 5; } private downPriceCondition = (rowData: any, columnKey: any): boolean => { return rowData[columnKey] <= 5; } public priceClasses = { downPrice: this.downPriceCondition, upPrice: this.upPriceCondition }; // sample.component.scss ::ng-deep { .upPrice { color: red; } .downPrice { color: green; } } Use ::ng-deep or ViewEncapsulation.None to force the custom styles down through the current component and its children. Demo By using the IgxColumnComponent input cellStyles which accepts an object literal where the keys are style properties and the values are expressions for evaluation. public styles = { 'background': 'linear-gradient(180deg, #dd4c4c 0%, firebrick 100%)', 'text-shadow': '1px 1px 2px rgba(25,25,25,.25)', 'animation': '0.25s ease-in-out forwards alternate popin' }; The callback signature for both cellStyles and cellClasses is now changed to: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Using cellStyles Columns now expose the cellStyles property which allows conditional styling of the column cells. Similar to cellClasses it accepts an object literal where the keys are style properties and the values are expressions for evaluation. Also, you can apply regular styling with ease (without any conditions). In the sample above we've created: Two different styles that will be applied based on the column index. You will also change the text color based on even/odd rows. The callback signature for both cellStyles is: (rowData: any, columnKey: string, cellValue: any, rowIndex: number) => boolean Let's define our styles: // component.ts public oddColStyles = { background: 'linear-gradient(to right, #b993d6, #8ca6db)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'white' : 'gray', animation: '0.75s popin' }; public evenColStyles = { background: 'linear-gradient(to right, #8ca6db, #b993d6)', color: (rowData, coljey, cellValue, rowIndex) => rowIndex % 2 === 0 ? 'gray' : 'white', animation: '0.75s popin' }; On ngOnInit we will add the cellStyles configuration for each column of the predefined columns collection, which is used to create the IgxTreeGrid columns dynamically. // component.ts public ngOnInit() { this.data = athletesData; this.columns = [ { field: 'Id' }, { field: 'Position' }, { field: 'Name' }, { field: 'AthleteNumber' }, { field: 'CountryName' } ]; this.applyCSS(); } public applyCSS() { this.columns.forEach((column, index) => { column.cellStyles = (index % 2 === 0 ? this.evenColStyles : this.oddColStyles); }); } public updateCSS(css: string) { this.oddColStyles = {...this.oddColStyles, ...JSON.parse(css)}; this.evenColStyles = {...this.evenColStyles, ...JSON.parse(css)}; this.applyCSS(); } // component.html <igx-grid #grid1 [data]=\"data\" primaryKey=\"ID\" width=\"80%\" height=\"300px\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\" [cellStyles]=\"c.cellStyles\"> </igx-column> </igx-grid> Define a popin animation // component.scss @keyframes popin { 0% { opacity: 0.1; transform: scale(.75, .75); filter: blur(3px) invert(1); } 50% { opacity: .5; filter: blur(1px); } 100% { transform: scale(1, 1); opacity: 1; filter: none; } } Demo Known issues and limitations If there are cells bind to the same condition (from different columns) and one cell is updated, the other cells won't be updated based on the new value, if the condition is met. A pipe check should be performed in order to apply the changes to the rest of the cells. The example below shows how to do that with a spread operator ... on onCellEdit event. This will copy the original object with a new instance, and lead pure pipe to be fired. public backgroundClasses = { myBackground: (rowData: any, columnKey: string) => { return rowData.Col2 < 10; } }; ... editDone(evt) { this.backgroundClasses = {...this.backgroundClasses}; } <igx-grid #grid1 [data]=\"data\" height=\"500px\" width=\"100%\" (onCellEdit)=\"editDone($event)\"> <igx-column field=\"Col1\" dataType=\"number\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col2\" dataType=\"number\" [editable]=\"true\" [cellClasses]=\"backgroundClasses\"></igx-column> <igx-column field=\"Col3\" header=\"Col3\" dataType=\"string\" [cellClasses]=\"backgroundClasses\"></igx-column> </igx-grid> API References IgxColumnComponent IgxTreeGridComponent IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Column Hiding Selection Searching Toolbar Multi-column Headers Size (Display Density) Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/display-density.html": {
    "href": "components/treegrid/display-density.html",
    "title": "Angular Grid Size - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Size IgxTreeGrid design is based on Material Design Guidelines. We currently provide an option to choose between predefined set of size options that will bring a small, medium, or large view respectively. By selecting the right size for your Material UI table / Material UI grid you can significantly improve the user experience when interacting with large amounts of content. Angular Tree Grid Size Example Usage As you can see in the demo above, the IgxTreeGrid provides three size options: small, medium and large. The code snippet below shows how to set size: <igx-tree-grid #treeGrid [data]=\"data\" style=\"--ig-size: var(--ig-size-small)\"> </igx-tree-grid> And now let's see in details how each option reflects on the Tree Grid component. When you switch between different sizes the height of each Tree Grid element and the corresponding paddings will be changed. Also if you want to apply custom column width, please consider the fact that it must be bigger than the sum of left and right padding. --ig-size-large - this is the default Tree Grid size with the lowest intense and row height equal to 50px. Left and Right paddings are 24px; Minimal column width is 80px; --ig-size-medium - this is the middle size with 40px row height. Left and Right paddings are 16px; Minimal column width is 64px; --ig-size-small - this is the smallest size with 32px row height. Left and Right paddings are 12px; Minimal column width is 56px; Note Please keep in mind that currently you can not override any of the sizes. Let's now continue with our sample and see in action how each size is applied. Let's first add a button which will help us to switch between each size: <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\"></igx-buttongroup> </div> @ViewChild(IgxButtonGroupComponent) public buttonGroup: IgxButtonGroupComponent; public size = 'small'; public sizes; public ngOnInit() { this.sizes = [ { label: 'small', selected: this.size === 'small', togglable: true }, { label: 'medium', selected: this.sie === 'medium', togglable: true }, { label: 'large', selected: this.size === 'large', togglable: true } ]; } Now we can add the markup. <div class=\"density-chooser\"> <igx-buttongroup [values]=\"sizes\" (selected)=\"selectSize($event)\"></igx-buttongroup> </div> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\" width=\"200px\"></igx-column> <igx-column-group [pinned]=\"false\" header=\"General Information\"> <igx-column field=\"HireDate\" dataType=\"date\" [sortable]=\"true\" [hasSummary]=\"true\"> <ng-template igxCell let-cell=\"cell\" let-val> {{val | date:'dd/MM/yyyy'}} </ng-template> </igx-column> <igx-column-group header=\"Person Details\"> <igx-column field=\"ID\" dataType=\"number\" [filterable]=\"false\"></igx-column> <igx-column field=\"Title\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [hasSummary]=\"true\" [summaries]=\"numberSummaries\" [filterable]=\"false\"></igx-column> </igx-column-group> </igx-column-group> <igx-column-group header=\"Address Information\"> <igx-column-group header=\"Location\"> <igx-column field=\"Country\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"City\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Address\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> </igx-column-group> <igx-column-group header=\"Contact Information\"> <igx-column field=\"Phone\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Fax\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"PostalCode\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> </igx-column-group> </igx-column-group> <igx-column-group header=\"Address Information\"> <igx-column-group header=\"Location\"> <igx-column field=\"Country\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"City\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Address\" dataType=\"string\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> </igx-column-group> <igx-column-group header=\"Contact Information\"> <igx-column field=\"Phone\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Fax\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"PostalCode\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> </igx-column-group> </igx-column-group> </igx-tree-grid> Finally, let's provide the necessary logic in order to actually apply the size: @ViewChild('treeGrid', { read: IgxTreeGridComponent }) public treeGrid: IgxTreeGridComponent; public selectSize(event: any) { this.size = this.sizes[event.index].label; } @HostBinding('style.--ig-size') protected get sizeStyle() { return `var(--ig-size-${this.size})`; } Another option that IgxTreeGrid provides for you, in order to be able to change the height of the rows in the Tree Grid, is the property rowHeight. So let's see in action how this property affects the Tree Grid layout along with the --ig-size CSS variable. Please keep in mind the following: --ig-size CSS variable will have NO impact on row height if there is rowHeight specified; --ig-size will affect all of the rest elements in the Tree Grid, as it has been described above; And now we can extend our sample and add rowHeight property to the Tree Grid: <igx-tree-grid #treeGrid [data]=\"data\" [rowHeight]=\"'80px'\" width=\"100%\" height=\"550px\" [allowFiltering]=\"true\"> .............. </igx-tree-grid> API References IgxTreeGridComponent IgxTreeGridComponent Styles IgxColumnComponent Additional Resources Tree Grid overview Virtualization and Performance Editing Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/editing.html": {
    "href": "components/treegrid/editing.html",
    "title": "Angular Tree Grid Editing - Ignite UI for Angular",
    "keywords": "/* Fix for the overlapping right side-affix when the screen is shrinked */ .table-responsive { width:63vw; } Angular Tree Grid Editing Ignite UI for Angular Tree Grid component provides an easy way to perform data manipulation operations like creating, updating, and deleting records. The data manipulation phases are: Cell Editing, Row Editing, and Batch Editing. The Tree Grid gives you a powerful public API which allows you to customize the way these operations are performed. Additionally, Cell editing exposes several default editors based on the column data type, that could be easily customized via igxCellEditor directive or igxRow directives. Setup In order to specify which edit mode should be enabled, the Tree Grid exposes the following boolean properties - editable and rowEditable. Property editable enables you to specify the following options: false - the editing for the corresponding column will be disabled; /default value/ true - the editing for the corresponding column will be enabled; Keep in mind that if the column is not editable, you can still modify its value through the public API exposed by the Tree Grid. Property rowEditable enables you to specify the following options: false - the row editing in the corresponding grid will be disabled; /default value/ true - the row editing in the corresponding grid will be enabled; In the Tree Grid if you set rowEditable property to true, and editable property is not explicitly defined for any column, the editing will be enabled for all the columns except the primary key. Batch editing in the grid can be enabled for both cell editing and row editing modes. In order to set up batch editing it is necessary to provide to the grid a TransactionService. Cell and Batch Editing - in this scenario every singe modification of each cell is preserved separately and undo/ redo operations are available on cell level; Row and Batch Editing - in this scenario the modifications are preserved on row level so undo/ redo operations will not be working for each cell that is modified but for the bunch of cell from each row. Editing Templates If you want to use a data type specific edit templates, you should specify the column dataType property. So let's now see what are the default templates for each type: For string data type, default template is using igxInput For number data type, default template is using igxInput type=\"number\", so if you try to update cell to a value which can not be parsed to a number your change is going to be discarded, and the value in the cell will be set to 0. For date data type, default template is using igxDatePicker For dateTime data type, default template is using IgxDateTimeEditor directive. This editor will give you a mask directions for the input elements part of the DateTime object. For date data type, default template is using IgxDatePicker component. For time - data type, default template is using IgxTimePicker component. For boolean data type, default template is using igxCheckbox For currency data type, default template is using IgxInputGroup with prefix/suffix configuration based on application or grid locale settings. For percent data type, default template is using IgxInputGroup with suffix element that shows a preview of the edited value in percents. For custom templates you can see Cell Editing topic All available column data types could be found in the official Column types topic. Event arguments and sequence The grid exposes a wide array of events that provide greater control over the editing experience. These events are fired during the Row Editing and Cell Editing lifecycle - when starting, committing or canceling the editing action. Event Description Arguments Cancellable rowEditEnter If rowEditing is enabled, fires when a row enters edit mode IGridEditEventArgs true cellEditEnter Fires when a cell enters edit mode (after rowEditEnter) IGridEditEventArgs true cellEdit If value is changed, fires just before a cell's value is committed (e.g. by pressing Enter) IGridEditEventArgs true cellEditDone If value is changed, fires after a cell has been edited and cell's value is committed IGridEditDoneEventArgs false cellEditExit Fires when a cell exits edit mode IGridEditDoneEventArgs false rowEdit If rowEditing is enabled, fires just before a row in edit mode's value is committed (e.g. by clicking the Done button on the Row Editing Overlay) IGridEditEventArgs true rowEditDone If rowEditing is enabled, fires after a row has been edited and new row's value has been committed. IGridEditDoneEventArgs false rowEditExit If rowEditing is enabled, fires when a row exits edit mode IGridEditDoneEventArgs false Event cancelation RowEditEnter - Neither Row nor Cell will enter edit mode. CellEditEnter - Prevents entering cell edit. If rowEditable is enabled, row edit will be triggered, although cell edit will remain forbidden. CellEdit - Allowed Cell/Row edit, hitting Done button or Enter won't commit the value or row transaction. Cell editing and Row editing won't be closed until Cancel button is clicked. RowEdit - Committing cell is possible, but not the whole row. The row will stay in edit mode and the row transaction will be considered open. Hitting Done does not commit or close the row. Cancel button closes the editing process and the transaction without committing the changes. The following sample demonstrates the editing execution sequence in action: Features integration While a cell/row is in edit mode, a user may interact with the grid in many ways. The following table specifies how a certain interaction affects the current editing: Tree Grid Filtering Sorting Paging Moving Pinning Hiding GroupBy Resizing Escape Enter F2 Tab Cell Click Add new row/Delete/Edit Keep edit mode ✔ Exit edit mode ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ Commit ✔ ✔ ✔ ✔ ✔ Discard ✔ ✔ ✔ ✔ ✔ ✔ ✔ ✔ As seen from the table, all interactions, except resizing a column, will end the editing and will discard the new values. Should the new value be committed, this can be done by the developer in the corresponding feature \"-ing\" event. Example how to commit new values, if user tries to sort the column while a cell/row is in edit mode: <igx-grid #grid [data]=\"localData\" [primaryKey]=\"'ProductID'\" (sorting)=\"onSorting($event)\"> ... </igx-grid> public onSorting(event: ISortingEventArgs) { this.grid.endEdit(true); // (event.owner as IgxGridComponent).endEdit(true); } API References IgxGridCell IgxTreeGridComponent Styles IgxTreeGridRow IgxInputDirective IgxDatePickerComponent IgxDatePickerComponent Styles IgxCheckboxComponent IgxCheckboxComponent Styles IgxOverlay IgxOverlay Styles Additional Resources Tree Grid overview Build CRUD operations with igxGrid Column Data Types Virtualization and Performance Paging Filtering Sorting Summaries Column Pinning Column Resizing Selection Searching View page on GitHub"
  },
  "components/treegrid/excel-style-filtering.html": {
    "href": "components/treegrid/excel-style-filtering.html",
    "title": "Excel Style Filtering in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Excel Filtering in Angular Tree Grid The grid Excel filtering provides an Excel like filtering UI for any Angular table like the Tree Grid. Angular Tree Grid Excel Style Filtering Example Usage To turn on the grid excel filtering, two inputs should be set. The allowFiltering should be set to true and the filterMode should be set to excelStyleFilter. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"true\" [allowFiltering]=\"true\" [filterMode]=\"'excelStyleFilter'\"> </igx-tree-grid> Interactions In order to open the filter menu for a particular column, the Angular filter icon in the header should be clicked. Additionally, you can use the Ctrl + Shift + L combination on a selected header. If the column can be sorted, pinned, moved, selected or hidden along with the filtering functionality, there will be buttons available for the features that are turned on. If no filter is applied, all the items in the list will be selected. They can be filtered from the input above the list. In order to filter the data, you can select/deselect the items in the list and either click the Apply button, or press Enter. The filtering applied through the list items creates filter expressions with equals operator and the logic operator between the expressions is OR. If you type something in the search box and apply the filter, only the items that match the search criteria will be selected. If you want to add items to the currently filtered ones, however, you should select the option Add current selection to filter. If you want to clear the filter, you can check the Select All option and then click the Apply button. To apply a filter with different expressions, you can click the Text filter, which will open a sub menu with all available filter operators for the particular column. Selecting one of them will open the custom filter dialog, where you can add as many expressions as you want with different filter and logic operators. There is also a clear button, which can clear the filter. Configure Menu Features Sorting, pinning and hiding features can be removed from the filter menu using the corresponding inputs: sortable, selected, disablePinning, disableHiding. <igx-tree-grid #treegrid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"480px\" width=\"100%\" [moving]=\"true\" [allowFiltering]=\"true\" primaryKey=\"ID\" foreignKey=\"ParentID\" filterMode=\"excelStyleFilter\"> <igx-column field=\"ID\" header=\"Order ID\" [dataType]=\"'string'\"></igx-column> <igx-column field=\"Name\" header=\"Order Product\" [dataType]=\"'string'\" [sortable]=\"true\"></igx-column> <igx-column field=\"Category\" header=\"Category\" [dataType]=\"'string'\" [sortable]=\"true\"></igx-column> <igx-column field=\"Units\" header=\"Units\" [dataType]=\"'number'\" [sortable]=\"true\"></igx-column> <igx-column field=\"UnitPrice\" header=\"Unit Price\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\"></igx-column> <igx-column field=\"Price\" header=\"Price\" [dataType]=\"'currency'\" [pipeArgs]=\"formatOptions\" [sortable]=\"false\" [disablePinning]=\"true\" [disableHiding]=\"true\"></igx-column> <igx-column field=\"OrderDate\" header=\"Order Date\" [dataType]=\"'date'\" [formatter]=\"formatDate\" [sortable]=\"false\"></igx-column> <igx-column field=\"Delivered\" header=\"Deliverued\" [dataType]=\"'boolean'\" [sortable]=\"false\"> <ng-template igxCell let-cell=\"cell\" let-val> <img *ngIf=\"val\" src=\"assets/images/grid/active.png\" title=\"Delivered\" alt=\"Delivered\" /> <img *ngIf=\"!val\" src=\"assets/images/grid/expired.png\" title=\"Undelivered\" alt=\"Undelivered\" /> </ng-template> </igx-column> </igx-tree-grid> In the sample below 'Order Product', 'Category' and 'Units' columns have all three features enabled, 'Price' have all three disabled, 'Order Date' and 'Delivered' have only pinning and hiding. Templates If you want to further customize the Excel style filter menu without disabling the column features you could use custom templates. The Excel Style filter menu provides two directives for templating: IgxExcelStyleColumnOperationsTemplateDirective - re-templates the area with all column operations like sorting, pinning, etc. IgxExcelStyleFilterOperationsTemplateDirective - re-templates the area with all filter specific operations. You could either re-template only one of those areas or both of them. You could put any custom content inside those directives or you could use any of our built-in Excel style filtering components. The following code demonstrates how to define a custom Excel style filter menu using the igx-excel-style-header, igx-excel-style-sorting and igx-excel-style-search components. <igx-tree-grid #treegrid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"480px\" width=\"100%\" [allowFiltering]=\"true\" primaryKey=\"ID\" foreignKey=\"ParentID\" filterMode=\"excelStyleFilter\"> <igx-grid-excel-style-filtering [minHeight]=\"'380px'\" [maxHeight]=\"'500px'\"> <igx-excel-style-column-operations> <igx-excel-style-header [showPinning]=\"true\" [showHiding]=\"true\" > </igx-excel-style-header> <igx-excel-style-sorting></igx-excel-style-sorting> </igx-excel-style-column-operations> <igx-excel-style-filter-operations> <igx-excel-style-search></igx-excel-style-search> </igx-excel-style-filter-operations> </igx-grid-excel-style-filtering> ... </igx-tree-grid> You could also re-template the Excel style filtering icon in the column header using the igxExcelStyleHeaderIcon directive: <igx-tree-grid ...> <ng-template igxExcelStyleHeaderIcon> <igx-icon>filter_alt</igx-icon> </ng-template> </igx-tree-grid> Here is the full list of Excel style filtering components that you could use: igx-excel-style-header igx-excel-style-sorting igx-excel-style-moving igx-excel-style-pinning igx-excel-style-hiding igx-excel-style-selecting igx-excel-style-clear-filters igx-excel-style-conditional-filter igx-excel-style-search Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. These values can be provided manually and loaded on demand, which is demonstrated in the Tree Grid Remote Data Operations topic. Formatted Values Filtering Strategy By default, the Tree Grid component filters the data based on the original cell values, however in some cases you may want to filter the data based on the formatted values. In order to do that you can use the TreeGridFormattedValuesFilteringStrategy. The following sample demonstrates how to format the numeric values of a column as strings and filter the Tree Grid based on the string values: Note The formatted values filtering strategy won't work correctly if you have more than one column bound to the same field from your data and one of the columns has a formatter. Tree Filter View By default, the Excel Style Filtering dialog displays the items in a list view. In order to display them in a tree view you can use the TreeGridFilteringStrategy and specify an array of column field names. Filter items will be displayed in a tree view for the speicified columns and in a list view for all other columns. The following sample demonstrates how to show filter items in a tree view for the first column: External Excel Style filtering As you see at the demos above the default appearance of the Excel Style filtering dialog is inside the Tree Grid. So this dialog is only visible when configuring the filters. There is a way to make that dialog stay always visible - it can be used outside of the grid as a standalone component. In the demo below, the Excel style filtering is declared separately of the Tree Grid. Demo Usage In order to configure the Excel style filtering component, you should set its column property to one of the Tree Grid's columns. In the sample above, we have bound the column property to the value of an IgxSelectComponent that displays the Tree Grid's columns. <igx-select #gridColums value=\"ID\"> <label igxLabel>Columns:</label> <igx-select-item *ngFor=\"let c of treegrid1.columns\" [value]=\"c.field\"> {{ c.field }} </igx-select-item> </igx-select> <igx-grid-excel-style-filtering [column]=\"treegrid1.getColumnByName(gridColums.value)\"> </igx-grid-excel-style-filtering> External Outlet The Tree Grid's z-index creates separate stacking context for each grid in the DOM. This ensures that all descendant elements of the grid will render as intended, without overlapping one another. However, elements that go outside of the grid (e.g. Excel Style filter) will conflict with outside elements with the same z-index (e.g. having two grids one under another) resulting in false rendering. The solution for this issue is to set the outlet property to an external outlet directive which allows the overlay elements to always appear on top. Demo Styling To get started with styling the Excel Style Filtering dialog, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; The excel style filtering dialog takes its background color from the grid's theme, using the filtering-row-background parameter. In order to change the background we need to create a custom theme: $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); We obviously have a lot more components inside the excel like filtering dialog, such as buttons, checkboxes, a list and even a drop-down. In order to style them, we need to create a separate theme for each one: $dark-button: button-theme( $background: #FFCD0F, $foreground: #292826, $hover-background: #292826, $hover-foreground: #FFCD0F ); $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $custom-list: list-theme( $background: #FFCD0F ); $custom-checkbox: checkbox-theme( $empty-color: #292826, $fill-color: #292826, $tick-color: #FFCD0F, $label-color: #292826 ); $custom-drop-down: drop-down-theme( $background-color: #FFCD0F, $item-text-color: #292826, $hover-item-background: #292826, $hover-item-text-color: #FFCD0F ); In this example we only changed some of the parameters for the listed components, but the button-theme, checkbox-theme, drop-down-theme, input-group-theme, list-theme themes provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope most of the components' mixins within .igx-excel-filter and .igx-excel-filter__secondary, so that these custom themes will affect only components nested in the excel style filtering dialog and all of its sub-dialogs. Otherwise other buttons, checkboxes, input-groups and lists would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include drop-down($custom-drop-down); @include grid($custom-grid); .igx-excel-filter, .igx-excel-filter__secondary { @include button($dark-button); @include input-group($dark-input-group); @include list($custom-list); @include checkbox($custom-checkbox); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-background: #FFCD0F ); $dark-button: button-theme( $background: color($dark-palette, \"secondary\", 400), $foreground: color($dark-palette, \"primary\", 400), $hover-background: color($dark-palette, \"primary\", 400), $hover-foreground: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $custom-list: list-theme( $background: color($dark-palette, \"secondary\", 400) ); $custom-checkbox: checkbox-theme( $empty-color: color($dark-palette, \"primary\", 400), $fill-color: color($dark-palette, \"primary\", 400), $tick-color: color($dark-palette, \"secondary\", 400), $label-color: color($dark-palette, \"primary\", 400) ); $custom-drop-down:drop-down-theme( $background-color: color($dark-palette, \"secondary\", 400), $item-text-color: color($dark-palette, \"primary\", 400), $hover-item-background: color($dark-palette, \"primary\", 400), $hover-item-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group, light-button, light-list, light-checkbox and light-drop-down schemas: $custom-grid-schema: extend($_light-grid, ( filtering-row-background:( color: (\"secondary\", 400) ) ) ); $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ), contained-background:( color: (\"secondary\", 400) ), contained-text-color:( color: (\"primary\", 400) ), contained-hover-background:( color: (\"primary\", 400) ), contained-hover-text-color:( color: (\"secondary\", 400) ) ) ); $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); $custom-list-schema: extend($_light-list, ( background:( color: (\"secondary\", 400) ) ) ); $custom-checkbox-schema: extend($_light-checkbox, ( empty-color:( color: (\"primary\", 400) ), fill-color:( color: (\"primary\", 400) ), tick-color:( color: (\"secondary\", 400) ), label-color:( color: (\"primary\", 400) ) ) ); $custom-drop-down-schema: extend($_light-drop-down, ( background-color:( color: (\"secondary\", 400) ), item-text-color:( color: (\"primary\", 400) ), hover-item-background:( color: (\"primary\", 400) ), hover-item-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: $custom-light-schema: extend($light-schema,( grid: $custom-grid-schema, button: $custom-button-schema, input-group: $custom-input-group-schema, list: $custom-list-schema, checkbox: $custom-checkbox-schema, drop-down: $custom-drop-down-schema )); $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-list: list-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-checkbox: checkbox-theme( $palette: $dark-palette, $schema: $custom-light-schema ); $custom-drop-down: drop-down-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxColumnComponent IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/export-excel.html": {
    "href": "components/treegrid/export-excel.html",
    "title": "Angular Tree Grid Export to Excel - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Export to Excel Service The Excel Exporter service can export data to excel from the IgxTreeGrid. The data export functionality is encapsulated in the IgxExcelExporterService class and the data is exported in MS Excel table format. This format allows features like filtering, sorting, etc. To do this you need to invoke the IgxExcelExporterService's export method and pass the IgxTreeGrid component as first argument to export grid easily. Angular Excel Exporter Example Exporting Tree Grid's Data To start using the IgniteUI Excel Exporter first import the IgxExcelExporterService in the app.module.ts file and add the service to the providers array: // app.module.ts import { IgxExcelExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ providers: [ IgxExcelExporterService ] }) export class AppModule {} Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. To initiate an export process you may use the handler of a button in your component's template. <igx-tree-grid #treeGrid [data]=\"localData\" [autoGenerate]=\"true\"></igx-tree-grid> <button (click)=\"exportButtonHandler()\">Export IgxTreeGrid to Excel</button> You may access the exporter service by defining an argument of type IgxExcelExporterService in the component's constructor and the Angular framework will provide an instance of the service. To export some data in MS Excel format you need to invoke the exporter service's export method and pass the IgxTreeGrid component as first argument. Here is the code which will execute the export process in the component's typescript file: // component.ts import { IgxExcelExporterService, IgxExcelExporterOptions } from 'igniteui-angular'; import { IgxTreeGridComponent } from 'igniteui-angular'; @ViewChild('treeGrid') public treeGrid: IgxTreeGridComponent; constructor(private excelExportService: IgxExcelExporterService) { } public exportButtonHandler() { this.excelExportService.export(this.treeGrid, new IgxExcelExporterOptions('ExportedDataFile')); } If all went well, you should see the IgxTreeGrid component and a button under it. When pressing the button, it will trigger the export process and the browser will download a file named \"ExportedDataFile.xlsx\" which contains the data from the Tree Grid component in MS Excel format. Export All Data There are some cases when you might be using remote operations like Paging and the Grid won't have access to all of its data. In these cases, we recommend using the Excel Export Service and pass the whole data collection, if available. Example: public exportButtonHandler() { this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions('ExportedDataFile')); } Export Multi Column Headers Grid It is now possible to export Tree Grid with defined multi-column headers. All headers will be reflected in the exported excel file as they are displayed in the Tree Grid. If you want to exclude the defined multi-column headers from the exported data you can set the exporter option ignoreMultiColumnHeaders to true. Note The exported Tree Grid will not be formatted as a table, since Excel tables do not support multiple row headers. Export Grid with Frozen Column Headers By default Excel Exporter service exports the grid with scrollable (unfrozen) column headers. There are scenarios in which you may want to freeze all headers on top of the exported excel file so they always stay in view as the user scrolls through the records. To achieve this you could set the exporter option freezeHeaders to true. public exportButtonHandler() { const exporterOptions = new IgxExcelExporterOptions('ExportedDataFile'); exporterOptions.freezeHeaders = true; this.excelExportService.export(this.grid, exporterOptions); } Customizing the Exported Content In the above examples the Excel Exporter service was exporting all available data. There are situations in which you may want to skip exporting a row or even an entire column. To achieve this you may hook to the columnExporting and/or rowExporting events which are fired respectively for each column and/or each row and cancel the respective event by setting the event argument object's cancel property to true. The following example will exclude a column from the export if its header is \"Age\" and if its index is 1: // component.ts this.excelExportService.columnExporting.subscribe((args: IColumnExportingEventArgs) => { if (args.header == 'Age' && args.columnIndex == 1) { args.cancel = true; } }); this.excelExportService.export(this.treeGrid, new IgxExcelExporterOptions('ExportedDataFile')); When you are exporting data from the Tree Grid component, the export process takes in account features like row filtering and column hiding and exports only the data visible in the Tree Grid. You can configure the exporter service to include filtered rows or hidden columns by setting properties on the IgxExcelExporterOptions object. Known Limitations Limitation Description Hierarchy levels The excel exporter service can create up to 8 levels of hierarchy. Max worksheet size The maximum worksheet size supported by Excel is 1,048,576 rows by 16,384 columns. Cell Styling The excel exporter service does not support exporting a custom style applied to a cell component. In such scenarios we recommend using the Excel Library. API References The Excel Exporter service has a few more APIs to explore, which are listed below. IgxExcelExporterService API IgxExcelExporterOptions API Additional components that were used: IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/filtering.html": {
    "href": "components/treegrid/filtering.html",
    "title": "Angular Tree Grid Filter - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Filtering IgniteUI for Angular Tree Grid component provides three different filtering types - Quick filtering, Excel style filtering and Advanced filtering which enable you to display only the records that meet specified criteria. The Material UI grid component in Ignite UI provides angular filter capabilities and extensive filtering API through the Data Container to which the Tree Grid is bound. Angular Tree Grid Filtering Example The sample below demonstrates Tree Grid's Quick filtering user experience. API filter() method is used to apply contains condition on the ProductName column through external igxInputGroup component. Setup In order to specify if filtering is enabled and which filtering mode should be used, the Tree Grid exposes the following boolean properties - allowFiltering, allowAdvancedFiltering, filterMode and filterable. Property allowFiltering enables you to specify the following options: false - the filtering for the corresponding grid will be disabled; /default value/ true - the filtering for the corresponding grid will be enabled; Property allowAdvancedFiltering enables you to specify the following options: false - the advanced filtering for the corresponding grid will be disabled; /default value/ true - the advanced filtering for the corresponding grid will be enabled; Property filterMode enables you to specify the following options: quickFilter - a simplistic filtering UI; /default value/ excelStyleFilter - an Excel-like filtering UI; Property filterable enables you to specify the following options: true - the filtering for the corresponding column will be enabled; /default value/ false - the filtering for the corresponding column will be disabled; <igx-tree-grid [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" header=\"Order Product\"></igx-column> <igx-column field=\"Units\" header=\"Units\" dataType=\"number\" [filterable]=\"false\"></igx-column> </igx-tree-grid> To enable the Advanced filtering however, you need to set the allowAdvancedFiltering input properties to true. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"true\" [allowAdvancedFiltering]=\"true\"> </igx-tree-grid> Note You can enable both the quickFilter/excelStyleFilter and the advanced filtering user interfaces in the Tree Grid. Both filtering user interfaces will work independently of one another. The final filtered result in the Tree Grid is the intersection between the results of the two filters. Interaction In order to open the filter row for a particular column, the 'Filter' chip below its header should be clicked. To add conditions you should choose filter operand using the dropdown on the left of the input and enter value. For number and date columns 'Equals' is selected by default, for string - 'Contains' and for boolean - 'All'. Pressing 'Enter' confirms the condition and you are now able to add another one. There is a dropdown, between 'condition' chips, which determines the logical operator between them, 'AND' is selected by default. To remove a condition you can click the 'X' button of the chip, and to edit it you should select the chip and the input will be populated with the chip's data. While filter row is opened you can click on any filterable column's header in order to select it and to be able to add filter conditions for it. While some filtering conditions have been applied to a column, and the filter row is closed, you can either remove the conditions by clicking the chip's close button, or you can open the filter row by selecting any of the chips. When there is not enough space to show all the conditions, a filter icon is shown with a badge that indicates how many more conditions there are. It can also be clicked in order to open the filter row. Usage There's a default filtering strategy provided out of the box, as well as all the standard filtering conditions, which the developer can replace with their own implementation. In addition, we've provided a way to easily plug in your own custom filtering conditions. The Tree Grid currently provides not only a simplistic filtering UI, but also more complex filtering options. Depending on the set dataType of the column, the correct set of filtering operations is loaded inside the filter UI dropdown. Additionally, you can set the ignoreCase and the initial condition properties. Filtering feature is enabled for the Tree Grid component by setting the allowFiltering input to true. The default filterMode is quickFilter and it cannot be changed run time. To disable this feature for a certain column – set the filterable input to false. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" header=\"Order Product\"></igx-column> <igx-column field=\"Units\" header=\"Units\" dataType=\"number\"></igx-column> <igx-column field=\"Delivered\" header=\"Delivered\" [dataType]=\"'boolean'\" [filterable]=\"false\"> </igx-tree-grid> Note If values of type string are used by a column of dataType Date, the Tree Grid won't parse them to Date objects and using filtering conditions won't be possible. If you want to use string objects, additional logic should be implemented on the application level, in order to parse the values to Date objects. You can filter any column or a combination of columns through the Tree Grid API. The Tree Grid exposes several methods for this task - filter, filterGlobal and clearFilter. filter - filter a single column or a combination of columns. There are five filtering operand classes exposed: IgxFilteringOperand: this is a base filtering operand, which can be inherited when defining custom filtering conditions. IgxBooleanFilteringOperand defines all default filtering conditions for boolean type. IgxNumberFilteringOperand defines all default filtering conditions for numeric type. IgxStringFilteringOperand defines all default filtering conditions for string type. IgxDateFilteringOperand defines all default filtering conditions for Date type. // Single column filtering // Filter the `Order Product` column for values which `contains` the `myproduct` substring, ignoring case this.treeGrid.filter('Order Product', 'myproduct', IgxStringFilteringOperand.instance().condition('contains'), true); The only required parameters are the column field key and the filtering term. Both the condition and the case sensitivity will be inferred from the column properties if not provided. In the case of multiple filtering, the method accepts an array of filtering expressions. Note The filtering operation DOES NOT change the underlying data source of the Tree Grid. // Multi column filtering const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'ProductName'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'Order Product', ignoreCase: true, searchVal: 'ch' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); const priceFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'Price'); const priceExpression = { condition: IgxNumberFilteringOperand.instance().condition('greaterThan'), fieldName: 'UnitPrice', ignoreCase: true, searchVal: 20 }; priceFilteringExpressionsTree.filteringOperands.push(priceExpression); gridFilteringExpressionsTree.filteringOperands.push(priceFilteringExpressionsTree); this.treeGrid.filteringExpressionsTree = gridFilteringExpressionsTree; filterGlobal - clears all existing filters and applies the new filtering condition to all Tree Grid's columns. // Filter all cells for a value which contains `myproduct` this.treeGrid.filteringLogic = FilteringLogic.Or; this.treeGrid.filterGlobal('myproduct', IgxStringFilteringOperand.instance().condition('contains'), false); clearFilter - removes any applied filtering from the target column. If called with no arguments it will clear the filtering of all columns. // Remove the filtering state from the ProductName column this.treeGrid.clearFilter('Order Product'); // Clears the filtering state from all columns this.treeGrid.clearFilter(); Initial filtered state To set the initial filtering state of the Tree Grid, set the IgxTreeGridComponent filteringExpressionsTree property to an array of IFilteringExpressionsTree for each column to be filtered. constructor(private cdr: ChangeDetectorRef) { } public ngAfterViewInit() { const gridFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And); const productFilteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, 'Order Product'); const productExpression = { condition: IgxStringFilteringOperand.instance().condition('contains'), fieldName: 'Order Product', ignoreCase: true, searchVal: 'c' }; productFilteringExpressionsTree.filteringOperands.push(productExpression); gridFilteringExpressionsTree.filteringOperands.push(productFilteringExpressionsTree); this.treeGrid.filteringExpressionsTree = gridFilteringExpressionsTree; this.cdr.detectChanges(); } Filtering logic The filteringLogic property of the Tree Grid controls how filtering multiple columns will resolve in the Tree Grid. You can change it at any time through the Tree Grid API, or through the Tree Grid input property. import { FilteringLogic } from 'igniteui-angular'; // import { FilteringLogic } from '@infragistics/igniteui-angular'; for licensed package ... this.treeGrid.filteringLogic = FilteringLogic.OR; The default value of AND returns only the rows that match all the currently applied filtering expressions. Following the example above, a row will be returned when both the 'ProductName' cell value contains 'myproduct' and the 'Price' cell value is greater than 55. When set to OR, a row will be returned when either the 'ProductName' cell value contains 'myproduct' or the 'Price' cell value is greater than 55. Remote Filtering The Tree Grid supports remote filtering, which is demonstrated in the Tree Grid Remote Data Operations topic. Custom Filtering Operands You can customize the filtering menu by adding, removing or modifying the filtering operands. By default, the filtering menu contains certain operands based on the column’s data type (IgxBooleanFilteringOperand, IgxDateFilteringOperand, IgxNumberFilteringOperand and IgxStringFilteringOperand). You can extend these classes or their base class IgxFilteringOperand to change the filtering menu items’ behavior. In the sample below, inspect the \"Order Product\" and \"Delivered\" columns filters menus. For the \"Delivered\" column filter, we have limited the number of operands to All, True and False. For the \"Order Product\" column filter – we have modified the Contains and Does Not Contain operands logic to perform case sensitive search and added also Empty and Not Empty operands. To do that, extend the IgxStringFilteringOperand and IgxBooleanFilteringOperand, modify the operations and their logic, and set the column filters input to the new operands. // grid-custom-filtering.component.ts export class GridCustomFilteringComponent { public caseSensitiveFilteringOperand = CaseSensitiveFilteringOperand.instance(); public booleanFilteringOperand = BooleanFilteringOperand.instance(); } export class CaseSensitiveFilteringOperand extends IgxStringFilteringOperand { private constructor() { super(); const customOperations = [ { iconName: 'contains', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) !== -1; }, name: 'Contains (case sensitive)' }, { iconName: 'does_not_contain', isUnary: false, logic: (target: string, searchVal: string, ignoreCase?: boolean) => { ignoreCase = false; const search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase); target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase); return target.indexOf(search) === -1; }, name: 'Does Not Contain (case sensitive)' } ]; const emptyOperators = [ // 'Empty' this.operations[6], // 'Not Empty' this.operations[7] ]; this.operations = customOperations.concat(emptyOperators); } } export class BooleanFilteringOperand extends IgxBooleanFilteringOperand { private constructor() { super(); this.operations = [ // 'All' this.operations[0], // 'TRUE' this.operations[1], // 'FALSE' this.operations[2] ]; } } <!-- tree-grid-filtering-custom-sample.component.html --> <igx-tree-grid [data]=\"data\" [autoGenerate]=\"false\" [allowFiltering]=\"true\"> <igx-column field=\"Name\" header=\"Order Product\" [filters]=\"caseSensitiveFilteringOperand\"></igx-column> <igx-column field=\"Delivered\" header=\"Delivered\" [dataType]=\"'boolean'\" [filters]=\"booleanFilteringOperand\"> <ng-template igxCell let-cell=\"cell\" let-val> <img *ngIf=\"val\" src=\"assets/images/grid/active.png\" title=\"Delivered\" alt=\"Delivered\" /> <img *ngIf=\"!val\" src=\"assets/images/grid/expired.png\" title=\"Undelivered\" alt=\"Undelivered\" /> </ng-template> </igx-column> </igx-tree-grid> Re-templating filter cell You can add a template marked with igxFilterCellTemplate in order to retemplate the filter cell. In the sample below, an input is added for the string columns and IgxDatePicker for the date column. When the user types or selects a value, a filter with contains operator for string columns and equals operator for date columns, is applied using grid's public API. Matching Records Only Filtering Strategy By default, after a filtering is applied, the Tree Grid component displays the records matching the criterion that have been set and their parents in a grayed-out fashion to provide additional context. However, in some cases, you may want to display only the records matching particular filtering condition without any trace for their parents. This can be achieved by using the TreeGridMatchingRecordsOnlyFilteringStrategy: <igx-grid [data]=\"data\" [allowFiltering]=\"true\" [filterStrategy]=\"matchingRecordsOnlyStrategy\"> </igx-grid> import { TreeGridMatchingRecordsOnlyFilteringStrategy } from \"igniteui-angular\"; ... public matchingRecordsOnlyStrategy = new TreeGridMatchingRecordsOnlyFilteringStrategy(); Styling To get started with styling the filtering row, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $filtering-row-text-color, $filtering-row-background, $filtering-header-text-color and the $filtering-header-background parameters. $custom-grid: grid-theme( $filtering-row-text-color: #292826, $filtering-row-background: #FFCD0F, $filtering-header-text-color: #292826, $filtering-header-background: #FFCD0F ); As seen, the grid-theme only controls colors for the filtering row and the respective column header that is being filtered. We obviously have a lot more components inside the filtering row, such as an input group, chips, buttons and others. In order to style them, we need to create a separate theme for each one, so let's create a new input group theme and a new button theme: $dark-input-group: input-group-theme( $box-background: #FFCD0F, $idle-text-color: #292826, $focused-text-color: #292826, $filled-text-color: #292826 ); $dark-button: button-theme( $flat-background: #FFCD0F, $flat-text-color: #292826, $flat-hover-background: #292826, $flat-hover-text-color: #FFCD0F ); In this example we only changed some of the parameters for the input group and the button, but the input-group-theme and the button-theme provide way more parameters to control their respective styling. The last step is to include the component mixins, each with its respective theme. We will also set the color property for the input's placeholder. @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } Note We scope the igx-button and the igx-input-group mixins within .igx-grid__filtering-row, so that only the filtering row buttons and its input group would be styled. Otherwise other buttons and input groups in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-grid); .igx-grid__filtering-row { @include button($dark-button); @include input-group($dark-input-group); .igx-input-group__input::placeholder { color: #FFCD0F; } } } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-grid: grid-theme( $filtering-row-text-color: color($dark-palette, \"primary\", 400), $filtering-row-background: color($dark-palette, \"secondary\", 400), $filtering-header-text-color: color($dark-palette, \"primary\", 400), $filtering-header-background: color($dark-palette, \"secondary\", 400) ); $dark-input-group: input-group-theme( $box-background: color($dark-palette, \"secondary\", 400), $idle-text-color: color($dark-palette, \"primary\", 400), $focused-text-color: color($dark-palette, \"primary\", 400), $filled-text-color: color($dark-palette, \"primary\", 400) ); $dark-button: button-theme( $flat-background: color($dark-palette, \"secondary\", 400), $flat-text-color: color($dark-palette, \"primary\", 400), $flat-hover-background: color($dark-palette, \"primary\", 400), $flat-hover-text-color: color($dark-palette, \"secondary\", 400) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid, light-input-group and light-button schemas: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( filtering-row-text-color:( color: (\"primary\", 400) ), filtering-row-background:( color: (\"secondary\", 400) ), filtering-header-text-color:( color: (\"primary\", 400) ), filtering-header-background:( color: (\"secondary\", 400) ) ) ); // Extending the light input group schema $custom-input-group-schema: extend($_light-input-group, ( box-background:( color: (\"secondary\", 400) ), idle-text-color:( color: (\"primary\", 400) ), focused-text-color:( color: (\"primary\", 400) ), filled-text-color:( color: (\"primary\", 400) ) ) ); // Extending the light button schema $custom-button-schema: extend($_light-button, ( flat-background:( color: (\"secondary\", 400) ), flat-text-color:( color: (\"primary\", 400) ), flat-hover-background:( color: (\"primary\", 400) ), flat-hover-text-color:( color: (\"secondary\", 400) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $custom-light-schema: extend($light-schema,( igx-grid: $custom-grid-schema, igx-input-group: $custom-input-group-schema, igx-button: $custom-button-schema )); // Defining grid-theme with the global light schema $custom-grid: grid-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining button-theme with the global light schema $custom-button: button-theme( $palette: $dark-palette, $schema: $custom-light-schema ); // Defining input-group-theme with the global light schema $custom-input-group: input-group-theme( $palette: $dark-palette, $schema: $custom-light-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Limitations Note Some browsers such as Firefox fail to parse regional specific decimal separators by considering them grouping separators, thus resulting in them being invalid. When inputting such values for a numeric column filter value, only the valid part of the number will be applied to the filtering expression. For further information, refer to the Firefox issue. Breaking Changes in 6.1.0 IgxTreeGrid filteringExpressions property is removed. Use filteringExpressionsTree instead. filter_multiple method is removed. Use filter method and filteringExpressionsTree property instead. The filter method has new signature. It now accepts the following parameters: name - the name of the column to be filtered. value - the value to be used for filtering. conditionOrExpressionTree (optional) - this parameter accepts object of type IFilteringOperation or IFilteringExpressionsTree. If only simple filtering is needed, a filtering operation could be passed as an argument. In case of advanced filtering, an expressions tree containing complex filtering logic could be passed as an argument. ignoreCase (optional) - whether the filtering is case sensitive or not. filteringDone event now have only one parameter of type IFilteringExpressionsTree which contains the filtering state of the filtered column. filtering operands: IFilteringExpression condition property is no longer a direct reference to a filtering condition method, instead it's a reference to an IFilteringOperation. IgxColumnComponent now exposes a filters property, which takes an IgxFilteringOperand class reference. Custom filters can be provided to the Tree Grid columns by populating the operations property of the IgxFilteringOperand with operations of IFilteringOperation type. API References IgxColumnComponent IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/groupby.html": {
    "href": "components/treegrid/groupby.html",
    "title": "Angular Tree Grid Group By | Group by multiple fields | Infragistics",
    "keywords": "Angular Tree Grid Group By If you have non-hierarchical data and you want to group by one or more columns and populate the parent rows with aggregated values, you could use the IgxTreeGridComponent along with treeGridGrouping pipe and the UI component with selector igx-tree-grid-group-by-area. The treeGridGrouping pipe groups the data based on the provided parameters and the resulting hierarchy is displayed in a separate column. The pipe can also calculate aggregated values for the generated parent rows if aggregations are provided. Here is an example of how to use the pipe in the template: <igx-tree-grid #grid [data]=\"data | treeGridGrouping:groupingExpressions:groupKey:childDataKey:grid:aggregations\" [childDataKey]=\"childDataKey\" [sortStrategy]=\"sorting\"> The pipe arguments are the following: groupingExpressions - an array of IGroupingExpression objects which contains information about the fields used to generate the hierarchy and the sorting details for each group groupKey - a string value for the name of the generated hierarchy column childDataKey - a string value for the field where the child collection of the generated parent rows is stored grid - IgxTreeGridComponent that is used for the grouping aggregations (optional) - an array of ITreeGridAggregation objects which contains information about the aggregation functions The UI component with selector igx-tree-grid-group-by-area handles the UI interactions related to the columns that are used for the grouping. Here is an example of how to use the component in the template: <igx-tree-grid-group-by-area [grid]='grid' [(expressions)]='groupingExpressions' [hideGroupedColumns]='true'> </igx-tree-grid-group-by-area> The component's inputs are the following: grid - IgxTreeGridComponent that is used for the grouping expressions - an array of IGroupingExpression objects which contains the fields used to generate the hierarchy hideGroupedColumns - a boolean value indicating whether to hide the columns by which grouping was performed dropAreaTemplate - a template for the drop area that can be used to override the default drop area template dropAreaMessage - a string that can be used to override the default message for the default drop area template Note In order for the sorting to work correctly you should set the sortStrategy property of the IgxTreeGridComponent to an instance of IgxGroupedTreeGridSorting. Angular Tree Grid Group By Example Implementation In this sample we are using the treeGridGrouping pipe and the UI component with selector igx-tree-grid-group-by-area for the grouping. The data is grouped by the \"category\", \"type\" and \"contract\" fields. The resulting hierarchy is displayed in the newly created \"categories\" column. The pipe also calculates aggregated values for the generated parent rows for the \"price\", \"change\" and \"changeP\" columns. <igx-tree-grid #grid1 [data]=\"data$ | async | treeGridGrouping:groupingExpressions:groupColumnKey:childDataKey:grid1:aggregations\" [childDataKey]=\"childDataKey\" [sortStrategy]=\"sorting\"> <igx-tree-grid-group-by-area [grid]=\"grid1\" [(expressions)]=\"groupingExpressions\" [hideGroupedColumns]=\"true\"> </igx-tree-grid-group-by-area> <igx-column [field]=\"groupColumnKey\"></igx-column> Here you can see how the grouping expressions and aggregations are defined: public groupingExpressions: IGroupingExpression[] = [ { fieldName: 'category', dir: 2, ignoreCase: true, strategy: DefaultSortingStrategy.instance() }, { fieldName: 'type', dir: 1, ignoreCase: true, strategy: DefaultSortingStrategy.instance() }, { fieldName: 'contract', dir: 1, ignoreCase: true, strategy: DefaultSortingStrategy.instance() } ]; public aggregations: ITreeGridAggregation[] = [ { aggregate: (parent: any, data: any[]) => data.map((r) => r.change).reduce((ty, u) => ty + u, 0), field: 'change' }, { aggregate: (parent: any, data: any[]) => data.map((r) => r.price).reduce((ty, u) => ty + u, 0), field: 'price' }, { aggregate: (parent: any, data: any[]) => parent.change / (parent.price - parent.change) * 100, field: 'changeP' } ]; public childDataKey = 'children'; public groupColumnKey = 'categories'; public sorting = IgxGroupedTreeGridSorting.instance(); Angular Tree Grid Group By Load On Demand Example Implementation In this sample, data is loaded in portions. Initially, only the top level categories are displayed, then child data is served once a parent row is expanded. For more information on this approach, please refer to the Tree Grid Load On Demand topic. The data is grouped by the \"ShipCountry\", \"ShipCity\" and \"Discontinued\" fields and the resulting hierarchy is displayed in a separate column. The grouping is performed on a remote service - the data is modified and corresponding child and parent keys are assigned that are used to display the final data in a hierarchical view. For more information on how this service works you can take a look at the TreeGridGroupingLoadOnDemandService class in the remoteService.ts file. Here is an example of how to use load on demand: <igx-tree-grid #treeGrid [data]=\"data\" [loadChildrenOnDemand]=\"loadChildren\" [primaryKey]=\"primaryKey\" [foreignKey]=\"foreignKey\" [hasChildrenKey]=\"hasChildrenKey\"> <igx-tree-grid-group-by-area [grid]=\"treeGrid\" [(expressions)]=\"groupingExpressions\" (expressionsChange)=\"onExpressionsChange($event)\" [hideGroupedColumns]=\"true\"> </igx-tree-grid-group-by-area> <igx-column [field]=\"groupColumnKey\"></igx-column> In order to load the child rows when the user expands a row, the Tree Grid provides the callback input property loadChildrenOnDemand - the children data is retrieved from the server and it is assigned to the requested parent row based on the grouping parameters. public groupingExpressions: IGroupingExpression[] = [ { fieldName: 'ShipCountry', dir: 2, ignoreCase: true, strategy: DefaultSortingStrategy.instance() }, { fieldName: 'ShipCity', dir: 1, ignoreCase: true, strategy: DefaultSortingStrategy.instance() }, { fieldName: 'Discontinued', dir: 1, ignoreCase: true, strategy: DefaultSortingStrategy.instance() } ]; public primaryKey = 'id'; public foreignKey = 'parentId'; public hasChildrenKey = 'children'; public groupColumnKey = ''; private dataService = new TreeGridGroupingLoadOnDemandService(); public ngOnInit() { this.reloadData(); } public loadChildren = (parentID: any, done: (children: any[]) => void) => { const groupingParameters = this.assembleGroupingParameters(); this.dataService.getData(parentID, this.hasChildrenKey, groupingParameters, (children) => done(children)); }; private reloadData() { this.treeGrid.isLoading = true; this.treeGrid.expansionStates.clear(); const groupingParameters = this.assembleGroupingParameters(); this.dataService.getData(null, this.hasChildrenKey, groupingParameters, (children) => { this.data = children; this.treeGrid.isLoading = false; this.treeGrid.reflow(); }); } API References IgxTreeGridComponent IgxGridComponent Styles Additional Resources TreeGrid overview TreeGrid Summaries Grid Summaries Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/keyboard-navigation.html": {
    "href": "components/treegrid/keyboard-navigation.html",
    "title": "Angular Tree Grid Keyboard Navigation - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Keyboard Navigation Keyboard navigation in the IgxTreeGrid provides a rich variety of keyboard interactions for the user. It enhances the accessibility of the IgxTreeGrid and allows to navigate through any type of elements inside (cell, row, column header, toolbar, footer, etc.). This functionality is enabled by default, and the developer has the option to override any of the default behaviors in an easy way. The tabulations of the IgxTreeGrid has been reduced so that the navigation is compliant with W3C accesibility standards and convenient to use. Currently, the IgxTreeGrid introduces the following tab stops: GroupBy or Toolbar area (if enabled); IgxTreeGrid header; IgxTreeGrid body; Column summaries (if enabled); IgxTreeGrid paginator (if enabled); Note Due to this change, navigating between the cells with tab and Shift + Tab is no longer supported in the IgxTreeGrid. Pressing the Tab key now goes through the tab stops in the following order: GroupBy / Toolbar -> Headers -> Body -> Summaries -> Footer / Paginator. Note Exposing any focusable element into the IgxTreeGrid body via template may introduce side effects in the keyboard navigation, since the default browser behavior is not prevented. It is the developer's responsibility to prevent or modify it appropriately. Header Navigation A full keyboard navigation support in the IgxTreeGrid header is now introduced. Column headers can be easily traversed with the arrow keys. Additionally, there are a number of key combinations that trigger actions on the columns like filtering, sorting, grouping and etc. When the IgxTreeGrid header container is focused, the following key combinations are available: Key Combinations Arrow Up navigates one cell up in the headers (no looping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Down navigates one cell down in the headers (no wrapping). Available only when Multi-row Layout (MRL) or Multi-column Headers (MCH) are defined Arrow Left navigates one cell left (no looping) Arrow Right navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Home navigates to the leftmost cell in the row; if MRL or MCH are enabled, navigates to the leftmost cell at the same level Ctrl + Arrow Right navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level End navigates to the rightmost cell in row; if MRL or MCH are enabled, navigates to the rightmost cell at the same level Alt + L opens Advanced Filtering dialog if Advanced Filtering is enabled Ctrl + Shift + L opens the Excel Style Filter dialog or the default (row) filter if the column is filterable Ctrl + Arrow Up sorts the active column header in ASC order. If the column is already sorted in ASC, sorting state is cleared Ctrl + Arrow Down sorts the active column header in DSC order. If the column is already sorted in DSC, sorting state is cleared Space selects the column; If the column is already selected, selection is cleared Body navigation When the IgxTreeGrid body is focused, the following key combinations are available: Key Combination Arrow Up- navigates one cell up (no wrapping) Arrow Down navigates one cell down (no wrapping) Arrow Left navigates one cell left (no wrapping between lines) Arrow Right - navigates one cell right (no wrapping between lines) Ctrl + Arrow Left navigates to the leftmost cell in the row Ctrl + Arrow Right navigates to the rightmost cell in the row Ctrl + Arrow Up navigates to the first cell in the column Ctrl + Arrow Down navigates to the last cell in the column Home navigates to the leftmost cell in the row End navigates to the rightmost cell in the row Ctrl + Home navigates to the top leftmost data cell in the grid Ctrl + End navigates to the bottom rightmost data cell in the grid Page Up scrolls one page (view port) up Page Down scrolls one page (view port) down Enter enters edit mode F2 enters edit mode Esc exits edit mode Tab available only if there is a cell in edit mode; moves the focus to the next editable cell in the row; after reaching the last cell in the row, moves te focus to the first editable cell in the next row. When Row Editing is enabled, moves the focus from the right-most editable cell to the CANCEL and DONE buttons, and from DONE button to the left-most editable cell in the row Shift + Tab - available only if there is a cell in edit mode; moves the focus to the previous editable cell in the row; after reaching the first cell in the row, moves the focus to the last editable cell in the previous row. When Row Editing is enabled, moves the focus from the right-most editable cell to CANCEL and DONE buttons, and from DONE button to the right-most editable cell in the row Space - selects the row, if Row Selection is enabled Alt + Arrow Left or Alt + Arrow Up - collapses the current node Alt + Arrow Right or Alt + Arrow Down - expands the current node Practice all of the above mentioned actions in the demo sample below. Focus any navigable grid element and a list with some of the available actions for the element will be shown to guide you through. Demo Custom keyboard navigation Overriding the default behavior for a certain key or keys combination is one of the benefits that the Keyboard Navigation feature provides. For example: press the Enter or Tab key to navigate to the next cell or the cell below. This or any other navigation scenario is easily achieved by the Keyboard Navigation API: API Description Arguments gridKeydown An event that is emitted when any of key press/combinations described above is performed. Can be canceled. For any other key press/combination, use the default onkeydown event. IGridKeydownEventArgs activeNodeChange An event that is emitted when the active node is changed. You can use it to determine the Active focus position (header, tbody etc.), column index, row index or nested level. IActiveNodeChangeEventArgs navigateTo Navigates to a position in the grid, based on provided rowindex and visibleColumnIndex. It can also execute a custom logic over the target element, through a callback function that accepts param of type { targetType: GridKeydownTargetType, target: Object } . Usage: grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); }); rowindex: number, visibleColumnIndex: number, callback: ({ targetType: GridKeydownTargetType, target: Object }) => {} getNextCell returns ICellPosition object, which defines the next cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getNextCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const nextEditableCell = grid.getNextCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean getPreviousCell returns ICellPosition object, which defines the previous cell by rowIndex and visibileColumnIndex. A callback function can be passed as a third parameter of getPreviousCell method. The callback function accepts IgxColumnComponent as a param and returns a boolean value indication if a given criteria is met: const prevEditableCell = grid.getPreviousCell(0, 4, (col) => col.editable); currentRowIndex: number, currentVisibleColumnIndex: number, callback: (IgxColumnComponent) => boolean Let's try the API to demonstrate how to achieve common scenarios like user input validation and custom navigation. First we need to register an event handler for the gridKeydown event: <igx-tree-grid #grid1 [data]=\"data\" (gridKeydown)=\"customKeydown($event)\"> </igx-tree-grid> public customKeydown(args: IGridKeydownEventArgs) { const target: IgxGridCell = args.target as IgxGridCell; const evt: KeyboardEvent = args.event as KeyboardEvent; const type = args.targetType; if (type === 'dataCell' && target.inEditMode && evt.key.toLowerCase() === 'tab') { // 1. USER INPUT VALIDATON ON TAB } if (type === 'dataCell' && evt.key.toLowerCase() === 'enter') { // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS } } Based on the IGridKeydownEventArgs values we identified two cases, where to provide our own logic (see above). Now, using the methods from the API, let's perform the desired - if the user is pressing Tab key over a cell in edit mode, we will perform validation on the input. If the user is pressing Enter key over a cell, we will move focus to cell in the next row: // 1. USER INPUT VALIDATON ON TAB if (target.column.dataType === 'number' && target.editValue < 18) { // alert the user that the input is invalid return; } // 2. CUSTOM NAVIGATION ON ENTER KEY PRESS const nexRowIndex = target.row.expanded ? target.rowIndex + 2 : target.rowIndex + 1; grid.navigateTo(nexRowIndex, target.visibleColumnIndex, (obj) => { obj.target.nativeElement.focus(); }); Note: Please refer to the sample code for full implementation details. Use the demo below to try out the custom scenarios that we just implemented: Double click or press F2 key on a cell in the Age column, change the value to 16 and press tab key. Prompt message will be shown. Select a cell and press Enter key a couple of times. Every key press will move the focus to a cell in the next row, under the same column. Known Limitations Limitation Description Navigating inside а grid with scrollable parent container. If the grid is positioned inside a scrollable parent container and the user navigates to a grid cell that is out of view, parent container will not be scrolled. API References IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Hierarchical Grid Keyboard Navigation Grid Keyboard Navigation Tree Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/live-data.html": {
    "href": "components/treegrid/live-data.html",
    "title": "Live Data Updates in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Live Data Updates The Tree Grid component is able to handle thousands of updates per second, while staying responsive for user interactions. Angular Live-data Update Example The sample below demonstrates the Tree Grid performance when all records are updated multiple times per second. Use the UI controls to choose the number of records loaded and the frequency of updates. Feed the same data into the Line Chart to experience the powerful charting capabilities of Ignite UI for Angular. The Chart button will show Category Prices per Region data for the selected rows and the Chart column button will show the same for the current row. API References IgxTreeGridComponent IgxGridCell IgxTreeGridRow IgxGridComponent IgxGridComponent Styles IgxGridCell IgxBaseTransactionService Additional Resources Data Grid Row Editing Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/load-on-demand.html": {
    "href": "components/treegrid/load-on-demand.html",
    "title": "Tree Grid load on demand - Native Angular | Ignite UI for Angular",
    "keywords": "Tree Grid Load On Demand The Ignite UI for Angular IgxTreeGrid can be rendered in such way that it requires the minimal amount of data to get from the server so the user could see it as quickly as possible. Then, only after the user expands a row, the children for that particular parent row will be loaded. This mechanism, also known as Load on Demand, can be easily configured to work with any remote data. Angular Tree Grid Load On Demand Example Usage The Load on Demand feature is compatible with both types of Tree Grid data sources - primary and foreign keys or child collection. You only need to load the root level data in the Tree Grid and specify the necessary keys for one of the data source types. In order to load the child rows when the user expands a row, the Tree Grid provides the callback input property loadChildrenOnDemand. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [loadChildrenOnDemand]=\"loadChildren\"> ... </igx-tree-grid> The loadChildrenOnDemand callback provides two parameters: parentID - the ID of the parent row that is being expanded. done - callback that should be called with the children when they are retrieved from the server. public loadChildren = (parentID: any, done: (children: any[]) => void) => { this.dataService.getData(parentID, (children) => done(children)); } After the user clicks the expand icon, it is replaced by a loading indicator. When the done callback is called, the loading indicator disappears and the children are loaded. The Tree Grid adds the children to the underlying data source and populates the necessary keys automatically. If you have a way to provide an information whether a row has children prior to its expanding, you could use the hasChildrenKey input property. This way you could provide a boolean property from the data objects which indicates whether an expansion indicator should be displayed. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [loadChildrenOnDemand]=\"loadChildren\" hasChildrenKey=\"hasEmployees\"> ... </igx-tree-grid> Note that setting the hasChildrenKey property is not required. In case you don't provide it, expansion indicators will be displayed for each row. After expanding a row that has no children, you still need to call the done callback with undefined or empty array. In this case after the loading indicator disappears, the expansion indicator never shows up. If you want to provide your own custom loading indicator, you may create an ng-template and mark it with the igxRowLoadingIndicator directive. The following code snippet demonstrates how to define such custom template: <igx-tree-grid ...> ... <ng-template igxRowLoadingIndicator> <igx-icon fontSet=\"material\">loop</igx-icon> </ng-template> </igx-tree-grid> API References IgxTreeGridComponent IgxGridComponent Styles Additional Resources Tree Grid overview Tree Grid Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/multi-column-headers.html": {
    "href": "components/treegrid/multi-column-headers.html",
    "title": "Angular Multi-column Headers - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Multi-column Headers Overview IgxTreeGrid supports multi-column headers which allows you to group columns by placing them under a common multi headers. Each multi-column headers group could be a representation of combinations between other groups or columns within the Material UI grid. Angular Tree Grid Multi-column Headers Overview Example The declaration of Multi-column header could be achieved by wrapping a set of columns into igx-column-group component with header title passed. <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\"> <igx-column-group header=\"Contact Information\"> <igx-column field=\"Phone\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Fax\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"PostalCode\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> </igx-column-group> </igx-tree-grid> For achieving n-th level of nested headers, the declaration above should be followed. So by nesting igx-column-group leads to the desired result. <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [moving]=\"true\"> <igx-column-group [pinned]=\"false\" header=\"General Information\"> <igx-column field=\"HireDate\" dataType=\"date\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column-group header=\"Person Details\"> <igx-column field=\"ID\" dataType=\"number\" [resizable]=\"true\" [filterable]=\"false\"></igx-column> <igx-column field=\"Title\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> </igx-column-group> </igx-column-group> </igx-tree-grid> Every igx-column-group supports moving, pinning and hiding. Note When there is a set of columns and column groups, pinning works only for top level column parents. More specifically pinning per nested column groups or columns is not allowed. Please note that when using Pinning with Multi-Column Headers, the entire Group gets pinned. Moving between columns and column groups is allowed only when they are at the same level in the hierarchy and both are in the same group. When columns/column-groups are not wrapped by current group which means they are top level columns, moving is allowed between whole visible columns. <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [moving]=\"true\"> <igx-column-group header=\"Contact Information\"> <igx-column field=\"Phone\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> </igx-column-group> <igx-column field=\"Name\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Title\" dataType=\"string\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [resizable]=\"true\"></igx-column> </igx-tree-grid> Multi-column Header Template Each of the column groups of the grid can be templated separately. The column group expects ng-template tag decorated with the igxHeader directive. The ng-template is provided with the column group object as a context. ... <igx-column-group header=\"General Information\"> <ng-template igxHeader let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... </igx-column-group> ... If you want to re-use a single template for several column groups, you could set the headerTemplate property of the column group like this: <ng-template #columnGroupHeaderTemplate let-columnGroup> {{ columnGroup.header | uppercase }} </ng-template> ... <igx-column-group header=\"General Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> <igx-column-group header=\"Address Information\" [headerTemplate]=\"columnGroupHeaderTemplate\"> ... </igx-column-group> ... Note If a column header is retemplated and the grid moving is enabled, you have to set the draggable attribute of corresponding column to false on the templated elements, so that you can handle any of the events that are applied! <ng-template igxHeader> <igx-icon [attr.draggable]=\"false\" (click)=\"onClick()\"></igx-icon> </ng-template> The following sample demonstrates how to implement collapsible column groups using header templates. Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $header-background, $header-text-color, $header-border-width, $header-border-style and $header-border-color parameters. $custom-theme: grid-theme( $header-background: #e0f3ff, $header-text-color: #e41c77, $header-border-width: 1px, $header-border-style: solid, $header-border-color: rgba(0, 0, 0, 0.08) ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $light-blue-color: #e0f3ff; $deep-pink-color: #e41c77; $custom-palette: palette($primary: $light-blue-color, $deep-pink-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $header-background: color($custom-palette, \"primary\", 500), $header-text-color: color($custom-palette, \"secondary\", 500), $header-border-width: 1px, $header-border-style: solid, $header-border-color: color($custom-palette, \"grays\", 200) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( header-background: (igx-color:('primary', 500)), header-text-color: (igx-color:('secondary', 500)), header-border-width: 1px, header-border-style: solid, header-border-color: (igx-color:('grays', 200)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations Using Tree Grid with multi-column headers on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. import 'core-js/es7/array'; API References IgxTreeGridComponent IgxTreeGridComponent Styles IgxColumnGroupComponent Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/multi-row-layout.html": {
    "href": "components/treegrid/multi-row-layout.html",
    "title": "Angular Grid Multi-row Layout - Ignite UI for Angular",
    "keywords": "Angular Multi-row Layout Multi-row Layout extends the rendering capabilities of the igxGridComponent. The feature allows splitting a single data record into multiple visible rows. Angular Multi-row Layout Example The declaration of Multi-row Layout is achieved through igx-column-layout component. Each igx-column-layout component should be considered as a block, containing one or multiple igx-column components. Some of the grid features work on block level (those are listed in the \"Feature Integration\" section below). For example the virtualization will use the block to determine the virtual chunks, so for better performance split the columns into more igx-column-layout blocks if the layout allows it. There should be no columns outside of those blocks and no usage of IgxColumnGroupComponent when configuring a multi-row layout. Multi-row Layout is implemented on top of the grid layout specification and should conform to its requirements. IgxColumnComponent exposes four @Input properties to determine the location and span of each cell: colStart - column index from which the field is starting. This property is mandatory. rowStart - row index from which the field is starting. This property is mandatory. colEnd - column index where the current field should end. The amount of columns between colStart and colEnd will determine the amount of spanning columns to that field. This property is optional. If not set defaults to colStart + 1. rowEnd - row index where the current field should end. The amount of rows between rowStart and rowEnd will determine the amount of spanning rows to that field. This property is optional. If not set defaults to rowStart + 1. <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [rowEnd]=\"3\" field=\"ID\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"CompanyName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"2\" field=\"ContactName\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"2\" [colEnd]=\"3\" field=\"ContactTitle\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" [colEnd]=\"3\" field=\"Country\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"3\" [colEnd]=\"5\" field=\"Region\"></igx-column> <igx-column [rowStart]=\"1\" [colStart]=\"5\" [colEnd]=\"7\" field=\"PostalCode\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" [colEnd]=\"4\" field=\"City\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"4\" [colEnd]=\"7\" field=\"Address\"></igx-column> </igx-column-layout> <igx-column-layout> <igx-column [rowStart]=\"1\" [colStart]=\"1\" field=\"Phone\"></igx-column> <igx-column [rowStart]=\"2\" [colStart]=\"1\" field=\"Fax\"></igx-column> </igx-column-layout> The result of the above configuration can be seen on the screenshot below: Note rowStart and colStart properties must be set for each igx-column into igx-column-layout. The igxColumnLayout component is not verifying if the layout is correct and not throwing errors or warnings about that. The developers must make sure that the declaration of their layout is correct and complete, otherwise they may end up in broken layout with misalignments, overlaps and browser inconsistencies. Feature Integration Due to the completly different rendering approach of Multi-row Layout, some of the column features will work only on igx-column-layout component. Such features are Column Pinning and Column Hiding. Othes like - Sorting and Grouping will work in the same way - on igx-column component. Filtering - only Excel Style Filtering is supported. Setting filterMode explicitly to FilterMode.quickFilter has no effect. Paging - works on records, not visual rows. Group By - hideGroupedColumns option has no effect in Multi-row Layout. The grouped columns are always visible. The following features are currently not supported: Column Moving Multi-column Headers Export to Excel Summaries Keyboard Navigation IgxGridComponent with Multi-Row Layouts provides build-in keyboard navigation. Horizontal nagivation Arrow Left or Arrow Right - move to the adjacent cell on the left/right within the current row unaffected by the column layouts that are defined. If the current cell spans on more than one row, Arrow Left and Arrow Right should navigate to the first cell on the left and right with the same rowStart, unless you have navigated to some other adjacent cell before. The navigation stores the starting navigation cell and navigates to the cells with the same rowStart if possible. Ctrl + Arrow Left (HOME) or Ctrl + Arrow Right (END) - navigate to the start or end of the row and select the cell with accordance to the starting navigation cell. Vertical nagivation Arrow Up or Arrow Down - move to the cell above/below in relation to a starting position and is unaffected by the rows. If the current cell spans on more than one column the next active cell will be selected with accordance to the starting navigation cell. Ctrl + Arrow Up or Ctrl + Down - Navigate and apply focus on the same column on the first or on the last row. Ctrl + Home or Ctrl + End - Navigate to the first row and focus first cell or navigate to the last row and focus the last cell. Note Navigation through cells which span on multiple rows or columns is done with accordance to the starting navigation cell and will allow returning to the starting cell using the key for the opposite direction. The same approach is used when navigating through group rows. Note Selection and multi cell selection are working on layout, meaning that when a cell is active, its layout will be selected. Also all features of multiple selection like drag selection are applicable and will work per layout not per cell. Custom Keyboard Navigation The grid allows customizing the default navigation behavior when a certain key is pressed. Actions like going to the next cell or cell below could be handled easily with the powerful keyboard navigation API: gridKeydown is exposed. The event will emit IGridKeydownEventArgs. This event is available only through the keyboard key combinations mentioned above, for all other key actions you can use keydown event (keydown)=\"onKeydown($event)\" navigateTo - this method allows you to navigate to a position based on provided rowindex and visibleColumnIndex The demo below adds additional navigation down/up via the Enter and Shift + Enter keys, similar to the behavior observed in Excel. Demo Layout Configurator Sometimes when configuring a column layout it might be a challenge to calculate and set the proper colStart and colEnd or rowStart and rowEnd. Especially when there are a lot of columns in a single layout. That is why we have created a small configurator, so you can easily do that and have a similar preview of how it would look inside the igxGrid when applied. You can do the following interactions with it: Set number of rows for the whole configuration. All layouts must have the same amount of rows. Add/Remove column layouts by clicking the Add Layout chip or reordering them by dragging a layout chip left/right. Set specific settings for each layout as number of columns and how wide they will be. The setting refer to the currently selected layout. Resize column cells in the layout preview so they can span more columns/rows or clear them using the Delete button. Set columns in the preview by dragging a column chip in the place your will want it to be. Add/Remove new columns by using the Add Column chip. Get template output of the whole configuration ready to by placed inside an igxGrid or the JSON representation that can also be used and parsed in your template using NgForOf for example. By default we have set the same columns as our previous sample, but it can be cleared and configured to match your desired configuration. Styling The igxGrid allows styling through the Ignite UI for Angular Theme Library. The grid's theme exposes a wide variety of properties, which allow the customization of all the features of the grid. In the below steps, we are going through the steps of customizing the grid's Multi-row Layout styling. Importing global theme To begin the customization of the Multi-row Layout feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining custom theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the feature layout as desired. $custom-theme: grid-theme( $cell-active-border-color: #ffcd0f, $cell-selected-background: #6f6f6f, $row-hover-background: #fde069, $row-selected-background: #8d8d8d, $header-background: #494949, $header-text-color: #fff, $sorted-header-icon-color: #ffcd0f, $sortable-header-icon-hover-color: #e9bd0d ); Defining a custom color palette In the approach, that was described above, the color values were hardcoded. Alternatively, you can achieve greater flexibility, using the igx-palette and igx-color functions. igx-palette generates a color palette, based on provided primary and secondary colors. $black-color: #494949; $yellow-color: #FFCD0F; $custom-palette: palette( $primary: $black-color, $secondary: $yellow-color ); After a custom palette has been generated, the igx-color function can be used to obtain different varieties of the primary and the secondary colors. $custom-theme: grid-theme( $cell-active-border-color: color($custom-palette, \"secondary\", 500), $cell-selected-background: color($custom-palette, \"primary\", 300), $row-hover-background: color($custom-palette, \"secondary\", 300), $row-selected-background: color($custom-palette, \"primary\", 100), $header-background: color($custom-palette, \"primary\", 500), $header-text-color:contrast-color($custom-palette, \"primary\", 500), $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"secondary\", 600) ); Defining custom schemas You can go even further and build flexible structure that has all the benefits of a schema. The schema is the recipe of a theme. Extend one of the two predefined schemas, that are provided for every component. In our case, we would use $_light_grid. $custom-grid-schema: extend($_light-grid,( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 300)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('secondary', 600)) )); In order for the custom schema to be applied, either light, or dark globals has to be extended. The whole process is actually supplying a component with a custom schema and adding it to the respective component theme afterwards. $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Applying the custom theme The easiest way to apply your theme is with a sass @include statement in the global styles file: @include grid($custom-theme); Scoped component theme In order for the custom theme do affect only specific component, you can move all of the styles you just defined from the global styles file to the custom component's style file (including the import of the index file). This way, due to Angular's ViewEncapsulation, your styles will be applied only to your custom component. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. Note Wrap the statement inside of a :host selector to prevent your styles from affecting elements outside of our component: :host { ::ng-deep { @include grid($custom-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxTreeGridComponent IgxTreeGridComponent Styles IgxColumnLayoutComponent IgxColumnComponent Additional Resources Tree Grid overview Virtualization and Performance Paging Sorting Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/paging.html": {
    "href": "components/treegrid/paging.html",
    "title": "Angular Grid Paging | Angular Pagination Table | Infragistics",
    "keywords": "Angular Tree Grid Pagination Pagination is used to split a large set of data into a sequence of pages that have similar content. Angular table pagination improves user experience and data interaction. Tree Grid pagination is configurable via a separate component projected in the grid tree by defining a igx-paginator tag, similar to adding of a column. As in any Angular Table, the pagination in the Tree Grid supports template for custom pages. Angular Pagination Example The following example represents Tree Grid pagination and exposes the options usage of items per page and how paging can be enabled. The user can also quickly navigate through the Tree Grid pages via \"Go to last page\" and \"Go to first page\" buttons. Adding a igx-paginator component will control whether the feature is present, you can enable/disable it by using a simple *ngIf with a toggle property. The perPage input controls the visible records per page. Let’s update our Tree Grid to enable paging: <igx-tree-grid #treeGrid [data]=\"data\" [height]=\"'500px'\" [width]=\"'100%'\"> <igx-paginator [perPage]=\"10\"> </igx-paginator> </igx-tree-grid> Example: <igx-paginator #paginator [totalRecords]=\"20\"> <igx-paginator-content> <div id=\"numberPager\" style=\"justify-content: center;\"> <button [disabled]=\"paginator.isFirstPage\" (click)=\"paginator.previousPage()\" igxButton=\"flat\"> PREV </button> <span> Page {{paginator.page}} of {{paginator.totalPages}} </span> <button [disabled]=\"paginator.isLastPage\" (click)=\"paginator.nextPage()\" igxButton=\"flat\"> NEXT </button> </div> </igx-paginator-content> </igx-paginator> Usage The igx-paginator component is used along with the igx-tree-grid component in the example below, but you can use it with any other component in case paging functionality is needed. <igx-tree-grid #treeGrid [data]=\"data\"> <igx-paginator #paginator [(page)]=\"treeGrid.page\" [totalRecords]=\"treeGrid.length\" [(perPage)]=\"10\" [selectOptions]=\"selectOptions\"> </igx-paginator> </igx-tree-grid> Paginator Component Demo Remote Paging Remote paging can be achieved by declaring a service, responsible for data fetching and a component, which will be responsible for the Grid construction and data subscription. For more detailed information, check the Tree Grid Remote Data Operations topic. Pagination Styling in Angular To get started with styling the paginator, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the paginator-theme and accepts the $text-color, $background-color and the $border-color parameters. $dark-paginator: paginator-theme( $text-color: #F4D45C, $background-color: #575757, $border-color: #292826 ); As seen, the paginator-theme only controls colors for the paging container, but does not affect the buttons in the pager UI. To style those buttons, let's create a new button theme: $dark-button: button-theme( $icon-color: #FFCD0F, $icon-hover-color: #292826, $icon-hover-background: #FFCD0F, $icon-focus-color: #292826, $icon-focus-background: #FFCD0F, $disabled-color: #16130C ); In this example we only changed the icon color and background and the button disabled color, but the the button-theme provides way more parameters to control the button style. The last step is to include the component mixins, each with its respective theme: @include grid-paginator($dark-grid-paginator); .igx-grid-paginator__pager { @include button($dark-button); } Note We scope the igx-button mixin within .igx-paginator__pager, so that only the paginator buttons would be styled. Otherwise other buttons in the grid would be affected too. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include paginator($dark-paginator); .igx-paginator__pager { @include button($dark-button); } } } Defining a Color Palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #F9D342; $black-color: #292826; $dark-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the pallette. $dark-paginator: paginator-theme( $palette: $dark-palette, $text-color: color($dark-palette, \"secondary\", 400), $background-color: color($dark-palette, \"primary\", 200), $border-color: color($dark-palette, \"primary\", 500) ); $dark-button: button-theme( $palette: $dark-palette, $icon-color: color($dark-palette, \"secondary\", 700), $icon-hover-color: color($dark-palette, \"primary\", 500), $icon-hover-background: color($dark-palette, \"secondary\", 500), $icon-focus-color: color($dark-palette, \"primary\", 500), $icon-focus-background: color($dark-palette, \"secondary\", 500), $disabled-color: color($dark-palette, \"primary\", 700) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - dark-pagination and dark-button schemas: // Extending the dark paginator schema $dark-paginator-schema: extend($_dark-pagination, ( text-color:( color: (\"secondary\", 400) ), background-color:( color: (\"primary\", 200) ), border-color:( color:( \"primary\", 500) ) ) ); // Extending the dark button schema $dark-button-schema: extend($_dark-button, ( icon-color:( color:(\"secondary\", 700) ), icon-hover-color:( color:(\"primary\", 500) ), icon-hover-background:( color:(\"secondary\", 500) ), icon-focus-color:( color:(\"primary\", 500) ), icon-focus-background:( color:(\"secondary\", 500) ), disabled-color:( color:(\"primary\", 700) ) ) ); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global dark-schema $custom-dark-schema: extend($dark-schema,( igx-paginator: $dark-paginator-schema, igx-button: $dark-button-schema )); // Definingpaginator-theme with the global dark schema $dark-paginator: paginator-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); // Defining button-theme with the global dark schema $dark-button: button-theme( $palette: $dark-palette, $schema: $custom-dark-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxTreeGridComponent API IgxTreeGridComponent Styles IgxGridPaginator Styles Additional Resources Tree Grid overview Paginator Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/remote-data-operations.html": {
    "href": "components/treegrid/remote-data-operations.html",
    "title": "Angular Tree Remote Data Operations - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Remote Data Operations The Ignite UI for Angular Tree Grid supports remote data operations such as remote virtualization, remote sorting, remote filtering and others. This allows the developer to perform these tasks on a server, retrieve the data that is produced and display it in the Tree Grid. Angular Tree Grid Remote Data Operations Overview Example By default, the Tree Grid uses its own logic for performing data operations. You can perform these tasks remotely and feed the resulting data to the Tree Grid by taking advantage of certain inputs and events, which are exposed by the Tree Grid. Remote Filtering To provide remote filtering, you need to subscribe to the filteringExpressionsTreeChange output so that you make the appropriate request based on the arguments received. Let's use a flat collection as a data source for our Tree Grid by providing a primaryKey and a foreignKey. We will also take advantage of the rxjs debounceTime function, which emits a value from the source Observable only after a particular time span has passed without another source emission. This way the remote operation will be triggered only when the specified amount of time has passed without the user interrupting it. const DEBOUNCE_TIME = 300; ... public ngAfterViewInit() { ... this.treeGrid.filteringExpressionsTreeChange.pipe( debounceTime(DEBOUNCE_TIME), takeUntil(this.destroy$) ).subscribe(() => { this.processData(); }); } When remote filtering is provided, usually we do not need the built-in filtering of the Tree Grid. We can disable it by setting the filterStrategy input of the Tree Grid to the NoopFilteringStrategy instance. <!-- tree-grid-remote-filtering-sample.html --> <igx-tree-grid #treeGrid [data]=\"remoteData | async\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" [filterStrategy]=\"noopFilterStrategy\" [allowFiltering]=\"true\"> <igx-column [field]=\"'Name'\" dataType=\"string\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\"></igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\"></igx-column> </igx-tree-grid> // tree-grid-remote-filtering-sample.ts public noopFilterStrategy = NoopFilteringStrategy.instance(); public processData() { this.treeGrid.isLoading = true; const filteringExpr = this.treeGrid.filteringExpressionsTree; this._remoteService.getData(filteringExpr, () => { this.treeGrid.isLoading = false; }); } The remote filtering will have to be performed over the flat collection directly. We will also have to include all the parents for any record that matches the filtering condition regardless of whether or not the parents match the filtering (we do this to keep the hierarchy intact). The result can be seen below: Note When remote data is requested, the filtering operation is case-sensitive. Remote Filtering Demo You can see the result of the code from above at the beginning of this article in the Demo section. Unique Column Values Strategy The list items inside the Excel Style Filtering dialog represent the unique values for the respective column. The Tree Grid generates these values based on its data source by default. In case of remote filtering, the grid data does not contain all the data from the server. In order to provide the unique values manually and load them on demand, we can take advantage of the Tree Grid's uniqueColumnValuesStrategy input. This input is actually a method that provides three arguments: column - The respective column instance. filteringExpressionsTree - The filtering expressions tree, which is reduced based on the respective column. done - Callback that should be called with the newly generated column values when they are retrieved from the server. The developer can manually generate the necessary unique column values based on the information, that is provided by the column and the filteringExpressionsTree arguments and then invoke the done callback. Note When the uniqueColumnValuesStrategy input is provided, the default unique values generating process in the excel style filtering will not be used. <igx-tree-grid #treeGrid [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... </igx-tree-grid> public columnValuesStrategy = (column: ColumnType, columnExprTree: IFilteringExpressionsTree, done: (uniqueValues: any[]) => void) => { // Get specific column data. this.remoteValuesService.getColumnData(column, columnExprTree, uniqueValues => done(uniqueValues)); } Unique Column Values Strategy Demo In order to provide a custom loading template for the excel style filtering, we can use the igxExcelStyleLoading directive: <igx-tree-grid [data]=\"data\" [filterMode]=\"'excelStyleFilter'\" [uniqueColumnValuesStrategy]=\"columnValuesStrategy\"> ... <ng-template igxExcelStyleLoading> Loading ... </ng-template> </igx-tree-grid> Remote Paging In this sample we will demonstrate how to display a certain number of root records per page no matter how many child records they have. In order to cancel the built-in Tree Grid paging algorithm, which displays a certain number of records no matter their level (root or child), we have to set the perPage property to Number.MAX_SAFE_INTEGER. <igx-tree-grid #treeGrid ...> <igx-paginator [perPage]=\"maxPerPage\"> </igx-paginator> ... public maxPerPage = Number.MAX_SAFE_INTEGER; Now we can choose between setting-up our own custom paging template or using the default one that the igx-paginator provides. Let's first take a look what is necessary to set-up remote paging by using the default paging template. Remote paging with default template If you want to use the default paging template you need to set the Paginator's totalRecords property, only then the grid will be able to calculate the total page number based on total remote records. When performing a remote pagination the Paginator will pass to the Grid only the data for the current page, so the grid will not try to paginate the provided data source. That's why we should set Grid's pagingMode property to GridPagingMode.remote. Also it is necessary to either subscribe to pagingDone or perPageChange events in order to fetch the data from your remote service, it depends on the use case which event will be used. <igx-tree-grid #treeGrid [data]=\"data | async\" childDataKey=\"Content\" [pagingMode]=\"mode\"> <igx-column field=\"Name\"></igx-column> ... <igx-paginator [(page)]=\"page\" [(perPage)]=\"perPage\" [totalRecords]=\"totalCount\" (pagingDone)=\"paginate($event.current)\"> </igx-paginator> </igx-tree-grid> public totalCount = 0; public data: Observable<any[]>; public mode = GridPagingMode.remote; public isLoading = true; @ViewChild('grid1', { static: true }) public grid1: IgxGridComponent; private _dataLengthSubscriber; public set perPage(val: number) { this._perPage = val; this.paginate(0); } public ngOnInit() { this.data = this.remoteService.remoteData.asObservable(); this._dataLengthSubscriber = this.remoteService.getDataLength().subscribe((data: any) => { this.totalCount = data; this.grid1.isLoading = false; }); } public ngAfterViewInit() { const skip = this.page * this.perPage; this.remoteService.getData(skip, this.perPage); } public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } Remote Paging with custom igx-paginator-content When we define a custom paginator content we need to define the content in a way to get the data only for the requested page and to pass the correct skip and top parameters to the remote service according to the selected page and items perPage. We are going to use the <igx-paginator> in order to ease our example configuration, along with the IgxPageSizeSelectorComponent and IgxPageNavigationComponent that were introduced - igx-page-size will add the per page dropdown and label and igx-page-nav will add the navigation action buttons and labels. <igx-paginator #paginator [totalRecords]=\"totalCount\" [(perPage)]=\"perPage\" [selectOptions]=\"selectOptions\" (pageChange)=\"paginate($event)\"> <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> </igx-paginator> public paginate(page: number) { this.page = page; const skip = this.page * this.perPage; const top = this.perPage; this.remoteService.getData(skip, top); } Note In order the Remote Paging to be configured properly a GridPagingMode.Remote should be set: <igx-tree-grid #treeGrid [data]=\"data | async\" childDataKey=\"Content\" expansionDepth=\"0\" width=\"100%\" height=\"540px\" [pagingMode]=\"mode\"></igx-tree-grid> ... public mode = GridPagingMode.Remote; The last step will be to declare the paginator content based on your requirements. <igx-paginator-content> <igx-page-size></igx-page-size> [This is my custom content] <igx-page-nav></igx-page-nav> </igx-paginator-content> After all the changes above, the following result will be achieved. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. API References IgxPaginatorComponent API IgxTreeGridComponent API IgxTreeGridComponent Styles Additional Resources Paging Tree Grid overview Virtualization and Performance Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/row-actions.html": {
    "href": "components/treegrid/row-actions.html",
    "title": "Row actions in Angular Data Grid - Ignite UI for Angular",
    "keywords": "Row Actions in Angular Tree Grid The tree grid component in Ignite UI for Angular provides the ability to use ActionStrip and utilize CRUD for row/cell components and row pinning. The Action Strip component can host predefined UI controls for these operations. Usage The first step is to import the IgxActionStripModule in our app.module.ts file: // app.module.ts ... import { IgxActionStripModule } from 'igniteui-angular'; // import { IgxActionStripModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxActionStripModule], ... }) The predefined actions UI components are: IgxGridEditingActionsComponent - includes functionality and UI specifically designed for the grid editing. It allows you to quickly toggle edit mode for cells or rows, depending on the rowEditable option and row deletion of the grid. IgxGridPinningActionsComponent - includes functionality and UI specifically designed for the grid row pinning. It allows you to quickly pin rows and navigate between pinned rows and their disabled counterparts. They are added inside the <igx-action-strip> and this is all needed to have an Action Strip providing default interactions. <igx-tree-grid [data]=\"data\" [rowEditable]=\"true\" [primaryKey]=\"'ID'\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-tree-grid> Note When IgxActionStripComponent is a child component of the grid, hovering a row will automatically show the UI. Custom implementation These components expose templates giving flexibility for customization. For instance, if we would like to use the ActionStrip for a Gmail scenario with row actions such as delete, edit and etc. You can simply create button component with igx-icon, add click event to it and insert it into the igx-action-strip component. <igx-grid> <igx-action-strip #actionstrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <button title=\"Edit\" igxIconButton=\"flat\" igxRipple (click)='startEdit(actionstrip.context)'> <igx-icon>edit</igx-icon> </button> <button title=\"Delete\" igxIconButton=\"flat\" igxRipple *ngIf='!isDeleted(actionstrip.context)' (click)='actionstrip.context.delete()'> <igx-icon>delete</igx-icon> </button> </igx-action-strip> </igx-grid> Note The predefined actions inherit IgxGridActionsBaseDirective and when creating a custom grid action component, it should also inherit IgxGridActionsBaseDirective. API References For more detailed information regarding the Action Strip API, refer to the following links: IgxActionStripComponent API Additional components and/or directives that can be used within the Action Strip: IgxGridActionsBaseDirective IgxGridPinningActionsComponent IgxGridEditingActionsComponent IgxDividerDirective View page on GitHub"
  },
  "components/treegrid/row-adding.html": {
    "href": "components/treegrid/row-adding.html",
    "title": "Adding Rows in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Adding Rows in Angular Tree Grid The Tree Grid provides a convenient way to perform data manipulations through inline row adding and a powerful API for Angular CRUD operations. Add an Action Strip component with editing actions enabled in the grid's template, hover a row and use the provided button, press ALT + + to spawn the row adding UI or ALT + SHIFT + + to spawn the UI for adding a child for the selected row. Angular Tree Grid Row Adding Example The following sample demonstrates how to enable native row adding in the Tree Grid. Changing a cell value and then clicking or navigating to another cell on the same row doesn't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Row Adding Usage To get started import the IgxTreeGridModule in the app.module.ts file: // app.module.ts ... import { IgxTreeGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxTreeGridModule], ... }) export class AppModule {} Then define a Tree Grid with bound data source and rowEditable set to true and an Action Strip component with editing actions enabled. The addRow input controls the visibility of the button that spawns the row adding UI. <igx-tree-grid igxPreventDocumentScroll [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [rowEditable]=\"true\"> <igx-column [field]=\"'Name'\" dataType=\"string\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\"></igx-column> <igx-column [field]=\"'HireDate'\" dataType=\"date\"></igx-column> <igx-column [field]=\"'OnPTO'\" dataType=\"boolean\" width=\"130px\"> <ng-template igxCell let-cell=\"cell\" let-val> <igx-icon [color]=\"cell.row.data.OnPTO? 'red': 'green'\">account_circle</igx-icon> </ng-template> </igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\"></igx-column> <igx-action-strip #actionstrip> <igx-grid-editing-actions [addRow]=\"true\" [addChild]=\"actionstrip.context?.treeRow.level < 2\"> </igx-grid-editing-actions> </igx-action-strip> </igx-tree-grid> Note Setting primary key is mandatory for row adding operations. Note Every column excluding the primary key one is editable in the row adding UI by default. If you want to disable editing for a specific column, then you have to set the editable column's input to false. Note The IgxGridEditingActions inputs controlling the visibility of the add row and add child buttons may use the action strip context (which is of type RowType) to fine tune which records the buttons show for. The internal IgxBaseTransactionService is automatically provided for Tree Grid. It holds pending cell changes until the row state is submitted or cancelled. Start Row Adding Programmatically Tree Grid allows to programmatically spawn the add row UI by using two different public methods. One that accepts a row ID for specifying the row under which the UI should spawn and another that works by index. You can use these methods to spawn the UI anywhere within the current data view. Changing the page or specifying a row that is e.g. filtered out is not supported. Using beginAddRowById requires you to specify the row to use as context for the operation by its rowID (PK). The method then functions as though the end-user clicked on the add row action strip button for the specified row, spawning the UI under it. The second parameter controls if the row is added as a child to the context row or as a sibling. You can also make the UI spawn as the very first row in the grid by passing null for the first parameter. this.treeGrid.beginAddRowById('ALFKI', true); // spawns the add row UI to add a child for the row with PK 'ALFKI' this.treeGrid.beginAddRowById(null); // spawns the add row UI as the first record The beginAddRowByIndex method works similarly but the row to use as context is specified by index. this.treeGrid.beginAddRowByIndex(10, true); // spawns the add row UI to add a child for the row at index 10 this.treeGrid.beginAddRowByIndex(null); // spawns the add row UI as the first record Positioning The Default position row add UI is below the row that the end user clicked the add row button for. The Tree Grid scrolls to fully display the add row UI automatically. The overlay for the add row UI maintains its position during scrolling. Behavior The add row UI has the same behavior as the row editing one as they are designed to provide a consistent editing experience to end users. Please, refer to the Tree Grid Row Editing topic for more information. After a new row is added through the row adding UI, its position and/or visibility is determined by the sorting, filtering and grouping state of the Tree Grid. In a Tree Grid that does not have any of these states applied, it appears as the last record. A snackbar is briefly displayed containing a button the end user may use to scroll the Tree Grid to its position if it is not in view. Keyboard Navigation ALT + + - Enters edit mode for adding a row ALT + SHIFT + + - Enters edit mode for adding a child ESC exits row adding mode without submitting any changes TAB move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any row adding operation will stop if the data view of the Tree Grid gets modified. Any changes made by the end user are submitted. Operations that change the data view include but are not limited to sorting, grouping, filtering, paging, etc. Summaries are updated after the row add operation finishes. The same is valid for the other data view dependant features such as sorting, filtering, etc. Customizing Row Adding Overlay Customizing Text Customizing the text of the row adding overlay is possible using the igxRowAddTextDirective. <ng-template igxRowAddText> Adding Row </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Note Using igxRowEditActions directive will change edit actions for both editing and adding overlay buttons. Remote scenarios In most remote data scenarios the Primary Key assignment happens on the create server request. In this case the added records on the client will not have the final primary key value until saved on the server's data base. In that case the recommended way to handle this update in the Tree Grid is as follows: If the Tree Grid does not use transactions. Once the create request is successfully completed and returns the added record data, you can replace that record's id in the local data record instance. If the Tree Grid uses transactions. Once the create request or batch update request is successfully completed and returns the added record instances (with their db generated ids), the related ADD transactions should be cleared from the transaction log using the clear API method. This is necessary because the local transaction will have a generated id field, which may differ than the one created in the data base, so they should be cleared. You can then add the record(s) passed in the response to the local data instance. This will ensure that the remotely generated ids are always reflected in the local data, and subsequent update/delete operations target the correct record ids. Styling The row adding UI comprises the buttons in the IgxActionStrip editing actions, the editing editors and overlay, as well as the snackbar which allows end users to scroll to the newly added row. To style these components you may refer to these comprehensive guides in their respective topics: Tree Grid Row Editing IgxSnackbar IgxActionStrip API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit primaryKey IgxTreeGridComponent IgxActionStripComponent IgxGridEditingActionsComponent Additional Resources Tree Grid Overview Tree Grid Editing Tree Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/row-drag.html": {
    "href": "components/treegrid/row-drag.html",
    "title": "Row Dragging in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Row Dragging in Angular Tree Grid In Ignite UI for Angular Tree Grid, RowDrag is initialized on the root igx-tree-grid component and is configurable via the rowDraggable input. Enabling row dragging provides users with a row drag-handle with which they can initiate dragging of a row. Angular Tree Grid Row Drag Example Configuration In order to enable row-dragging for your igx-tree-grid, all you need to do is set the grid's rowDraggable to true. Once this is enabled, a row-drag handle will be displayed on each row. This handle can be used to initiate row dragging. <igx-tree-grid [rowDraggable]=\"true\"> ... </igx-tree-grid> Clicking on the drag-handle and moving the cursor while holding down the button will cause the grid's rowDragStart event to fire. Releasing the click at any time will cause rowDragEnd event to fire. Below, you can find a walkthrough on how to configure an igx-tree-grid to support row dragging and how to properly handle the drop event. In this example, we'll handle dragging a row from a grid to a designated area and, when dropping it, removing it from the grid. Drop Areas Enabling row-dragging was pretty easy, but now we have to configure how we'll handle row-dropping. We can define where we want our rows to be dropped using the igxDrop directive. First we need to import the IgxDragDropModule in our app module: import { ..., IgxDragDropModule } from 'igniteui-angular'; // import { ..., IgxDragDropModule } from '@infragistics/igniteui-angular'; for licensed package ... @NgModule({ imports: [..., IgxDragDropModule] }) Then, in our template, we define a drop-area using the directive's selector: <div class=\"drop-area\" igxDrop (enter)=\"onEnterAllowed($event)\" (leave)=\"onLeaveAllowed($event)\" (dropped)=\"onDropAllowed($event)\"> <igx-icon>delete</igx-icon> <div>Drag a row here to delete it</div> </div> You may enable animation when a row is dropped on a non-droppable area using the animation parameter of the rowDragEnd event. If set to true, the dragged row will animate back to its' original position when dropped over a non-droppable area. You may enable animation like this: export class IgxTreeGridRowDragComponent { public onRowDragEnd(args) { args.animation = true; } } Drop Area Event Handlers Once we've defined our drop-area in the template, we have to declare our handlers for the igxDrop's enter, leave and dropped events in our component's .ts file. First, let's take a look at our enter and leave handlers. In those methods, we just want to change the icon of the drag's ghost so we can indicate to the user that they are above an area that allows them to drop the row: export class IgxTreeGridRowDragComponent { public onEnterAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.ALLOW); } public onLeaveAllowed(args) { this.changeGhostIcon(args.drag.ghostElement, DragIcon.DEFAULT); } private changeGhostIcon(ghost, icon: string) { if (ghost) { const currentIcon = ghost.querySelector('.igx-grid__drag-indicator > igx-icon'); if (currentIcon) { currentIcon.innerText = icon; } } } } The changeGhostIcon private method just changes the icon inside of the drag ghost. The logic in the method finds the element that contains the icon (using the igx-grid__drag-indicator class that is applied to the drag-indicator container), changing the element's inner text to the passed one. The icons themselves are from the material font set and are defined in a separate enum: enum DragIcon { DEFAULT = 'drag_indicator', ALLOW = 'remove' } Next, we have to define what should happen when the user actually drops the row inside of the drop-area. export class IgxTreeGridRowDragComponent { public onDropAllowed(args: IDropDroppedEventArgs) { const draggedRow: RowType = args.dragData; draggedRow.delete(); } } Once the row is dropped, we just call the row's delete() method Note When using row data from the event arguments (args.dragData.data) or any other row property, note that the entire row is passed in the arguments as a reference, which means that you must clone the data you need, if you want to distinguish it from the one in the source grid. Templating the drag ghost The drag ghost can be templated using the IgxRowDragGhost directive, applied to a <ng-template> inside of the igx-tree-grid's body: <igx-tree-grid> ... <ng-template igxRowDragGhost> <div> <igx-icon fontSet=\"material\">arrow_right_alt</igx-icon> </div> </ng-template> ... </igx-tree-grid> The result of the configuration can be seem below in a igx-tree-grid with row dragging and multiple selection enabled. The demo shows the count of the currently dragged rows: Example Demo Templating the drag icon The drag handle icon can be templated using the grid's dragIndicatorIconTemplate. In the example we're building, let's change the icon from the default one (drag_indicator) to drag_handle. To do so, we can use the igxDragIndicatorIcon to pass a template inside of the igx-tree-grid's body: <igx-tree-grid> ... <ng-template igxDragIndicatorIcon> <igx-icon>drag_handle</igx-icon> </ng-template> ... </igx-tree-grid> Once we've set the new icon template, we also need to adjust the DEFAULT icon in our DragIcon enum, so it's properly change by the changeIcon method: enum DragIcon { DEFAULT = \"drag_handle\", ... } Styling the drop area Once our drop handlers are properly configured, all that's left is to style our drop area a bit: .drop-area { width: 160px; height: 160px; background-color: #d3d3d3; border: 1px dashed #131313; display: flex; justify-content: center; align-items: center; flex-flow: column; text-align: center; margin: 8px; } :host { display: flex; justify-content: center; align-items: center; flex-flow: column; width: 100%; } The result can be seen in the demo below: Example Demo Application Demo Row Reordering Demo With the help of the grid's row drag events and the igxDrop directive, you can create a grid that allows you to reorder rows by dragging them. Since all of the actions will be happening inside of the grid's body, that's where you have to attach the igxDrop directive: <igx-tree-grid igxPreventDocumentScroll #treeGrid [data]=\"localData\" [rowDraggable]=\"true\" foreignKey=\"ParentID\" [primaryKey]=\"'ID'\" (rowDragStart)=\"rowDragStart($event)\" igxDrop (dropped)=\"dropInGrid($event)\"> ... </igx-tree-grid> Note Make sure that there is a primaryKey specified for the grid! The logic needs an unique identifier for the rows so they can be properly reordered Once rowDraggable is enabled and a drop zone has been defined, you need to implement a simple handler for the drop event. When a row is dragged, check the following: Is the row expanded? If so, collapse it. Was the row dropped inside of the grid? If so, on which other row was the dragged row dropped? Once you've found the target row, swap the records' places in the data array Was the row initially selected? If so, mark it as selected. Below, you can see this implemented in the component's .ts file: export class TreeGridRowReorderComponent { public rowDragStart(args: any): void { const targetRow = args.dragData; if (targetRow.expanded) { this.treeGrid.collapseRow(targetrow.key); } } public dropInGrid(args: IDropDroppedEventArgs): void { const draggedRow = args.dragData; const event = args.originalEvent; const cursorPosition: Point = { x: event.clientX, y: event.clientY }; this.moveRow(draggedRow, cursorPosition); } private moveRow(draggedRow: RowType, cursorPosition: Point): void { const row = this.catchCursorPosOnElem(this.treeGrid.rowList.toArray(), cursorPosition); if (!row) { return; } if (row.data.ParentID === -1) { this.performDrop(draggedRow, row).ParentID = -1; } else { if (row.data.ParentID === draggedrow.data.ParentID) { this.performDrop(draggedRow, row); } else { const rowIndex = this.getRowIndex(draggedrow.data); this.localData[rowIndex].ParentID = row.data.ParentID; } } if (draggedRow.selected) { this.treeGrid.selectRows([this.treeGrid.rowList.toArray() .find((r) => r.rowID === draggedrow.key).rowID], false); } this.localData = [...this.localData]; } private performDrop( draggedRow: IgxTreeGridRowComponent, targetRow: IgxTreeGridRowComponent) { const draggedRowIndex = this.getRowIndex(draggedrow.data); const targetRowIndex: number = this.getRowIndex(targetrow.data); if (draggedRowIndex === -1 || targetRowIndex === -1) { return; } this.localData.splice(draggedRowIndex, 1); this.localData.splice(targetRowIndex, 0, draggedrow.data); return this.localData[targetRowIndex]; } private getRowIndex(rowData: any): number { return this.localData.indexOf(rowData); } private catchCursorPosOnElem(rowListArr: IgxTreeGridRowComponent[], cursorPosition: Point) : IgxTreeGridRowComponent { for (const row of rowListArr) { const rowRect = row.nativeElement.getBoundingClientRect(); if (cursorPosition.y > rowRect.top + window.scrollY && cursorPosition.y < rowRect.bottom + window.scrollY && cursorPosition.x > rowRect.left + window.scrollX && cursorPosition.x < rowRect.right + window.scrollX) { return row; } } return null; } } With these few easy steps, you've configured a grid that allows reordering rows via drag/drop! You can see the above code in action in the following demo. Notice that we also have row selection enabled and we preserve the selection when dropping the dragged row. Limitations Currently, there are no known limitations for the rowDraggable directive. API References rowDraggable rowDragStart rowDragEnd IgxTreeGridComponent Additional Resources Tree Grid Overview Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/row-editing.html": {
    "href": "components/treegrid/row-editing.html",
    "title": "Editing Rows in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Row Editing The Tree Grid provides a convenient way to perform data manipulations through inline editing and a powerful API for Angular CRUD operations. Click on a row and press Enter key or simply double click with the mouse on the row that needs to be modified. Angular Tree Grid Row Editing Example The following sample demonstrates how to enable row editing in the Tree Grid. Changing a cell value and then clicking or navigating to another cell on the same row won't update the row value until confirmed by using the Done button, or discarded by using Cancel button. Note When a row is in edit mode, then clicking on a cell on another row will act like the Done button is pressed - submit all the changes of the previous row. If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. Row Editing Usage To get started import the IgxTreeGridModule in the app.module.ts file: // app.module.ts ... import { IgxTreeGridModule } from 'igniteui-angular'; @NgModule({ ... imports: [..., IgxTreeGridModule], ... }) export class AppModule {} Then define a Tree Grid with bound data source and rowEditable set to true: <igx-tree-grid [data]=\"data\" [primaryKey]=\"EmployeID\" [foreignKey]=\"PID\" [rowEditable]=\"true\" [rowSelection]=\"'multiple'\" [moving]=\"true\"> <igx-column *ngFor=\"let c of columns\" [editable] =\"c.editable\" [field]=\"c.field\" [dataType]=\"c.dataType\" [header]=\"c.label\" [resizable]=\"c.resizable\" [sortable]=\"c.sortable\" [filterable]=\"c.filterable\"> </igx-column> </igx-tree-grid> Note Setting primary key is mandatory for row editing operations. Note It's not needed to enable editing for individual columns. Using the rowEditable property in the Tree Grid, will mean that all rows, with defined field property, excluding primary one, will be editable. If you want to disable editing for specific column, then you set the editable column's input to false. import { Component, OnInit, ViewChild } from '@angular/core'; import { IgxTreeGridComponent } from 'igniteui-angular'; // import { IgxTreeGridComponent } from '@infragistics/igniteui-angular'; for licensed package import { FLAT_DATA } from './data'; @Component({ providers: [], selector: 'app-tree-grid-row-editing-sample', styleUrls: ['tree-grid-row-editing-sample.component.scss'], templateUrl: 'tree-grid-row-editing-sample.component.html' }) export class TreeGridRowEditSampleComponent implements OnInit { public data: any[]; public columns: any[]; @ViewChild('treeGrid') public treeGrid: IgxTreeGridComponent; public ngOnInit(): void { this.data = FLAT_DATA; this.columns = [ { field: 'FirstName', label: 'First Name', resizable: true, sortable: true, filterable: true, editable: true, dataType: 'string' }, { field: 'LastName', label: 'Last Name', resizable: false, sortable: false, filterable: false, editable: true, dataType: 'string' }, { field: 'Title', label: 'Title', resizable: true, sortable: true, filterable: true, editable: true, dataType: 'string' }, { field: 'HireDate', label: 'Hire Date', resizable: true, sortable: true, filterable: true, editable: true, dataType: 'date' } ]; } } Note The Tree Grid uses internally a provider IgxBaseTransactionService that holds pending cell changes, until row state submitted or cancelled. Positioning Default position of the overlay will be below the row that is in edit mode If there is no space below the row then overlay will appear above the row. Once shown - top or bottom, overlay will maintain this position during scrolling, until the overlay is closed. Behavior If row is in edit mode, then editing will continue, if a cell from the same row is clicked. Clicking \"Done\" button will finish row editing and will submit changes either to the data source, or to a transaction if available. In addition row will exit edit mode. Clicking \"Cancel\" button will revert all current changes in the row and row will exit edit mode. If row is in edit mode, then clicking a cell from another row will finish the current row edit and will submit new row changes (the same behavior clicking \"Done\" button). If the new cell that gets focus is editable, then the new row also enters edit mode, while if the cell is not editable, then only the previous row exits edit mode. If row is in edit mode and Tree Grid is scrolled so that row goes outside the visible area, the latter will be still in edit mode. When Tree Grid is scrolled, so that the row is visible again, the row will be still in edit mode. When clicked outside the Tree Grid, the cell will also stay in edit mode. When perform sorting, filtering, searching and hiding operations, will revert all current changes in the row and row will exit edit mode. When perform paging, resizing, pinning and moving operations, will exit edit mode and will submit latest value. Each modified cell gets edited style until row edit is finished. This is the behavior, when Tree Grid is not provided with transactions. When transactions are available - then cell edit style is applied until all the changes are committed. Keyboard Navigation Enter and F2 enters row edit mode Esc exits row edit mode and doesn't submit any of the cell changes, made while the row was in edit mode. Tab move focus from one editable cell in the row to the next and from the right-most editable cell to the CANCEL and DONE buttons. Navigation from DONE button goes to the left-most editable cell within the currently edited row. Feature Integration Any data changing operation will terminate row editing operations and will submit current row changes. This will include operations like sorting, changing grouping and filtering criteria, paging, etc. Summaries will be updated after row edit is finished. Same is valid for the other features like sorting, filtering, etc. Customizing Row Editing Overlay Customizing Text Customizing the text of the row editing overlay is possible using the igxRowEditTextDirective. The rowChangesCount property is exposed and it holds the count of the changed cells. <ng-template igxRowEditText let-rowChangesCount> Changes: {{rowChangesCount}} </ng-template> Customizing Buttons Customizing the buttons of the row editing overlay is possible using the igxRowEditActionsDirective. If you want the buttons to be part of the keyboard navigation, then each on of them should have the igxRowEditTabStopDirective. <ng-template igxRowEditActions let-endRowEdit> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(false)\">Cancel</button> <button igxButton igxRowEditTabStop (click)=\"endRowEdit(true)\">Apply</button> </ng-template> Styling Using the Ignite UI for Angular Theme Library, we can greatly alter the Row Editing overlay. The Row Editing overlay is a composite element - its UI is comprised of a couple of other components: - igx-banner in order to render its contents - igx-buttons are rendered in the default template (for the Done and Cancel buttons). In the below example, we will make use of those two components' styling options, ([button styling](../button.md#Angular Button Styling) & banner-styling), to customize the experience of our IgxTreeGrid's Row Editing. We will also style the current cell's editor and background to make it more distinct. You can learn more about cell styling here. Import theme The easiest way to style the Row Editing banner is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Once we've imported the themes file, we can create custom themes. Define the theme We can now define a custom banner theme that will affect our Row Editing background and make use of one of the predefined palettes namely $purple-palette : $my-light-gray: #e3e3e3; $my-banner-palette: $purple-palette; $banner-theme: banner-theme( $banner-background: $my-light-gray, $banner-message-color: color($my-banner-palette, \"secondary\", 600) ); Here we are using my-banner-palette in conjunction with igx-color (exposed by the theme library) for generating our colors. Include the theme All we have to do now is apply the theme with a Sass @include statement. We pass our newly defined $banner-theme through the igx-banner mixin: @include banner($banner-theme); This will apply our custom banner theme to the Row Editing overlay. However, since we defined these in the global styles file, these styles will also apply to all banners in our application. Component styles Since the Row Editing overlay makes use of a lot of other components' themes, styling it via the global styles can affect other parts of our application (e.g. banners, buttons, etc.). The best way to prevent that is to scope our banner theme. We can define our styles (including the theme/index import) in the component containing our igx-tree-grid. Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep in order to style the grid. We wrap the statement inside of a :host selector to prevent our styles from affecting elements outside of our component: // custom.component.scss :host { ::ng-deep { @include banner($banner-theme); } } With the above syntax, our custom banner theme properly applies to the grid's Row Editing overlay. Custom Templates To further customize our Row Editing overlay, we can pass a custom template so we can style the Done and Cancel buttons separately: <!-- in component.html --> <igx-tree-grid> <ng-template igxRowEditActions let-endRowEdit> <div class=\"custom-buttons\"> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(false)\"> <igx-icon>clear</igx-icon> </button> <button igxIconButton=\"flat\" class=\"custom-button\" igxRowEditTabStop (click)=\"endRowEdit(true)\"> <igx-icon>check</igx-icon> </button> </div> </ng-template> </igx-tree-grid> After we've defined our custom buttons, we can make use of the button-theme to style them. You can learn more about igx-button styling here. We can create a custom theme for our Done and Cancel: // custom.component.scss ... $button-theme: button-theme( $palette: $purple-palette ); ... .custom-buttons { @include button($button-theme); } We scope our @include statement in .custom-buttons so that it is only applied to the Doneand Cancel buttons. Demo After styling the banner and buttons, we also define a custom style for the cell in edit mode. The result of all the combined styles can be seen below: Note The sample will not be affected by the selected global theme from Change Theme. Known Issues and Limitations When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References rowEditable onRowEditEnter onRowEdit rowEditDone onRowEditCancel endEdit field editable primaryKey IgxTreeGridComponent Additional Resources Build CRUD operations with igxGrid Tree Grid Overview Tree Grid Editing Tree Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/row-pinning.html": {
    "href": "components/treegrid/row-pinning.html",
    "title": "Row Pinning in Angular Tree Grid - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Row Pinning One or multiple rows can be pinned to the top or bottom of the Angular UI Grid. Row Pinning in Ignite UI for Angular allows end-users to pin rows in a particular order, duplicating them in a special area that is always visible even when they scroll the Tree Grid vertically. The Material UI Grid has a built-in row pinning UI, which is enabled by initializing an igxActionStrip component in the context of Tree Grid. In addition, you can define custom UI and change the pin state of the rows via the Row Pinning API. Angular Tree Grid Row Pinning Example Row Pinning UI The built-in row pinning UI is enabled by adding an igxActionStrip component with the GridPinningActions component. The action strip is automatically shown when hovering a row and will display a pin or unpin button icon based on the state of the row it is shown for. An additional action allowing to scroll the copy of the pinned row into view is shown for each pinned row as well. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"false\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> <igx-action-strip #actionStrip> <igx-grid-pinning-actions></igx-grid-pinning-actions> <igx-grid-editing-actions></igx-grid-editing-actions> </igx-action-strip> </igx-tree-grid> Row Pinning API Row pinning is controlled through the pinned input of the row. Pinned rows are rendered at the top of the Tree Grid by default and stay fixed through vertical scrolling of the unpinned rows in the Tree Grid body. this.treeGrid.getRowByIndex(0).pinned = true; You may also use the Tree Grid's pinRow or unpinRow methods of the IgxTreeGridComponent to pin or unpin records by their ID: this.treeGrid.pinRow('ALFKI'); this.treeGrid.unpinRow('ALFKI'); Note that the row ID is the primary key value, defined by the primaryKey of the grid, or the record instance itself. Both methods return a boolean value indicating whether their respective operation is successful or not. Usually the reason they fail is that the row is already in the desired state. A row is pinned below the last pinned row. Changing the order of the pinned rows can be done by subscribing to the rowPinning event and changing the insertAtIndex property of the event arguments to the desired position index. <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\" (rowPinning)=\"rowPinning($event)\"> </igx-tree-grid> public rowPinning(event) { event.insertAtIndex = 0; } Pinning Position You can change the row pinning position via the pinning configuration option. It allows you to set the pin area position to either Top or Bottom. When set to Bottom pinned rows are rendered at the bottom of the grid, after the unpinned rows. Unpinned rows can be scrolled vertically, while the pinned rows remain fixed at the bottom. <igx-tree-grid [data]=\"data\" [autoGenerate]=\"true\" [pinning]=\"pinningConfig\"></igx-tree-grid> public pinningConfig: IPinningConfig = { rows: RowPinningPosition.Bottom }; Custom Row Pinning UI You can define your custom UI and change the pin state of the rows via the related API. Via extra column with icon Let's say that instead of an action strip you would like to show a pin icon in every row allowing the end-user to click and change a particular row's pin state. This can be done by adding an extra column with a cell template containing the custom icon. <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\"> <igx-column width=\"70px\"> <ng-template igxCell let-cell=\"cell\" let-val> <igx-icon class=\"pin-icon\" (mousedown)=\"togglePinning(cell.row, $event)\"> {{cell.row.pinned ? 'lock' : 'lock_open'}} </igx-icon> </ng-template> </igx-column> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [header]=\"c.field\"> </igx-column> </igx-tree-grid> On click of the custom icon the pin state of the related row can be changed using the row's API methods. public togglePinning(row: IgxGridRow, event) { event.preventDefault(); if (row.pinned) { row.unpin(); } else { row.pin(); } } Demo Row Pinning Limitations Only records that exist in the data source can be pinned. The row pinning state is not exported to excel. The grid is exported as if no row pinning is applied. Because of how pinned rows are stored internally so that they may appear both in the pinned and unpinned areas of the grid, row pinning is not supported when records in the grid are fetched from a remote endpoint on demand (remote virtualization). The copies of pinned rows in the scrollable area of the grid are an integral part of how other grid features achieve their functionality in the presence of pinned rows and therefore their creation cannot be disabled nor can they be removed. As Row Selection works entirely with row Ids, selecting pinned rows selects their copies as well (and vise versa). Additionally, range selection (e.g. using Shift + click) within the pinned area works the same way as selecting a range of rows within the scrollable area. The resulting selection includes all rows in between even if they are not currently pinned. Getting the selected rows through the API only returns a single instance of each selected record. When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning Styling The IgxTreeGrid allows styling through the Ignite UI for Angular Theme Library. The Tree Grid's theme exposes a wide variety of properties, which allow the customization of all the features of the Tree Grid. Below, we are going through the steps of customizing the Tree Grid's row pinning styling. Importing the Styling Library To begin the customization of the row pinning feature, you need to import the index file, where all styling functions and mixins are located. @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Defining a Theme Next, create a new theme, that extends the grid-theme and accepts the parameters, required to customize the row pinning feature as desired. $custom-grid-theme: grid-theme( /* Pinning properties that affect styling */ $pinned-border-width: 5px, $pinned-border-style: double, $pinned-border-color: #FFCD0F, $cell-active-border-color: #FFCD0F /* add other features properties here... */ ); Using CSS variables The last step is to pass the custom grid theme: @include css-vars($custom-grid-theme); Using mixins In order to style components for Internet Explorer 11, you have to use different approach, since it doesn't support CSS variables. If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep. However, in order to prevent the custom theme to leak to other components, be sure to include the :host selector before ::ng-deep: :host { ::ng-deep { // Pass the custom grid theme to the `igx-grid` mixin @include grid($custom-grid-theme); } } Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxTreeGridComponent IgxGridRow IgxTreeGridRow IgxHierarchicalGridRow RowType IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Sorting Summaries Column Moving Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/row-selection.html": {
    "href": "components/treegrid/row-selection.html",
    "title": "Angular Grid Select Row - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Row Selection With row selection in Ignite UI for Angular, there is row selector column that precedes all other columns within the row. When a user clicks on the row selector, the row will either become selected or deselected, enabling the user to select multiple rows of data. Angular Row Selection Example The sample below demonstrates the four types of Tree Grid's row selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Use the switch button to hide or show the row selector checkbox. Setup In order to setup row selection in the igx-tree-grid, you just need to set the rowSelection property. This property accepts GridSelectionMode enumeration. GridSelectionMode exposes the following four modes: none, single, multiple and multipleCascade. Below we will take a look at each of them in more detail. None Selection In the igx-tree-grid by default row selection is disabled, otherwise ([rowSelection]=\"'none'\"). So you can not select or deselect a row through interaction with the Tree Grid UI, the only way to complete these actions is to use the provided API methods. Single Selection Single row selection can now be easily set up, the only thing you need to do, is to set [rowSelection] = '\"single\"' property. This gives you the opportunity to select only one row within a grid. You can select a row by clicking on a cell or pressing the space key when you focus on a cell of the row, and of course you can select a row by clicking on the row selector field. When row is selected or deselected rowSelectionChanging event is emitted. <!-- selectionExample.component.html --> <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\" [rowSelection]=\"'single'\" [allowFiltering]=\"true\" (rowSelectionChanging)=\"handleRowSelection($event)\"> </igx-tree-grid> /* selectionExample.component.ts */ public handleRowSelection(event) { if (args.added.length && args.added[0] === 3) { args.cancel = true; } } Multiple Selection To enable multiple row selection in the igx-tree-grid just set the rowSelection property to multiple. This will enable a row selector field on each row and in the Tree Grid header. The row selector allows users to select multiple rows, with the selection persisting through scrolling, paging, and data operations, such as sorting and filtering. The row also can be selected by clicking on a cell or by pressing the space key when a cell is focused. If you have selected one row and click on another while holding the shift key, this will select the whole range of rows. In this selection mode, when you click on a single row, the previous selected rows will be deselected. If you click while holding the ctrl key, the row will be toggled and the previous selection will be preserved. <!-- selectionExample.component.html --> <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [rowSelection]=\"'multiple'\" [allowFiltering]=\"true\" (rowSelectionChanging)=\"handleRowSelection($event)\" > </igx-tree-grid> Cascade Selection To enable cascade row selection in the igx-tree-grid just set the rowSelection property to multipleCascade. This will enable a row selector field on each row and in the Tree Grid header. The row selector allows users to select multiple rows which would select all children in the tree below. The selection persists through scrolling, paging, and data operations, such as sorting and filtering. The row can also be selected by clicking on a cell or by pressing the space key when a cell is focused. If you have selected one row and click on another while holding the shift key, the selection of a parent record will select all of its children even if they are not in the selected range. In this selection mode, when you click on a single row, the previously selected rows will be deselected. If you click while holding the ctrl key, the row and its children will be toggled and the previous selection will be preserved. <!-- selectionExample.component.html --> <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\" [rowSelection]=\"'multipleCascade'\" [allowFiltering]=\"true\" (rowSelectionChanging)=\"handleRowSelection($event)\"> </igx-tree-grid> In this mode a parent's selection state entirely depends on the selection state of its children. When a parent has some selected and some deselected children, its checkbox is in an indeterminate state. <!-- selectionExample.component.ts --> public handleRowSelection(event: IRowSelectionEventArgs) { // use event.newSelection to retrieve primary key/row data of latest selected row this.selectedRowsCount = event.newSelection.length; this.selectedRowIndex = event.newSelection[0]; } Notes Row selection will trigger rowSelectionChanging event. This event gives you information about the new selection, old selection, the rows that have been added and removed from the old selection. Also the event is cancellable, so this allows you to prevent selection. When row selection is enabled row selectors are displayed, but if you don't want to show them, you can set [hideRowSelectors] = true. When you switch between row selection modes at runtime, this will clear the previous row selection state. API usage Select rows programmatically The code snippet below can be used to select one or multiple rows simultaneously (via primaryKey); Additionally, the second parameter of this method is a boolean property through which you may choose whether the previous row selection will be cleared or not. The previous selection is preserved by default. <!-- selectionExample.component.html --> <igx-tree-grid ... [primaryKey]=\"'ID'\"> ... </igx-tree-grid> ... <button (click)=\"this.treeGrid.selectRows([1,2,5], true)\">Select 1,2 and 5</button> // select rows and clear previous selection state This will add the rows which correspond to the data entries with IDs 1, 2 and 5 to the Tree Grid selection. Deselect rows If you need to deselect rows programmatically, you can use the deselectRows(rowIds: []) method. <!-- selectionExample.component.html --> <igx-tree-grid ... [primaryKey]=\"'ID'\"> ... </igx-tree-grid> ... <button (click)=\"this.treeGrid.deselectRows([1,2,5])\">Deselect 1,2 and 5</button> Row selection event When there is some change in the row selection rowSelectionChanging event is emitted. rowSelectionChanging exposes the following arguments: oldSelection - array of row's data that contains the previous state of the row selection. newSelection - array of row's data that match the new state of the row selection. added - array of row's data that are currently added to the selection. removed - array of row's data that are currently removed according old selection state. event - the original event that triggered row selection change. cancel - allows you the prevent the row selection change. Row selection event in remote data scenarios In remote data scenarios, when the grid has a primaryKey set, rowSelectionChanging.oldSelection event argument will not contain the full row data object for the rows that are currently out of the data view. In this case, rowSelectionChanging.oldSelection object will contain only one property, which is the primaryKey field. For the rest of the rows, currently in the data view, rowSelectionChanging.oldSelection will contain the whole row data. <!-- selectionExample.component.html --> <igx-tree-grid (rowSelectionChanging)=\"handleRowSelectionChange($event)\"> ... </igx-tree-grid> /* selectionExample.component.ts */ public handleRowSelectionChange(args) { args.cancel = true; // this will cancel the row selection } Select all rows Another useful API method that igx-tree-grid provides is selectAll(onlyFilteredData). By default this method will select all data rows, but if filtering is applied, it will select only the rows that match the filter criteria. But if you call the method with false parameter, selectAll(false) will always select all data in the grid, even if filtering is applied. Note Keep in mind that selectAll() will not select the rows that are deleted. Deselect all rows igx-tree-grid provides deselectAll(onlyFilteredData) method, which by default will deselect all data rows, but if filtering is applied will deselect only the rows that match the filter criteria. But if you call the method with false parameter, deselectAll(false) will always clear all row selection state even if filtering is applied. How to get selected rows If you need to see which rows are currently selected, you can get their row IDs with the selectedRows getter. public getSelectedRows() { const currentSelection = this.treeGrid.selectedRows; // return array of row IDs } Additionally, assigning row IDs to selectedRows will allow you to change the grid's selection state. public mySelectedRows = ['Johnathan Winchester', 'Ana Sanders']; // an array of row IDs <igx-tree-grid primaryKey=\"ID\" rowSelection=\"multiple\" [autoGenerate]=\"false\" [selectedRows]=\"mySelectedRows\" [data]=\"data\"> <igx-column [field]=\"'Name'\"></igx-column> <igx-column [field]=\"'Title'\"></igx-column> </igx-tree-grid> Row selector templates You can template header and row selectors in the Tree Grid and also access their contexts which provide useful functionality for different scenarios. By default, the Tree Grid handles all row selection interactions on the row selector's parent container or on the row itself, leaving just the state visualization for the template. Overriding the base functionality should generally be done using the rowSelectionChanging event. In case you implement a custom template with a click handler which overrides the base functionality, you should stop the event's propagation to preserve the correct row state. Row template To create a custom row selector template, within the igx-tree-grid, declare an <ng-template> with igxRowSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the row's state. The selected property shows whether the current row is selected or not while the index property can be used to access the row index. <ng-template igxRowSelector let-rowContext> {{ rowContext.index }} <igx-checkbox [checked]=\"rowContext.selected\" [readonly]=\"true\" ></igx-checkbox> </ng-template> The rowID property can be used to get a reference of an igx-tree-grid row. This is useful when you implement a click handler on the row selector element. <ng-template igxRowSelector let-rowContext> <igx-checkbox (click)=\"onSelectorClick($event, rowContext.key)\"></igx-checkbox> </ng-template> In the above example we are using an igx-checkbox and we bind rowContext.selected to its checked property. See this in action in our Row Numbering Demo. Header template To create a custom header selector template, within the Tree Grid, declare an <ng-template> with igxHeadSelector directive. From the template you can access the implicitly provided context variable, with properties that give you information about the header's state. The selectedCount property shows you how many rows are currently selected while totalCount shows you how many rows there are in the Tree Grid in total. <ng-template igxHeadSelector let-headContext> {{ headContext.selectedCount }} / {{ headContext.totalCount }} </ng-template> The selectedCount and totalCount properties can be used to determine if the head selector should be checked or indeterminate (partially selected). <igx-tree-grid [data]=\"tGridData\" primaryKey=\"ProductID\" childDataKey=\"Products\"> <!-- ... --> <ng-template igxHeadSelector let-headContext> <igx-checkbox [checked]=\"headContext.selectedCount > 0 && headContext.selectedCount === headContext.totalCount\" [indeterminate]=\"headContext.selectedCount > 0 && headContext.selectedCount !== headContext.totalCount\"> </igx-checkbox> </ng-template> </igx-tree-grid> Row Numbering Demo This demo shows the usage of custom header and row selectors. The latter uses rowContext.index to display row numbers and an igx-checkbox bound to rowContext.selected. Conditional Selection Demo This demo prevents some rows from being selected using the rowSelectionChanging event and a custom template with disabled checkbox for non-selectable rows. API References IgxTreeGridComponent API IgxTreeGridRow API IgxGridCell API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Selection Cell selection Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/search.html": {
    "href": "components/treegrid/search.html",
    "title": "Angular Tree Grid Search Filter - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Search Filter Angular Tree Grid search enables the process of finding values in the collection of data. We make it easier to setup this functionality and it can be implemented with search input box, buttons, keyboard navigation and other useful features for an even better user experience. While browsers natively provide content search functionality, most of the time the Tree Grid virtualizes its columns and rows that are out of view. In these cases, the native grid search is unable to search data in the virtualized cells, since they are not part of the DOM. We have extended the Ignite UI for Angular table-based grid with a search API that allows you to search through the virtualized content of the Tree Grid. Angular Search Example The following example represents Tree Grid with search input box that allows searching in all columns and rows, as well as specific filtering options for each column. Angular Search Usage Grid setup Let's start by creating our grid and binding it to our data. We will also add some custom styles for the components we will be using! <!--searchgrid.component.html--> <igx-tree-grid #treeGrid1 [data]=\"data\" [autoGenerate]=\"false\" primaryKey=\"ID\" foreignKey=\"ParentID\" [allowFiltering]=\"true\"> <igx-column [field]=\"'Name'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'ID'\" dataType=\"number\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Title'\" dataType=\"string\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'Age'\" dataType=\"number\" [sortable]=\"true\"></igx-column> <igx-column [field]=\"'HireDate'\" dataType=\"date\" [sortable]=\"true\"></igx-column> </igx-tree-grid> /* searchgrid.component.css */ .grid__wrapper { margin: 15px; } .offset { margin-bottom: 15px; } .resultsText { font-size: 0.875rem; } .chips { margin-left: 5px; } .searchButtons { margin-left: 5px; } Great, and now let's prepare for the search API of our Tree Grid! We can create a few properties, which can be used for storing the currently searched text and whether the search is case sensitive and/or by an exact match. // searchgrid.component.ts public searchText: string = ''; public caseSensitive: boolean = false; public exactMatch: boolean = false; Angular search box input Now let's create our search input! By binding our searchText as ngModel to our newly created input and subscribe to the ngModelChange event, we can detect every single searchText modification by the user. This will allow us to use the Tree Grid's findNext and findPrev methods to highlight all the occurrences of the searchText and scroll to the next/previous one (depending on which method we have invoked). Both the findNext and the findPrev methods have three arguments: text: string (the text we are searching for) (optional) caseSensitive: boolean (should the search be case sensitive or not, default value is false) (optional) exactMatch: boolean (should the search be by an exact match or not, default value is false) When searching by an exact match, the search API will highlight as results only the cell values that match entirely the searchText by taking the case sensitivity into account as well. For example the strings 'software' and 'Software' are an exact match with a disregard for the case sensitivity. The methods from above return a number value (the number of times the Tree Grid contains the given string). <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"treeGrid.findNext(searchText, caseSensitive, exactMatch)\" /> Display results count Let's also display the position of the current occurrence, along with the total results count! We can do this by using the grid's lastSearchInfo property. This property is automatically updated when using the find methods. The treeGrid.lastSearchInfo.matchInfoCache.length value will give us the total results count. The treeGrid.lastSearchInfo.activeMatchIndex value will give us the index position of the current occurrence (match). <!--searchgrid.component.html--> <div class=\"resultsText\" *ngIf=\"treeGrid.lastSearchInfo\"> <span *ngIf=\"treeGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ treeGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ treeGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"treeGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> Add search buttons In order to freely search and navigate among our search results, let's create a couple of buttons by invoking the findNext and the findPrev methods inside the buttons' respective click event handlers. <!--searchgrid.component.html--> <div class=\"searchButtons\"> <input type=\"button\" value=\"Previous\" (click)=\"treeGrid.findPrev(searchText, caseSensitive, exactMatch)\" /> <input type=\"button\" value=\"Next\" (click)=\"treeGrid.findNext(searchText, caseSensitive, exactMatch)\" /> </div> Add keyboard search We can also allow the users to navigate the results by using the keyboard's arrow keys and the Enter key. In order to achieve this, we can handle the keydown event of our search input by preventing the default caret movement of the input with the preventDefault() method and invoke the findNext/findPrev methods depending on which key the user has pressed. <!--searchgrid.component.html--> <input #search1 id=\"search1\" placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"treeGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> // searchgrid.component.ts public searchKeyDown(ev) { if (ev.key === 'Enter' || ev.key === 'ArrowDown' || ev.key === 'ArrowRight') { ev.preventDefault(); this.treeGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } else if (ev.key === 'ArrowUp' || ev.key === 'ArrowLeft') { ev.preventDefault(); this.treeGrid.findPrev(this.searchText, this.caseSensitive, this.exactMatch); } } Case sensitive and Exact match Now let's allow the user to choose whether the search should be case sensitive and/or by an exact match. For this purpose we can use simple checkbox inputs by binding our caseSensitive and exactMatch properties to the inputs' checked properties respectively and handle their change events by toggling our properties and invoking the findNext method. <!--searchgrid.component.html--> <span>Case sensitive</span> <input type=\"checkbox\" [checked]=\"caseSensitive\" (change)=\"updateSearch()\"> <span>Exact match</span> <input type=\"checkbox\" [checked]=\"exactMatch\" (change)=\"updateExactSearch()\"> // searchgrid.component.ts public updateSearch() { this.caseSensitive = !this.caseSensitive; this.treeGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } public updateExactSearch() { this.exactMatch = !this.exactMatch; this.treeGrid.findNext(this.searchText, this.caseSensitive, this.exactMatch); } Persistence What if we would like to filter and sort our Tree Grid or even to add and remove records? After such operations, the highlights of our current search automatically update and persist over any text that matches the searchText! Furthermore, the search will work with paging and will persist the highlights through changes of the Tree Grid's perPage property. Adding icons By using some of our other components, we can create an enriched user interface and improve the overall design of our entire search bar! We can have a nice search or delete icon on the left of the search input, a couple of chips for our search options and some material design icons combined with nice ripple styled buttons for our navigation on the right. We can wrap these components inside an input group for a more refined design. To do this, let's go and grab the IgxInputGroup, IgxIcon, IgxRipple, IgxButton and the IgxChip modules. // app.module.ts ... import { IgxTreeGridModule, IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule } from 'igniteui-angular'; // import { // IgxInputGroupModule, // IgxIconModule, // IgxRippleModule, // IgxButtonModule, // IgxChipsModule // } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... imports: [..., IgxInputGroupModule, IgxIconModule, IgxRippleModule, IgxButtonModule, IgxChipsModule], }) export class AppModule {} Finally, let's update our template with the new components! We will wrap all of our components inside an IgxInputGroup. On the left we will toggle between a search and a delete/clear icon (depending on whether the search input is empty or not). In the center, we will position the input itself. In addition, whenever the delete icon is clicked, we will update our searchText and invoke the Tree Grid's clearSearch method to clear the highlights. <!--searchgrid.component.html--> <igx-input-group type=\"search\" class=\"offset\"> <igx-prefix> <igx-icon *ngIf=\"searchText.length == 0\">search</igx-icon> <igx-icon *ngIf=\"searchText.length > 0\" (click)=\"clearSearch()\">clear</igx-icon> </igx-prefix> <input #search1 id=\"search1\" igxInput placeholder=\"Search\" [(ngModel)]=\"searchText\" (ngModelChange)=\"treeGrid.findNext(searchText, caseSensitive, exactMatch)\" (keydown)=\"searchKeyDown($event)\" /> <igx-suffix *ngIf=\"searchText.length > 0\"> ... </igx-suffix> </igx-input-group> // searchgrid.component.ts public clearSearch() { this.searchText = ''; this.treeGrid.clearSearch(); } On the right in our input group, let's create three separate containers with the following purposes: For displaying the search results. <!--searchgrid.component.html--> <igx-suffix *ngIf=\"searchText.length > 0\"> <div class=\"resultsText\" *ngIf=\"treeGrid.lastSearchInfo\"> <span *ngIf=\"treeGrid.lastSearchInfo.matchInfoCache.length > 0\"> {{ treeGrid.lastSearchInfo.activeMatchIndex + 1 }} of {{ treeGrid.lastSearchInfo.matchInfoCache.length }} results </span> <span *ngIf=\"treeGrid.lastSearchInfo.matchInfoCache.length == 0\"> No results </span> </div> </igx-suffix> For displaying a couple of chips that toggle the caseSensitive and the exactMatch properties. We have replaced the checkboxes with two stylish chips that change color based on these properties. Whenever a chip is clicked, we invoke its respective handler - updateSearch or updateExactSearch depending on which chip has been clicked. <!--searchgrid.component.html--> ... <div class=\"chips\"> <igx-chips-area> <igx-chip (click)=\"updateSearch()\" [color]=\"caseSensitive? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Case Sensitive</span> </igx-chip> <igx-chip (click)=\"updateExactSearch()\" [color]=\"exactMatch? 'lightgrey' : 'rgba(0, 0, 0, .04)'\"> <span>Exact Match</span> </igx-chip> </igx-chips-area> </div> ... For the search navigation buttons, we have transformed our inputs into ripple styled buttons with material icons. The handlers for the click events remain the same - invoking the findNext/findPrev methods. <!--searchgrid.component.html--> <igx-suffix> <div class=\"searchButtons\"> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"treeGrid.findPrev(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_before</igx-icon> </button> <button igxIconButton=\"flat\" igxRipple igxRippleCentered=\"true\" (click)=\"treeGrid.findNext(searchText, caseSensitive, exactMatch)\"> <igx-icon fontSet=\"material\">navigate_next</igx-icon> </button> </div> </igx-suffix> Known Limitations Limitation Description Searching in cells with a template The search functionality highlights work only for the default cell templates. If you have a column with custom cell template, the highlights will not work so you should either use alternative approaches, such as a column formatter, or set the searchable property on the column to false. Remote Virtualization The search will not work properly when using remote virtualization Cells with cut off text When the text in the cell is too large to fit and the text we are looking for is cut off by the ellipsis, we will still scroll to the cell and include it in the match count, but nothing will be highlighted API References In this article we implemented our own search bar for the Tree Grid with some additional functionality when it comes to navigating between the search results. We also used some additional Ignite UI for Angular components like icons, chips and inputs. The search API is listed below. IgxTreeGridComponent methods: findNext findPrev clearSearch refreshSearch IgxGridCell methods: IgxColumnComponent properties: searchable ISearchInfo Additional components and/or directives with relative APIs that were used: IgxInputGroupComponent IgxIconComponent IgxRippleDirective IgxButtonDirective IgxChipComponent Styles: IgxTreeGridComponent Styles IgxInputGroupComponent Styles IgxIconComponent Styles IgxRippleDirective Styles IgxButtonDirective Styles IgxChipComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Filtering Paging Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/selection.html": {
    "href": "components/treegrid/selection.html",
    "title": "Angular Tree Grid Selection - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Selection With Ignite UI for Angular Tree Grid you can easily select data by using variety of events, rich API or with simple mouse interactions like single select. Angular Grid Selection Example The sample below demonstrates the three types of Tree Grid's cell selection behavior. Use the buttons below to enable each of the available selection modes. A brief description will be provided on each button interaction through a snackbar message box. Angular Grid Selection Options IgniteUI for Angular Tree Grid component provides three different selection modes - Row selection, Cell selection and Column selection. By default only Multi-cell selection mode is enabled in the Tree Grid. In order to change/enable selection mode you can use rowSelection, cellSelection or selectable properties. Angular Row Selection Property rowSelection enables you to specify the following options: none - Row selection would be disabled for the Tree Grid single - Selection of only one row within the Tree Grid would be available multiple - Multi-row selection would be available by using the Row selectors, with a key combination like ctrl + click, or by pressing the space key once a cell is focused multipleCascade - This is a mode for cascading selection, resulting in the selection of all children in the tree below the record that the user selects with user interaction. In this mode a parent's selection state entirely depends on the selection state of its children. Go to Row selection topic for more information. Angular Cell Selection Property cellSelection enables you to specify the following options: none - Cell selection would be disabled for the Tree Grid single - Selection of only one cell within the Tree Grid would be available. multiple - Currently, this is the default state of the selection in the Tree Grid. Multi-cell selection is available by mouse dragging over the cells, after a left button mouse clicked continuously. Go to Cell selection topic for more information. Angular Column Selection The selectable property enables you to specify the following options for each column: false - the corresponding column selection will be disabled for the Tree Grid true - the corresponding column selection will be enabled for the Tree Grid This lead to the following three variations: Single selection - mouse click over the column cell. Multi column selection - holding ctrl + mouse click over the column cells. Range column selection - holding shift + mouse click selects everything in between. Go to Column selection topic for more information. Known Issues and Limitations Using the Tree Grid with Selection enabled on IE11 requires the explicit import of the array polyfill in polyfill.ts of the angular application. IE11 is no longer supported as of version 13.0.0. import 'core-js/es7/array'; When the grid has no primaryKey set and remote data scenarios are enabled (when paging, sorting, filtering, scrolling trigger requests to a remote server to retrieve the data to be displayed in the grid), a row will lose the following state after a data request completes: Row Selection Row Expand/collapse Row Editing Row Pinning API References IgxTreeGridComponent API IgxTreeGridRow API IgxGridCell API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Row Selection Cell Selection Paging Filtering Sorting Summaries Column Moving Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/sizing.html": {
    "href": "components/treegrid/sizing.html",
    "title": "Angular Tree Grid Sizing - Ignite UI for Angular",
    "keywords": "Angular Grid Sizing There are many different ways to size the IgxTreeGrid in order to accommodate a lot of scenarios that the users can have. While some are straight forward, others might be more complex and that is why we will take each one and look into them in more depth. We will go through setting width and height separately since there are some differences e.g. when using percentages for each. When it comes to border and padding size for the IgxTreeGrid, they are taken into its width/height size calculations or also known as Border box sizing. It is applied in all scenarios. Note If the Border box sizing is overridden by the user we cannot guarantee that the IgxTreeGrid will size correctly. Width If the width input does not have value assigned, its default value is 100% and the IgxTreeGrid tries to fill the available space. You can check how the grid reacts to it in the Percentages section. Note Setting manually the width style of the IgxTreeGrid itself will result in an unexpected behavior. Null The grid's width can accepts value of null, which when set, renders all columns in the DOM. The grid sizes accordingly so there is no grid horizontal scrollbar since column virtualization is not applied. If there are 6 columns and none of them has width defined, the grid will have width of 816px, because each column by default have assigned width of 136px in this scenario. Same will happen if the columns have width in percentages. If vertical scrollbar is rendered or there are features that render additional columns their width will be added also. If there are 6 columns with column width set to 200px they will fit in our window and all will be visible: If there are more columns or ones with bigger width that go out of the browser's view, they will all still render. Let's have the same amount of columns but each with column width of 300px. Since they don't all fit in the browser view area, it will create a scrollbar natively. The next example displays this exact scenario: If the grid has a parent element of any sort and it doesn't have any overflow set, it will still render all columns visible. Otherwise if the parent element has overflow auto or scroll, a scrollbar for that parent element will be rendered natively. The parent has bigger height for easier visualization in the following example. Note Due to this behavior, if the grid data contains too many columns, it might have significant impact on the browser performance, since all columns would be rendered without virtualization. Pixels When the IgxTreeGrid width input is set to pixels it will set the whole grid size to that value and it will be static. It will not react to any browser resizing or changes in the DOM, although this is not the case for the grid content: When width is set in pixels in order for the grid to render horizontal scrollbar, its content width needs to exceed the specified grid width. Let's, for example, have the combined width of the columns exceed 1200px. In this case a horizontal scrollbar will be rendered. For scenarios where the grid has a parent element, it depends on the parent styling if it will render scrollbar or not. Everything else related to the grid itself is still retained. If the parent element width is smaller than the grid's width and has overflow style set to auto or scroll, it will render scrollbar natively. For example, if the parent has width set to 1000px and the IgxTreeGrid width is still 1200px, it will look similar to the following illustrations: Percentages When the width of the IgxTreeGrid is set to percentages it will size the grid according to the parent element's width. If the parent element does not have width specified the IgxTreeGrid will size relative to the browser window. For example, if we set the grid width input to 100% and there is no parent element it will fill 100% of the available width of the browser window. If it is resized the grid will resize as well accordingly. If we set grid's width to 100% and there is a parent element that has specific width of 1200px, this will mean that the grid will size relative to that element and his final width will be 1200px. If we have a parent element with width of 1000px and have the grid's width set to 150%, the calculated grid width will be 1500px. In this case the grid will still render fully visible but if we set overflow: auto of the parent, that parent will render scrollbar on its own. Height By default if no height is defined for the IgxTreeGrid, it will be set to 100%. You can check how the grid reacts depending on the DOM structure in the Percentages section. Note Setting manually the height style of the IgxTreeGrid itself will result in an unexpected behavior. Null The IgxTreeGrid height input can accept null value, which when set, displays all rows with no scrollbar no matter how many they are. In this case, there is no vertical virtualization since the grid renders all rows anyway. If we have data with 14 rows in this case the grid will render all 14 of them and size the grid so all are visible without any empty space inside the grid. If we have 24 rows instead, the grid will still render all rows but since they are too many, they exceed the browser boundaries. That's why the browser itself will render vertical scrollbar by default so the user can scroll down to the rest of the rows. If there is a parent element with defined height, the grid will still render all rows and not be affected. Let's say the parent has height of 650px. If he has overflow set to auto or scroll, it will render a vertical scrollbar but the grid will still be unaffected: Note Due to this behavior, if the grid data contains too many rows, it might have significant impact on the browser performance, since all rows would be rendered without virtualization. Pixels Setting the IgxTreeGrid height in pixels is more straightforward since the grid will size to that specific size in all occasions similarly to how width is set in pixels. If we set, for example, the height 500px with 4 rows for our data the grid will sit to that size and since 4 rows are not enough to fill the visible area it is expected to have some empty area. If the number of rows exceeds the visible area of the grid when height is set to pixels a vertical scrollbar will be rendered. For example, a grid with 500px height set and 14 rows will be rendered the following way: If there is a parent element with height defined, unless it has overflow set to auto or scroll, the grid will still be fully visible. Otherwise it will render a scrollbar. Percentages When the height input is set to percentages the IgxTreeGrid will size based on the parent element height. If the parent element has its height set in pixels or percentages, the grid will size relative to the size of the parent. When the parent element does not have defined height, the browser does not assign height to it initially and sizes it based on its children and their size. That is why there is no way for the grid to know what base height to use in order to apply percentage sizing based on it. For this reason, it will render a maximum of 10 rows and if they are more rows, a vertical scrollbar will be rendered. Otherwise, the grid will fit to number of rendered rows. We will look in this scenario in more detail in the next examples. Let's have width set to 1200px and the parent element not having any size applied to it: If there are less than 10 rows the grid will try to fit all rows in the `visible area without having an empty space between the last row and the bottom of the visible area. For example, let's have the grid data to consist of 7 rows. The grid will render all 7 rows without vertical scrollbar and without empty space inside the grid. If there are more than 10 rows a vertical scrollbar will be rendered for the rest of the rows and only 10 rows can be visible at any time. In the next example only the row number is increased to 14. If we set the parent element height to 800px and the IgxTreeGrid to 100% height this means that the grid will be sized to 100 percentages of 800px. If the IgxTreeGrid height is set to a number bigger than 100% and the parent element has height, for the parent to render scrollbar it again needs to have overflow set to auto or scroll. Otherwise the grid will be fully visibly and size relative to the parent size. If we want the grid to be sized to 100% from the browser window we would need to set both body and parent grid element heights to 100%. In this case, the parent element can be sized and the grid will size accordingly if the browser is resized. Column Sizing Depending on the grid size itself, the columns inside it can also be sized differently that could result in scenarios where the grid renders horizontal scrollbar or not. Columns can have width set in pixels, percentages or autosized when nothing is set. We will take a deeper look regarding these scenarios in this section. Default By default when a column doesn't have a specified width it will try to autosize, so that it fills if any empty space is available in the grid view area. Autosized columns have minimum width of 136px, so if the area available is less than 136px for that column, it will default to that size. When the grid is resized in these scenarios, the column width is also updated to reflect the changes, so it fills any new empty space available. If a column does not have specified width and the IgxTreeGrid has width set to null, it will be sized to the minimum of 136px. This means that for a grid with width null and 6 columns that don't have width, each column will be sized to 136px. When there are multiple autosized columns they will divide the available space between each other equally. This means that if we have 6 columns and there is empty area of 1200px, each will size to 200px. If there is available empty space, so that each autosized column will be less than 136px, all autosized columns will default to 136px and the grid will render horizontal scrollbar. In the next example let's have 12 autosized columns and the grid width set to 1000px. If a column does not have width specified, but all other columns have either width in pixels or percentages, that column will try to also fill the available space. For example, if we don't have width set to the first column and all other 5 have width of 100px, the first will fill the rest. Same applies if multiple columns does not have width specified, all will divide the available space between each other equally. In the next illustration the first column has width set to 100px. Note Feature columns like Row Selector checkbox column and etc. fill additional space that is taken into account when autosizing columns. Pixels When columns have set specific width in pixels, they stick to that size, unless they are resized manually. Since the combined width of the columns is static, it can be less than the IgxTreeGrid width or exceed it. If the combined width of all columns is less than the IgxTreeGrid width, there would be an empty are inside the grid that the columns wouldn't be able to fill. This is the expected behavior of the IgxTreeGrid. In the next example the columns have 150px width. If the combined width of all columns is bigger than the actual IgxTreeGrid width, a horizontal scrollbar will be rendered. In the next example each of the 6 columns have width of 300px and grid has width of 1200px, which means that the columns combined have excess of 600px that goes out of bounds. Auto When columns are set to auto their size adjusts to fit the longest word in the column. Empty areas are possible if there are cells with very short values, while other cells have very long ones. In this scenario, all cells in the column would adjust to take the width of the cell with the longest value. Percentages When columns have set width in percentages, their size is calculated relatively to the grid size. It is similar to how width in pixels works, but provides also responsiveness to the columns which means that when the grid is resized, the columns also will resize accordingly. If the combined width of all columns is less than 100%, similarly to when in pixels, there could be an empty area of the grid that the columns do not cover. If the combined width is exactly 100%, the columns will fill all available space of the grid. If the combined width exceeds 100% in order for the user to be able to see the columns out of view, a horizontal scrollbar is rendered. If columns are set in percentages and the grid width is set to null, it would applywidth of 136px to each column. That is because the columns cannot be sized relatively to the grid, since it doesn't have width itself and relies on its content to be sized when its width is null. In the following example all 6 columns have width set to 50%: API References IgxTreeGridComponent API IgxTreeGridRow API IgxTreeGridComponent Styles Additional Resources Tree Grid overview Virtualization and Performance Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/sorting.html": {
    "href": "components/treegrid/sorting.html",
    "title": "Angular Tree Grid Sorting - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Sorting In Ignite UI for Angular Tree Grid, data sorting is enabled on a per-column level, meaning that the igx-tree-grid can have a mix of sortable and non-sortable columns. Performing angular sort actions enables you to change the display order of the records based on specified criteria. Note Up until now, grouping/sorting worked in conjuction with each other. In 13.2 version, a new behavior which decouples gropuing from sorting is introduced. For example - clearing the grouping will not clear sorting expressions in the grid or vice versa. Still, if a column is both sorted and grouped, grouped expressions take precedence. Angular Tree Grid Sorting Overview Example Additionally there is a custom contextmenu added for sorting using igx-tree-grid's contextMenu Output. This is done via the sortable input. With the Tree Grid sorting, you can also set the sortingIgnoreCase property to perform case sensitive sorting: <igx-column field=\"Name\" header=\"Order Product\" [dataType]=\"'string'\" sortable=\"true\"></igx-column> Sorting Indicators Having a certain amount of sorted columns could be really confusing if there is no indication of the sorted order. The IgxTreeGrid provides a solution for this problem by indicating the index of each sorted column. Sorting through the API You can sort any column or a combination of columns through the Tree Grid API using the Tree Grid sort method: import { SortingDirection } from 'igniteui-angular'; // import { SortingDirection } from '@infragistics/igniteui-angular'; for licensed package // Perform a case insensitive ascending sort on the ProductName column. this.treeGrid.sort({ fieldName: 'Name', dir: SortingDirection.Asc, ignoreCase: true }); // Perform sorting on both the ProductName and Price columns. this.treeGrid.sort([ { fieldName: 'Name', dir: SortingDirection.Asc, ignoreCase: true }, { fieldName: 'UnitPrice', dir: SortingDirection.Desc } ]); Note Sorting is performed using our DefaultSortingStrategy algorithm. Any IgxColumnComponent or ISortingExpression can use a custom implementation of the ISortingStrategy as a substitute algorithm. This is useful when custom sorting needs to be defined for complex template columns, or image columns, for example. As with the filtering behavior, you can clear the sorting state by using the clearSort method: // Removes the sorting state from the ProductName column this.treeGrid.clearSort('Name'); // Removes the sorting state from every column in the Tree Grid this.treeGrid.clearSort(); Note The sortStrategy of the Tree Grid is of different type compared to the sortStrategy of the column, since they work in different scopes and expose different parameters. Note The sorting operation DOES NOT change the underlying data source of the Tree Grid. Initial sorting state It is possible to set the initial sorting state of the Tree Grid by passing an array of sorting expressions to the sortingExpressions property of the Tree Grid. Note If values of type string are used by a column of dataType Date, the Tree Grid won't parse them to Date objects and using Tree Grid sorting won't work as expected. If you want to use string objects, additional logic should be implemented on an application level, in order to parse the values to Date objects. Sorting Indicators Templates The sorting indicator icon in the column header can be customized using a template. The following directives are available for templating the sorting indicator for any sorting state (ascending, descending, none): IgxSortHeaderIconDirective – re-templates the sorting icon when no sorting is applied. <ng-template igxSortHeaderIcon> <igx-icon>unfold_more</igx-icon> </ng-template> IgxSortAscendingHeaderIconDirective – re-templates the sorting icon when the column is sorted in ascending order. <ng-template igxSortAscendingHeaderIcon> <igx-icon>expand_less</igx-icon> </ng-template> IgxSortDescendningHeaderIconDirective – re-templates the sorting icon when the column is sorted in descending order. <ng-template igxSortDescendingHeaderIcon> <igx-icon>expand_more</igx-icon> </ng-template> Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the $sorted-header-icon-color and sortable-header-icon-hover-color parameters. $custom-theme: grid-theme( $sorted-header-icon-color: #ffb06a, $sortable-header-icon-hover-color: black ); The last step is to include the component mixins: @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $black-color: black; $orange-color: #ffb06a; $custom-palette: palette($primary: $black-color, $secondary: $orange-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $sorted-header-icon-color: color($custom-palette, \"secondary\", 500), $sortable-header-icon-hover-color: color($custom-palette, \"primary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid: // Extending the light grid schema $custom-grid-schema: extend($_light-grid, ( sorted-header-icon-color: (igx-color:('secondary', 500)), sortable-header-icon-hover-color: (igx-color:('primary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo Note The sample will not be affected by the selected global theme from Change Theme. API References IgxTreeGridComponent API IgxTreeGridComponent Styles ISortingExpression Additional Resources Tree Grid overview Virtualization and Performance Paging Filtering Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/state-persistence.html": {
    "href": "components/treegrid/state-persistence.html",
    "title": "Angular Tree Grid State Persistence - Ignite UI for Angular",
    "keywords": "Angular Tree Grid State Persistence Тhe igxGridState directive allows developers to easily save and restore the grid state. When the IgxGridState directive is applied on the grid, it exposes the getState and setState methods that developers can use to achieve state persistence in any scenario. Supported Features IgxGridState directive supports saving and restoring the state of the following features: Sorting Filtering Advanced Filtering Paging Cell Selection Row Selection Column Selection Row Pinning Expansion GroupBy Columns NEW: Multi column headers are now supported out of the box Columns order Column properties defined by the IColumnState interface. Columns templates and functions are restored using application level code, see Restoring Column section. Note The IgxGridState directive does not take care of templates. Go to Restoring Column section to see how to restore column templates. Usage getState - This method returns the grid state in a serialized JSON string, so developers can just take it and save it on any data storage (database, cloud, browser localStorage, etc). The method accepts first optional parameter serialize, which determines whether getState will return an IGridState object or a serialized JSON string. The developer may choose to get only the state for a certain feature/features, by passing in the feature name, or an array with feature names as a second argument. // get all features` state in a serialized JSON string const gridState = state.getState(); // get an `IGridState` object, containing all features original state objects, as returned by the grid public API const gridState: IGridState = state.getState(false); // get the sorting and filtering expressions const sortingFilteringStates: IGridState = state.getState(false, ['sorting', 'filtering']); setState - The setState method accepts the serialized JSON string or IGridState object as argument and will restore the state of each feature found in the object/JSON string. state.setState(gridState); state.setState(sortingFilteringStates) options - The options object implements the IGridStateOptions interface, i.e. for every key, which is the name of a certain feature, there is the boolean value indicating if this feature state will be tracked. getState method will not put the state of these features in the returned value and setState method will not restore state for it. public options = { cellSelection: false; sorting: false; } <igx-tree-grid [igxGridState]=\"options\"></igx-tree-grid> The simple to use single-point API's allows to achieve a full state persistence functionality in just a few lines of code. Copy paste the code from below - it will save the grid state in the browser sessionStorage object every time the user leaves the current page. Whenever the user returns to main page, the grid state will be restored. No more need to configure those complex advanced filtering and sorting expressions every time to get the data you want - do it once and have the code from below do the rest for your users: // app.component.ts @ViewChild(IgxGridStateDirective, { static: true }) public state!: IgxGridStateDirective; public ngOnInit() { this.router.events.pipe(take(1)).subscribe((event: NavigationStart) => { this.saveGridState(); }); } public ngAfterViewInit() { this.restoreGridState(); } public saveGridState() { const state = this.state.getState() as string; window.sessionStorage.setItem('grid1-state', state); } public restoreGridState() { const state = window.sessionStorage.getItem('grid1-state'); this.state.setState(state); } Restoring columns IgxGridState will not persist columns templates, column formatters, etc. by default (see limitations). Restoring any of these can be achieved with code on application level. Let's show how to do this for templated columns: Define a template reference variable (in the example below it is #activeTemplate) and assign an event handler for the columnInit event: <igx-tree-grid id=\"grid\" #grid igxGridState (columnInit)=\"onColumnInit($event)\"> <igx-column [field]=\"'IsActive'\" header=\"IsActive\"> <ng-template igxCell #activeTemplate let-column let-val=\"val\"> <igx-checkbox [checked]=\"val\"></igx-checkbox> </ng-template> </igx-column> ... </igx-tree-grid> Query the template view in the component using @ViewChild or @ViewChildren decorator. In the columnInit event handler, assign the template to the column bodyTemplate property: @ViewChild('activeTemplate', { static: true }) public activeTemplate: TemplateRef<any>; public onColumnInit(column: IgxColumnComponent) { if (column.field === 'IsActive') { column.bodyTemplate = this.activeTemplate; column.summaries = MySummary; column.filters = IgxNumberFilteringOperand.instance(); } } Demo Limitations getState method uses JSON.stringify() method to convert the original objects to a JSON string. JSON.stringify() does not support Functions, thats why the [IgxGridState] directive will ignore the columns formatter, filters, summaries, sortStrategy, cellClasses, cellStyles, headerTemplate and bodyTemplate properties. API References IgxTreeGridComponent IgxGridStateDirective Additional Resources Tree Grid overview Paging Filtering Sorting Selection View page on GitHub"
  },
  "components/treegrid/summaries.html": {
    "href": "components/treegrid/summaries.html",
    "title": "Angular Grid Summaries - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Summaries The Angular UI grid in Ignite UI for Angular has a summaries feature that functions on a per-column level as group footer. Angular grid summaries is powerful feature which enables the user to see column information in a separate container with a predefined set of default summary items, depending on the type of data within the column or by implementing a custom angular template in the Tree Grid. Angular Tree Grid Summaries Overview Example Note The summary of the column is a function of all column values, unless filtering is applied, then the summary of the column will be function of the filtered result values Tree Grid summaries can also be enabled on a per-column level in Ignite UI for Angular, which means that you can activate it only for columns that you need. Tree Grid summaries gives you a predefined set of default summaries, depending on the type of data in the column, so that you can save some time: For string and boolean data types, the following function is available: count For number, currency and percent data types, the following functions are available: count min max average sum For date data type, the following functions are available: count earliest latest All available column data types could be found in the official Column types topic. Tree Grid summaries are enabled per-column by setting hasSummary property to true. It is also important to keep in mind that the summaries for each column are resolved according to the column data type. In the igx-tree-grid the default column data type is string, so if you want number or date specific summaries you should specify the dataType property as number or date. Note that the summary values will be displayed localized, according to the grid locale and column pipeArgs. <igx-tree-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\"> <igx-column field=\"ID\" header=\"Order ID\" width=\"200px\" [sortable]=\"true\"></igx-column> <igx-column field=\"Name\" header=\"Order Product\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Units\" width=\"200px\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"true\"></igx-column> </igx-tree-grid> The other way to enable/disable summaries for a specific column or a list of columns is to use the public method enableSummaries/disableSummaries of the igx-tree-grid. <igx-tree-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\" > <igx-column field=\"ID\" header=\"Order ID\" width=\"200px\" [sortable]=\"true\"></igx-column> <igx-column field=\"Name\" header=\"Order Product\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\" ></igx-column> <igx-column field=\"Units\" width=\"200px\" [editable]=\"true\" [dataType]=\"'number'\" [hasSummary]=\"false\"></igx-column> </igx-tree-grid> <button (click)=\"enableSummary()\">Enable Summary</button> <button (click)=\"disableSummary()\">Disable Summary </button> public enableSummary() { this.grid1.enableSummaries([ {fieldName: 'Units', customSummary: this.mySummary}, {fieldName: 'ID'} ]); } public disableSummary() { this.grid1.disableSummaries('Name'); } Custom Tree Grid Summaries If these functions do not fulfill your requirements you can provide a custom summary for the specific columns. In order to achieve this you have to override one of the base classes IgxSummaryOperand, IgxNumberSummaryOperand or IgxDateSummaryOperand according to the column data type and your needs. This way you can redefine the existing function or you can add new functions. IgxSummaryOperand class provides the default implementation only for the count method. IgxNumberSummaryOperand extends IgxSummaryOperand and provides implementation for the min, max, sum and average. IgxDateSummaryOperand extends IgxSummaryOperand and additionally gives you earliest and latest. import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from 'igniteui-angular'; // import { IgxSummaryResult, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand } from '@infragistics/igniteui-angular'; for licensed package class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(data?: any[]): IgxSummaryResult[] { const result = super.operate(data); result.push({ key: 'test', label: 'Test', summaryResult: data.filter(rec => rec > 10 && rec < 30).length }); return result; } } As seen in the examples, the base classes expose the operate method, so you can choose to get all default summaries and modify the result, or calculate entirely new summary results. The method returns a list of IgxSummaryResult. interface IgxSummaryResult { key: string; label: string; summaryResult: any; } and take optional parameters for calculating the summaries. See Custom summaries, which access all data section below. Note In order to calculate the summary row height properly, the Tree Grid needs the operate method to always return an array of IgxSummaryResult with the proper length even when the data is empty. And now let's add our custom summary to the column UnitPrice. We will achieve that by setting the summaries property to the class we create below. <igx-tree-grid #grid1 [data]=\"data\" [autoGenerate]=\"false\" height=\"800px\" width=\"800px\" (columnInit)=\"initColumn($event)\"> <igx-column field=\"ID\" header=\"Order ID\" width=\"200px\" [sortable]=\"true\"></igx-column> <igx-column field=\"Name\" header=\"Order Product\" width=\"200px\" [sortable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"Units\" [dataType]=\"'number'\" width=\"200px\" [editable]=\"true\" [hasSummary]=\"true\" [summaries]=\"mySummary\"></igx-column> <igx-column field=\"UnitPrice\" header=\"Unit Price\" width=\"200px\" [dataType]=\"'number'\" [dataType]=\"'currency'\" [hasSummary]=\"true\"></igx-column> </igx-tree-grid> ... export class GridComponent implements OnInit { mySummary = MySummary; .... } Custom summaries, which access all data Now you can access all Tree Grid data inside the custom column summary. Two additional optional parameters are introduced in the IgxSummaryOperand operate method. As you can see in the code snippet below the operate method has the following three parameters: columnData - gives you an array that contains the values only for the current column allGridData - gives you the whole grid data source fieldName - current column field class MySummary extends IgxNumberSummaryOperand { constructor() { super(); } operate(columnData: any[], allGridData = [], fieldName?): IgxSummaryResult[] { const result = super.operate(allData.map(r => r[fieldName])); result.push({ key: 'test', label: 'Total Undelivered', summaryResult: allData.filter((rec) => rec.Discontinued).length }); return result; } } Summary Template igxSummary targets the column summary providing as a context the column summary results. <igx-column ... [hasSummary]=\"true\"> <ng-template igxSummary let-summaryResults> <span> My custom summary template</span> <span>{{ summaryResults[0].label }} - {{ summaryResults[0].summaryResult }}</span> </ng-template> </igx-column> When a default summary is defined, the height of the summary area is calculated by design depending on the column with the largest number of summaries and the display density of the grid. Use the summaryRowHeight input property to override the default value. As an argument it expects a number value, and setting a falsy value will trigger the default sizing behavior of the grid footer. Note Column summary template could be defined through API by setting the column summaryTemplate property to the required TemplateRef. Formatting summaries By default, summary results, produced by the built-in summary operands, are localized and formatted according to the grid locale and column pipeArgs. When using custom operands, the locale and pipeArgs are not applied. If you want to change the default appearance of the summary results, you may format them using the summaryFormatter property. public dateSummaryFormat(summary: IgxSummaryResult, summaryOperand: IgxSummaryOperand): string { const result = summary.summaryResult; if(summaryOperand instanceof IgxDateSummaryOperand && summary.key !== 'count' && result !== null && result !== undefined) { const pipe = new DatePipe('en-US'); return pipe.transform(result,'MMM YYYY'); } return result; } <igx-column ... [summaryFormatter]=\"dateSummaryFormat\"></igx-column> Child Summaries The Tree Grid supports separate summaries for the root nodes and for each nested child node level. Which summaries are shown is configurable using the summaryCalculationMode property. The child level summaries can be shown before or after the child nodes using the summaryPosition property. Along with these two properties the IgxTreeGrid exposes and showSummaryOnCollapse property which allows you to determine whether the summary row stays visible when the parent node that refers to is collapsed. The available values of the summaryCalculationMode property are: rootLevelOnly - Summaries are calculated only for the root level nodes. childLevelsOnly - Summaries are calculated only for the child levels. rootAndChildLevels - Summaries are calculated for both root and child levels. This is the default value. The available values of the summaryPosition property are: top - The summary row appears before the list of child rows. bottom - The summary row appears after the list of child rows. This is the default value. The showSummaryOnCollapse property is boolean. Its default value is set to false, which means that the summary row would be hidden when the parent row is collapsed. If the property is set to true the summary row stays visible when parent row is collapsed. Note The summaryPosition property applies only for the child level summaries. The root level summaries appear always fixed at the bottom of the Tree Grid. Exporting Summaries There is an exportSummaries option in IgxExcelExporterOptions that specifies whether the exported data should include the grid's summaries. Default exportSummaries value is false. The IgxExcelExporterService will export the default summaries for all column types as their equivalent excel functions so they will continue working properly when the sheet is modified. Try it for yourself in the example below: The exported file includes a hidden column that holds the level of each DataRecord in the sheet. This level is used in the summaries to filter out the cells that need to be included in the summary function. In the table below, you can find the corresponding Excel formula for each of the default summaries. Data Type Function Excel Function string, boolean count =\"Count: \"&COUNTIF(start:end, recordLevel) number, currency, percent count =\"Count: \"&COUNTIF(start:end, recordLevel) min =\"Min: \"&MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)) max =\"Max: \"&MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)) average =\"Avg: \"&AVERAGEIF(start:end, recordLevel, rangeStart:rangeEnd) sum =\"Sum: \"&SUMIF(start:end, recordLevel, rangeStart:rangeEnd) date count =\"Count: \"&COUNTIF(start:end, recordLevel) earliest =\"Earliest: \"& TEXT(MIN(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) latest =\"Latest: \"&TEXT(MAX(IF(start:end=recordLevel, rangeStart:rangeEnd)), format) Known Limitations Limitation Description Exporting custom summaries Custom summaries will be exported as strings instead of Excel functions. Exporting templated summaries Templated summaries are not supported and will be exported as the default ones. Keyboard Navigation The summary rows can be navigated with the following keyboard interactions: UP - navigates one cell up DOWN - navigates one cell down LEFT - navigates one cell left RIGHT - navigates one cell right CTRL + LEFT or HOME - navigates to the leftmost cell CTRL + RIGHT or END - navigates to the rightmost cell Styling To get started with styling the sorting behavior, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-summary-theme and accepts the $background-color, $focus-background-color, $label-color, $result-color, $pinned-border-width, $pinned-border-style and $pinned-border-color parameters. $custom-theme: grid-summary-theme( $background-color: #e0f3ff, $focus-background-color: rgba( #94d1f7, .3 ), $label-color: #e41c77, $result-color: black, $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: #e41c77 ); The last step is to include the component mixins: @include grid-summary($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-summary($custom-theme); } } Defining a color palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $blue-color: #7793b1; $green-color: #00ff2d; $my-custom-palette: palette($primary: $blue-color, $secondary: $green-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-summary-theme( $background-color: color($my-custom-palette, \"primary\", 700), $focus-background-color: color($my-custom-palette, \"primary\", 800), $label-color: color($my-custom-palette, \"secondary\", 500), $result-color: color($my-custom-palette, \"grays\", 900), $pinned-border-width: 2px, $pinned-border-style: dotted, $pinned-border-color: color($my-custom-palette, \"secondary\", 500) ); Note The igx-color and igx-palette are powerful functions for generating and retrieving colors. Please refer to Palettes topic for detailed guidance on how to use them. Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - _light-grid-summary: // Extending the light grid summary schema $my-summary-schema: extend($_light-grid-summary, ( background-color: (igx-color: ('primary', 700)), focus-background-color: (igx-color: ('primary', 800)), label-color: (igx-color: ('secondary', 500)), result-color: (igx-color: ('grays', 900)), pinned-border-width: 2px, pinned-border-style: dotted, pinned-border-color: (igx-color: ('secondary', 500)) ) ); In order to apply our custom schema we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid-summary: $my-summary-schema ) ); // Defining our custom theme with the custom schema $custom-theme: grid-summary-theme( $palette: $my-custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Demo API References IgxTreeGridComponent API IgxTreeGridComponent Styles IgxTreeGridSummaries Styles IgxSummaryOperand IgxNumberSummaryOperand IgxDateSummaryOperand IgxColumnGroupComponent IgxColumnComponent Additional Resources Tree Grid overview Column Data Types Virtualization and Performance Paging Filtering Sorting Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/toolbar.html": {
    "href": "components/treegrid/toolbar.html",
    "title": "Angular Grid Toolbar - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Toolbar The Tree Grid in Ignite UI for Angular provides an IgxGridToolbarComponent which is essentially a container for UI operations. The Angular toolbar is located at the top of the Angular component, i.e the Tree Grid and it matches its horizontal size. The toolbar container can host predefined UI controls for the following Tree Grid's features: Column Hiding Column Pinning Excel Exporting Advanced Filtering or just any other custom content. The toolbar and the predefined UI components support Angular events and expose API for developers. Angular Toolbar Grid Example The predefined actions and title UI components are added inside the <igx-grid-toolbar> and this is all needed to have a toolbar providing default interactions with the corresponding Grid features: <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Tree Grid Toolbar</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering><igx-grid-toolbar-advanced-filtering> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning> <igx-grid-toolbar-exporter></igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-tree-grid> Note: As seen in the code snippet above, the predefined actions UI components are wrapped in the <igx-grid-toolbar-actions> container. This way, the toolbar title is aligned to the left of the toolbar and the actions are aligned to the right of the toolbar. Of course, each of these UIs can be added independently of each other, or may not be added at all. This way the toolbar container will be rendered empty: <igx-tree-grid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"true\"> <igx-grid-toolbar> </igx-grid-toolbar> </igx-tree-grid> For a comprehensive look over each of the default UI components, continue reading the Features section below. Features The toolbar is great at separating logic/interactions which affects the grid as a whole. As shown above, it can be configured to provide default components for controlling, column hiding, column pinning, advanced filtering and exporting data from the grid. These features can be enabled independently from each other by following a pattern similar to the card component of the Ignite UI for Angular suite. Listed below are the main features of the toolbar with example code for each of them. Title Setting a title for the toolbar in your grid is achieved by using the IgxGridToolbarTitleComponent. Users can provide anything from simple text to more involved templates. <igx-grid-toolbar> <igx-grid-toolbar-title>Grid toolbar title</igx-grid-toolbar-title> </igx-grid-toolbar> Actions The toolbar exposes a specific container where users can place actions/interactions in relation to the parent grid. As with the title portion of the toolbar, users can provide anything inside that template part, including the default toolbar interaction components. <igx-grid-toolbar> <igx-grid-toolbar-actions> <button igxButton>Action</button> <igx-select></igx-select> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> Each action now exposes a way to change the overlay settings of the actions dialog by using the overlaySettings input, example: <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning [overlaySettings]=\"overlaySettingsScaleCenter\"></igx-grid-toolbar-pinning> <igx-grid-toolbar-hiding [overlaySettings]=\"overlaySettingsAuto\"></igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> public data: any[]; public positionStrategyScaleCenter = new GlobalPositionStrategy({ openAnimation: scaleInCenter, closeAnimation: scaleOutCenter }); public overlaySettingsScaleCenter = { positionStrategy: this.positionStrategyScaleCenter, scrollStrategy: new AbsoluteScrollStrategy(), modal: true, closeOnEscape: true }; public positionStrategyAuto = new AutoPositionStrategy(); public overlaySettingsAuto = { positionStrategy: this.positionStrategyAuto, scrollStrategy: new AbsoluteScrollStrategy(), modal: false, closeOnEscape: false }; constructor() { this.data = athletesData; } The default overlaySettings are using ConnectedPositionStrategy with Absolute scroll strategy, modal set to false, with enabled close on escape and close on outside click interactions. Column pinning Toolbar Pinning component provides the default UI for interacting with column pinning in the grid. The component is setup to work out of the box with the parent grid containing the toolbar as well as several input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-pinning title=\"Grid pinned columns\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-pinning> </igx-grid-toolbar-actions> </igx-grid-toolbar> Column hiding Toolbar Hiding component provides the default UI for interacting with column hiding. Exposes the same input properties for customizing the UI, such as the component title, the placeholder for the component input and the height of the dropdown itself. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding title=\"Grid column hiding\" prompt=\"Filter column collection\" columnListHeight=\"400px\" > </igx-grid-toolbar-hiding> </igx-grid-toolbar-actions> </igx-grid-toolbar> Advanced filtering Toolbar Advanced Filtering component provides the default UI for the Advanced Filtering feature. The component exposes a way to change the default text of the button. <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-advanced-filtering>Custom text for the toggle button</igx-grid-toolbar-advanced-filtering> </igx-grid-toolbar-actions> </igx-grid-toolbar> Data exporting As with the rest of the toolbar actions, exporting is provided through a Toolbar Exporter component out of the box. The exporting component is using the respective service for the target data format (Excel CSV). That means if the respective service is not provided through the dependency injection chain, the component won't be able to export anything. If you need a refresher on the DI in Angular, check the official guide. Here is a sample snippet showing how to enable all export services for your application. // app.module.ts import { IgxExcelExporterService, IgxCsvExporterService } from 'igniteui-angular'; // import { IgxExcelExporterService, IgxCsvExporterService } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ ... providers: [IgxExcelExporterService, IgxCsvExporterService ] }) export class AppModule { ... } Note In v12.2.1 and later, the exporter services are provided in root, which means you no longer need to declare them in the AppModule providers. The toolbar exporter component exposes several input properties for customizing both the UI and the exporting experience. These range from changing the display text, to enabling/disabling options in the dropdown to customizing the name of the generated file. For full reference, consult the API documentation for the toolbar exporter component. Here is a snippet showing some of the options which can be customized through the Angular template: <igx-grid-toolbar> <igx-grid-toolbar-actions> <igx-grid-toolbar-exporter <!-- If active, enables the csv export entry in the dropdown UI --> [exportCSV]=\"csvExportEnabled\" <!-- If active, enables the excel export entry in the dropdown UI --> [exportExcel]=\"excelExportEnabled\" <!-- The name of the generated export file without the file extension --> filename=\"exported_data\" > Custom text for the exporter button <span excelText>Custom text for the excel export entry</span> <span csvText>Custom text for the CSV export entry</span> </igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> In addition to changing the exported filename, the user can further configure the exporter options by waiting for the toolbarExporting event and customizing the options entry in the event properties. Note By default when exporting to CSV the exporter exports using a comma separator and uses a '.csv' extension for the output file. You can customize these exporting parameters by subscribing to events of the exporter or changing the values of the exporter options fields. You can also cancel the export process by setting the cancel field of the event args to true. The following code snippet demonstrates subscribing to the toolbar exporting event and configuring the exporter options: <igx-tree-grid (toolbarExporting)=\"configureExport($event)\" ></igx-tree-grid> configureExport(args: IGridToolbarExportEventArgs) { const options: IgxExporterOptionsBase = args.options; options.fileName = `Report_${new Date().toDateString()}`; if (options instanceof IgxExcelExporterOptions) { options.columnWidth = 10; } else { options.fileType = CsvFileTypes.TSV; options.valueDelimiter = '\\t'; } args.exporter.columnExporting.subscribe((columnArgs: IColumnExportingEventArgs) => { // Don't export image field columnArgs.cancel = columnArgs.header === 'Name'; }); } The following sample demonstrates how to customize the exported files: Exporting Indicator When using the default toolbar exporter component, whenever an export operation takes place the toolbar will show a progress indicator while the operation is in progress. Moreover, users can set the toolbar showProgress property and use for their own long running operations or just as another way to signify an action taking place in the grid. The sample belows uses has significant amount of data, in order to increase the time needed for data export so the progressbar can be seen. Additionally it has another button that simulates a long running operation in the grid: Custom Content Note This replaces the old toolbar template directive. If you are migrating from a version before v11 our migrations will handle the moving of the template content. However, we do not handle the bindings in the template, so make sure to double check the modified template files after the migration completes. If the actions part of the toolbar component is not sufficient for a particular use case, the toolbar itself has a general content projection where users can provide additional UI. If the user needs the respective grid instance for API calls or bindings, they can create a template reference variable. Here is a sample snippet: <igx-tree-grid #gridRef ...> ... <igx-grid-toolbar> <igx-grid-toolbar-title>{{ titleBinding }}</igx-grid-toolbar-title> <!-- Everything between the toolbar tags except the default toolbar components/directives will be projected as custom content. --> <button igxButton=\"flat\" igxRipple (click)=\"#gridRef.clearSort()\"> <igx-icon fontSet=\"material\">clear</igx-icon> Clear Sort </button> <igx-grid-toolbar-actions> ... </igx-grid-toolbar-actions> </igx-grid-toolbar> </igx-tree-grid> The following sample demonstrates how to add an additional button to the toolbar to clear the sorting set by clicking on the columns' headers: Styling To get started with styling the toolbar, we need to import the index file, where all the theme functions and component mixins live: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; First, let's create a new palette. $my-dark-palette: palette( $primary: #2466ff, $secondary: #FFCD0F, $surface: #2a2b2f, $grays: #fff, ); $my-dark-color: color($my-dark-palette, 'surface'); Now, create a new theme that extends the grid-toolbar-theme and modify the $background-color and the $title-text-color parameters. $dark-grid-toolbar-theme: grid-toolbar-theme( $palette: $my-dark-palette, $background-color: $my-dark-color, $title-text-color: color($my-dark-palette, 'secondary'), $dropdown-background: $my-dark-color, ); To theme the column actions menus of the toolbar, we have to change the theme of the column-actions-theme component. $dark-column-actions-theme: column-actions-theme( $palette: $my-dark-palette, $title-color: color($my-dark-palette, 'secondary'), $background-color: color($my-dark-palette, 'surface') ); Since the column actions are using other components - igx-button, igx-checkbox, and igx-input-group, we need to change their themes to match our new toolbar theme. $dark-button-theme: button-theme( $palette: $my-dark-palette, $outlined-background: color($my-dark-palette, 'secondary'), $outlined-hover-background: color($my-dark-palette, 'grays', 100), $outlined-hover-text-color: color($my-dark-palette, 'secondary') ); $dark-checkbox-theme: checkbox-theme( $palette: $my-dark-palette, $tick-color: $my-dark-color, ); $dark-input-group-theme: input-group-theme( $palette: $my-dark-palette ); The last step is to include the newly created themes. :host { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } Note If $legacy-support is set to false(default), include the component css variables like that: :host { @include css-vars($dark-grid-toolbar-theme); @include css-vars($dark-column-actions-theme); @include css-vars($dark-checkbox-theme); @include css-vars($dark-input-group-theme); @include css-vars($dark-button-theme); } Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid-toolbar($dark-grid-toolbar-theme); @include column-actions($dark-column-actions-theme); @include checkbox($dark-checkbox-theme); @include input-group($dark-input-group-theme); @include button($dark-button-theme); } } Demo API References The Grid Toolbar service has a few more APIs to explore, which are listed below. IgxGridToolbarActionsComponent IgxGridToolbarAdvancedFilteringComponent IgxGridToolbarComponent IgxGridToolbarExporterComponent IgxGridToolbarHidingComponent IgxGridToolbarPinningComponent IgxGridToolbarTitleComponent IgxTreeGridComponent events: toolbarExporting Styles: IgxTreeGridComponent Styles Additional Resources Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/tree-grid.html": {
    "href": "components/treegrid/tree-grid.html",
    "title": "Angular Tree Grid | Fastest Angular Tree Table | Infragistics",
    "keywords": "Angular Tree Grid Component Overview The Ignite UI for Angular Tree Grid is used to display and manipulate hierarchical or flat self-referencing data. Quickly bind your data with very little code or use a variety of events to customize different behaviors. This component provides a rich set of features like data selection, excel style filtering, sorting, paging, grouping, templating, column moving, column pinning, export to Excel and CSV, and more. Angular Tree Grid Example In this example, you can see how users can display hierarchical data. We have included filtering and sorting options, pinning and hiding, row selection, export to excel and csv, and cell templating that uses our Sparkline component. In addition, you can see an example of custom pagination with Angular Pagination. Getting Started with Ignite UI for Angular Tree Grid To get started with the Ignite UI for Angular Tree Grid component, first you need to install Ignite UI for Angular. In an existing Angular application, type the following command: ng add igniteui-angular For a complete introduction to the Ignite UI for Angular, read the getting started topic. The next step is to import the IgxTreeGridModule in your app.module.ts file. // app.module.ts import { IgxTreeGridModule } from 'igniteui-angular'; // import { IgxTreeGridModule } from '@infragistics/igniteui-angular'; for licensed package @NgModule({ imports: [ ... IgxTreeGridModule, ... ] }) export class AppModule {} Alternatively, as of 16.0.0 you can import the IgxTreeGridComponent as a standalone dependency, or use the IGX_TREE_GRID_DIRECTIVES token to import the component and all of its supporting components and directives. // home.component.ts import { IGX_TREE_GRID_DIRECTIVES } from 'igniteui-angular'; // import { IGX_TREE_GRID_DIRECTIVES } from '@infragistics/igniteui-angular'; for licensed package @Component({ selector: 'app-home', template: '<igx-tree-grid [data]=\"data\"></igx-tree-grid>', styleUrls: ['home.component.scss'], standalone: true, imports: [IGX_TREE_GRID_DIRECTIVES] /* or imports: [IgxTreeGridComponent] */ }) export class HomeComponent { public data: Employee []; } Now that you have the Ignite UI for Angular Tree Grid module or directives imported, you can start using the igx-tree-grid component. Using the Angular Tree Grid Note This component requires HammerModule to be imported in the root module of the application in order for touch interactions to work as expected.. The IgxTreeGridComponent shares a lot of features with the IgxGridComponent, but it also adds the ability to display its data hierarchically. In order to achieve this, the IgxTreeGridComponent provides us with a couple of ways to define the relations among our data objects - by using a child collection for every data object or by using primary and foreign keys for every data object. Tree Cells Regardless of which option is used for building the tree grid's hierarchy (child collection or primary and foreign keys), the tree grid's rows are constructed of two types of cells: IgxGridCell - Ordinary cell that contains a value. IgxGridCell - Tree cell that contains a value, an expand/collapse indicator and an indentation div element, which is based on the level of the cell's row. The level of a row component can be accessed through the level property of its inner treeRow. Note Each row can have only one tree cell, but it can have multiple (or none) ordinary cells. Initial Expansion Depth Initially the tree grid will expand all node levels and show them. This behavior can be configured using the expansionDepth property. By default its value is Infinity which means all node levels will be expanded. You may control the initial expansion depth by setting this property to a numeric value. For example 0 will show only root level nodes, 1 will show root level nodes and their child nodes and so on. Child Collection When we are using the child collection option, every data object contains a child collection, that is populated with items of the same type as the parent data object. This way every record in our tree grid will have a direct reference to any of its children. In this case the data property of our tree grid that contains the original data source will be a hierarchically defined collection. For this sample, let's use the following collection structure: // Sample Employee Data export const EMPLOYEE_DATA = [ { Name: \"Johnathan Winchester\", ID: 1, HireDate: new Date(2008, 3, 20), Age: 55, Employees: [ { Name: \"Michael Burke\", ID: 3, HireDate: new Date(2011, 6, 3), Age: 43, Employees: [] }, { Name: \"Thomas Anderson\" ID: 2, HireDate: new Date(2009, 6, 19), Age: 29, Employees: [] }, ... ] }, ... ] Now let's start by importing our data collection and binding it to the data input of our tree grid. <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"localData\"> </igx-tree-grid> In order for the IgxTreeGridComponent to build the hierarchy, we will have to set its childDataKey property to the name of the child collection that is used in each of our data objects. In our case that will be the Employees collection. In addition, we will disable the automatic column generation and define them manually by matching them to the actual properties of our data objects. (The Employees collection will be automatically used for the hierarchy, so there is no need to include it in the columns' definitions.) <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"localData\" childDataKey=\"Employees\" [autoGenerate]=\"false\"> <igx-column field=\"Name\" dataType=\"string\"></igx-column> <igx-column field=\"HireDate\" dataType=\"date\"></igx-column> <igx-column field=\"Age\" dataType=\"number\"></igx-column> </igx-tree-grid> We will now enable the row selection and paging features of the tree grid by using the rowSelection and the paging properties. We will also enable the summaries feature on the first column and the filtering, sorting, editing, moving and resizing features for each of our columns. <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"localData\" childDataKey=\"Employees\" [autoGenerate]=\"false\" [rowSelection]=\"'multiple'\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column field=\"Name\" dataType=\"string\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\" [hasSummary]=\"true\"></igx-column> <igx-column field=\"HireDate\" dataType=\"date\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-paginator> </igx-paginator> </igx-tree-grid> Finally, we will enable the toolbar of our tree grid, along with the column hiding, column pinning and exporting features by using the IgxGridToolbarComponent, IgxGridToolbarHidingComponent, IgxGridToolbarPinningComponent and IgxGridToolbarExporterComponent respectively. <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"localData\" childDataKey=\"Employees\" [autoGenerate]=\"false\" [rowSelection]=\"'multiple'\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-grid-toolbar> <igx-grid-toolbar-title>Employees</igx-grid-toolbar-title> <igx-grid-toolbar-actions> <igx-grid-toolbar-hiding></igx-grid-toolbar-hiding> <igx-grid-toolbar-pinning></igx-grid-toolbar-pinning> <igx-grid-toolbar-exporter></igx-grid-toolbar-exporter> </igx-grid-toolbar-actions> </igx-grid-toolbar> <igx-column field=\"Name\" dataType=\"string\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"HireDate\" dataType=\"date\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-paginator [perPage]=\"6\"> </igx-paginator> </igx-tree-grid> You can see the result of the code from above at the beginning of this article in the Angular Tree Grid Example section. Primary and Foreign keys When we are using the primary and foreign keys option, every data object contains a primary key and a foreign key. The primary key is the unique identifier of the current data object and the foreign key is the unique identifier of its parent. In this case the data property of our tree grid that contains the original data source will be a flat collection. The following is an example of a component which contains a flat collection defined with primary and foreign keys relation: // treeGridSample.component.ts @Component({...}) export class MyComponent implements OnInit { public data: any[]; constructor() { } public ngOnInit() { // Primary and Foreign keys sample data this.data = [ { ID: 1, ParentID: -1, Name: \"Casey Houston\", JobTitle: \"Vice President\", Age: 32 }, { ID: 2, ParentID: 1, Name: \"Gilberto Todd\", JobTitle: \"Director\", Age: 41 }, { ID: 3, ParentID: 2, Name: \"Tanya Bennett\", JobTitle: \"Director\", Age: 29 }, { ID: 4, ParentID: 2, Name: \"Jack Simon\", JobTitle: \"Software Developer\", Age: 33 }, { ID: 5, ParentID: 8, Name: \"Celia Martinez\", JobTitle: \"Senior Software Developer\", Age: 44 }, { ID: 6, ParentID: -1, Name: \"Erma Walsh\", JobTitle: \"CEO\", Age: 52 }, { ID: 7, ParentID: 2, Name: \"Debra Morton\", JobTitle: \"Associate Software Developer\", Age: 35 }, { ID: 8, ParentID: 10, Name: \"Erika Wells\", JobTitle: \"Software Development Team Lead\", Age: 50 }, { ID: 9, ParentID: 8, Name: \"Leslie Hansen\", JobTitle: \"Associate Software Developer\", Age: 28 }, { ID: 10, ParentID: -1, Name: \"Eduardo Ramirez\", JobTitle: \"Development Manager\", Age: 53 } ]; } } In the sample data above, all records have an ID, a ParentID and some additional properties like Name, JobTitle and Age. As mentioned previously, the ID of the records must be unique. The ParentID contains the ID of the parent node. If a row has a ParentID that does not match any row in the tree grid, then that means this row is a root row. The parent-child relation is configured using the tree grid's primaryKey and foreignKey properties. Here is the template of the component which demonstrates how to configure the tree grid to display the data defined in the above flat collection: <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\"> <igx-column field=\"Name\" dataType=\"string\"></igx-column> <igx-column field=\"JobTitle\" dataType=\"string\"></igx-column> <igx-column field=\"Age\" dataType=\"number\"></igx-column> </igx-tree-grid> In addition we will enable the row selection feature of the tree grid by using the rowSelection property and also the filtering, sorting, editing, moving and resizing features for each of our columns. <!--treeGridSample.component.html--> <igx-tree-grid #treeGrid [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [autoGenerate]=\"false\" [rowSelection]=\"'multiple'\" [allowFiltering]=\"true\" [moving]=\"true\"> <igx-column field=\"Name\" dataType=\"string\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"JobTitle\" dataType=\"string\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> <igx-column field=\"Age\" dataType=\"number\" [sortable]=\"true\" [editable]=\"true\" [resizable]=\"true\"></igx-column> </igx-tree-grid> And here is the final result: Persistence and Integration The indentation of the tree cells persists across other tree grid features like filtering, sorting and paging. When sorting is applied on a column, the data rows get sorted by levels. This means that the root level rows will be sorted independently from their respective children. Their respective children collections will each be sorted independently as well and so on. The first column (the one that has a visibleIndex of 0) is always the tree column. The column that ends up with a visibleIndex of 0 after operations like column pinning, column hiding and column moving becomes the tree column. Exported Excel worksheets reflect the hierarchy by grouping the records as they are grouped in the tree grid itself. All records expanded states would also be persisted and reflected. When exporting to CSV, levels and expanded states are ignored and all data is exported as flat. Angular Tree Grid Sizing See the Grid Sizing topic. Angular Tree Grid Styling The Tree Grid allows styling through the Ignite UI for Angular Theme Library. The tree grid's theme exposes a wide variety of properties, which allows the customization of all the tree grid's features. To get started with styling the Tree Grid, we need to import the index file, where all the theme functions and component mixins live: @import '~igniteui-angular/lib/core/styles/themes/index'; Following the simplest approach, we create a new theme that extends the grid-theme and accepts the parameters, required to customize the tree grid as desired. Note There is no specific sass tree grid function. $custom-theme: grid-theme( $cell-active-border-color: #FFCD0F, $cell-selected-background: #6F6F6F, $row-hover-background: #F8E495, $row-selected-background: #8D8D8D, $header-background: #494949, $header-text-color: #FFF, $expand-icon-color: #FFCD0F, $expand-icon-hover-color: #E0B710, $resize-line-color: #FFCD0F, $row-highlight: #FFCD0F ); The last step is to include the component theme in our application. @include grid($custom-theme); Note If the component is using an Emulated ViewEncapsulation, it is necessary to penetrate this encapsulation using ::ng-deep: :host { ::ng-deep { @include grid($custom-theme); } } Defining a Color Palette Instead of hardcoding the color values like we just did, we can achieve greater flexibility in terms of colors by using the igx-palette and igx-color functions. igx-palette generates a color palette based on the primary and secondary colors that are passed: $yellow-color: #FFCD0F; $black-color: #494949; $custom-palette: palette($primary: $black-color, $secondary: $yellow-color); And then with igx-color we can easily retrieve color from the palette. $custom-theme: grid-theme( $cell-active-border-color: color($custom-palette, \"secondary\", 500), $cell-selected-background: color($custom-palette, \"primary\", 300), $row-hover-background: color($custom-palette, \"secondary\", 100), $row-selected-background: color($custom-palette, \"primary\", 100), $header-background: color($custom-palette, \"primary\", 500), $header-text-color:contrast-color($custom-palette, \"primary\", 500), $expand-icon-color: color($custom-palette, \"secondary\", 500), $expand-icon-hover-color: color($custom-palette, \"secondary\", 600), $resize-line-color: color($custom-palette, \"secondary\", 500), $row-highlight: color($custom-palette, \"secondary\", 500) ); Using Schemas Going further with the theming engine, you can build a robust and flexible structure that benefits from schemas. A schema is a recipe of a theme. Extend one of the two predefined schemas, that are provided for every component, in this case - light-grid schema: // Extending the light tree grid schema $custom-grid-schema: extend($_light-grid, ( cell-active-border-color: (igx-color:('secondary', 500)), cell-selected-background: (igx-color:('primary', 300)), row-hover-background: (igx-color:('secondary', 100)), row-selected-background: (igx-color:('primary', 100)), header-background: (igx-color:('primary', 500)), header-text-color: (igx-contrast-color:('primary', 500)), expand-icon-color: (igx-color:('secondary', 500)), expand-icon-hover-color: (igx-color:('secondary', 600)), resize-line-color: (igx-color:('secondary', 500)), row-highlight: (igx-color:('secondary', 500)) )); In order to apply our custom schemas we have to extend one of the globals (light or dark), which is basically pointing out the components with a custom schema, and after that add it to the respective component themes: // Extending the global light-schema $my-custom-schema: extend($light-schema, ( igx-grid: $custom-grid-schema )); // Defining grid-theme with the global light schema $custom-theme: grid-theme( $palette: $custom-palette, $schema: $my-custom-schema ); Don't forget to include the themes in the same way as it was demonstrated above. Angular Tree Grid Styling Demo Note The sample will not be affected by the selected global theme from Change Theme. Performance (Experimental) The igxTreeGrid's design allows it to take advantage of the Event Coalescing feature that has Angular introduced. This feature allows for improved performance with roughly around 20% in terms of interactions and responsiveness. This feature can be enabled on application level by simply setting the ngZoneEventCoalescing and ngZoneRunCoalescing properties to true in the bootstrapModule method: platformBrowserDynamic() .bootstrapModule(AppModule, { ngZoneEventCoalescing: true, ngZoneRunCoalescing: true }) .catch(err => console.error(err)); Note This is still in experimental feature for the igxTreeGrid. This means that there might be some unexpected behaviors in the Tree Grid. In case of encountering any such behavior, please contact us on our Github page. Note Enabling it can affects other parts of an Angular application that the igxTreeGrid is not related to. Known Limitations Limitation Description Templating Tree Cells When templating a tree cell, content that spans outside the boundaries of the cell will not be shown unless positioned in an overlay. Group By Group By feature is not supported, because it is inherent to the tree grid. Note The tree grid has a depth limit of 25 levels. Supporting more levels requires adding custom CSS classes in the application. You may see an example of such CSS class below: .igx-grid__tree-cell--padding-level-26 { padding-left: 39rem; } Note igxTreeGrid uses igxForOf directive internally hence all igxForOf limitations are valid for igxTreeGrid. For more details see igxForOf Known Issues section. API References IgxTreeGridComponent IgxGridCell IgxTreeGridRow IgxGridComponent IgxGridComponent Styles IgxBaseTransactionService Theming Dependencies IgxIcon Theme IgxInputGroup Theme IgxChip Theme IgxRipple Theme IgxButton Theme IgxOverlay Theme IgxDropDown Theme IgxCalendar Theme IgxSnackBar Theme IgxBadge Theme Additional Resources Grid Sizing Data Grid Row Editing Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/validation.html": {
    "href": "components/treegrid/validation.html",
    "title": "Editing and Validation in Angular Tree Grid - Infragistics",
    "keywords": "Angular Tree Grid Editing and Validation The Tree Grid's editing exposes a built-in validation mechanism of user input when editing cells/rows. It extends the Angular Form validation functionality to allow easier integration with a well known functionality. When the state of the editor changes, visual indicators are applied to the edited cell. Configuration Configure via template-driven configuration We extend some of the Angular Forms validator directives to directly work with the IgxColumn. The same validators are available as attributes to be set declaratively in igx-column. The following validators are supported out-of-the-box: required min max email minlength maxlength pattern To validate that a column input would be set and the value is going to be formatted as an email, you can use the related directives: <igx-column [field]=\"email\" [header]=\"User E-mail\" required email></igx-column> The following sample demonstrates how to use the prebuilt required, email and min validator directives in a Tree Grid. Configure via reactive forms We expose the FormGroup that will be used for validation when editing starts on a row/cell via a formGroupCreated event. You can modify it by adding your own validators for the related fields: <igx-tree-grid (formGroupCreated)='formCreateHandler($event)' ...> public formCreateHandler(args: IGridFormGroupCreatedEventArgs) { const formGroup = args.formGroup; const hireDateRecord = formGroup.get('HireDate'); hireDateRecord.addValidators([this.futureDateValidator(), this.pastDateValidator()]); } You can decide to write your own validator function, or use one of the built-in Angular validator functions. Validation service API The grid exposes a validation service via the validation property. That service has the following public APIs: valid - returns if the grid validation state is valid. getInvalid - returns records with invalid states. clear - clears state for record by id or clears all state if no id is provided. markAsTouched - marks the related record/field as touched. Invalid states will persis until the validation errors in them are fixed according to the validation rule or they are cleared. Validation triggers Validation will be triggered in the following scenarios: While editing via the cell editor based on the grid's validationTrigger. Either on change while typing in the editor, or on blur when the editor loses focus or closes. When updating cells/rows via the API - updateRow, updateCell etc.. When using batch editing and the undo/redo API of the transaction service. Note: Validation will not trigger for records that have not been edited via user input or via the editing API. Visual indicators on the cell will only shown if the related input is considered touched - either via user interaction or via the markAsTouched API of the validation service. Angular Tree Grid Validation Customization Options Set a custom validator You can define your own validation directive to use on a <igx-column> in the template. @Directive({ selector: '[phoneFormat]', providers: [{ provide: NG_VALIDATORS, useExisting: PhoneFormatDirective, multi: true }] }) export class PhoneFormatDirective extends Validators { @Input('phoneFormat') public phoneFormatString = ''; public validate(control: AbstractControl): ValidationErrors | null { return this.phoneFormatString ? phoneFormatValidator(new RegExp(this.phoneFormatString, 'i'))(control) : null; } } Once it is defined and added in your app module you can set it declaratively to a given column in the grid: <igx-column phoneFormat=\"\\+\\d{1}\\-(?!0)(\\d{3})\\-(\\d{3})\\-(\\d{4})\\b\" ...> Change default error template You can define your own custom error template that will be displayed in the error tooltip when the cell enters invalid state. This is useful in scenarios where you want to add your own custom error message or otherwise change the look or content of the message. <igx-column ... > <ng-template igxCellValidationError let-cell='cell' let-defaultErr=\"defaultErrorTemplate\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> <div *ngIf=\"cell.validation.errors?.['phoneFormat']\"> Please enter correct phone format </div> </ng-template> </igx-column> Prevent exiting edit mode on invalid state In some cases you may want to disallow submitting an invalid value in the data. In that scenarios you can use the cellEdit or rowEdit events and cancel the event in case the new value is invalid. Both events' arguments have a valid property and can be canceled accordingly. How it is used can be seen in the Cross-field Validation example <igx-tree-grid (cellEdit)='cellEdit($event)' ...> public cellEdit(evt) { if (!evt.valid) { evt.cancel = true; } } Example The below example demonstrates the above-mentioned customization options. Cross-field validation In some scenarios validation of one field may depend on the value of another field in the record. In that case a custom validator can be used to compare the values in the record via their shared FormGroup. The below sample demonstrates a cross-field validation between different field of the same record. It checks that a specified City for a person is in the Country currently set and vice versa. Also check if the age for a person was 18 already when it was hired. The next lines of code show the cross-field validator function, which contains comparisons described above and sets the related errors. private rowValidator(): ValidatorFn { return (formGroup: FormGroup): ValidationErrors | null => { let returnObject = {}; const age = formGroup.get('Age'); const hireDate = formGroup.get('HireDate'); if((new Date().getFullYear() - new Date(hireDate.value).getFullYear()) + 18 >= age.value) { returnObject['ageLessHireDate'] = true; } const city = formGroup.get('City'); const country = formGroup.get('Country'); const validCities = this.countryData.get(country.value); if (!validCities || !validCities[city.value]) { returnObject['invalidAddress'] = true; } return returnObject; }; } The cross-field validator can be added to the formGroup of the row from formGroupCreated event, which returns the new formGroup for each row when entering edit mode: <igx-tree-grid igxPreventDocumentScroll #treeGrid [batchEditing]=\"true\" [data]=\"data\" primaryKey=\"ID\" foreignKey=\"ParentID\" [width]=\"'100%'\" [height]=\"'500px'\" [rowEditable]=\"true\" [pinning]=\"pinningConfig\" (formGroupCreated)=\"formCreateHandler($event)\"> <!-- ... --> </igx-tree-grid> public formCreateHandler(evt: IGridFormGroupCreatedEventArgs) { evt.formGroup.addValidators(this.rowValidator()); } The different errors are displayed in a templated cell that combines all errors in a single tooltip. Depending on the row valid state different icon is displayed: <igx-column field=\"row_valid\" header=\" \" [editable]=\"false\" [dataType]=\"'number'\" [pinned]=\"true\" [width]=\"'150px'\"> <ng-template igxCell let-cell=\"cell\"> <div *ngIf=\"isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" style=\"margin: 'auto';\"> <img width=\"18\" src=\"assets/images/grid/active.png\"/> </div> <div *ngIf=\"!isRowValid(cell)\" [igxTooltipTarget]=\"tooltipRef\" style=\"margin: 'auto';\"> <img width=\"18\" src=\"assets/images/grid/expired.png\"/> </div> <div #tooltipRef=\"tooltip\" igxTooltip [style.width]=\"'max-content'\"> <div *ngFor=\"let message of stateMessage(cell)\"> {{message}} </div> </div> </ng-template> </igx-column> The error messages are gathered in the stateMessage function, which gathers the errors for each cell, because each column could have templated form validations and then checks the errors for the row itself, which come from the custom rowValidator. public stateMessage(cell: CellType) { const messages = []; const row = cell.row; const cellValidationErrors = row.cells.filter(x => !!x.validation.errors); cellValidationErrors.forEach(cell => { if (cell.validation.errors) { if (cell.validation.errors.required) { messages.push(`The \\`${cell.column.header}\\` column is required.`); } // Other cell errors... } }); if (row.validation.errors?.ageLessHireDate) { messages.push(`\\`Age\\` cannot be less than 18 when the person was hired.`); } if (row.validation.errors?.invalidAddress) { messages.push(`Selected \\`City\\` does not match the \\`Country\\`.`); } if (messages.length === 0 && this.isRowValid(cell)) { messages.push('OK'); } return messages; } Cross-field example The below sample demonstrates the cross-field validation in action. Styling Using the Ignite UI for Angular Theme Library, we can alter the default validation styles while editing. In the example below, we will make use of the exposed template for validation message, which pops out in a tooltip and overriding the error color to modify the default looks of the validation. We will also style the background of the invalid rows to make them more distinct. Import theme The easiest way to style and access css variables is to define styles in our app's global style file (typically styles.scss). The first thing we need to do is import the themes/index file - this gives us access to all the powerful tools of the Ignite UI for Angular Sass framework: @use \"igniteui-angular/theming\" as *; // IMPORTANT: Prior to Ignite UI for Angular version 13 use: // @import '~igniteui-angular/lib/core/styles/themes/index'; Include the styles In order to change the error color you can use the css variable --igx-error-500: --igx-error-500: 34, 80%, 63%; Custom Templates Changing the default error template allows setting custom classes and styles: <ng-template igxCellValidationError let-cell='cell' let-defaultErr='defaultErrorTemplate'> <div class=\"validator-container\"> <ng-container *ngTemplateOutlet=\"defaultErr\"> </ng-container> </div> </ng-template> Invalid row and cell styles Rows and cells provide API for the developers to know if a row or cell is invalid and what kind of errors are active. public rowStyles = { background: (row: RowType) => row.cells.find(c => c.validation.errors !== null && c.validation.errors !== undefined) ? '#FF000033' : '#00000000' }; public cellStyles = { 'invalid-cell': (rowData, columnKey) => { const pKey = this.treeGrid.primaryKey; const cell = this.treeGrid.getCellByKey(rowData[pKey], columnKey); return cell && cell.validation.status === 'INVALID'; } } <igx-tree-grid [rowStyles]=\"rowStyles\"> <igx-column *ngFor=\"let c of columns\" [field]=\"c.field\" [dataType]=\"c.dataType\" [header]=\"c.label\" [required]=\"c.required\" [cellClasses]=\"cellStyles\"> Demo API References IgxBaseTransactionService IgxGridComponent IgxColumnComponent Known Issues and Limitations Limitation Description When validationTrigger is blur, editValue and validation will trigger only after editor is blurred. Reason is that this utilizes the formControl's updateOn property. This determines the event on which the formControl will update and trigger related validators. Additional Resources Build CRUD operations with igxGrid Tree Grid Overview Tree Grid Editing Tree Grid Row Editing Tree Grid Row Adding Tree Grid Transactions Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/treegrid/virtualization.html": {
    "href": "components/treegrid/virtualization.html",
    "title": "Angular Grid Virtualization and Performance - Ignite UI for Angular",
    "keywords": "Angular Tree Grid Virtualization and Performance In Ignite UI for Angular, the IgxTreeGrid control now utilizes the igxForOf directive and virtualizes its content both vertically and horizontally. Enabling Virtualization By utilizing the igxForOf directive the IgxTreeGrid now optimizes DOM rendering and memory consumption by rendering only what is currently visible in the view port and swapping the displayed data while the user scrolls the data horizontally/vertically. IgxTreeGrid's width and height defaults to 100% which will enable virtualization if the content displayed cannot fit inside the available space and scrollbars are required either vertically or horizontally. However, it is also possible to explicitly set the Tree Grid's width and/or height to null which means that the related dimension will be determined by the total size of the items inside. No scrollbar will then be shown and all items will be rendered along the respective dimension (columns if width is null and rows if height is null). The size of the data chunks is determined by: The row height for the vertical (row) virtualization. This is determined by the rowHeight option and is 50(px) by default. The individual column widths in pixels for the horizontal (column) virtualization. They can be determined by either setting explicit width for each column component or setting the Tree Grid's columnWidth option, which will be applied to all columns that don't have explicit width set. In most cases, letting the grid apply its default behavior by leaving dimensions unset will produce the desired layout. For column widths it is determined by the column count, the columns with set width, and the calculated width of the Tree Grid's container. The grid will try to fit all columns inside the available space as long as the width it attempts to assign is not under 136(px). In such cases, columns with unassigned width will receive the minimum width of 136(px) and a horizontal scrollbar will be shown. The grid will be horizontally virtualized. Explicitly setting column widths in percentages (%) will, in most cases, create a grid that is not virtualized horizontally as it will not have a horizontal scrollbar. Virtualization Limitations On Mac OS horizontal scrollbar is not visible when \"Show scrollbars only when scrolling\" system option is set to true (which is the default value). This is because the Tree Grid’s row container has an overflow set to hidden. Change the option to \"Always\" and the scrollbar will appear. FAQ Why having dimensions in the Tree Grid is necessary for virtualization to work? Without information about the sizes of the container and the items before rendering them setting the width or height of a scrollbar or determining which of the items should be in the view when you scroll to a random location in the Tree Grid is erroneous. Any assumptions on what the actual dimensions might be could lead to unnatural behavior of the scrollbar and ultimately suboptimal experience for the end-user. This is why setting the related dimensions is enforced in order for virtualization to take effect. API References IgxTreeGridComponent IgxTreeGridComponent Styles IgxColumnComponent IgxForOfDirective IForOfState Additional Resources Tree Grid overview Paging Filtering Sorting Summaries Column Moving Column Pinning Column Resizing Selection Our community is active and always welcoming to new ideas. Ignite UI for Angular Forums Ignite UI for Angular GitHub View page on GitHub"
  },
  "components/zoomslider-overview.html": {
    "href": "components/zoomslider-overview.html",
    "title": "Angular ZoomSlider | Data Visualization Tools | Navigation | Zooming | DataChart | Data Binding | Infragistics",
    "keywords": "Angular Zoom Slider Overview The Angular ZoomSlider control provides zooming functionality to range-enabled controls. The ZoomSlider features a horizontal scroll bar, a thumbnail of the whole range, and a resizable zoom-range window. The ZoomSlider cannot work as a standalone control and it acts as an enhancement for range-based controls like the DataChart or CategoryChart. Angular Zoom Slider Example The following sample demonstrates how to use IgxZoomSliderComponent to navigate content in IgxDataChartComponent. Usage Feature Name Description Scrollbar navigation Users can change scale and scroll through ranges of data using the built-in capabilities of the ZoomSlider scrollbar. Panning and zooming Users can adjust the display scale by dragging the edges of the thumb pad to either make the current display cover a larger range (zoom out) or a smaller range (zoom in). Multiple user interaction options All mouse user interactions are redundantly supported through touch and most of them – through the keyboard. For details, see User Interactions and Usability. Touch support On touch-enabled devices, users can enjoy the full ZoomSlider functionality. All mouse interactions are supported in touch environment. Extensibility The ZoomSlider control supports DataChart control out-of the box. Configurable zoom-range window The initial zoom-range window width and position, as well as its minimum size, are configurable. Dependencies When installing the Angular chart component, the core package must also be installed. npm install --save igniteui-angular-core npm install --save igniteui-angular-charts Component Modules The IgxZoomSliderComponent requires the following modules: import { IgxZoomSliderModule } from 'igniteui-angular-charts'; import { IgxZoomSliderComponent } from 'igniteui-angular-charts'; @NgModule({ imports: [ // ... IgxZoomSliderModule, // ... ] }) export class AppModule {} Code Snippet The following code demonstrates how to setup the ZoomSlider. <igx-zoom-slider width=\"100%\" height=\"150px\"> </igx-zoom-slider> Additional Resources You can find more information about charts in Chart Features topic. API References The following is a list of API members mentioned in the above sections: IgxZoomSliderComponent IgxDataChartComponent View page on GitHub"
  },
  "index.html": {
    "href": "index.html",
    "title": "Ignite UI for Angular",
    "keywords": "View page on GitHub"
  }
}J\iȯdK 1,7;r$Sf      fA0fA8F*fD+o   y    O^partitionKey=%28https%2Cinfragistics.com%29,:https://www.infragistics.com/products/ignite-ui-angular/angular/index.json necko:classified 1 strongly-framed 1 security-info FnhllAKWRHGAlo+ESXykKAAAAAAAAAAAwAAAAAAAAEaphjojH6pBabDSgSnsfLHeAAAAAgAAAAAAAAAAAAAAAAAAAAEAOQFmCjImkVxP+7sgiYWmMt8FvcOXmlQiTNWFiWlrbpbqgwAAAAAAAAf2MIIH8jCCBtqgAwIBAgIQCSVEgSEs1AnSDLfF9tfz2zANBgkqhkiG9w0BAQsFADBeMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMR0wGwYDVQQDExRHZW9UcnVzdCBSU0EgQ0EgMjAxODAeFw0yNDAyMTkwMDAwMDBaFw0yNTAzMjEyMzU5NTlaMHAxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpOZXcgSmVyc2V5MRUwEwYDVQQHEwxFYXN0IFdpbmRzb3IxGjAYBgNVBAoTEUluZnJhZ2lzdGljcyBJbmMuMRkwFwYDVQQDExBpbmZyYWdpc3RpY3MuY29tMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAvT0f1Mdrkedpj5eRntSsrAT6+Xbuv/UrHhEPpzR1qJN2gG/8djAkeRX41KvA5VfE1kSdG7u4n2Zt+IDXDkDvKoKqpQ8zgcG+lFYdf+8ATna6+supfjhl3EnGYaFoLRjoA3RHQ3/eiT/wfCJZ1VCOfb2xe0xVxR76AGd8Dc09ub4GqgRrtHjh8wMVVF0m6NXAEPYRNz8l5JYfR67TIpqi9x8LYSzv6nqxMG9RpobSv4HtABG6WxrEu8zvaqvSRLNzPxvApoBeq/nEnDhF02qRzRAcYMiE0Gp/Yz8Z0lrTpjecpKsMe7qq7V2+C+F0aU/Z2vbBzWISR1V5+RL99X76G8h4h6pFAKh2nX7dTgoO83eB75M90JxtHZErFfWzhe8IqF/4xOhvdVLrSjBzbVOIMjBvuBRLxl2C+B0SYO+4dF+3TheQjwUQqrWb50jIojBriFyTjkDXKjrJK9qRfc7Acszpdp+rq5lWUODdRGCDdfQatK+FBpGJnNRvYAL4kpDsKgQ55dDxpkg/CkfL/bgzaleJgT95WOZ1bFcsyf2B2wFszcXusZ8a+i0n10df6K+Xqujn6KcqMCxZJihJ2ighHHD4KxFREgB387zbazbhZe0GgCeaFTghrgJcUF0JF6uvmM5SfFy7xYX6rv/xRUO1PbXKo6nvWA5ApL5jsspklakCAwEAAaOCA5gwggOUMB8GA1UdIwQYMBaAFJBY/7CcdahRVHex7fKjQxY4nmzFMB0GA1UdDgQWBBRgg9Gl4GhwTQBXEPuc4mhaNLnPFzCBmwYDVR0RBIGTMIGQghBpbmZyYWdpc3RpY3MuY29tggtyZXZlYWxiaS5pb4IPc2xpbmdzaG90YXBwLmlvghJpbmZyYWdpc3RpY3MuY28ua3KCEiouaW5mcmFnaXN0aWNzLmNvbYINKi5yZXZlYWxiaS5pb4IRKi5zbGluZ3Nob3RhcHAuaW+CFCouaW5mcmFnaXN0aWNzLmNvLmtyMD4GA1UdIAQ3MDUwMwYGZ4EMAQICMCkwJwYIKwYBBQUHAgEWG2h0dHA6Ly93d3cuZGlnaWNlcnQuY29tL0NQUzAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMD4GA1UdHwQ3MDUwM6AxoC+GLWh0dHA6Ly9jZHAuZ2VvdHJ1c3QuY29tL0dlb1RydXN0UlNBQ0EyMDE4LmNybDB1BggrBgEFBQcBAQRpMGcwJgYIKwYBBQUHMAGGGmh0dHA6Ly9zdGF0dXMuZ2VvdHJ1c3QuY29tMD0GCCsGAQUFBzAChjFodHRwOi8vY2FjZXJ0cy5nZW90cnVzdC5jb20vR2VvVHJ1c3RSU0FDQTIwMTguY3J0MAwGA1UdEwEB/wQCMAAwggF+BgorBgEEAdZ5AgQCBIIBbgSCAWoBaAB2AM8RVu7VLnyv84db2Wkum+kacWdKsBfsrAHSW3fOzDsIAAABjcE1JZEAAAQDAEcwRQIgIqIJuQd0BRzNgDltUcZURXnrl6CiaL9uPzAZF1jU4UwCIQCMPkJApXWu8b0oAeGjw22wf2WzXYOHOpzECmH8zbWNCgB2AH1ZHhLheCp7HGFnfF79+NCHXBSgTpWeuQMv2Q6MLnm4AAABjcE1JZUAAAQDAEcwRQIgJRgKzJP9KVl+9LnkqJCgbJud2h4yXdhfHTtnPTDtdRECIQCxY7jvqP45mVx1l9Ikb1Vs+jmylJdY8frswCrAA6Wi1wB2AObSMWNAd4zBEEEG13G5zsHSQPaWhIb7uocyHf0eN45QAAABjcE1Jb4AAAQDAEcwRQIgMcIyClMVwHO8n31lLaztvSkJQiGRWxJzl9PwCzMr/sUCIQDky+IV3df0BOOWSgVVAWF9UtLjlpDrPW0Kvb1XA+k16DANBgkqhkiG9w0BAQsFAAOCAQEAvBd3AvDin80YxAfqWJKcrrOTMoWiVGVgebkDCp+3LTQblxKHGbwlEtDj2mUSHmMyoDjr0Ny3EhPtqEkd7ebnX2odv+eoyOrBPPWYCB4nU+tFss64NZIAz7bvc33f2rPDlKSh+ZL6B9BK5aUjUxN5+Er0GvJKwg4DeiPsvbBACd+hSWi4Wo7tXKieqA5U4ew5LoaYVJx26VMUeOn4EN+ApsDBDdYH7NJvqc/HP+BTRFgH28+0K5dGZDURb94zjgtcup2qaTYhzBUFlAzlKSZU1V31luwgjILd9mAM1LZymgfAQl4go2ZIOulWxVZejd1vQ9Su1VcRY5tPlQvD+onn4MAwAAMAAAAAAAEBAAAAAAAABngyNTUxOQAAAA5SU0EtUFNTLVNIQTI1NgADZgoyJpFcT/u7IImFpjLfBb3Dl5pUIkzVhYlpa26W6oMAAAAAAAAH9jCCB/IwggbaoAMCAQICEAklRIEhLNQJ0gy3xfbX89swDQYJKoZIhvcNAQELBQAwXjELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEdMBsGA1UEAxMUR2VvVHJ1c3QgUlNBIENBIDIwMTgwHhcNMjQwMjE5MDAwMDAwWhcNMjUwMzIxMjM1OTU5WjBwMQswCQYDVQQGEwJVUzETMBEGA1UECBMKTmV3IEplcnNleTEVMBMGA1UEBxMMRWFzdCBXaW5kc29yMRowGAYDVQQKExFJbmZyYWdpc3RpY3MgSW5jLjEZMBcGA1UEAxMQaW5mcmFnaXN0aWNzLmNvbTCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAL09H9THa5HnaY+XkZ7UrKwE+vl27r/1Kx4RD6c0daiTdoBv/HYwJHkV+NSrwOVXxNZEnRu7uJ9mbfiA1w5A7yqCqqUPM4HBvpRWHX/vAE52uvrLqX44ZdxJxmGhaC0Y6AN0R0N/3ok/8HwiWdVQjn29sXtMVcUe+gBnfA3NPbm+BqoEa7R44fMDFVRdJujVwBD2ETc/JeSWH0eu0yKaovcfC2Es7+p6sTBvUaaG0r+B7QARulsaxLvM72qr0kSzcz8bwKaAXqv5xJw4RdNqkc0QHGDIhNBqf2M/GdJa06Y3nKSrDHu6qu1dvgvhdGlP2dr2wc1iEkdVefkS/fV++hvIeIeqRQCodp1+3U4KDvN3ge+TPdCcbR2RKxX1s4XvCKhf+MTob3VS60owc21TiDIwb7gUS8ZdgvgdEmDvuHRft04XkI8FEKq1m+dIyKIwa4hck45A1yo6ySvakX3OwHLM6Xafq6uZVlDg3URgg3X0GrSvhQaRiZzUb2AC+JKQ7CoEOeXQ8aZIPwpHy/24M2pXiYE/eVjmdWxXLMn9gdsBbM3F7rGfGvotJ9dHX+ivl6ro5+inKjAsWSYoSdooIRxw+CsRURIAd/O822s24WXtBoAnmhU4Ia4CXFBdCRerr5jOUnxcu8WF+q7/8UVDtT21yqOp71gOQKS+Y7LKZJWpAgMBAAGjggOYMIIDlDAfBgNVHSMEGDAWgBSQWP+wnHWoUVR3se3yo0MWOJ5sxTAdBgNVHQ4EFgQUYIPRpeBocE0AVxD7nOJoWjS5zxcwgZsGA1UdEQSBkzCBkIIQaW5mcmFnaXN0aWNzLmNvbYILcmV2ZWFsYmkuaW+CD3NsaW5nc2hvdGFwcC5pb4ISaW5mcmFnaXN0aWNzLmNvLmtyghIqLmluZnJhZ2lzdGljcy5jb22CDSoucmV2ZWFsYmkuaW+CESouc2xpbmdzaG90YXBwLmlvghQqLmluZnJhZ2lzdGljcy5jby5rcjA+BgNVHSAENzA1MDMGBmeBDAECAjApMCcGCCsGAQUFBwIBFhtodHRwOi8vd3d3LmRpZ2ljZXJ0LmNvbS9DUFMwDgYDVR0PAQH/BAQDAgWgMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA+BgNVHR8ENzA1MDOgMaAvhi1odHRwOi8vY2RwLmdlb3RydXN0LmNvbS9HZW9UcnVzdFJTQUNBMjAxOC5jcmwwdQYIKwYBBQUHAQEEaTBnMCYGCCsGAQUFBzABhhpodHRwOi8vc3RhdHVzLmdlb3RydXN0LmNvbTA9BggrBgEFBQcwAoYxaHR0cDovL2NhY2VydHMuZ2VvdHJ1c3QuY29tL0dlb1RydXN0UlNBQ0EyMDE4LmNydDAMBgNVHRMBAf8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgDPEVbu1S58r/OHW9lpLpvpGnFnSrAX7KwB0lt3zsw7CAAAAY3BNSWRAAAEAwBHMEUCICKiCbkHdAUczYA5bVHGVEV565egomi/bj8wGRdY1OFMAiEAjD5CQKV1rvG9KAHho8NtsH9ls12DhzqcxAph/M21jQoAdgB9WR4S4XgqexxhZ3xe/fjQh1wUoE6VnrkDL9kOjC55uAAAAY3BNSWVAAAEAwBHMEUCICUYCsyT/SlZfvS55KiQoGybndoeMl3YXx07Zz0w7XURAiEAsWO476j+OZlcdZfSJG9VbPo5spSXWPH67MAqwAOlotcAdgDm0jFjQHeMwRBBBtdxuc7B0kD2loSG+7qHMh39HjeOUAAAAY3BNSW+AAAEAwBHMEUCIDHCMgpTFcBzvJ99ZS2s7b0pCUIhkVsSc5fT8AszK/7FAiEA5MviFd3X9ATjlkoFVQFhfVLS45aQ6z1tCr29VwPpNegwDQYJKoZIhvcNAQELBQADggEBALwXdwLw4p/NGMQH6liSnK6zkzKFolRlYHm5Awqfty00G5cShxm8JRLQ49plEh5jMqA469DctxIT7ahJHe3m519qHb/nqMjqwTz1mAgeJ1PrRbLOuDWSAM+273N939qzw5SkofmS+gfQSuWlI1MTefhK9BrySsIOA3oj7L2wQAnfoUlouFqO7VyonqgOVOHsOS6GmFScdulTFHjp+BDfgKbAwQ3WB+zSb6nPxz/gU0RYB9vPtCuXRmQ1EW/eM44LXLqdqmk2IcwVBZQM5SkmVNVd9ZbsIIyC3fZgDNS2cpoHwEJeIKNmSDrpVsVWXo3db0PUrtVXEWObT5ULw/qJ5+BmCjImkVxP+7sgiYWmMt8FvcOXmlQiTNWFiWlrbpbqgwAAAAAAAASPMIIEizCCA3OgAwIBAgIQBUb+GCP34ZQdo5/OFMRhczANBgkqhkiG9w0BAQsFADBhMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTAeFw0xNzExMDYxMjIzNDVaFw0yNzExMDYxMjIzNDVaMF4xCzAJBgNVBAYTAlVTMRUwEwYDVQQKEwxEaWdpQ2VydCBJbmMxGTAXBgNVBAsTEHd3dy5kaWdpY2VydC5jb20xHTAbBgNVBAMTFEdlb1RydXN0IFJTQSBDQSAyMDE4MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAv4rRY03hGOqHXegWPI9/tr6HFzekDPgxP59FVEAh150Hm8oDI0q9m+2FAmM/n4W57Cjv8oYi2/hNVEHFtEJ/zzMXAQ6CkFLTxzSkwaEB2jKgQK0fWeQz/KDDlqxobNPomXOMJhB3y7c/OTLo0lko7geG4gk7hfiqafapa59YrXLIW4dmrgjgdPstU0Nigz2PhUwRl9we/FAwuIMIMl5cXMThdSBK66XWdS3cLX184ND+fHWhTkAChJrZDVouoKzzNYoq6tZaWmyOLKv23v14RyZ5eqoi6qnmcRID0/i6U9J5nL1krPYbY7tNjzgC+PBXXcWqJVoMXcUw/iBTGWzpwwIDAQABo4IBQDCCATwwHQYDVR0OBBYEFJBY/7CcdahRVHex7fKjQxY4nmzFMB8GA1UdIwQYMBaAFAPeUDVW0Uy7ZvCj4hsbw5eyPdFVMA4GA1UdDwEB/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwEgYDVR0TAQH/BAgwBgEB/wIBADA0BggrBgEFBQcBAQQoMCYwJAYIKwYBBQUHMAGGGGh0dHA6Ly9vY3NwLmRpZ2ljZXJ0LmNvbTBCBgNVHR8EOzA5MDegNaAzhjFodHRwOi8vY3JsMy5kaWdpY2VydC5jb20vRGlnaUNlcnRHbG9iYWxSb290Q0EuY3JsMD0GA1UdIAQ2MDQwMgYEVR0gADAqMCgGCCsGAQUFBwIBFhxodHRwczovL3d3dy5kaWdpY2VydC5jb20vQ1BTMA0GCSqGSIb3DQEBCwUAA4IBAQAw8YdVPYQI/C5earp80s3VLOO+AtpdiXft9OlWwJLwKlUtRfccKj8QW/Pp4b7h6QAlufejwQMb455OjpIbCZVS+awY/R8pAYsXCnM09GcSVe4ivMswyoCZP/vPEn/LPRhHhdgUPk8MlD979RGoUWz7qGAwqJChi28uRds3thx+vRZZIbEyZ62No0tJPzsSGSz8nQ//jP8BIwrzBAUH5WcBAbmvgWfrKcuv+PyGPqRcc4T55TlzrBnzAzZ3oClo9fTvO9PuiHMKrC6V6mgi0s2sa/gbXlPCD9Z24XUMxJElwIVTDuKB0Q4YMMlnpN/QChJ4B0AFsQ+DU0NCO+f78Xf7ZgoyJpFcT/u7IImFpjLfBb3Dl5pUIkzVhYlpa26W6oMAAAAAAAADszCCA68wggKXoAMCAQICEAg74FaQQkaxoXVqyVmRx0owDQYJKoZIhvcNAQEFBQAwYTELMAkGA1UEBhMCVVMxFTATBgNVBAoTDERpZ2lDZXJ0IEluYzEZMBcGA1UECxMQd3d3LmRpZ2ljZXJ0LmNvbTEgMB4GA1UEAxMXRGlnaUNlcnQgR2xvYmFsIFJvb3QgQ0EwHhcNMDYxMTEwMDAwMDAwWhcNMzExMTEwMDAwMDAwWjBhMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMRkwFwYDVQQLExB3d3cuZGlnaWNlcnQuY29tMSAwHgYDVQQDExdEaWdpQ2VydCBHbG9iYWwgUm9vdCBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOI74RFy3qik06NXqlCijwt3kMmipe4SzpZbAQkgzAGTp04wt1P3Q8RpAFed4o0i3YcGQACBCc7OG4O/3807cUbi1mbHBbN2JxaPe54elX3ut0ijCNrWr3oMOQZlf0pdH7wX+Ku+7ijXdH96eJlZhWhuXCMyS79OwOhabeNwv3cQv/wB9oXZqEQQWDKpdRjV0aK+R+InavSaM/hJCGCL1F+0OoS/oapKTH0+z09fbHZeoEs3kZ7cIuZtzhQajmrL/s2zFGQXx1spnjK/8u760wtC1Ku3QTLaDNTv+IHVu41YP7Ub6EkoonDaMQTd97IW8kwKTgeo7Uo9XrV/o5DDrycCAwEAAaNjMGEwDgYDVR0PAQH/BAQDAgGGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFAPeUDVW0Uy7ZvCj4hsbw5eyPdFVMB8GA1UdIwQYMBaAFAPeUDVW0Uy7ZvCj4hsbw5eyPdFVMA0GCSqGSIb3DQEBBQUAA4IBAQDLnDeqSBMSCvrdRJxPUrD0364E9Xl5CKMkGPxLK4TALbnVx/70wR9Yy7htnHp055gpqxG143Cgoc1MiJmTjJFw4qsPHL6Tqf9j1eQHYNOjv51bCfHVjuNT9I5j+j+n27Rm32Jm1tFuQY3yLbXqd0qfnVjiK1nAQCPtLSiCRT55VJImmOCASKg37/DWeWAW3qzoDs1urEQXOC9J2uFFPiq5NlPPOlAG9y7oxFdJbGEhGNUErXg8LDqAa6frrxUU6diJwbk4bOKRbIr/ZLl3JVcwwBsko+Hc6d9HfLW0JAgFMOwtvQu/Rb9Quanz65gBEq3IiMaYNF+NCjzG6dWVlW3eAAAAAQAAAAJoMgABAAAAAFd0bHNmbGFnczB4MDAwMDAwMDA6d3d3LmluZnJhZ2lzdGljcy5jb206NDQzXnBhcnRpdGlvbktleT0lMjhodHRwcyUyQ2luZnJhZ2lzdGljcy5jb20lMjkBAA== request-method GET response-head HTTP/2 200 
server: nginx/1.18.0
date: Mon, 13 May 2024 10:53:36 GMT
content-type: application/json;charset=UTF-8;
content-length: 3269913
last-modified: Fri, 26 Apr 2024 13:22:59 GMT
etag: "a5e386dbdc97da1:0"
x-powered-by: ASP.NET
web: 7
x-xss-protection: 0
content-security-policy: frame-ancestors 'self' https://*.infragistics.com https://*.infragistics.co.kr https://*.appbuilder.dev;
access-control-allow-origin: https://www.igniteui.com
permissions-policy: browsing-topics=()
x-cache-status: HIT
x-nlb-node: 1
accept-ranges: bytes
X-Firefox-Spdy: h2
 original-response-headers server: nginx/1.18.0
date: Mon, 13 May 2024 10:53:36 GMT
content-type: application/json;charset=UTF-8;
content-length: 3269913
last-modified: Fri, 26 Apr 2024 13:22:59 GMT
etag: "a5e386dbdc97da1:0"
x-powered-by: ASP.NET
web: 7
x-xss-protection: 0
content-security-policy: frame-ancestors 'self' https://*.infragistics.com https://*.infragistics.co.kr https://*.appbuilder.dev;
access-control-allow-origin: https://www.igniteui.com
permissions-policy: browsing-topics=()
x-cache-status: HIT
x-nlb-node: 1
accept-ranges: bytes
X-Firefox-Spdy: h2
 ctid 1 net-response-time-onstart 287 net-response-time-onstop 8601  1